openapi: 3.1.0
info:
  title: VCCDB HTTP API
  version: 0.1.0
  description: |
    HTTP API für VCC Multi‑Modell‑Datenbank. Beinhaltet Health, CRUD, Indexverwaltung, Query,
    und Observability (/stats, /metrics). Die Query-Engine unterstützt AND-Gleichheitsprädikate,
    Range-Prädikate (gte/lte) und ORDER BY über Range-Indizes. Optional: Fallback Full-Scan.
servers:
  - url: http://localhost:8765
paths:
  /health:
    get:
      summary: Health Check
      operationId: getHealth
      tags: [system]
      responses:
        '200':
          description: Server ist gesund
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthResponse'
  /stats:
    get:
      summary: Statistiken (Server + RocksDB)
      operationId: getStats
      tags: [observability]
      responses:
        '200':
          description: Laufzeitmetriken und RocksDB-Statistiken
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StatsResponse'
  /metrics:
    get:
      summary: Prometheus Metriken
      operationId: getMetrics
      tags: [observability]
      responses:
        '200':
          description: Prometheus Text Exposition Format
          content:
            text/plain:
              schema:
                type: string
                example: |
                  # HELP process_uptime_seconds Process uptime in seconds
                  # TYPE process_uptime_seconds gauge
                  process_uptime_seconds 13
                  # HELP vccdb_requests_total Total HTTP requests handled
                  # TYPE vccdb_requests_total counter
                  vccdb_requests_total 1
                  ...
  /cache/query:
    post:
      summary: Semantic Cache Lookup
      operationId: cacheQuery
      tags: [cache]
      description: |
        Führt eine semantische Cache-Abfrage aus. Optional mit Embedding zur Ähnlichkeitssuche.
        Falls kein Treffer vorliegt und `allow_insert_on_miss=true` gesetzt ist, kann der Eintrag direkt (mit optionalem TTL) hinterlegt werden.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CacheQueryRequest'
            examples:
              simple_query:
                value:
                  key: "rag:question:hash123"
                  top_k: 1
              semantic_query:
                value:
                  prompt: "Wie skaliere ich HNSW efSearch?"
                  embedding: [0.01, 0.12, 0.0]
                  top_k: 3
      responses:
        '200':
          description: Ergebnis der Cache-Abfrage
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CacheQueryResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /cache/put:
    post:
      summary: Semantic Cache Put
      operationId: cachePut
      tags: [cache]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CachePutRequest'
            examples:
              put_example:
                value:
                  key: "rag:question:hash123"
                  value: { answer: "Nutze ef_search 64–128 für Latenz/Qualität." }
                  embedding: [0.01, 0.12, 0.0]
                  ttl_sec: 3600
                  metadata: { model: "gpt-4o", topic: "vecsearch" }
      responses:
        '200':
          description: Eintrag erstellt/aktualisiert
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CachePutResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /cache/stats:
    get:
      summary: Semantic Cache Statistiken
      operationId: cacheStats
      tags: [cache]
      responses:
        '200':
          description: Statistiken zum Semantic Cache
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CacheStatsResponse'
        '500': { $ref: '#/components/responses/InternalError' }
  /llm/interaction:
    post:
      summary: LLM-Interaktion speichern
      operationId: createLlmInteraction
      tags: [llm]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LlmInteractionRequest'
            examples:
              basic:
                value:
                  model: "gpt-4o"
                  messages:
                    - role: user
                      content: "Erkläre MVCC kurz"
                  reasoning_steps:
                    - type: chain_of_thought
                      content: ["MVCC erlaubt paralleles Lesen/Schreiben", "Versionen pro Tx"]
                  metadata: { session_id: "abc" }
      responses:
        '201':
          description: Interaktion angelegt
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LlmInteractionResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
    get:
      summary: LLM-Interaktionen auflisten
      operationId: listLlmInteractions
      tags: [llm]
      parameters:
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, default: 50 }
        - in: query
          name: after
          schema: { type: string, description: Cursor/ID für Pagination }
      responses:
        '200':
          description: Liste von Interaktionen
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/LlmInteraction' }
                  next:
                    type: string
                    nullable: true
                required: [items]
  /llm/interaction/{id}:
    get:
      summary: LLM-Interaktion lesen
      operationId: getLlmInteraction
      tags: [llm]
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Interaktion gefunden
          content:
            application/json:
              schema: { $ref: '#/components/schemas/LlmInteraction' }
        '404': { $ref: '#/components/responses/NotFound' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /changefeed:
    get:
      summary: Change Data Capture (CDC) Feed
      operationId: getChangefeed
      tags: [cdc]
      description: |
        Liefert Änderungen ab einer Sequenznummer. Unterstützt optionales Long‑Polling.
      parameters:
        - in: query
          name: from_seq
          required: true
          schema: { type: integer, format: int64, minimum: 0 }
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, default: 100 }
        - in: query
          name: long_poll_ms
          schema: { type: integer, minimum: 0, maximum: 60000, default: 0 }
      responses:
        '200':
          description: Änderungen
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChangefeedResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /entities:
    post:
      summary: Entity anlegen/ersetzen (Upsert)
      operationId: postEntity
      tags: [entities]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PutEntityRequest'
      responses:
        '201':
          description: Entity erstellt/aktualisiert
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PutEntityResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /entities/{key}:
    get:
      summary: Entity lesen
      operationId: getEntity
      tags: [entities]
      parameters:
        - name: key
          in: path
          required: true
          description: Key im Format table:pk
          schema: { type: string }
      responses:
        '200':
          description: Entity gefunden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetEntityResponse'
        '404': { $ref: '#/components/responses/NotFound' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
    put:
      summary: Entity anlegen/ersetzen (Upsert) mit Key in der URL
      operationId: putEntity
      tags: [entities]
      parameters:
        - name: key
          in: path
          required: true
          description: Key im Format table:pk
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                blob:
                  type: string
                  description: Beliebiger JSON-Inhalt als String. Server speichert binär.
              required: [blob]
      responses:
        '201':
          description: Entity erstellt/aktualisiert
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PutEntityResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
    delete:
      summary: Entity löschen
      operationId: deleteEntity
      tags: [entities]
      parameters:
        - name: key
          in: path
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Entity gelöscht
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DeleteEntityResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /index/create:
    post:
      summary: Sekundärindex erstellen (Equality oder Range)
      operationId: createIndex
      tags: [indexes]
      description: |
        Erstellt einen Index auf einer Spalte. Zwei Typen verfügbar:
        - equality: Für Gleichheitsfilter (default). Optional: unique=true für Unique-Constraint.
        - range: Für gte/lte-Prädikate und ORDER BY.
        
        Ein Range-Index kann unabhängig von einem Equality-Index existieren.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IndexRequest'
            examples:
              equality_index:
                summary: Equality-Index
                value:
                  table: users
                  column: age
                  type: equality
              range_index:
                summary: Range-Index
                value:
                  table: users
                  column: salary
                  type: range
              unique_index:
                summary: Unique Equality-Index
                value:
                  table: users
                  column: email
                  type: equality
                  unique: true
      responses:
        '200':
          description: Index erstellt
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IndexResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
  /index/drop:
    post:
      summary: Sekundärindex löschen
      operationId: dropIndex
      tags: [indexes]
      description: |
        Löscht einen Index. Der Typ (equality oder range) kann angegeben werden, um
        zwischen Equality- und Range-Index auf derselben Spalte zu unterscheiden.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IndexRequest'
            examples:
              drop_equality:
                summary: Equality-Index löschen
                value:
                  table: users
                  column: age
                  type: equality
              drop_range:
                summary: Range-Index löschen
                value:
                  table: users
                  column: salary
                  type: range
      responses:
        '200':
          description: Index gelöscht
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IndexResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
  /query:
    post:
      summary: Query mit Gleichheits-, Range-Prädikaten und ORDER BY
      operationId: postQuery
      tags: [query]
      description: |
        Führt eine Abfrage mit AND-Gleichheitsprädikaten, Range-Prädikaten (gte/lte) und
        optionaler Sortierung über Range-Indizes aus. Range- und ORDER BY-Features erfordern
        Range-Indizes auf den jeweiligen Spalten.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QueryRequest'
            examples:
              equality_only:
                summary: Nur Gleichheitsfilter
                value:
                  table: users
                  predicates:
                    - column: age
                      value: "30"
                    - column: city
                      value: Berlin
                  return: keys
              range_and_order:
                summary: Range-Prädikat mit ORDER BY
                value:
                  table: employees
                  predicates:
                    - column: department
                      value: Engineering
                  range:
                    - column: salary
                      gte: "60000"
                      lte: "100000"
                      includeLower: true
                      includeUpper: true
                  order_by:
                    column: salary
                    desc: false
                    limit: 10
                  return: entities
              order_by_only:
                summary: Top-N via ORDER BY ohne weitere Prädikate
                value:
                  table: products
                  order_by:
                    column: price
                    desc: true
                    limit: 5
                  return: keys
      responses:
        '200':
          description: Abfrage erfolgreich
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/QueryKeysResponse'
                  - $ref: '#/components/schemas/QueryEntitiesResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '501':
          description: Nicht implementiert (z. B. Graph/Vector Platzhalter)
  /query/aql:
    post:
      summary: AQL Query (FOR/FILTER/SORT/LIMIT/RETURN)
      operationId: postAqlQuery
      tags: [query]
      description: |
        Führt eine AQL-Query aus. Unterstützt relationale Abfragen (FOR/FILTER/SORT/LIMIT/RETURN)
        sowie Cursor-basierte Pagination über `use_cursor`/`cursor`.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AqlQueryRequest'
            examples:
              simple:
                summary: Einfache AQL-Abfrage
                value:
                  query: |
                    FOR user IN users
                      FILTER user.city == "Berlin"
                      SORT user.age ASC
                      LIMIT 10
                      RETURN user
              with_cursor:
                summary: Cursor-Pagination
                value:
                  query: 'FOR user IN users SORT user.name ASC LIMIT 10 RETURN user'
                  use_cursor: true
      responses:
        '200':
          description: Abfrage erfolgreich
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/AqlStandardResponse'
                  - $ref: '#/components/schemas/AqlPaginatedResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /graph/traverse:
    post:
      summary: Graph-Traversierung (BFS)
      operationId: graphTraverse
      tags: [graph]
      description: |
        Führt eine Breadth-First-Search (BFS) Traversierung ab einem Startknoten aus.
        Graph-Kanten müssen als Entities mit Feldern `id`, `_from`, `_to` gespeichert sein.
        Die Outdex- und Index-Indizes werden automatisch bei PUT/DELETE aktualisiert.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GraphTraverseRequest'
            examples:
              simple_traverse:
                summary: Einfache Traversierung
                value:
                  start_vertex: user1
                  max_depth: 3
      responses:
        '200':
          description: Traversierung erfolgreich
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GraphTraverseResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
components:
  schemas:
    HealthResponse:
      type: object
      properties:
        status: { type: string, enum: [healthy] }
        version: { type: string }
        database: { type: string }
        uptime_seconds: { type: integer, format: int64 }
      required: [status, version, database, uptime_seconds]
    StatsResponse:
      type: object
      properties:
        server:
          type: object
          properties:
            uptime_seconds: { type: integer, format: int64 }
            total_requests: { type: integer, format: int64 }
            total_errors: { type: integer, format: int64 }
            queries_per_second: { type: number, format: float }
            threads: { type: integer }
          required: [uptime_seconds, total_requests, total_errors, queries_per_second, threads]
        storage:
          type: object
          properties:
            rocksdb:
              type: object
              properties:
                block_cache_usage_bytes: { type: integer, format: int64 }
                block_cache_capacity_bytes: { type: integer, format: int64 }
                estimate_num_keys: { type: integer, format: int64 }
                estimate_live_data_size_bytes: { type: integer, format: int64 }
                estimate_pending_compaction_bytes: { type: integer, format: int64 }
                num_running_compactions: { type: integer }
                num_running_flushes: { type: integer }
                memtable_size_bytes: { type: integer, format: int64 }
                cur_size_all_mem_tables_bytes: { type: integer, format: int64 }
                files_per_level:
                  type: object
                  additionalProperties:
                    type: integer
                block_cache_hit: { type: integer, format: int64 }
                block_cache_miss: { type: integer, format: int64 }
                cache_hit_rate_percent: { type: number }
                bytes_written: { type: integer, format: int64 }
                bytes_read: { type: integer, format: int64 }
                compaction_keys_dropped: { type: integer, format: int64 }
            raw_stats:
              type: string
              description: Vollständige RocksDB-Statistiken im Textformat
      required: [server, storage]
    PutEntityRequest:
      type: object
      description: Upsert einer Entität. Key kann im Body oder in der URL stehen.
      properties:
        key:
          type: string
          description: Key im Format table:pk (optional wenn in URL)
        blob:
          type: string
          description: Beliebiger JSON-String; Server speichert als Binär-Blob
      required: [blob]
    PutEntityResponse:
      type: object
      properties:
        success: { type: boolean }
        key: { type: string }
        blob_size: { type: integer }
      required: [success, key, blob_size]
    GetEntityResponse:
      type: object
      properties:
        key: { type: string }
        blob: { type: string }
      required: [key, blob]
    DeleteEntityResponse:
      type: object
      properties:
        success: { type: boolean }
        key: { type: string }
      required: [success, key]
    IndexRequest:
      type: object
      properties:
        table: { type: string }
        column: { type: string }
        type:
          type: string
          enum: [equality, range]
          default: equality
          description: Index-Typ. equality für Gleichheitsfilter, range für gte/lte und ORDER BY
        unique:
          type: boolean
          default: false
          description: Nur für Equality-Indizes. Wenn true, wird eine Unique-Constraint erzwungen.
      required: [table, column]
    IndexResponse:
      type: object
      properties:
        success: { type: boolean }
        table: { type: string }
        column: { type: string }
      required: [success, table, column]
    QueryPredicate:
      type: object
      properties:
        column: { type: string }
        value: { type: string }
      required: [column, value]
    RangePredicate:
      type: object
      description: Range-Prädikat für Spalten mit Range-Index
      properties:
        column: { type: string }
        gte:
          type: string
          description: Untere Grenze (greater than or equal). Optional.
        lte:
          type: string
          description: Obere Grenze (less than or equal). Optional.
        includeLower:
          type: boolean
          default: true
          description: Untere Grenze inklusiv?
        includeUpper:
          type: boolean
          default: true
          description: Obere Grenze inklusiv?
      required: [column]
    OrderBy:
      type: object
      description: Sortierung über Range-Index
      properties:
        column:
          type: string
          description: Spalte zum Sortieren (muss Range-Index haben)
        desc:
          type: boolean
          default: false
          description: Absteigend sortieren?
        limit:
          type: integer
          default: 1000
          description: Maximale Anzahl zurückgegebener Keys
      required: [column]
    QueryRequest:
      type: object
      properties:
        table: { type: string }
        predicates:
          type: array
          items: { $ref: '#/components/schemas/QueryPredicate' }
          description: AND-verknüpfte Gleichheitsfilter
        range:
          type: array
          items: { $ref: '#/components/schemas/RangePredicate' }
          description: AND-verknüpfte Range-Prädikate (optional)
        order_by:
          $ref: '#/components/schemas/OrderBy'
          description: Sortierung über Range-Index (optional)
        optimize:
          type: boolean
          default: true
        allow_full_scan:
          type: boolean
          default: false
        explain:
          type: boolean
          default: false
        return:
          type: string
          enum: [keys, entities]
          default: entities
      required: [table]
    QueryPlan:
      type: object
      properties:
        mode:
          type: string
          description: index_parallel | index_optimized | range_aware | full_scan_fallback
        order:
          type: array
          items: { $ref: '#/components/schemas/QueryPredicate' }
        estimates:
          type: array
          items:
            type: object
            properties:
              column: { type: string }
              value: { type: string }
              estimatedCount: { type: integer }
              capped: { type: boolean }
    QueryKeysResponse:
      type: object
      properties:
        table: { type: string }
        count: { type: integer }
        keys:
          type: array
          items: { type: string }
        plan:
          $ref: '#/components/schemas/QueryPlan'
      required: [table, count, keys]
    QueryEntitiesResponse:
      type: object
      properties:
        table: { type: string }
        count: { type: integer }
        entities:
          type: array
          description: JSON-Strings, jede Entität als serialisiertes JSON
          items: { type: string }
        plan:
          $ref: '#/components/schemas/QueryPlan'
      required: [table, count, entities]
    AqlQueryRequest:
      type: object
      properties:
        query:
          type: string
          description: AQL-Query (FOR/FILTER/SORT/LIMIT/RETURN)
        explain:
          type: boolean
          default: false
        optimize:
          type: boolean
          default: true
        allow_full_scan:
          type: boolean
          default: false
        use_cursor:
          type: boolean
          default: false
          description: Cursor-basierte Pagination aktivieren (ändert Response-Format)
        cursor:
          type: string
          nullable: true
          description: Cursor-Token der vorherigen Seite (nur wenn use_cursor=true)
      required: [query]
    AqlExplainPlan:
      type: object
      properties:
        mode:
          type: string
          description: index_parallel | index_optimized | index_rangeaware | full_scan_fallback
        order:
          type: array
          items:
            type: object
            properties:
              column: { type: string }
              value: { type: string }
        estimates:
          type: array
          items:
            type: object
            properties:
              column: { type: string }
              value: { type: string }
              estimatedCount: { type: integer }
              capped: { type: boolean }
    AqlStandardResponse:
      type: object
      properties:
        table: { type: string }
        count: { type: integer }
        entities:
          type: array
          items: { type: string }
          description: Jede Entität als JSON-String (serialisiert)
        plan: { $ref: '#/components/schemas/AqlExplainPlan' }
        query: { type: string }
        ast:
          type: object
          description: AST der AQL-Query (nur bei explain=true)
      required: [table, count, entities]
    AqlPaginatedResponse:
      type: object
      properties:
        items:
          type: array
          items: { type: string }
          description: Seite von Entitäten (serialisierte JSON-Strings)
        batch_size: { type: integer }
        has_more: { type: boolean }
        next_cursor:
          type: string
          description: Cursor-Token für die nächste Seite (falls has_more=true)
        plan: { $ref: '#/components/schemas/AqlExplainPlan' }
        query: { type: string }
        ast:
          type: object
          description: AST der AQL-Query (nur bei explain=true)
      required: [items, batch_size, has_more]
    GraphTraverseRequest:
      type: object
      description: Graph-Traversierung via BFS
      properties:
        start_vertex:
          type: string
          description: Primärschlüssel des Startknotens
        max_depth:
          type: integer
          minimum: 0
          default: 3
          description: Maximale Traversierungstiefe (0 = nur Startknoten)
      required: [start_vertex, max_depth]
    GraphTraverseResponse:
      type: object
      properties:
        start_vertex: { type: string }
        max_depth: { type: integer }
        visited_count: { type: integer }
        visited:
          type: array
          items: { type: string }
          description: Liste der besuchten Knoten in BFS-Reihenfolge
      required: [start_vertex, max_depth, visited_count, visited]
  responses:
    BadRequest:
      description: Ungültige Anforderung
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
    NotFound:
      description: Nicht gefunden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
    InternalError:
      description: Interner Serverfehler
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
  schemas:
    ErrorResponse:
      type: object
      properties:
        error: { type: boolean }
        message: { type: string }
        status_code: { type: integer }
      required: [error, message, status_code]
    CacheQueryRequest:
      type: object
      properties:
        key: { type: string, description: Eindeutiger Schlüssel }
        prompt: { type: string, description: Freitext für semantische Suche }
        embedding:
          type: array
          items: { type: number }
          description: Vektor für Semantik-Abgleich
        top_k: { type: integer, minimum: 1, default: 1 }
        allow_insert_on_miss: { type: boolean, default: false }
        ttl_sec: { type: integer, minimum: 0 }
        metadata: { type: object, additionalProperties: true }
      anyOf:
        - required: [key]
        - required: [prompt]
        - required: [embedding]
    CacheHit:
      type: object
      properties:
        key: { type: string }
        value: { type: object, additionalProperties: true }
        score: { type: number }
        metadata: { type: object, additionalProperties: true }
    CacheQueryResponse:
      type: object
      properties:
        hit: { type: boolean }
        hits:
          type: array
          items: { $ref: '#/components/schemas/CacheHit' }
          description: Top‑K Ergebnisse bei semantischer Suche
      required: [hit]
    CachePutRequest:
      type: object
      properties:
        key: { type: string }
        value: { type: object, additionalProperties: true }
        embedding:
          type: array
          items: { type: number }
        ttl_sec: { type: integer, minimum: 0 }
        metadata: { type: object, additionalProperties: true }
      required: [key, value]
    CachePutResponse:
      type: object
      properties:
        success: { type: boolean }
        key: { type: string }
        expires_at: { type: string, format: date-time, nullable: true }
      required: [success, key]
    CacheStatsResponse:
      type: object
      properties:
        entries: { type: integer, format: int64 }
        hit_ratio_1m: { type: number }
        hit_ratio_1h: { type: number }
        evictions_total: { type: integer, format: int64 }
        bytes: { type: integer, format: int64 }
      required: [entries]
    LlmMessage:
      type: object
      properties:
        role: { type: string, enum: [user, system, assistant, tool] }
        content: { type: string }
    ReasoningStep:
      type: object
      properties:
        type: { type: string, description: chain_of_thought | tool_plan | scratchpad }
        content:
          type: array
          items: { type: string }
    LlmInteractionRequest:
      type: object
      properties:
        model: { type: string }
        messages:
          type: array
          items: { $ref: '#/components/schemas/LlmMessage' }
        reasoning_steps:
          type: array
          items: { $ref: '#/components/schemas/ReasoningStep' }
        metadata: { type: object, additionalProperties: true }
      required: [model, messages]
    LlmInteraction:
      type: object
      properties:
        id: { type: string }
        created_at: { type: string, format: date-time }
        model: { type: string }
        messages:
          type: array
          items: { $ref: '#/components/schemas/LlmMessage' }
        reasoning_steps:
          type: array
          items: { $ref: '#/components/schemas/ReasoningStep' }
        metadata: { type: object, additionalProperties: true }
    LlmInteractionResponse:
      type: object
      properties:
        id: { type: string }
        success: { type: boolean }
      required: [id, success]
    ChangeEntry:
      type: object
      properties:
        seq: { type: integer, format: int64 }
        ts: { type: string, format: date-time }
        op: { type: string, enum: [put, delete] }
        key: { type: string }
        table: { type: string }
        value: { type: object, additionalProperties: true, nullable: true }
        prev: { type: object, additionalProperties: true, nullable: true }
        txn_id: { type: string, nullable: true }
    ChangefeedResponse:
      type: object
      properties:
        from_seq: { type: integer, format: int64 }
        next_seq: { type: integer, format: int64 }
        entries:
          type: array
          items: { $ref: '#/components/schemas/ChangeEntry' }
      required: [from_seq, next_seq, entries]
