openapi: 3.1.0
info:
  title: VCCDB HTTP API
  version: 0.1.0
  description: |
    HTTP API für VCC Multi‑Modell‑Datenbank. Beinhaltet Health, CRUD, Indexverwaltung, Query,
    und Observability (/stats, /metrics). Die Query-Engine unterstützt AND-Gleichheitsprädikate,
    Range-Prädikate (gte/lte) und ORDER BY über Range-Indizes. Optional: Fallback Full-Scan.
servers:
  - url: http://localhost:8765
paths:
  /health:
    get:
      summary: Health Check
      operationId: getHealth
      tags: [system]
      responses:
        '200':
          description: Server ist gesund
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthResponse'
  /stats:
    get:
      summary: Statistiken (Server + RocksDB)
      operationId: getStats
      tags: [observability]
      responses:
        '200':
          description: Laufzeitmetriken und RocksDB-Statistiken
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StatsResponse'
  /metrics:
    get:
      summary: Prometheus Metriken
      operationId: getMetrics
      tags: [observability]
      responses:
        '200':
          description: Prometheus Text Exposition Format
          content:
            text/plain:
              schema:
                type: string
                example: |
                  # HELP process_uptime_seconds Process uptime in seconds
                  # TYPE process_uptime_seconds gauge
                  process_uptime_seconds 13
                  # HELP vccdb_requests_total Total HTTP requests handled
                  # TYPE vccdb_requests_total counter
                  vccdb_requests_total 1
                  ...
  /content/import:
    post:
      summary: Content importieren (v0 Bulk)
      operationId: contentImport
      tags: [content]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ContentImportRequest'
      responses:
        '200':
          description: Import erfolgreich
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ContentImportResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /content/{id}:
    get:
      summary: Content-Metadaten lesen
      operationId: getContent
      tags: [content]
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Content-Metadaten
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ContentMeta'
        '404': { $ref: '#/components/responses/NotFound' }
  /content/{id}/chunks:
    get:
      summary: Chunks eines Contents auflisten
      operationId: getContentChunks
      tags: [content]
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Liste der Chunks
          content:
            application/json:
              schema:
                type: object
                properties:
                  count: { type: integer }
                  chunks:
                    type: array
                    items: { $ref: '#/components/schemas/ChunkMeta' }
                required: [count, chunks]
        '404': { $ref: '#/components/responses/NotFound' }
  /content/{id}/blob:
    get:
      summary: Original-Blob eines Contents abrufen
      operationId: getContentBlob
      tags: [content]
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Raw Blob (Content-Type aus Metadaten)
          content:
            '*/*':
              schema:
                type: string
                format: binary
        '404': { $ref: '#/components/responses/NotFound' }
  /cache/query:
    post:
      summary: Semantic Cache Lookup
      operationId: cacheQuery
      tags: [cache]
      description: |
        Führt eine semantische Cache-Abfrage aus. Optional mit Embedding zur Ähnlichkeitssuche.
        Falls kein Treffer vorliegt und `allow_insert_on_miss=true` gesetzt ist, kann der Eintrag direkt (mit optionalem TTL) hinterlegt werden.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CacheQueryRequest'
            examples:
              simple_query:
                value:
                  key: "rag:question:hash123"
                  top_k: 1
              semantic_query:
                value:
                  prompt: "Wie skaliere ich HNSW efSearch?"
                  embedding: [0.01, 0.12, 0.0]
                  top_k: 3
      responses:
        '200':
          description: Ergebnis der Cache-Abfrage
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CacheQueryResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /cache/put:
    post:
      summary: Semantic Cache Put
      operationId: cachePut
      tags: [cache]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CachePutRequest'
            examples:
              put_example:
                value:
                  key: "rag:question:hash123"
                  value: { answer: "Nutze ef_search 64–128 für Latenz/Qualität." }
                  embedding: [0.01, 0.12, 0.0]
                  ttl_sec: 3600
                  metadata: { model: "gpt-4o", topic: "vecsearch" }
      responses:
        '200':
          description: Eintrag erstellt/aktualisiert
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CachePutResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /cache/stats:
    get:
      summary: Semantic Cache Statistiken
      operationId: cacheStats
      tags: [cache]
      responses:
        '200':
          description: Statistiken zum Semantic Cache
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CacheStatsResponse'
        '500': { $ref: '#/components/responses/InternalError' }
  /llm/interaction:
    post:
      summary: LLM-Interaktion speichern
      operationId: createLlmInteraction
      tags: [llm]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LlmInteractionRequest'
            examples:
              basic:
                value:
                  model: "gpt-4o"
                  messages:
                    - role: user
                      content: "Erkläre MVCC kurz"
                  reasoning_steps:
                    - type: chain_of_thought
                      content: ["MVCC erlaubt paralleles Lesen/Schreiben", "Versionen pro Tx"]
                  metadata: { session_id: "abc" }
      responses:
        '201':
          description: Interaktion angelegt
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LlmInteractionResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
    get:
      summary: LLM-Interaktionen auflisten
      operationId: listLlmInteractions
      tags: [llm]
      parameters:
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, default: 50 }
        - in: query
          name: after
          schema: { type: string, description: Cursor/ID für Pagination }
      responses:
        '200':
          description: Liste von Interaktionen
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/LlmInteraction' }
                  next:
                    type: string
                    nullable: true
                required: [items]
  /llm/interaction/{id}:
    get:
      summary: LLM-Interaktion lesen
      operationId: getLlmInteraction
      tags: [llm]
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Interaktion gefunden
          content:
            application/json:
              schema: { $ref: '#/components/schemas/LlmInteraction' }
        '404': { $ref: '#/components/responses/NotFound' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /changefeed:
    get:
      summary: Change Data Capture (CDC) Feed (Long‑Polling)
      operationId: getChangefeed
      tags: [cdc]
      description: |
        Liefert Änderungen ab einer Sequenznummer. Unterstützt optionales Long‑Polling.
        Für Streaming siehe `/changefeed/stream` (SSE).
      parameters:
        - in: query
          name: from_seq
          required: true
          schema: { type: integer, format: int64, minimum: 0 }
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, default: 100 }
        - in: query
          name: long_poll_ms
          schema: { type: integer, minimum: 0, maximum: 60000, default: 0 }
      responses:
        '200':
          description: Änderungen
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChangefeedResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /changefeed/stream:
    get:
      summary: Change Data Capture (CDC) Stream (SSE)
      operationId: getChangefeedStream
      tags: [cdc]
      description: |
        Streamt Änderungen in Server‑Sent Events (SSE) Format. Jedes Event hat `data:` Zeile mit JSON.
        Unterstützt Keep‑Alive Streaming mit optionalen Heartbeats.
      parameters:
        - in: query
          name: from_seq
          schema: { type: integer, format: int64, minimum: 0, default: 0 }
        - in: query
          name: key_prefix
          schema: { type: string }
          description: Filtert Events nach Key‑Präfix (z.B. `user:`)
        - in: query
          name: keep_alive
          schema: { type: boolean, default: true }
          description: Verbindung offen halten und neue Events fortlaufend senden
        - in: query
          name: max_seconds
          schema: { type: integer, minimum: 1, maximum: 60, default: 30 }
          description: Maximale Stream‑Dauer (Test/CI hilfreich)
        - in: query
          name: heartbeat_ms
          schema: { type: integer, minimum: 100, maximum: 60000 }
          description: Optionaler Heartbeat‑Override in Millisekunden (nur Test/Dev)
      responses:
        '200':
          description: SSE Stream mit Change Events
          content:
            text/event-stream:
              schema:
                type: string
                description: |
                  SSE Format: `data: {json}\n\n` pro Event, Heartbeat als Kommentar `: heartbeat\n\n`.
                  JSON Struktur: `{operation, key, sequence, ...}`.
                example: |
                  data: {"operation":"PUT","key":"doc:1","sequence":42,"old_val":null,"new_val":"{\"x\":1}"}

                  data: {"operation":"DELETE","key":"doc:2","sequence":43,"old_val":"{\"y\":2}","new_val":null}
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /entities:
    post:
      summary: Entity anlegen/ersetzen (Upsert)
      operationId: postEntity
      tags: [entities]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PutEntityRequest'
      responses:
        '201':
          description: Entity erstellt/aktualisiert
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PutEntityResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /entities/{key}:
    get:
      summary: Entity lesen
      operationId: getEntity
      tags: [entities]
      parameters:
        - name: key
          in: path
          required: true
          description: Key im Format table:pk
          schema: { type: string }
      responses:
        '200':
          description: Entity gefunden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetEntityResponse'
        '404': { $ref: '#/components/responses/NotFound' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
    put:
      summary: Entity anlegen/ersetzen (Upsert) mit Key in der URL
      operationId: putEntity
      tags: [entities]
      parameters:
        - name: key
          in: path
          required: true
          description: Key im Format table:pk
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                blob:
                  type: string
                  description: Beliebiger JSON-Inhalt als String. Server speichert binär.
              required: [blob]
      responses:
        '201':
          description: Entity erstellt/aktualisiert
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PutEntityResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
    delete:
      summary: Entity löschen
      operationId: deleteEntity
      tags: [entities]
      parameters:
        - name: key
          in: path
          required: true
          schema: { type: string }
      responses:
        '200':
          description: Entity gelöscht
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DeleteEntityResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /index/create:
    post:
      summary: Sekundärindex erstellen (Equality oder Range)
      operationId: createIndex
      tags: [indexes]
      description: |
        Erstellt einen Index auf einer Spalte. Zwei Typen verfügbar:
        - equality: Für Gleichheitsfilter (default). Optional: unique=true für Unique-Constraint.
        - range: Für gte/lte-Prädikate und ORDER BY.
        
        Ein Range-Index kann unabhängig von einem Equality-Index existieren.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IndexRequest'
            examples:
              equality_index:
                summary: Equality-Index
                value:
                  table: users
                  column: age
                  type: equality
              range_index:
                summary: Range-Index
                value:
                  table: users
                  column: salary
                  type: range
              unique_index:
                summary: Unique Equality-Index
                value:
                  table: users
                  column: email
                  type: equality
                  unique: true
      responses:
        '200':
          description: Index erstellt
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IndexResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
  /index/drop:
    post:
      summary: Sekundärindex löschen
      operationId: dropIndex
      tags: [indexes]
      description: |
        Löscht einen Index. Der Typ (equality oder range) kann angegeben werden, um
        zwischen Equality- und Range-Index auf derselben Spalte zu unterscheiden.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IndexRequest'
            examples:
              drop_equality:
                summary: Equality-Index löschen
                value:
                  table: users
                  column: age
                  type: equality
              drop_range:
                summary: Range-Index löschen
                value:
                  table: users
                  column: salary
                  type: range
      responses:
        '200':
          description: Index gelöscht
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IndexResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
  /query:
    post:
      summary: Query mit Gleichheits-, Range-Prädikaten und ORDER BY
      operationId: postQuery
      tags: [query]
      description: |
        Führt eine Abfrage mit AND-Gleichheitsprädikaten, Range-Prädikaten (gte/lte) und
        optionaler Sortierung über Range-Indizes aus. Range- und ORDER BY-Features erfordern
        Range-Indizes auf den jeweiligen Spalten.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QueryRequest'
            examples:
              equality_only:
                summary: Nur Gleichheitsfilter
                value:
                  table: users
                  predicates:
                    - column: age
                      value: "30"
                    - column: city
                      value: Berlin
                  return: keys
              range_and_order:
                summary: Range-Prädikat mit ORDER BY
                value:
                  table: employees
                  predicates:
                    - column: department
                      value: Engineering
                  range:
                    - column: salary
                      gte: "60000"
                      lte: "100000"
                      includeLower: true
                      includeUpper: true
                  order_by:
                    column: salary
                    desc: false
                    limit: 10
                  return: entities
              order_by_only:
                summary: Top-N via ORDER BY ohne weitere Prädikate
                value:
                  table: products
                  order_by:
                    column: price
                    desc: true
                    limit: 5
                  return: keys
      responses:
        '200':
          description: Abfrage erfolgreich
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/QueryKeysResponse'
                  - $ref: '#/components/schemas/QueryEntitiesResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '501':
          description: Nicht implementiert (z. B. Graph/Vector Platzhalter)
  /query/aql:
    post:
      summary: AQL Query (FOR/FILTER/SORT/LIMIT/RETURN, LET, einfacher JOIN)
      operationId: postAqlQuery
      tags: [query]
      description: |
        Führt eine AQL-Query aus. Unterstützt relationale Abfragen (FOR/FILTER/SORT/LIMIT/RETURN),
        LET‑Bindings für Projektionen und einfache Equality‑Joins über zwei FOR‑Klauseln.
        Cursor‑basierte Pagination ist über `use_cursor`/`cursor` verfügbar.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AqlQueryRequest'
            examples:
              simple:
                summary: Einfache AQL-Abfrage
                value:
                  query: |
                    FOR user IN users
                      FILTER user.city == "Berlin"
                      SORT user.age ASC
                      LIMIT 10
                      RETURN user
              with_cursor:
                summary: Cursor-Pagination
                value:
                  query: 'FOR user IN users SORT user.name ASC LIMIT 10 RETURN user'
                  use_cursor: true
              join_equality:
                summary: Einfacher Equality-Join über zwei FORs
                value:
                  query: |
                    FOR u IN users
                      FOR o IN orders
                      FILTER u._key == o.user_id
                      RETURN u
                  allow_full_scan: true
              let_projection:
                summary: LET-Binding und Objekt-Projektion
                value:
                  query: |
                    FOR u IN users
                      LET c = u.city
                      RETURN { name: u.name, city: c }
                  allow_full_scan: true
      responses:
        '200':
          description: Abfrage erfolgreich
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/AqlStandardResponse'
                  - $ref: '#/components/schemas/AqlPaginatedResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /graph/traverse:
    post:
      summary: Graph-Traversierung (BFS)
      operationId: graphTraverse
      tags: [graph]
      description: |
        Führt eine Breadth-First-Search (BFS) Traversierung ab einem Startknoten aus.
        Graph-Kanten müssen als Entities mit Feldern `id`, `_from`, `_to` gespeichert sein.
        Die Outdex- und Index-Indizes werden automatisch bei PUT/DELETE aktualisiert.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GraphTraverseRequest'
            examples:
              simple_traverse:
                summary: Einfache Traversierung
                value:
                  start_vertex: user1
                  max_depth: 3
      responses:
        '200':
          description: Traversierung erfolgreich
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GraphTraverseResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /vector/search:
    post:
      summary: Vektor-KNN Suche
      operationId: vectorSearch
      tags: [vector]
      description: |
        Führt eine k-NN Suche im Vektorindex aus. Optional Cursor‑Pagination mit `use_cursor` und `cursor`.
        Ohne Cursor werden die Ergebnisse im Legacy-Format zurückgegeben.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/VectorSearchRequest'
      responses:
        '200':
          description: Suchergebnisse
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: '#/components/schemas/VectorSearchResponseLegacy'
                  - $ref: '#/components/schemas/VectorSearchPaginatedResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /vector/batch_insert:
    post:
      summary: Vektoren im Batch einfügen
      operationId: vectorBatchInsert
      tags: [vector]
      description: |
        Fügt mehrere Vektor-Entities in den aktuellen Vektorindex ein. Das Feld mit dem Vektor
        kann über `vector_field` angegeben werden (Default `embedding`).
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/VectorBatchInsertRequest'
      responses:
        '200':
          description: Batch-Ergebnis
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VectorBatchInsertResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /vector/by-filter:
    delete:
      summary: Vektoren per Filter löschen (PKs oder Prefix)
      operationId: vectorDeleteByFilter
      tags: [vector]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/VectorDeleteByFilterRequest'
      responses:
        '200':
          description: Anzahl gelöschter Einträge
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VectorDeleteByFilterResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /vector/index/save:
    post:
      summary: Vektorindex speichern
      operationId: vectorIndexSave
      tags: [vector]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/VectorIndexDirRequest' }
      responses:
        '200':
          description: Index gespeichert
          content:
            application/json:
              schema: { $ref: '#/components/schemas/VectorIndexOpResponse' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /vector/index/load:
    post:
      summary: Vektorindex laden
      operationId: vectorIndexLoad
      tags: [vector]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/VectorIndexDirRequest' }
      responses:
        '200':
          description: Index geladen
          content:
            application/json:
              schema: { $ref: '#/components/schemas/VectorIndexOpResponse' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /vector/index/config:
    get:
      summary: Vektorindex Konfiguration lesen
      operationId: vectorIndexConfigGet
      tags: [vector]
      responses:
        '200':
          description: Aktuelle Konfiguration
          content:
            application/json:
              schema: { $ref: '#/components/schemas/VectorIndexConfig' }
        '500': { $ref: '#/components/responses/InternalError' }
    put:
      summary: Vektorindex Konfiguration ändern
      operationId: vectorIndexConfigPut
      tags: [vector]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                efSearch:
                  type: integer
                  minimum: 1
                  maximum: 10000
      responses:
        '200':
          description: Konfiguration aktualisiert
          content:
            application/json:
              schema:
                type: object
                properties:
                  message: { type: string }
                  updated_fields: { type: object, additionalProperties: true }
        '400': { $ref: '#/components/responses/BadRequest' }
        '500': { $ref: '#/components/responses/InternalError' }
  /vector/index/stats:
    get:
      summary: Vektorindex Statistiken
      operationId: vectorIndexStats
      tags: [vector]
      responses:
        '200':
          description: Status und Kennzahlen des Vektorindex
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/VectorIndexConfig'
                  - type: object
                    properties:
                      vectorCount: { type: integer }
        '500': { $ref: '#/components/responses/InternalError' }
components:
  schemas:
    ContentMeta:
      type: object
      properties:
        id: { type: string }
        mime_type: { type: string }
        category: { type: integer, description: "Enum: TEXT=0, IMAGE=1, AUDIO=2, VIDEO=3, GEO=4, CAD=5, ARCHIVE=6, STRUCTURED=7, BINARY=8, UNKNOWN=9" }
        original_filename: { type: string }
        size_bytes: { type: integer, format: int64 }
        created_at: { type: integer, format: int64 }
        modified_at: { type: integer, format: int64 }
        hash_sha256: { type: string }
        text_extracted: { type: boolean }
        chunked: { type: boolean }
        indexed: { type: boolean }
        chunk_count: { type: integer }
        embedding_dim: { type: integer }
        extracted_metadata: { type: object, additionalProperties: true }
        user_metadata: { type: object, additionalProperties: true }
        tags:
          type: array
          items: { type: string }
        parent_id: { type: string }
        child_ids:
          type: array
          items: { type: string }
    ChunkMeta:
      type: object
      properties:
        id: { type: string }
        content_id: { type: string }
        seq_num: { type: integer }
        chunk_type: { type: string }
        text: { type: string }
        data: { type: object, additionalProperties: true }
        blob_ref: { type: string }
        start_offset: { type: integer }
        end_offset: { type: integer }
        embedding:
          type: array
          items: { type: number }
        embedding_indexed: { type: boolean }
        created_at: { type: integer, format: int64 }
    ContentImportRequest:
      type: object
      properties:
        content: { $ref: '#/components/schemas/ContentMeta' }
        chunks:
          type: array
          items: { $ref: '#/components/schemas/ChunkMeta' }
        edges:
          type: array
          items: { type: object, additionalProperties: true }
        blob: { type: string, description: "Roh-Blob als String" }
        blob_base64: { type: string, description: "Base64-kodierter Blob (im MVP nicht automatisch dekodiert)" }
      required: [content]
    ContentImportResponse:
      type: object
      properties:
        status: { type: string }
        content_id: { type: string }
      required: [status, content_id]
    HealthResponse:
      type: object
      properties:
        status: { type: string, enum: [healthy] }
        version: { type: string }
        database: { type: string }
        uptime_seconds: { type: integer, format: int64 }
      required: [status, version, database, uptime_seconds]
    StatsResponse:
      type: object
      properties:
        server:
          type: object
          properties:
            uptime_seconds: { type: integer, format: int64 }
            total_requests: { type: integer, format: int64 }
            total_errors: { type: integer, format: int64 }
            queries_per_second: { type: number, format: float }
            threads: { type: integer }
          required: [uptime_seconds, total_requests, total_errors, queries_per_second, threads]
        storage:
          type: object
          properties:
            rocksdb:
              type: object
              properties:
                block_cache_usage_bytes: { type: integer, format: int64 }
                block_cache_capacity_bytes: { type: integer, format: int64 }
                estimate_num_keys: { type: integer, format: int64 }
                estimate_live_data_size_bytes: { type: integer, format: int64 }
                estimate_pending_compaction_bytes: { type: integer, format: int64 }
                num_running_compactions: { type: integer }
                num_running_flushes: { type: integer }
                memtable_size_bytes: { type: integer, format: int64 }
                cur_size_all_mem_tables_bytes: { type: integer, format: int64 }
                files_per_level:
                  type: object
                  additionalProperties:
                    type: integer
                block_cache_hit: { type: integer, format: int64 }
                block_cache_miss: { type: integer, format: int64 }
                cache_hit_rate_percent: { type: number }
                bytes_written: { type: integer, format: int64 }
                bytes_read: { type: integer, format: int64 }
                compaction_keys_dropped: { type: integer, format: int64 }
            raw_stats:
              type: string
              description: Vollständige RocksDB-Statistiken im Textformat
      required: [server, storage]
    PutEntityRequest:
      type: object
      description: Upsert einer Entität. Key kann im Body oder in der URL stehen.
      properties:
        key:
          type: string
          description: Key im Format table:pk (optional wenn in URL)
        blob:
          type: string
          description: Beliebiger JSON-String; Server speichert als Binär-Blob
      required: [blob]
    PutEntityResponse:
      type: object
      properties:
        success: { type: boolean }
        key: { type: string }
        blob_size: { type: integer }
      required: [success, key, blob_size]
    GetEntityResponse:
      type: object
      properties:
        key: { type: string }
        blob: { type: string }
      required: [key, blob]
    DeleteEntityResponse:
      type: object
      properties:
        success: { type: boolean }
        key: { type: string }
      required: [success, key]
    IndexRequest:
      type: object
      properties:
        table: { type: string }
        column: { type: string }
        type:
          type: string
          enum: [equality, range]
          default: equality
          description: Index-Typ. equality für Gleichheitsfilter, range für gte/lte und ORDER BY
        unique:
          type: boolean
          default: false
          description: Nur für Equality-Indizes. Wenn true, wird eine Unique-Constraint erzwungen.
      required: [table, column]
    IndexResponse:
      type: object
      properties:
        success: { type: boolean }
        table: { type: string }
        column: { type: string }
      required: [success, table, column]
    QueryPredicate:
      type: object
      properties:
        column: { type: string }
        value: { type: string }
      required: [column, value]
    RangePredicate:
      type: object
      description: Range-Prädikat für Spalten mit Range-Index
      properties:
        column: { type: string }
        gte:
          type: string
          description: Untere Grenze (greater than or equal). Optional.
        lte:
          type: string
          description: Obere Grenze (less than or equal). Optional.
        includeLower:
          type: boolean
          default: true
          description: Untere Grenze inklusiv?
        includeUpper:
          type: boolean
          default: true
          description: Obere Grenze inklusiv?
      required: [column]
    OrderBy:
      type: object
      description: Sortierung über Range-Index
      properties:
        column:
          type: string
          description: Spalte zum Sortieren (muss Range-Index haben)
        desc:
          type: boolean
          default: false
          description: Absteigend sortieren?
        limit:
          type: integer
          default: 1000
          description: Maximale Anzahl zurückgegebener Keys
      required: [column]
    QueryRequest:
      type: object
      properties:
        table: { type: string }
        predicates:
          type: array
          items: { $ref: '#/components/schemas/QueryPredicate' }
          description: AND-verknüpfte Gleichheitsfilter
        range:
          type: array
          items: { $ref: '#/components/schemas/RangePredicate' }
          description: AND-verknüpfte Range-Prädikate (optional)
        order_by:
          $ref: '#/components/schemas/OrderBy'
          description: Sortierung über Range-Index (optional)
        optimize:
          type: boolean
          default: true
        allow_full_scan:
          type: boolean
          default: false
        explain:
          type: boolean
          default: false
        return:
          type: string
          enum: [keys, entities]
          default: entities
      required: [table]
    QueryPlan:
      type: object
      properties:
        mode:
          type: string
          description: index_parallel | index_optimized | range_aware | full_scan_fallback
        order:
          type: array
          items: { $ref: '#/components/schemas/QueryPredicate' }
        estimates:
          type: array
          items:
            type: object
            properties:
              column: { type: string }
              value: { type: string }
              estimatedCount: { type: integer }
              capped: { type: boolean }
    QueryKeysResponse:
      type: object
      properties:
        table: { type: string }
        count: { type: integer }
        keys:
          type: array
          items: { type: string }
        plan:
          $ref: '#/components/schemas/QueryPlan'
      required: [table, count, keys]
    QueryEntitiesResponse:
      type: object
      properties:
        table: { type: string }
        count: { type: integer }
        entities:
          type: array
          description: JSON-Strings, jede Entität als serialisiertes JSON
          items: { type: string }
        plan:
          $ref: '#/components/schemas/QueryPlan'
      required: [table, count, entities]
    AqlQueryRequest:
      type: object
      properties:
        query:
          type: string
          description: AQL-Query (FOR/FILTER/SORT/LIMIT/RETURN)
        explain:
          type: boolean
          default: false
        optimize:
          type: boolean
          default: true
        allow_full_scan:
          type: boolean
          default: false
        use_cursor:
          type: boolean
          default: false
          description: Cursor-basierte Pagination aktivieren (ändert Response-Format)
        cursor:
          type: string
          nullable: true
          description: Cursor-Token der vorherigen Seite (nur wenn use_cursor=true)
      required: [query]
    AqlExplainPlan:
      type: object
      properties:
        mode:
          type: string
          description: index_parallel | index_optimized | range_aware | full_scan_fallback
        order:
          type: array
          items:
            type: object
            properties:
              column: { type: string }
              value: { type: string }
        estimates:
          type: array
          items:
            type: object
            properties:
              column: { type: string }
              value: { type: string }
              estimatedCount: { type: integer }
              capped: { type: boolean }
        let_pre_extracted:
          type: boolean
          description: true, wenn LET-in-FILTER vor der Übersetzung extrahiert wurde
    AqlStandardResponse:
      type: object
      properties:
        table: { type: string }
        count: { type: integer }
        entities:
          type: array
          items: { type: string }
          description: Jede Entität als JSON-String (serialisiert)
        plan: { $ref: '#/components/schemas/AqlExplainPlan' }
        query: { type: string }
        ast:
          type: object
          description: AST der AQL-Query (nur bei explain=true)
      required: [table, count, entities]
    AqlPaginatedResponse:
      type: object
      properties:
        items:
          type: array
          items: { type: string }
          description: Seite von Entitäten (serialisierte JSON-Strings)
        batch_size: { type: integer }
        has_more: { type: boolean }
        next_cursor:
          type: string
          description: Cursor-Token für die nächste Seite (falls has_more=true)
        plan: { $ref: '#/components/schemas/AqlExplainPlan' }
        query: { type: string }
        ast:
          type: object
          description: AST der AQL-Query (nur bei explain=true)
      required: [items, batch_size, has_more]
    GraphTraverseRequest:
      type: object
      description: Graph-Traversierung via BFS
      properties:
        start_vertex:
          type: string
          description: Primärschlüssel des Startknotens
        max_depth:
          type: integer
          minimum: 0
          default: 3
          description: Maximale Traversierungstiefe (0 = nur Startknoten)
      required: [start_vertex, max_depth]
    GraphTraverseResponse:
      type: object
      properties:
        start_vertex: { type: string }
        max_depth: { type: integer }
        visited_count: { type: integer }
        visited:
          type: array
          items: { type: string }
          description: Liste der besuchten Knoten in BFS-Reihenfolge
      required: [start_vertex, max_depth, visited_count, visited]
    VectorSearchRequest:
      type: object
      properties:
        vector:
          type: array
          items: { type: number }
          description: Query-Vektor
        k:
          type: integer
          minimum: 1
          default: 10
        use_cursor:
          type: boolean
          default: false
          description: Aktiviert Cursor-Pagination (ändert das Response-Format)
        cursor:
          type: string
          nullable: true
          description: Cursor-Token (Offset) der vorherigen Seite
      required: [vector]
    VectorSearchHit:
      type: object
      properties:
        pk: { type: string }
        distance: { type: number }
    VectorSearchResponseLegacy:
      type: object
      properties:
        results:
          type: array
          items: { $ref: '#/components/schemas/VectorSearchHit' }
        k: { type: integer }
        count: { type: integer }
      required: [results, k, count]
    VectorSearchPaginatedResponse:
      type: object
      properties:
        items:
          type: array
          items: { $ref: '#/components/schemas/VectorSearchHit' }
        batch_size: { type: integer }
        has_more: { type: boolean }
        next_cursor: { type: string }
      required: [items, batch_size, has_more]
    VectorBatchInsertItem:
      type: object
      properties:
        pk: { type: string }
        vector:
          type: array
          items: { type: number }
        fields:
          type: object
          additionalProperties: true
      required: [pk, vector]
    VectorBatchInsertRequest:
      type: object
      properties:
        vector_field:
          type: string
          default: embedding
          description: Feldname des Vektors in der Entity
        items:
          type: array
          items: { $ref: '#/components/schemas/VectorBatchInsertItem' }
      required: [items]
    VectorBatchInsertResponse:
      type: object
      properties:
        inserted: { type: integer }
        errors: { type: integer }
        objectName: { type: string }
        dimension: { type: integer }
      required: [inserted, errors]
    VectorDeleteByFilterRequest:
      type: object
      properties:
        pks:
          type: array
          items: { type: string }
        prefix:
          type: string
      oneOf:
        - required: [pks]
        - required: [prefix]
    VectorDeleteByFilterResponse:
      type: object
      properties:
        deleted: { type: integer }
        method: { type: string, enum: [pks, prefix] }
        prefix: { type: string }
      required: [deleted, method]
    VectorIndexDirRequest:
      type: object
      properties:
        directory: { type: string }
      required: [directory]
    VectorIndexOpResponse:
      type: object
      properties:
        message: { type: string }
        directory: { type: string }
      required: [message, directory]
    VectorIndexConfig:
      type: object
      properties:
        objectName: { type: string }
        dimension: { type: integer }
        metric: { type: string, enum: [L2, COSINE] }
        efSearch: { type: integer }
        M: { type: integer }
        efConstruction: { type: integer }
        hnswEnabled: { type: boolean }
  responses:
    BadRequest:
      description: Ungültige Anforderung
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
    NotFound:
      description: Nicht gefunden
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
    InternalError:
      description: Interner Serverfehler
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/ErrorResponse'
  schemas:
    ErrorResponse:
      type: object
      properties:
        error: { type: boolean }
        message: { type: string }
        status_code: { type: integer }
      required: [error, message, status_code]
    CacheQueryRequest:
      type: object
      properties:
        key: { type: string, description: Eindeutiger Schlüssel }
        prompt: { type: string, description: Freitext für semantische Suche }
        embedding:
          type: array
          items: { type: number }
          description: Vektor für Semantik-Abgleich
        top_k: { type: integer, minimum: 1, default: 1 }
        allow_insert_on_miss: { type: boolean, default: false }
        ttl_sec: { type: integer, minimum: 0 }
        metadata: { type: object, additionalProperties: true }
      anyOf:
        - required: [key]
        - required: [prompt]
        - required: [embedding]
    CacheHit:
      type: object
      properties:
        key: { type: string }
        value: { type: object, additionalProperties: true }
        score: { type: number }
        metadata: { type: object, additionalProperties: true }
    CacheQueryResponse:
      type: object
      properties:
        hit: { type: boolean }
        hits:
          type: array
          items: { $ref: '#/components/schemas/CacheHit' }
          description: Top‑K Ergebnisse bei semantischer Suche
      required: [hit]
    CachePutRequest:
      type: object
      properties:
        key: { type: string }
        value: { type: object, additionalProperties: true }
        embedding:
          type: array
          items: { type: number }
        ttl_sec: { type: integer, minimum: 0 }
        metadata: { type: object, additionalProperties: true }
      required: [key, value]
    CachePutResponse:
      type: object
      properties:
        success: { type: boolean }
        key: { type: string }
        expires_at: { type: string, format: date-time, nullable: true }
      required: [success, key]
    CacheStatsResponse:
      type: object
      properties:
        entries: { type: integer, format: int64 }
        hit_ratio_1m: { type: number }
        hit_ratio_1h: { type: number }
        evictions_total: { type: integer, format: int64 }
        bytes: { type: integer, format: int64 }
      required: [entries]
    LlmMessage:
      type: object
      properties:
        role: { type: string, enum: [user, system, assistant, tool] }
        content: { type: string }
    ReasoningStep:
      type: object
      properties:
        type: { type: string, description: chain_of_thought | tool_plan | scratchpad }
        content:
          type: array
          items: { type: string }
    LlmInteractionRequest:
      type: object
      properties:
        model: { type: string }
        messages:
          type: array
          items: { $ref: '#/components/schemas/LlmMessage' }
        reasoning_steps:
          type: array
          items: { $ref: '#/components/schemas/ReasoningStep' }
        metadata: { type: object, additionalProperties: true }
      required: [model, messages]
    LlmInteraction:
      type: object
      properties:
        id: { type: string }
        created_at: { type: string, format: date-time }
        model: { type: string }
        messages:
          type: array
          items: { $ref: '#/components/schemas/LlmMessage' }
        reasoning_steps:
          type: array
          items: { $ref: '#/components/schemas/ReasoningStep' }
        metadata: { type: object, additionalProperties: true }
    LlmInteractionResponse:
      type: object
      properties:
        id: { type: string }
        success: { type: boolean }
      required: [id, success]
    ChangeEntry:
      type: object
      properties:
        seq: { type: integer, format: int64 }
        ts: { type: string, format: date-time }
        op: { type: string, enum: [put, delete] }
        key: { type: string }
        table: { type: string }
        value: { type: object, additionalProperties: true, nullable: true }
        prev: { type: object, additionalProperties: true, nullable: true }
        txn_id: { type: string, nullable: true }
    ChangefeedResponse:
      type: object
      properties:
        from_seq: { type: integer, format: int64 }
        next_seq: { type: integer, format: int64 }
        entries:
          type: array
          items: { $ref: '#/components/schemas/ChangeEntry' }
      required: [from_seq, next_seq, entries]
