
<!doctype html>
<html lang="de" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Offizielle Dokumentation für ThemisDB (Architektur, Storage, Query/AQL, Sicherheit, APIs und Betrieb)">
      
      
      
        <link rel="canonical" href="https://example.local/themisdb/docs/print_page/">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>Gesamte Dokumentation (Druckansicht) - ThemisDB Docs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../css/print-site.css">
    
      <link rel="stylesheet" href="../css/print-site-material.css">
    
    <script>__md_scope=new URL("/themisdb/docs/",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  
        <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function () {
            remove_material_navigation();remove_mkdocs_theme_navigation();generate_toc();
        })
        </script>
        </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#index" class="md-skip">
          Zum Inhalt
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Kopfzeile">
    <a href=".." title="ThemisDB Docs" class="md-header__button md-logo" aria-label="ThemisDB Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ThemisDB Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Gesamte Dokumentation (Druckansicht)
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Suche" placeholder="Suche" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Suche">
        
        <button type="reset" class="md-search__icon md-icon" title="Zurücksetzen" aria-label="Zurücksetzen" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Suche wird initialisiert
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/makr-code/ThemisDB" title="Zum Repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    makr-code/ThemisDB
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Hauptnavigation" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
  
    
  
  Übersicht

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../architecture/" class="md-tabs__link">
        
  
  
    
  
  Architektur

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../base_entity/" class="md-tabs__link">
          
  
  
  Basismodell

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../storage/geo_relational_schema/" class="md-tabs__link">
          
  
  
  Storage & MVCC

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../indexes/" class="md-tabs__link">
          
  
  
  Indexe & Statistiken

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../query_engine_aql/" class="md-tabs__link">
          
  
  
  Query & AQL

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../content_pipeline/" class="md-tabs__link">
          
  
  
  Content Pipeline

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../search/hybrid_search_design/" class="md-tabs__link">
          
  
  
  Suche

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../performance_benchmarks/" class="md-tabs__link">
          
  
  
  Performance & Benchmarks

        </a>
      </li>
    
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../quality_assurance/" class="md-tabs__link">
        
  
  
    
  
  Qualitätssicherung

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../vector_ops/" class="md-tabs__link">
          
  
  
  Vektor & GNN

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../security/overview/" class="md-tabs__link">
          
  
  
  Sicherheit & Governance

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../deployment/" class="md-tabs__link">
          
  
  
  Deployment & Betrieb

        </a>
      </li>
    
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../publishing/" class="md-tabs__link">
        
  
  
    
  
  Publikation & Ablage

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../admin_tools_admin_guide/" class="md-tabs__link">
          
  
  
  Admin-Tools

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../apis/openapi/" class="md-tabs__link">
          
  
  
  APIs

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../styleguide/" class="md-tabs__link">
          
  
  
  Styleguide & Glossar

        </a>
      </li>
    
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../roadmap/" class="md-tabs__link">
        
  
  
    
  
  Roadmap

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../changelog/" class="md-tabs__link">
        
  
  
    
  
  Changelog

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="./" class="md-tabs__link">
        
  
  
    
  
  Gesamte Dokumentation (Druckansicht)

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="ThemisDB Docs" class="md-nav__button md-logo" aria-label="ThemisDB Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    ThemisDB Docs
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/makr-code/ThemisDB" title="Zum Repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    makr-code/ThemisDB
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Übersicht
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../architecture/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Architektur
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Basismodell
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Basismodell
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../base_entity/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Base Entity & Keys
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../path_constraints/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Pfad-Constraints
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../property_graph_model/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Property Graph Modell
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Storage & MVCC
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Storage & MVCC
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../storage/geo_relational_schema/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Storage-Layout (Geo/Relational)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../storage/rocksdb_layout/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    RocksDB Storage
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mvcc_design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MVCC-Design
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../transactions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Transaktionen
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../time_series/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Time-Series Überblick
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../memory_tuning/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Memory Tuning
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Indexe & Statistiken
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Indexe & Statistiken
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../indexes/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Indexe
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../index_stats_maintenance/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Index-Statistiken & Wartung
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../cursor_pagination/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Cursor/Pagination
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Query & AQL
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Query & AQL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../query_engine_aql/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Query Engine & AQL
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../aql_syntax/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    AQL Syntax
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../aql_explain_profile/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Explain & Profile
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../recursive_path_queries/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Rekursive Pfadabfragen
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../temporal_graphs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Temporale Graphen
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../temporal_time_range_queries/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Zeitbereichs-Abfragen
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../semantic_cache/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Semantischer Cache
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Content Pipeline
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Content Pipeline
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../content_pipeline/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Content Pipeline
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../content_architecture/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Architektur-Details
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../content/ingestion/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Ingestion
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ingestion/json_ingestion_spec/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    JSON Ingestion Spec
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../content/geo_processor_design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Geo-Processor Design
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../content/image_processor_design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Image-Processor Design
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Suche
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            Suche
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../search/hybrid_search_design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Hybrid Search Design
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../search/pagination_benchmarks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Pagination Benchmarks
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Performance & Benchmarks
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            Performance & Benchmarks
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../performance_benchmarks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Überblick & Tuning
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../compression_benchmarks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Kompression
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../search/pagination_benchmarks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Pagination Benchmarks
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../quality_assurance/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Qualitätssicherung
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          <label class="md-nav__link" for="__nav_11" id="__nav_11_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Vektor & GNN
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            Vektor & GNN
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../vector_ops/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Vektor-Operationen
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../gnn_embeddings/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    GNN Embeddings
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../hnsw_persistence/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    HNSW Persistenz & Warmstart
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
        
          
          <label class="md-nav__link" for="__nav_12" id="__nav_12_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Sicherheit & Governance
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_12">
            <span class="md-nav__icon md-icon"></span>
            Sicherheit & Governance
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security/overview/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Überblick
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../rbac_authorization/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    RBAC & Authorization
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security/key_management/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Schlüsselverwaltung
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../encryption_strategy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Verschlüsselungsstrategie
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../encryption_deployment/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Verschlüsselungsdeployment
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../column_encryption/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Spaltenverschlüsselung
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security/pii_detection/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PII-Detection (Überblick)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../pii_detection_engines/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PII-Detection Engines
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../pii_engine_signing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PII Engine Signing
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security/audit_and_retention/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Audit & Retention
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security/threat_model/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Threat Model
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security_hardening_guide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Security Hardening Guide
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security_audit_checklist/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Security Audit Checklist
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../compliance_audit/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Compliance Audit
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../compliance_governance_strategy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Governance-Strategie
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../compliance_integration/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Compliance-Integration
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../governance_usage/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Governance Usage
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../security/security_compliance_review/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Security/Compliance Review
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_13" >
        
          
          <label class="md-nav__link" for="__nav_13" id="__nav_13_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Deployment & Betrieb
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_13_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_13">
            <span class="md-nav__icon md-icon"></span>
            Deployment & Betrieb
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../deployment/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Deployment
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tracing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Tracing & Observability
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../change_data_capture/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Change Data Capture (CDC)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../operations_runbook/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Operations Runbook
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../publishing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Publikation & Ablage
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_15" >
        
          
          <label class="md-nav__link" for="__nav_15" id="__nav_15_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Admin-Tools
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_15_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_15">
            <span class="md-nav__icon md-icon"></span>
            Admin-Tools
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../admin_tools_admin_guide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Admin Guide
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../admin_tools_user_guide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    User Guide
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../admin_tools_feature_matrix/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Feature Matrix
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../admin_tools_search_sort_filter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Suche/Sortierung/Filter
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../admin_tools_demo_script/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Demo-Script
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_16" >
        
          
          <label class="md-nav__link" for="__nav_16" id="__nav_16_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    APIs
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_16_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_16">
            <span class="md-nav__icon md-icon"></span>
            APIs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../apis/openapi/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    OpenAPI & Endpunkte
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../apis/openapi.md#sse-streaming-changefeed" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    SSE-Streaming (Changefeed)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_17" >
        
          
          <label class="md-nav__link" for="__nav_17" id="__nav_17_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Styleguide & Glossar
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_17_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_17">
            <span class="md-nav__icon md-icon"></span>
            Styleguide & Glossar
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../styleguide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Styleguide
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../glossary/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Glossar
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../roadmap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Roadmap
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Changelog
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Gesamte Dokumentation (Druckansicht)
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Gesamte Dokumentation (Druckansicht)
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Inhaltsverzeichnis">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Inhaltsverzeichnis
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#index" class="md-nav__link">
    <span class="md-ellipsis">
      1 Übersicht
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#architecture" class="md-nav__link">
    <span class="md-ellipsis">
      2 Architektur
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-3" class="md-nav__link">
    <span class="md-ellipsis">
      3 Basismodell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3 Basismodell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#base_entity" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 Base Entity & Keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#path_constraints" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 Pfad-Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#property_graph_model" class="md-nav__link">
    <span class="md-ellipsis">
      3.3 Property Graph Modell
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-4" class="md-nav__link">
    <span class="md-ellipsis">
      4 Storage & MVCC
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4 Storage &amp; MVCC">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#storage-geo_relational_schema" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 Storage-Layout (Geo/Relational)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#storage-rocksdb_layout" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 RocksDB Storage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mvcc_design" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 MVCC-Design
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transactions" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 Transaktionen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#time_series" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 Time-Series Überblick
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memory_tuning" class="md-nav__link">
    <span class="md-ellipsis">
      4.6 Memory Tuning
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-5" class="md-nav__link">
    <span class="md-ellipsis">
      5 Indexe & Statistiken
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5 Indexe &amp; Statistiken">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#indexes" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 Indexe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index_stats_maintenance" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 Index-Statistiken & Wartung
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cursor_pagination" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 Cursor/Pagination
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-6" class="md-nav__link">
    <span class="md-ellipsis">
      6 Query & AQL
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6 Query &amp; AQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#query_engine_aql" class="md-nav__link">
    <span class="md-ellipsis">
      6.1 Query Engine & AQL
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aql_syntax" class="md-nav__link">
    <span class="md-ellipsis">
      6.2 AQL Syntax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aql_explain_profile" class="md-nav__link">
    <span class="md-ellipsis">
      6.3 Explain & Profile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursive_path_queries" class="md-nav__link">
    <span class="md-ellipsis">
      6.4 Rekursive Pfadabfragen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#temporal_graphs" class="md-nav__link">
    <span class="md-ellipsis">
      6.5 Temporale Graphen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#temporal_time_range_queries" class="md-nav__link">
    <span class="md-ellipsis">
      6.6 Zeitbereichs-Abfragen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#semantic_cache" class="md-nav__link">
    <span class="md-ellipsis">
      6.7 Semantischer Cache
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-7" class="md-nav__link">
    <span class="md-ellipsis">
      7 Content Pipeline
    </span>
  </a>
  
    <nav class="md-nav" aria-label="7 Content Pipeline">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#content_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      7.1 Content Pipeline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content_architecture" class="md-nav__link">
    <span class="md-ellipsis">
      7.2 Architektur-Details
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content-ingestion" class="md-nav__link">
    <span class="md-ellipsis">
      7.3 Ingestion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ingestion-json_ingestion_spec" class="md-nav__link">
    <span class="md-ellipsis">
      7.4 JSON Ingestion Spec
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content-geo_processor_design" class="md-nav__link">
    <span class="md-ellipsis">
      7.5 Geo-Processor Design
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content-image_processor_design" class="md-nav__link">
    <span class="md-ellipsis">
      7.6 Image-Processor Design
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-8" class="md-nav__link">
    <span class="md-ellipsis">
      8 Suche
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8 Suche">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#search-hybrid_search_design" class="md-nav__link">
    <span class="md-ellipsis">
      8.1 Hybrid Search Design
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#search-pagination_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      8.2 Pagination Benchmarks
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-9" class="md-nav__link">
    <span class="md-ellipsis">
      9 Performance & Benchmarks
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9 Performance &amp; Benchmarks">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#performance_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      9.1 Überblick & Tuning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compression_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      9.2 Kompression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#search-pagination_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      9.3 Pagination Benchmarks
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quality_assurance" class="md-nav__link">
    <span class="md-ellipsis">
      10 Qualitätssicherung
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-11" class="md-nav__link">
    <span class="md-ellipsis">
      11 Vektor & GNN
    </span>
  </a>
  
    <nav class="md-nav" aria-label="11 Vektor &amp; GNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vector_ops" class="md-nav__link">
    <span class="md-ellipsis">
      11.1 Vektor-Operationen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gnn_embeddings" class="md-nav__link">
    <span class="md-ellipsis">
      11.2 GNN Embeddings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hnsw_persistence" class="md-nav__link">
    <span class="md-ellipsis">
      11.3 HNSW Persistenz & Warmstart
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-12" class="md-nav__link">
    <span class="md-ellipsis">
      12 Sicherheit & Governance
    </span>
  </a>
  
    <nav class="md-nav" aria-label="12 Sicherheit &amp; Governance">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#security-overview" class="md-nav__link">
    <span class="md-ellipsis">
      12.1 Überblick
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rbac_authorization" class="md-nav__link">
    <span class="md-ellipsis">
      12.2 RBAC & Authorization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-key_management" class="md-nav__link">
    <span class="md-ellipsis">
      12.3 Schlüsselverwaltung
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#encryption_strategy" class="md-nav__link">
    <span class="md-ellipsis">
      12.4 Verschlüsselungsstrategie
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#encryption_deployment" class="md-nav__link">
    <span class="md-ellipsis">
      12.5 Verschlüsselungsdeployment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#column_encryption" class="md-nav__link">
    <span class="md-ellipsis">
      12.6 Spaltenverschlüsselung
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-pii_detection" class="md-nav__link">
    <span class="md-ellipsis">
      12.7 PII-Detection (Überblick)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pii_detection_engines" class="md-nav__link">
    <span class="md-ellipsis">
      12.8 PII-Detection Engines
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pii_engine_signing" class="md-nav__link">
    <span class="md-ellipsis">
      12.9 PII Engine Signing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-audit_and_retention" class="md-nav__link">
    <span class="md-ellipsis">
      12.10 Audit & Retention
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-threat_model" class="md-nav__link">
    <span class="md-ellipsis">
      12.11 Threat Model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security_hardening_guide" class="md-nav__link">
    <span class="md-ellipsis">
      12.12 Security Hardening Guide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security_audit_checklist" class="md-nav__link">
    <span class="md-ellipsis">
      12.13 Security Audit Checklist
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compliance_audit" class="md-nav__link">
    <span class="md-ellipsis">
      12.14 Compliance Audit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compliance_governance_strategy" class="md-nav__link">
    <span class="md-ellipsis">
      12.15 Governance-Strategie
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compliance_integration" class="md-nav__link">
    <span class="md-ellipsis">
      12.16 Compliance-Integration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#governance_usage" class="md-nav__link">
    <span class="md-ellipsis">
      12.17 Governance Usage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-security_compliance_review" class="md-nav__link">
    <span class="md-ellipsis">
      12.18 Security/Compliance Review
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-13" class="md-nav__link">
    <span class="md-ellipsis">
      13 Deployment & Betrieb
    </span>
  </a>
  
    <nav class="md-nav" aria-label="13 Deployment &amp; Betrieb">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#deployment" class="md-nav__link">
    <span class="md-ellipsis">
      13.1 Deployment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tracing" class="md-nav__link">
    <span class="md-ellipsis">
      13.2 Tracing & Observability
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#change_data_capture" class="md-nav__link">
    <span class="md-ellipsis">
      13.3 Change Data Capture (CDC)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operations_runbook" class="md-nav__link">
    <span class="md-ellipsis">
      13.4 Operations Runbook
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#publishing" class="md-nav__link">
    <span class="md-ellipsis">
      14 Publikation & Ablage
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-15" class="md-nav__link">
    <span class="md-ellipsis">
      15 Admin-Tools
    </span>
  </a>
  
    <nav class="md-nav" aria-label="15 Admin-Tools">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#admin_tools_admin_guide" class="md-nav__link">
    <span class="md-ellipsis">
      15.1 Admin Guide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_user_guide" class="md-nav__link">
    <span class="md-ellipsis">
      15.2 User Guide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_feature_matrix" class="md-nav__link">
    <span class="md-ellipsis">
      15.3 Feature Matrix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_search_sort_filter" class="md-nav__link">
    <span class="md-ellipsis">
      15.4 Suche/Sortierung/Filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_demo_script" class="md-nav__link">
    <span class="md-ellipsis">
      15.5 Demo-Script
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-16" class="md-nav__link">
    <span class="md-ellipsis">
      16 APIs
    </span>
  </a>
  
    <nav class="md-nav" aria-label="16 APIs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#apis-openapi" class="md-nav__link">
    <span class="md-ellipsis">
      16.1 OpenAPI & Endpunkte
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-17" class="md-nav__link">
    <span class="md-ellipsis">
      17 Styleguide & Glossar
    </span>
  </a>
  
    <nav class="md-nav" aria-label="17 Styleguide &amp; Glossar">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#styleguide" class="md-nav__link">
    <span class="md-ellipsis">
      17.1 Styleguide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#glossary" class="md-nav__link">
    <span class="md-ellipsis">
      17.2 Glossar
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#roadmap" class="md-nav__link">
    <span class="md-ellipsis">
      18 Roadmap
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#changelog" class="md-nav__link">
    <span class="md-ellipsis">
      19 Changelog
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Inhaltsverzeichnis">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Inhaltsverzeichnis
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#index" class="md-nav__link">
    <span class="md-ellipsis">
      1 Übersicht
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#architecture" class="md-nav__link">
    <span class="md-ellipsis">
      2 Architektur
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-3" class="md-nav__link">
    <span class="md-ellipsis">
      3 Basismodell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3 Basismodell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#base_entity" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 Base Entity & Keys
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#path_constraints" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 Pfad-Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#property_graph_model" class="md-nav__link">
    <span class="md-ellipsis">
      3.3 Property Graph Modell
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-4" class="md-nav__link">
    <span class="md-ellipsis">
      4 Storage & MVCC
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4 Storage &amp; MVCC">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#storage-geo_relational_schema" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 Storage-Layout (Geo/Relational)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#storage-rocksdb_layout" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 RocksDB Storage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mvcc_design" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 MVCC-Design
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transactions" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 Transaktionen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#time_series" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 Time-Series Überblick
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memory_tuning" class="md-nav__link">
    <span class="md-ellipsis">
      4.6 Memory Tuning
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-5" class="md-nav__link">
    <span class="md-ellipsis">
      5 Indexe & Statistiken
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5 Indexe &amp; Statistiken">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#indexes" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 Indexe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index_stats_maintenance" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 Index-Statistiken & Wartung
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cursor_pagination" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 Cursor/Pagination
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-6" class="md-nav__link">
    <span class="md-ellipsis">
      6 Query & AQL
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6 Query &amp; AQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#query_engine_aql" class="md-nav__link">
    <span class="md-ellipsis">
      6.1 Query Engine & AQL
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aql_syntax" class="md-nav__link">
    <span class="md-ellipsis">
      6.2 AQL Syntax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aql_explain_profile" class="md-nav__link">
    <span class="md-ellipsis">
      6.3 Explain & Profile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursive_path_queries" class="md-nav__link">
    <span class="md-ellipsis">
      6.4 Rekursive Pfadabfragen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#temporal_graphs" class="md-nav__link">
    <span class="md-ellipsis">
      6.5 Temporale Graphen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#temporal_time_range_queries" class="md-nav__link">
    <span class="md-ellipsis">
      6.6 Zeitbereichs-Abfragen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#semantic_cache" class="md-nav__link">
    <span class="md-ellipsis">
      6.7 Semantischer Cache
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-7" class="md-nav__link">
    <span class="md-ellipsis">
      7 Content Pipeline
    </span>
  </a>
  
    <nav class="md-nav" aria-label="7 Content Pipeline">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#content_pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      7.1 Content Pipeline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content_architecture" class="md-nav__link">
    <span class="md-ellipsis">
      7.2 Architektur-Details
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content-ingestion" class="md-nav__link">
    <span class="md-ellipsis">
      7.3 Ingestion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ingestion-json_ingestion_spec" class="md-nav__link">
    <span class="md-ellipsis">
      7.4 JSON Ingestion Spec
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content-geo_processor_design" class="md-nav__link">
    <span class="md-ellipsis">
      7.5 Geo-Processor Design
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#content-image_processor_design" class="md-nav__link">
    <span class="md-ellipsis">
      7.6 Image-Processor Design
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-8" class="md-nav__link">
    <span class="md-ellipsis">
      8 Suche
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8 Suche">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#search-hybrid_search_design" class="md-nav__link">
    <span class="md-ellipsis">
      8.1 Hybrid Search Design
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#search-pagination_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      8.2 Pagination Benchmarks
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-9" class="md-nav__link">
    <span class="md-ellipsis">
      9 Performance & Benchmarks
    </span>
  </a>
  
    <nav class="md-nav" aria-label="9 Performance &amp; Benchmarks">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#performance_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      9.1 Überblick & Tuning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compression_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      9.2 Kompression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#search-pagination_benchmarks" class="md-nav__link">
    <span class="md-ellipsis">
      9.3 Pagination Benchmarks
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quality_assurance" class="md-nav__link">
    <span class="md-ellipsis">
      10 Qualitätssicherung
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-11" class="md-nav__link">
    <span class="md-ellipsis">
      11 Vektor & GNN
    </span>
  </a>
  
    <nav class="md-nav" aria-label="11 Vektor &amp; GNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vector_ops" class="md-nav__link">
    <span class="md-ellipsis">
      11.1 Vektor-Operationen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gnn_embeddings" class="md-nav__link">
    <span class="md-ellipsis">
      11.2 GNN Embeddings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hnsw_persistence" class="md-nav__link">
    <span class="md-ellipsis">
      11.3 HNSW Persistenz & Warmstart
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-12" class="md-nav__link">
    <span class="md-ellipsis">
      12 Sicherheit & Governance
    </span>
  </a>
  
    <nav class="md-nav" aria-label="12 Sicherheit &amp; Governance">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#security-overview" class="md-nav__link">
    <span class="md-ellipsis">
      12.1 Überblick
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rbac_authorization" class="md-nav__link">
    <span class="md-ellipsis">
      12.2 RBAC & Authorization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-key_management" class="md-nav__link">
    <span class="md-ellipsis">
      12.3 Schlüsselverwaltung
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#encryption_strategy" class="md-nav__link">
    <span class="md-ellipsis">
      12.4 Verschlüsselungsstrategie
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#encryption_deployment" class="md-nav__link">
    <span class="md-ellipsis">
      12.5 Verschlüsselungsdeployment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#column_encryption" class="md-nav__link">
    <span class="md-ellipsis">
      12.6 Spaltenverschlüsselung
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-pii_detection" class="md-nav__link">
    <span class="md-ellipsis">
      12.7 PII-Detection (Überblick)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pii_detection_engines" class="md-nav__link">
    <span class="md-ellipsis">
      12.8 PII-Detection Engines
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pii_engine_signing" class="md-nav__link">
    <span class="md-ellipsis">
      12.9 PII Engine Signing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-audit_and_retention" class="md-nav__link">
    <span class="md-ellipsis">
      12.10 Audit & Retention
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-threat_model" class="md-nav__link">
    <span class="md-ellipsis">
      12.11 Threat Model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security_hardening_guide" class="md-nav__link">
    <span class="md-ellipsis">
      12.12 Security Hardening Guide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security_audit_checklist" class="md-nav__link">
    <span class="md-ellipsis">
      12.13 Security Audit Checklist
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compliance_audit" class="md-nav__link">
    <span class="md-ellipsis">
      12.14 Compliance Audit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compliance_governance_strategy" class="md-nav__link">
    <span class="md-ellipsis">
      12.15 Governance-Strategie
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#compliance_integration" class="md-nav__link">
    <span class="md-ellipsis">
      12.16 Compliance-Integration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#governance_usage" class="md-nav__link">
    <span class="md-ellipsis">
      12.17 Governance Usage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#security-security_compliance_review" class="md-nav__link">
    <span class="md-ellipsis">
      12.18 Security/Compliance Review
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-13" class="md-nav__link">
    <span class="md-ellipsis">
      13 Deployment & Betrieb
    </span>
  </a>
  
    <nav class="md-nav" aria-label="13 Deployment &amp; Betrieb">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#deployment" class="md-nav__link">
    <span class="md-ellipsis">
      13.1 Deployment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tracing" class="md-nav__link">
    <span class="md-ellipsis">
      13.2 Tracing & Observability
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#change_data_capture" class="md-nav__link">
    <span class="md-ellipsis">
      13.3 Change Data Capture (CDC)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operations_runbook" class="md-nav__link">
    <span class="md-ellipsis">
      13.4 Operations Runbook
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#publishing" class="md-nav__link">
    <span class="md-ellipsis">
      14 Publikation & Ablage
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-15" class="md-nav__link">
    <span class="md-ellipsis">
      15 Admin-Tools
    </span>
  </a>
  
    <nav class="md-nav" aria-label="15 Admin-Tools">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#admin_tools_admin_guide" class="md-nav__link">
    <span class="md-ellipsis">
      15.1 Admin Guide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_user_guide" class="md-nav__link">
    <span class="md-ellipsis">
      15.2 User Guide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_feature_matrix" class="md-nav__link">
    <span class="md-ellipsis">
      15.3 Feature Matrix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_search_sort_filter" class="md-nav__link">
    <span class="md-ellipsis">
      15.4 Suche/Sortierung/Filter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#admin_tools_demo_script" class="md-nav__link">
    <span class="md-ellipsis">
      15.5 Demo-Script
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-16" class="md-nav__link">
    <span class="md-ellipsis">
      16 APIs
    </span>
  </a>
  
    <nav class="md-nav" aria-label="16 APIs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#apis-openapi" class="md-nav__link">
    <span class="md-ellipsis">
      16.1 OpenAPI & Endpunkte
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#section-17" class="md-nav__link">
    <span class="md-ellipsis">
      17 Styleguide & Glossar
    </span>
  </a>
  
    <nav class="md-nav" aria-label="17 Styleguide &amp; Glossar">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#styleguide" class="md-nav__link">
    <span class="md-ellipsis">
      17.1 Styleguide
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#glossary" class="md-nav__link">
    <span class="md-ellipsis">
      17.2 Glossar
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#roadmap" class="md-nav__link">
    <span class="md-ellipsis">
      18 Roadmap
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#changelog" class="md-nav__link">
    <span class="md-ellipsis">
      19 Changelog
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<div id="print-site-page" class="print-site-enumerate-headings print-site-enumerate-figures">
        <section id="print-site-cover-page">
            <div style="text-align: center; padding: 100px 0;">
  <h1 style="font-size: 3em; margin-bottom: 0.5em;">ThemisDB</h1>
  <h2 style="font-size: 2em; color: #666; margin-bottom: 2em;">Vollständige Dokumentation</h2>
  <p style="font-size: 1.2em; color: #888;">Architektur • Query Engine • Deployment • Security</p>
  <hr style="width: 50%; margin: 3em auto; border: none; border-top: 2px solid #ddd;">
  <p style="font-size: 1em; color: #999;">ThemisDB Dokumentation</p>
  <p style="font-size: 0.9em; color: #aaa;">© 2025 ThemisDB Team</p>
</div>
        </section>
        
        <div id="print-site-banner">
            <div style="background: #f0f0f0; padding: 1em; margin-bottom: 2em; border-left: 4px solid #007acc;">
  <strong>💡 Hinweis:</strong> Dies ist eine druckoptimierte Gesamtansicht der Dokumentation. 
  Verwenden Sie Ihren Browser (Strg+P / Cmd+P), um diese Seite als PDF zu speichern.
</div>
        </div>
        
        <section class="print-page">
            <div id="print-page-toc" data-toc-depth="3">
                <nav role='navigation' class='print-page-toc-nav'>
                <h1 class='print-page-toc-title'>Inhaltsverzeichnis</h1>
                </nav>
            </div>
        </section>
        <section class="print-page" id="index" heading-number="1"><h1 id="index-themisdb-dokumentation">ThemisDB Dokumentation<a class="headerlink" href="#index-themisdb-dokumentation" title="Permanent link">&para;</a></h1>
<p>Willkommen bei ThemisDB. Diese Dokumentation beschreibt Architektur, Datenmodell, Storage &amp; MVCC, Query/AQL, Indexe, Content-Pipeline, Vektor-/Zeitreihenfunktionen, Sicherheit/Governance, APIs, Admin-Tools sowie Betrieb &amp; Performance.</p>
<h2 id="index-fur-wen-ist-das-gedacht">Für wen ist das gedacht?<a class="headerlink" href="#index-fur-wen-ist-das-gedacht" title="Permanent link">&para;</a></h2>
<ul>
<li>Benutzerinnen/Benutzer: Wie verwende ich AQL und die Server-APIs?</li>
<li>Operator/DevOps: Deployment, Betrieb, Observability, Backup/Restore</li>
<li>Entwicklerinnen/Entwickler: Architektur, interne Module, Erweiterungspunkte</li>
</ul>
<h2 id="index-schnellstart">Schnellstart<a class="headerlink" href="#index-schnellstart" title="Permanent link">&para;</a></h2>
<ul>
<li>Architekturüberblick: siehe „Architektur“</li>
<li>AQL Einstieg: siehe „Query &amp; AQL → AQL Syntax“</li>
<li>REST-APIs: siehe „APIs → OpenAPI &amp; Endpunkte“</li>
</ul>
<h2 id="index-aktuelle-schwerpunkte">Aktuelle Schwerpunkte<a class="headerlink" href="#index-aktuelle-schwerpunkte" title="Permanent link">&para;</a></h2>
<ul>
<li>TSStore und Aggregationen (Stabilisierung)</li>
<li>Tracing/Observability</li>
<li>API-Hardening (Keys, Classification, Reports)</li>
</ul>
<h2 id="index-nachste-schritte">Nächste Schritte<a class="headerlink" href="#index-nachste-schritte" title="Permanent link">&para;</a></h2>
<ul>
<li>OpenAPI um Keys/Classification/Reports aktualisieren</li>
<li>Konsolidierung Storage &amp; MVCC-Dokumente</li>
<li>Styleguide &amp; Glossar finalisieren</li>
</ul></section><section class="print-page" id="architecture" heading-number="2"><h1 id="architecture-themis-architecture">THEMIS Architecture<a class="headerlink" href="#architecture-themis-architecture" title="Permanent link">&para;</a></h1>
<h2 id="architecture-system-overview">System Overview<a class="headerlink" href="#architecture-system-overview" title="Permanent link">&para;</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                         HTTP/REST API                            │
│                      (Boost.Beast - Port 8765)                   │
└───────────────────────┬─────────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
        ▼               ▼               ▼
┌──────────────┐ ┌────────────┐ ┌─────────────┐
│   Entity     │ │   Query    │ │   Index     │
│   Manager    │ │   Engine   │ │   Manager   │
└──────┬───────┘ └─────┬──────┘ └──────┬──────┘
       │               │                │
       │        ┌──────┴──────┐        │
       │        │             │        │
       ▼        ▼             ▼        ▼
┌──────────────────────────────────────────────────────────────┐
│                     Index Projections                         │
│  ┌────────────┐ ┌───────────┐ ┌──────────┐ ┌──────────────┐ │
│  │ Secondary  │ │   Graph   │ │  Vector  │ │   Spatial    │ │
│  │   Index    │ │   Index   │ │  Index   │ │    Index     │ │
│  │ (Equality, │ │ (Outdex/  │ │ (HNSW/   │ │ (Geo, R*Tree)│ │
│  │  Range,    │ │  Indeg)   │ │  Faiss)  │ │              │ │
│  │ Composite, │ │           │ │          │ │              │ │
│  │ Fulltext)  │ │           │ │          │ │              │ │
│  └────────────┘ └───────────┘ └──────────┘ └──────────────┘ │
└──────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌──────────────────────────────────────────────────────────────┐
│                   Base Entity Layer                           │
│               (Canonical Storage Format)                      │
│                                                               │
│  Key Schema: table:primary_key                                │
│  Value: JSON blob (simdjson deserialization)                  │
│  Metadata: version, timestamp, blob_size                      │
└──────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌──────────────────────────────────────────────────────────────┐
│                    RocksDB LSM-Tree                           │
│                                                               │
│  • Write Buffer: 256 MB memtable                              │
│  • Block Cache: 1 GB (LRU)                                    │
│  • Compression: LZ4 (L0-L5), ZSTD (L6 bottommost)             │
│  • Compaction: Level-based (7 levels)                         │
│  • Bloom Filters: 10 bits per key                             │
└──────────────────────────────────────────────────────────────┘
                        │
                        ▼
                  ┌─────────┐
                  │  Disk   │
                  │ Storage │
                  └─────────┘
</code></pre>
<h2 id="architecture-data-flow">Data Flow<a class="headerlink" href="#architecture-data-flow" title="Permanent link">&para;</a></h2>
<h3 id="architecture-write-path-put-entitiestablepk">Write Path (PUT /entities/table:pk)<a class="headerlink" href="#architecture-write-path-put-entitiestablepk" title="Permanent link">&para;</a></h3>
<pre><code>Client Request
     │
     ├──&gt; 1. HTTP Handler (http_server.cpp)
     │
     ├──&gt; 2. Deserialize JSON blob
     │         └─&gt; Extract indexed fields (_from, _to, columns)
     │
     ├──&gt; 3. Base Entity Layer (base_entity.cpp)
     │         └─&gt; Serialize to RocksDB format (key: table:pk)
     │
     ├──&gt; 4. Index Updates (parallel with TBB)
     │         ├─&gt; Secondary Indexes (equality, range, composite)
     │         ├─&gt; Graph Indexes (outdex/indeg if _from/_to present)
     │         └─&gt; Vector Indexes (if embedding present)
     │
     └──&gt; 5. RocksDB Write
               ├─&gt; Write to memtable (in-memory)
               ├─&gt; Write to WAL (durability)
               └─&gt; Response to client (async)
</code></pre>
<h3 id="architecture-read-path-post-query">Read Path (POST /query)<a class="headerlink" href="#architecture-read-path-post-query" title="Permanent link">&para;</a></h3>
<pre><code>Client Query
     │
     ├──&gt; 1. Query Parser (query_parser.cpp)
     │         └─&gt; Parse predicates, range, order_by
     │
     ├──&gt; 2. Query Optimizer (query_optimizer.cpp)
     │         ├─&gt; Index selection (selectivity analysis)
     │         ├─&gt; Predicate reordering (most selective first)
     │         └─&gt; Execution plan generation
     │
     ├──&gt; 3. Query Executor (query_engine.cpp)
     │         ├─&gt; Parallel index scans (TBB task_group)
     │         │    └─&gt; For each predicate: index.get(table, column, value)
     │         │
     │         ├─&gt; Intersection of candidate sets (sorted merge)
     │         │    └─&gt; Early termination on empty intermediate results
     │         │
     │         └─&gt; Parallel entity loading (batch processing)
     │              ├─&gt; Batch size: 50 entities
     │              ├─&gt; Threshold: 100 entities (parallelization overhead)
     │              └─&gt; TBB task_group for concurrent RocksDB gets
     │
     └──&gt; 4. Result Serialization
               ├─&gt; return: &quot;keys&quot; → JSON array of primary keys
               └─&gt; return: &quot;entities&quot; → JSON array of blob contents
</code></pre>
<h3 id="architecture-index-rebuild-flow-post-indexrebuild">Index Rebuild Flow (POST /index/rebuild)<a class="headerlink" href="#architecture-index-rebuild-flow-post-indexrebuild" title="Permanent link">&para;</a></h3>
<pre><code>Rebuild Request
     │
     ├──&gt; 1. Drop existing index keys (range delete in RocksDB)
     │
     ├──&gt; 2. Scan all entities in table (prefix scan: table:*)
     │
     ├──&gt; 3. Parallel reindexing (batch processing)
     │         ├─&gt; Batch size: 1000 entities
     │         ├─&gt; For each batch:
     │         │    ├─&gt; Deserialize entity
     │         │    ├─&gt; Extract indexed field value
     │         │    └─&gt; Write index entry (index:table:column:value -&gt; pk)
     │         │
     │         └─&gt; TBB parallel_for across batches
     │
     └──&gt; 4. Update metrics
               ├─&gt; rebuild_count++
               ├─&gt; rebuild_duration_ms
               └─&gt; rebuild_entities_processed
</code></pre>
<h2 id="architecture-thread-model">Thread Model<a class="headerlink" href="#architecture-thread-model" title="Permanent link">&para;</a></h2>
<h3 id="architecture-http-server-boostbeast">HTTP Server (Boost.Beast)<a class="headerlink" href="#architecture-http-server-boostbeast" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>I/O Threads</strong>: 8 threads (configurable)</li>
<li><strong>Accept Loop</strong>: Async accept on main thread</li>
<li><strong>Request Handling</strong>: Each connection handled by worker thread</li>
<li><strong>Connection Pool</strong>: Reused connections (keep-alive)</li>
</ul>
<h3 id="architecture-query-engine-intel-tbb">Query Engine (Intel TBB)<a class="headerlink" href="#architecture-query-engine-intel-tbb" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Task Scheduling</strong>: Work-stealing scheduler (automatic load balancing)</li>
<li><strong>Index Scans</strong>: <code>tbb::task_group</code> for parallel predicate evaluation</li>
<li><strong>Entity Loading</strong>: Batch-based parallelization (threshold: 100 entities)
  <code>cpp
  std::vector&lt;std::vector&lt;BaseEntity&gt;&gt; batches;
  tbb::task_group tg;
  for (size_t batch_idx = 0; batch_idx &lt; num_batches; ++batch_idx) {
      tg.run([&amp;, batch_idx]() {
          // Load entities from RocksDB (batch_size = 50)
          // Deserialize JSON blobs
      });
  }
  tg.wait(); // Barrier
  // Merge results</code></li>
<li><strong>Parallelization Benefit</strong>: Up to 3.5x speedup on 8-core systems</li>
</ul>
<h3 id="architecture-rocksdb-internal-threads">RocksDB Internal Threads<a class="headerlink" href="#architecture-rocksdb-internal-threads" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Flush Threads</strong>: 2 (memtable → SST files)</li>
<li><strong>Compaction Threads</strong>: 4 (LSM-Tree level compaction)</li>
<li><strong>WAL Sync</strong>: Background thread (fsync batching)</li>
</ul>
<h2 id="architecture-memory-hierarchy">Memory Hierarchy<a class="headerlink" href="#architecture-memory-hierarchy" title="Permanent link">&para;</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  L1: TBB Task Scheduler (per-thread allocation)             │
│      - Lock-free task queues                                 │
│      - Work-stealing deques                                  │
└─────────────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────────────┐
│  L2: RocksDB Memtable (256 MB)                               │
│      - SkipList structure (sorted by key)                    │
│      - Write-ahead Log (WAL) for durability                  │
└─────────────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────────────┐
│  L3: Block Cache (1 GB LRU)                                  │
│      - Decompressed SST blocks                               │
│      - Index/filter blocks (pinned)                          │
│      - Bloom filters (10 bits/key)                           │
└─────────────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────────────┐
│  L4: Operating System Page Cache                             │
│      - Memory-mapped SST files                               │
│      - Kernel read-ahead                                     │
└─────────────────────────────────────────────────────────────┘
                        │
┌─────────────────────────────────────────────────────────────┐
│  L5: Disk Storage (SSD/NVMe)                                 │
│      - SST files (2-64 MB per file)                          │
│      - 7 levels (L0-L6)                                      │
│      - LZ4 compression (L0-L5), ZSTD (L6)                    │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Memory Budget (Typical Configuration):</strong>
- Memtable: 256 MB
- Block Cache: 1024 MB
- TBB Scheduler: ~50 MB (8 threads)
- HTTP Buffers: ~32 MB (8 connections × 4 MB)
- <strong>Total</strong>: ~1.36 GB RAM</p>
<p>See <a href="#memory_tuning">memory_tuning.md</a> for tuning guidelines.</p>
<h2 id="architecture-index-key-schemas">Index Key Schemas<a class="headerlink" href="#architecture-index-key-schemas" title="Permanent link">&para;</a></h2>
<h3 id="architecture-secondary-index-equality">Secondary Index (Equality)<a class="headerlink" href="#architecture-secondary-index-equality" title="Permanent link">&para;</a></h3>
<pre><code>Format: index:table:column:value -&gt; primary_key
Example: index:users:city:Berlin -&gt; alice,bob,charlie
</code></pre>
<h3 id="architecture-range-index">Range Index<a class="headerlink" href="#architecture-range-index" title="Permanent link">&para;</a></h3>
<pre><code>Format: range:table:column:value -&gt; primary_key
Example: range:products:price:00000999 -&gt; p1,p2
Note: Values are zero-padded for lexicographic ordering
</code></pre>
<h3 id="architecture-graph-index-outdex">Graph Index (Outdex)<a class="headerlink" href="#architecture-graph-index-outdex" title="Permanent link">&para;</a></h3>
<pre><code>Format: outdeg:from_vertex -&gt; to_vertex1,to_vertex2,...
Example: outdeg:user:alice -&gt; user:bob,user:charlie
</code></pre>
<h3 id="architecture-graph-index-indeg">Graph Index (Indeg)<a class="headerlink" href="#architecture-graph-index-indeg" title="Permanent link">&para;</a></h3>
<pre><code>Format: indeg:to_vertex -&gt; from_vertex1,from_vertex2,...
Example: indeg:user:bob -&gt; user:alice,user:dave
</code></pre>
<h3 id="architecture-composite-index">Composite Index<a class="headerlink" href="#architecture-composite-index" title="Permanent link">&para;</a></h3>
<pre><code>Format: composite:table:col1:col2:val1:val2 -&gt; primary_key
Example: composite:orders:customer:status:alice:pending -&gt; o1,o5
</code></pre>
<h2 id="architecture-query-optimization">Query Optimization<a class="headerlink" href="#architecture-query-optimization" title="Permanent link">&para;</a></h2>
<h3 id="architecture-selectivity-estimation">Selectivity Estimation<a class="headerlink" href="#architecture-selectivity-estimation" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Index statistics: sample-based cardinality estimation
struct IndexStats {
    uint64_t unique_values;    // Distinct values in index
    uint64_t total_entries;    // Total indexed entities
    uint64_t sample_size;      // Sample used for estimation
};

// Selectivity calculation
double selectivity = unique_values / (double)total_entries;
uint64_t estimated_results = total_entries * selectivity;
</code></pre>
<h3 id="architecture-predicate-reordering">Predicate Reordering<a class="headerlink" href="#architecture-predicate-reordering" title="Permanent link">&para;</a></h3>
<pre><code>Input Query:
  predicates: [
    {column: &quot;department&quot;, value: &quot;Engineering&quot;},  // 1000 results
    {column: &quot;level&quot;, value: &quot;Senior&quot;}             // 50 results
  ]

After Optimization:
  execution_order: [
    {column: &quot;level&quot;, value: &quot;Senior&quot;},            // Start with most selective
    {column: &quot;department&quot;, value: &quot;Engineering&quot;}   // Intersect with smaller set
  ]

Benefit: 50 vs 1000 initial candidates (20x reduction)
</code></pre>
<h3 id="architecture-execution-modes">Execution Modes<a class="headerlink" href="#architecture-execution-modes" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Index-Accelerated</strong> (predicates with indexes):</li>
<li>Parallel index scans → intersection → entity loading</li>
<li>
<p>Typical latency: 0.1-2 ms (depending on result set size)</p>
</li>
<li>
<p><strong>Range-Aware</strong> (range predicates + ORDER BY):</p>
</li>
<li>Direct range scan → sorted results (no intersection)</li>
<li>
<p>Typical latency: 0.5-5 ms (depends on range width)</p>
</li>
<li>
<p><strong>Full-Scan Fallback</strong> (no indexes, allow_full_scan: true):</p>
</li>
<li>Sequential table scan → filter in memory</li>
<li>Typical latency: 10-500 ms (depends on table size)</li>
<li><strong>Warning</strong>: Expensive for large tables (&gt;10K entities)</li>
</ol>
<h2 id="architecture-compression-strategy">Compression Strategy<a class="headerlink" href="#architecture-compression-strategy" title="Permanent link">&para;</a></h2>
<h3 id="architecture-write-amplification-vs-storage-savings">Write Amplification vs Storage Savings<a class="headerlink" href="#architecture-write-amplification-vs-storage-savings" title="Permanent link">&para;</a></h3>
<pre><code>Level   | Compression | Write Amp | Use Case
--------|-------------|-----------|----------------------------------
L0-L5   | LZ4         | 1.05x     | Hot data (frequent compaction)
L6      | ZSTD        | 1.15x     | Cold data (infrequent compaction)
</code></pre>
<p><strong>Rationale:</strong>
- LZ4: Fast compression (33.8 MB/s write throughput, 2.1x ratio)
- ZSTD: Better ratio (32.3 MB/s, 2.8x ratio) but slower → only for bottommost level
- Hybrid strategy: Balance performance and storage efficiency</p>
<p>See <a href="#memory_tuning">memory_tuning.md</a> for benchmark results.</p>
<h2 id="architecture-deployment-patterns">Deployment Patterns<a class="headerlink" href="#architecture-deployment-patterns" title="Permanent link">&para;</a></h2>
<h3 id="architecture-standalone-server">Standalone Server<a class="headerlink" href="#architecture-standalone-server" title="Permanent link">&para;</a></h3>
<pre><code>THEMIS Server (Port 8765)
     │
     ├─&gt; Data Directory: ./data/themis_server
     ├─&gt; Config: ./config/config.json
     └─&gt; Logs: stdout (spdlog)
</code></pre>
<h3 id="architecture-docker-container">Docker Container<a class="headerlink" href="#architecture-docker-container" title="Permanent link">&para;</a></h3>
<pre><code>Docker Host
     │
     ├─&gt; Container: vccdb:latest
     │    ├─&gt; Port Mapping: 8765:8765
     │    ├─&gt; Volume: /data (persistent storage)
     │    └─&gt; Config Mount: /etc/vccdb/config.json
     │
     └─&gt; External Access: http://localhost:8765
</code></pre>
<h3 id="architecture-monitoring-stack-prometheus-grafana">Monitoring Stack (Prometheus + Grafana)<a class="headerlink" href="#architecture-monitoring-stack-prometheus-grafana" title="Permanent link">&para;</a></h3>
<pre><code>┌────────────┐       ┌─────────────┐       ┌──────────┐
│   THEMIS    │──────&gt;│ Prometheus  │──────&gt;│ Grafana  │
│ (Port 8765)│ scrape│ (Port 9090) │ query │ (Port    │
│  /metrics  │       │             │       │  3000)   │
└────────────┘       └─────────────┘       └──────────┘

Prometheus Scrape Config:
  scrape_interval: 15s
  metrics_path: /metrics
  targets: ['vccdb:8765']

Grafana Dashboards:
  - QPS, Error Rate, Latency (p50/p95/p99)
  - RocksDB: Cache Hit Rate, Compaction Stats, Memtable Size
  - System: CPU, Memory, Disk I/O
</code></pre>
<h2 id="architecture-performance-tuning">Performance Tuning<a class="headerlink" href="#architecture-performance-tuning" title="Permanent link">&para;</a></h2>
<h3 id="architecture-rocksdb-configuration">RocksDB Configuration<a class="headerlink" href="#architecture-rocksdb-configuration" title="Permanent link">&para;</a></h3>
<p><strong>For Write-Heavy Workloads:</strong></p>
<pre><code class="language-json">{
  &quot;memtable_size_mb&quot;: 512,      // Larger write buffer
  &quot;max_write_buffer_number&quot;: 4,  // More concurrent memtables
  &quot;compression&quot;: &quot;lz4&quot;           // Fast compression
}
</code></pre>
<p><strong>For Read-Heavy Workloads:</strong></p>
<pre><code class="language-json">{
  &quot;block_cache_size_mb&quot;: 4096,   // Larger read cache
  &quot;enable_bloom_filters&quot;: true,  // Reduce disk seeks
  &quot;compression&quot;: &quot;zstd&quot;          // Better compression ratio
}
</code></pre>
<h3 id="architecture-query-engine-tuning">Query Engine Tuning<a class="headerlink" href="#architecture-query-engine-tuning" title="Permanent link">&para;</a></h3>
<p><strong>Batch Processing Thresholds:</strong></p>
<pre><code class="language-cpp">// Adjust in query_engine.cpp
constexpr size_t PARALLEL_THRESHOLD = 100;  // Entities before parallelization
constexpr size_t BATCH_SIZE = 50;           // Entities per batch

// For low-latency use cases:
PARALLEL_THRESHOLD = 50;   // More aggressive parallelization
BATCH_SIZE = 25;           // Smaller batches (lower latency variance)

// For high-throughput use cases:
PARALLEL_THRESHOLD = 200;  // Less overhead
BATCH_SIZE = 100;          // Larger batches (better CPU utilization)
</code></pre>
<h3 id="architecture-index-maintenance">Index Maintenance<a class="headerlink" href="#architecture-index-maintenance" title="Permanent link">&para;</a></h3>
<p><strong>Rebuild Strategy:</strong>
- <strong>Periodic</strong>: Weekly rebuild for active tables (prevents fragmentation)
- <strong>On-Demand</strong>: After bulk inserts (&gt;10K entities)
- <strong>Parallel</strong>: Use <code>bench_index_rebuild</code> pattern for large tables</p>
<p><strong>TTL Cleanup:</strong></p>
<pre><code class="language-cpp">// Automatic expiration (no manual cleanup needed)
// TTL indexes prune expired entries during range scans
</code></pre>
<h2 id="architecture-observability">Observability<a class="headerlink" href="#architecture-observability" title="Permanent link">&para;</a></h2>
<h3 id="architecture-health-check">Health Check<a class="headerlink" href="#architecture-health-check" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl http://localhost:8765/health
# Response: {&quot;status&quot;:&quot;ok&quot;,&quot;timestamp&quot;:&quot;2025-10-28T10:30:00Z&quot;}
</code></pre>
<h3 id="architecture-configuration-inspection">Configuration Inspection<a class="headerlink" href="#architecture-configuration-inspection" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl http://localhost:8765/config | jq .
# Returns: server config, RocksDB config, runtime stats, metrics
</code></pre>
<h3 id="architecture-metrics-export">Metrics Export<a class="headerlink" href="#architecture-metrics-export" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl http://localhost:8765/metrics
# Prometheus text format with 25+ metrics
</code></pre>
<h3 id="architecture-statistics-analysis">Statistics Analysis<a class="headerlink" href="#architecture-statistics-analysis" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl http://localhost:8765/stats | jq .storage.rocksdb
# Detailed RocksDB stats: cache hit rate, compaction, files per level
</code></pre>
<h2 id="architecture-references">References<a class="headerlink" href="#architecture-references" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#base_entity">Base Entity Layer</a></li>
<li><a href="#memory_tuning">Memory Tuning Guide</a></li>
<li><a href="#indexes">Index Documentation</a></li>
<li><a href="../docs/openapi.yaml">OpenAPI Specification</a></li>
</ul></section>
                    <section class='print-page md-section' id='section-3' heading-number='3'>
                        <h1>Basismodell<a class='headerlink' href='#section-3' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="base_entity" heading-number="3.1"><h1 id="base_entity-basismodell-der-datenbank">Basismodell der Datenbank<a class="headerlink" href="#base_entity-basismodell-der-datenbank" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 1.1<br />
<strong>Status:</strong> Implementiert<br />
<strong>Letzte Aktualisierung:</strong> 28. Oktober 2025</p>
<hr />
<h2 id="base_entity-uberblick">Überblick<a class="headerlink" href="#base_entity-uberblick" title="Permanent link">&para;</a></h2>
<p>Das <strong>Basismodell</strong> von THEMIS definiert die fundamentale Speichereinheit für alle Datenmodelle (relational, document, graph, vector). Jede logische Entität wird als <strong>BaseEntity</strong> gespeichert – ein einzelnes binäres Blob mit effizienter Serialisierung und schnellem Feldzugriff.</p>
<h3 id="base_entity-kernkonzepte">Kernkonzepte<a class="headerlink" href="#base_entity-kernkonzepte" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>BaseEntity</strong>: Kanonische Speichereinheit (ein Blob pro Entität)</li>
<li><strong>Primary Key</strong>: Eindeutige Identifikation innerhalb eines Namespace (table/collection/graph)</li>
<li><strong>Key Schema</strong>: Hierarchisches Schlüssel-System für Multi-Modell-Zugriff</li>
<li><strong>TTL/Retention</strong>: Automatische Ablauf-Mechanik über TTL-Indizes</li>
<li><strong>Path Constraints</strong>: Geplante Constraints für Graph-Traversals (siehe <a href="#path_constraints">Path Constraints</a>)</li>
</ol>
<hr />
<h2 id="base_entity-1-baseentity-die-speichereinheit">1. BaseEntity – Die Speichereinheit<a class="headerlink" href="#base_entity-1-baseentity-die-speichereinheit" title="Permanent link">&para;</a></h2>
<h3 id="base_entity-11-architektur">1.1 Architektur<a class="headerlink" href="#base_entity-11-architektur" title="Permanent link">&para;</a></h3>
<p><code>BaseEntity</code> ist die zentrale Klasse für alle persistierten Daten:</p>
<pre><code class="language-cpp">class BaseEntity {
public:
    using Blob = std::vector&lt;uint8_t&gt;;
    using FieldMap = std::map&lt;std::string, Value&gt;;

    enum class Format { BINARY, JSON };

    // Primärschlüssel
    const std::string&amp; getPrimaryKey() const;
    void setPrimaryKey(std::string_view pk);

    // Feld-Zugriff (lazy parsing)
    std::optional&lt;Value&gt; getField(std::string_view field_name) const;
    void setField(std::string_view field_name, const Value&amp; value);

    // Serialisierung
    Blob serialize() const;
    std::string toJson() const;

    // Factory-Methoden
    static BaseEntity fromJson(std::string_view pk, std::string_view json_str);
    static BaseEntity fromFields(std::string_view pk, const FieldMap&amp; fields);
    static BaseEntity deserialize(std::string_view pk, const Blob&amp; blob);

private:
    std::string primary_key_;
    Blob blob_;
    Format format_ = Format::BINARY;
    mutable std::shared_ptr&lt;FieldMap&gt; field_cache_;
};
</code></pre>
<h3 id="base_entity-12-value-typsystem">1.2 Value-Typsystem<a class="headerlink" href="#base_entity-12-value-typsystem" title="Permanent link">&para;</a></h3>
<p><code>Value</code> ist ein <code>std::variant</code> mit folgenden Typen:</p>
<table>
<thead>
<tr>
<th>Typ</th>
<th>C++ Typ</th>
<th>Verwendung</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>null</strong></td>
<td><code>std::monostate</code></td>
<td>Fehlende/leere Werte</td>
</tr>
<tr>
<td><strong>bool</strong></td>
<td><code>bool</code></td>
<td>Wahrheitswerte</td>
</tr>
<tr>
<td><strong>int</strong></td>
<td><code>int64_t</code></td>
<td>Ganzzahlen</td>
</tr>
<tr>
<td><strong>double</strong></td>
<td><code>double</code></td>
<td>Gleitkommazahlen</td>
</tr>
<tr>
<td><strong>string</strong></td>
<td><code>std::string</code></td>
<td>Texte</td>
</tr>
<tr>
<td><strong>vector</strong></td>
<td><code>std::vector&lt;float&gt;</code></td>
<td>Embeddings (optimiert für ANN-Indizes)</td>
</tr>
<tr>
<td><strong>binary</strong></td>
<td><code>std::vector&lt;uint8_t&gt;</code></td>
<td>Binärdaten</td>
</tr>
</tbody>
</table>
<p><strong>Hinweis:</strong> Nested Objects/Arrays sind aktuell nicht unterstützt (geplant für zukünftige Version).</p>
<hr />
<h2 id="base_entity-2-key-schema-namespacing-hierarchie">2. Key Schema – Namespacing &amp; Hierarchie<a class="headerlink" href="#base_entity-2-key-schema-namespacing-hierarchie" title="Permanent link">&para;</a></h2>
<h3 id="base_entity-21-multi-modell-schlussel">2.1 Multi-Modell-Schlüssel<a class="headerlink" href="#base_entity-21-multi-modell-schlussel" title="Permanent link">&para;</a></h3>
<p>THEMIS nutzt ein hierarchisches Schlüssel-System mit <strong>Präfixen</strong>, um alle Datenmodelle in einer RocksDB zu vereinen:</p>
<pre><code class="language-cpp">class KeySchema {
public:
    enum class KeyType {
        RELATIONAL,        // Tabellenzeilen
        DOCUMENT,          // Dokumente
        GRAPH_NODE,        // Graph-Knoten
        GRAPH_EDGE,        // Graph-Kanten
        VECTOR,            // Vektor-Objekte
        SECONDARY_INDEX,   // Sekundärindizes
        GRAPH_OUTDEX,      // Outgoing Edges
        GRAPH_INDEX        // Incoming Edges
    };

    // Key-Konstruktion
    static std::string makeRelationalKey(std::string_view table, std::string_view pk);
    static std::string makeGraphNodeKey(std::string_view pk);
    static std::string makeSecondaryIndexKey(
        std::string_view table,
        std::string_view column,
        std::string_view value,
        std::string_view pk
    );
};
</code></pre>
<h3 id="base_entity-22-schlussel-formate">2.2 Schlüssel-Formate<a class="headerlink" href="#base_entity-22-schlussel-formate" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Datenmodell</th>
<th>Schlüsselformat</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Relational</strong></td>
<td><code>entity:table:pk</code></td>
<td><code>entity:users:alice</code></td>
</tr>
<tr>
<td><strong>Document</strong></td>
<td><code>entity:collection:pk</code></td>
<td><code>entity:orders:order_123</code></td>
</tr>
<tr>
<td><strong>Graph Node</strong></td>
<td><code>entity:node:pk</code></td>
<td><code>entity:node:user_456</code></td>
</tr>
<tr>
<td><strong>Graph Edge</strong></td>
<td><code>entity:edge:pk</code></td>
<td><code>entity:edge:follows_789</code></td>
</tr>
<tr>
<td><strong>Vector</strong></td>
<td><code>entity:vectors:pk</code></td>
<td><code>entity:vectors:doc_abc</code></td>
</tr>
<tr>
<td><strong>Secondary Index</strong></td>
<td><code>idx:table:column:value:pk</code></td>
<td><code>idx:users:age:30:alice</code></td>
</tr>
<tr>
<td><strong>Range Index</strong></td>
<td><code>ridx:table:column:value:pk</code></td>
<td><code>ridx:products:price:99.99:prod_1</code></td>
</tr>
<tr>
<td><strong>Spatial Index</strong></td>
<td><code>sidx:table:geohash:pk</code></td>
<td><code>sidx:locations:u33dc1:berlin</code></td>
</tr>
<tr>
<td><strong>TTL Index</strong></td>
<td><code>ttlidx:table:column:timestamp:pk</code></td>
<td><code>ttlidx:sessions:created_at:1730000000:sess_1</code></td>
</tr>
<tr>
<td><strong>Fulltext Index</strong></td>
<td><code>ftidx:table:column:token:pk</code></td>
<td><code>ftidx:articles:body:search:art_42</code></td>
</tr>
<tr>
<td><strong>Graph Outdex</strong></td>
<td><code>graph:out:pk_start:pk_edge</code></td>
<td><code>graph:out:alice:follows_789</code></td>
</tr>
<tr>
<td><strong>Graph Indeg</strong></td>
<td><code>graph:in:pk_target:pk_edge</code></td>
<td><code>graph:in:bob:follows_789</code></td>
</tr>
<tr>
<td><strong>Changefeed</strong></td>
<td><code>changefeed:pk:seqno</code></td>
<td><code>changefeed:alice:0000000001</code></td>
</tr>
<tr>
<td><strong>Time-Series</strong></td>
<td><code>ts:metric:entity:timestamp</code></td>
<td><code>ts:cpu:server1:1730000000000</code></td>
</tr>
</tbody>
</table>
<p><strong>Separator:</strong> Alle Schlüssel verwenden <code>:</code> als Trennzeichen.</p>
<h3 id="base_entity-23-primary-key-extraktion">2.3 Primary Key Extraktion<a class="headerlink" href="#base_entity-23-primary-key-extraktion" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Aus beliebigem Schlüssel PK extrahieren
std::string pk = KeySchema::extractPrimaryKey(&quot;idx:users:age:30:alice&quot;);
// Ergebnis: &quot;alice&quot;

KeyType type = KeySchema::parseKeyType(&quot;entity:users:alice&quot;);
// Ergebnis: KeyType::RELATIONAL
</code></pre>
<p><strong>Siehe auch:</strong> <a href="#storage-rocksdb_layout">RocksDB Storage Layout</a> für Details zu Key Prefixes und Column Families.</p>
<hr />
<h2 id="base_entity-3-ttl-retention-automatisches-ablaufen">3. TTL &amp; Retention – Automatisches Ablaufen<a class="headerlink" href="#base_entity-3-ttl-retention-automatisches-ablaufen" title="Permanent link">&para;</a></h2>
<h3 id="base_entity-31-ttl-index-konzept">3.1 TTL-Index-Konzept<a class="headerlink" href="#base_entity-31-ttl-index-konzept" title="Permanent link">&para;</a></h3>
<p>THEMIS unterstützt <strong>Time-To-Live (TTL)</strong> für Entitäten über spezielle TTL-Indizes:</p>
<pre><code class="language-cpp">// TTL-Index erstellen (Sessions laufen nach 3600 Sekunden ab)
idx.createTTLIndex(&quot;sessions&quot;, &quot;created_at&quot;, /*ttl_seconds=*/3600);

// Entity einfügen (TTL wird automatisch berechnet)
BaseEntity session(&quot;sess_123&quot;);
session.setField(&quot;user&quot;, &quot;alice&quot;);
session.setField(&quot;created_at&quot;, &quot;2025-10-27T10:00:00Z&quot;);
idx.put(&quot;sessions&quot;, session);
// → TTL-Eintrag: ttlidx:sessions:created_at:1730034000:sess_123

// Periodisch Cleanup aufrufen (z. B. CRON/Timer alle 60s)
auto [status, deletedCount] = idx.cleanupExpiredEntities(&quot;sessions&quot;, &quot;created_at&quot;);
</code></pre>
<h3 id="base_entity-32-mechanik">3.2 Mechanik<a class="headerlink" href="#base_entity-32-mechanik" title="Permanent link">&para;</a></h3>
<p><strong>Beim Put:</strong>
1. Aktueller Timestamp: <code>now = std::chrono::system_clock::now()</code>
2. Expire-Timestamp: <code>expire = now + ttl_seconds</code>
3. TTL-Index-Key: <code>ttlidx:table:column:{expire}:pk</code>
4. Atomare WriteBatch: Entity + TTL-Index-Eintrag</p>
<p><strong>Beim Cleanup:</strong>
1. Scan TTL-Index: <code>ttlidx:table:column:0</code> bis <code>ttlidx:table:column:{current_time}</code>
2. Für jeden PK: Lösche Entity + alle Indizes (atomar per WriteBatch)
3. Rückgabe: Anzahl gelöschter Entities</p>
<h3 id="base_entity-33-retention-fur-time-series">3.3 Retention für Time-Series<a class="headerlink" href="#base_entity-33-retention-fur-time-series" title="Permanent link">&para;</a></h3>
<p>Zusätzlich gibt es eine <strong>Retention Policy</strong> für Time-Series-Daten (TSStore):</p>
<pre><code class="language-cpp">RetentionPolicy policy;
policy.per_metric[&quot;cpu&quot;] = std::chrono::hours(24);      // CPU-Daten 24h
policy.per_metric[&quot;logs&quot;] = std::chrono::hours(72);     // Logs 72h

RetentionManager mgr(&amp;tsstore, policy);
size_t deleted = mgr.apply();  // Löscht alte Datenpunkte pro Metrik
</code></pre>
<p><strong>Hinweis:</strong> TTL-Indizes sind für Entities (Dokumente, Sessions, Cache), Retention ist für Time-Series (Metriken, Logs).</p>
<p><strong>Siehe auch:</strong>
- <a href="#index_stats_maintenance">Index Stats &amp; Maintenance</a> für TTL-Index-Details
- <a href="#time_series">Time-Series</a> für Retention Policies</p>
<hr />
<h2 id="base_entity-4-verwendungsbeispiele">4. Verwendungsbeispiele<a class="headerlink" href="#base_entity-4-verwendungsbeispiele" title="Permanent link">&para;</a></h2>
<h3 id="base_entity-41-entity-erstellen-persistieren">4.1 Entity erstellen &amp; persistieren<a class="headerlink" href="#base_entity-41-entity-erstellen-persistieren" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Von Field Map erstellen
BaseEntity::FieldMap fields;
fields[&quot;name&quot;] = std::string(&quot;Alice&quot;);
fields[&quot;age&quot;] = int64_t(30);
fields[&quot;active&quot;] = true;

BaseEntity user = BaseEntity::fromFields(&quot;alice&quot;, fields);

// Von JSON erstellen
std::string json = R&quot;({&quot;name&quot;:&quot;Bob&quot;,&quot;age&quot;:25})&quot;;
BaseEntity user2 = BaseEntity::fromJson(&quot;bob&quot;, json);

// Serialisieren &amp; speichern
std::string key = KeySchema::makeRelationalKey(&quot;users&quot;, user.getPrimaryKey());
auto blob = user.serialize();
db.put(key, blob);
</code></pre>
<h3 id="base_entity-42-entity-laden-felder-lesen">4.2 Entity laden &amp; Felder lesen<a class="headerlink" href="#base_entity-42-entity-laden-felder-lesen" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Von RocksDB laden
auto blob = db.get(&quot;entity:users:alice&quot;);
BaseEntity user = BaseEntity::deserialize(&quot;alice&quot;, *blob);

// Felder lesen (typsicher)
auto name = user.getFieldAsString(&quot;name&quot;);    // std::optional&lt;std::string&gt;
auto age = user.getFieldAsInt(&quot;age&quot;);         // std::optional&lt;int64_t&gt;
auto active = user.getFieldAsBool(&quot;active&quot;);  // std::optional&lt;bool&gt;

if (name &amp;&amp; age) {
    std::cout &lt;&lt; *name &lt;&lt; &quot; ist &quot; &lt;&lt; *age &lt;&lt; &quot; Jahre alt\n&quot;;
}

// Alle Felder extrahieren (für Index-Updates)
auto attrs = user.extractAllFields();
for (const auto&amp; [field, value] : attrs) {
    // Index-Einträge erstellen
}
</code></pre>
<h3 id="base_entity-43-vector-embeddings">4.3 Vector-Embeddings<a class="headerlink" href="#base_entity-43-vector-embeddings" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Entity mit Embedding erstellen
std::vector&lt;float&gt; embedding = {0.1f, 0.2f, 0.3f, 0.4f};
BaseEntity doc(&quot;doc_123&quot;);
doc.setField(&quot;title&quot;, std::string(&quot;Artikel über KI&quot;));
doc.setField(&quot;embedding&quot;, embedding);

// Embedding für ANN-Index extrahieren
auto vec = doc.extractVector(&quot;embedding&quot;);
if (vec) {
    hnsw_index.add(*vec, doc.getPrimaryKey());
}
</code></pre>
<h3 id="base_entity-44-index-updates-secondary-index">4.4 Index-Updates (Secondary Index)<a class="headerlink" href="#base_entity-44-index-updates-secondary-index" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Entity + Secondary Index atomar updaten
auto batch = db.createWriteBatch();

// Entity speichern
std::string entityKey = KeySchema::makeRelationalKey(&quot;users&quot;, &quot;alice&quot;);
batch-&gt;put(entityKey, user.serialize());

// Secondary Index für age=30
std::string idxKey = KeySchema::makeSecondaryIndexKey(&quot;users&quot;, &quot;age&quot;, &quot;30&quot;, &quot;alice&quot;);
batch-&gt;put(idxKey, &quot;alice&quot;);  // PK als Value

batch-&gt;commit();  // Atomar!
</code></pre>
<hr />
<h2 id="base_entity-5-performance-implementierung">5. Performance &amp; Implementierung<a class="headerlink" href="#base_entity-5-performance-implementierung" title="Permanent link">&para;</a></h2>
<h3 id="base_entity-51-lazy-parsing-field-cache">5.1 Lazy Parsing (Field Cache)<a class="headerlink" href="#base_entity-51-lazy-parsing-field-cache" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Field Cache</strong> wird beim ersten Feldzugriff befüllt</li>
<li>Nachfolgende Zugriffe nutzen Cache (keine erneute Deserialisierung)</li>
<li>Cache wird invalidiert bei Blob-Modifikation (<code>setField()</code>)</li>
</ul>
<pre><code class="language-cpp">// Erstes getField() → Parse Blob → Cache füllen
auto name = entity.getField(&quot;name&quot;);  // Parse!

// Zweites getField() → Cache verwenden
auto age = entity.getField(&quot;age&quot;);    // Cache Hit!

// setField() → Cache invalidieren
entity.setField(&quot;status&quot;, std::string(&quot;online&quot;));  // Cache invalidiert
</code></pre>
<h3 id="base_entity-52-simdjson-integration-json-format">5.2 simdjson Integration (JSON Format)<a class="headerlink" href="#base_entity-52-simdjson-integration-json-format" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>JSON Format</strong> nutzt simdjson on-demand API</li>
<li>Feld-Extraktion <strong>ohne vollständigen Parse</strong> (O(1))</li>
<li>Parsing-Throughput: <strong>Multi-GB/s</strong> auf modernen CPUs</li>
</ul>
<pre><code class="language-cpp">// JSON-Entity laden (lazy parsing)
BaseEntity entity = BaseEntity::fromJson(&quot;alice&quot;, json_string);

// Einzelne Felder extrahieren (simdjson on-demand)
auto name = entity.extractField(&quot;name&quot;);  // Kein vollständiger Parse!
</code></pre>
<h3 id="base_entity-53-binary-format-effizienz">5.3 Binary Format Effizienz<a class="headerlink" href="#base_entity-53-binary-format-effizienz" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Eigenschaft</th>
<th>JSON</th>
<th>Binary</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Größe</strong></td>
<td>100%</td>
<td>~60% (kompakter)</td>
</tr>
<tr>
<td><strong>Parse-Overhead</strong></td>
<td>Mittel (simdjson)</td>
<td>Minimal (direkter Zugriff)</td>
</tr>
<tr>
<td><strong>Vector-Encoding</strong></td>
<td>Base64/String</td>
<td>Native Float-Array</td>
</tr>
<tr>
<td><strong>Lesbarkeit</strong></td>
<td>Hoch</td>
<td>Niedrig</td>
</tr>
</tbody>
</table>
<p><strong>Empfehlung:</strong> Binary für Produktiv-Storage, JSON für Debugging/Export.</p>
<h3 id="base_entity-54-binary-format-struktur">5.4 Binary Format Struktur<a class="headerlink" href="#base_entity-54-binary-format-struktur" title="Permanent link">&para;</a></h3>
<pre><code>&lt;Object&gt;
  &lt;num_fields: uint32&gt;           // Anzahl Felder
  &lt;field_1&gt;
    &lt;name_length: uint32&gt;        // Feldname-Länge
    &lt;name: bytes&gt;                // Feldname (UTF-8)
    &lt;type_tag: uint8&gt;            // Typ (siehe Type Tags)
    &lt;value: varies by type&gt;      // Wert (typ-abhängig)
  &lt;field_2&gt;
    ...
</code></pre>
<p><strong>Type Tags:</strong></p>
<pre><code class="language-cpp">NULL_VALUE    = 0x00
BOOL_FALSE    = 0x01
BOOL_TRUE     = 0x02
INT64         = 0x11
DOUBLE        = 0x21
STRING        = 0x30
BINARY        = 0x40
VECTOR_FLOAT  = 0x70  // Optimiert für Embeddings (ohne extra Encoding)
</code></pre>
<hr />
<h2 id="base_entity-6-best-practices">6. Best Practices<a class="headerlink" href="#base_entity-6-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="base_entity-61-storage-format-wahl">6.1 Storage-Format-Wahl<a class="headerlink" href="#base_entity-61-storage-format-wahl" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Binary Format</strong>: Immer für RocksDB-Storage (Standard, kompakt, schnell)</li>
<li><strong>JSON Format</strong>: Nur für Debugging, Export, HTTP-Responses</li>
</ul>
<pre><code class="language-cpp">// Produktiv: Binary
auto blob = entity.serialize();          // Binary (Standard)
db.put(key, blob);

// Debugging: JSON
std::string json = entity.toJson();      // Für Logs
THEMIS_DEBUG(&quot;Entity: {}&quot;, json);
</code></pre>
<h3 id="base_entity-62-feld-extraktion-fur-index-updates">6.2 Feld-Extraktion für Index-Updates<a class="headerlink" href="#base_entity-62-feld-extraktion-fur-index-updates" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Schnell: Einzelne Felder extrahieren (ohne Full Parse)
auto name = entity.extractField(&quot;name&quot;);
auto age = entity.extractField(&quot;age&quot;);

// Langsamer: Alle Felder (Full Parse)
auto attrs = entity.extractAllFields();
</code></pre>
<p><strong>Regel:</strong> <code>extractField()</code> für gezielte Updates, <code>extractAllFields()</code> nur wenn alle Felder benötigt.</p>
<h3 id="base_entity-63-batch-updates-atomaritat">6.3 Batch-Updates (Atomarität)<a class="headerlink" href="#base_entity-63-batch-updates-atomaritat" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: Atomare Updates via WriteBatch
auto batch = db.createWriteBatch();
batch-&gt;put(entity_key, entity.serialize());
batch-&gt;put(idx_key1, idx_value1);
batch-&gt;put(idx_key2, idx_value2);
batch-&gt;commit();  // Alles oder nichts!

// ❌ FALSCH: Einzelne Puts (nicht atomar)
db.put(entity_key, entity.serialize());
db.put(idx_key1, idx_value1);  // Fehler hier → Inkonsistenz!
</code></pre>
<h3 id="base_entity-64-vector-embeddings-optimieren">6.4 Vector-Embeddings optimieren<a class="headerlink" href="#base_entity-64-vector-embeddings-optimieren" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: Native float-Vektoren (kein Encoding)
std::vector&lt;float&gt; embedding = model.encode(text);
entity.setField(&quot;embedding&quot;, embedding);

// ❌ FALSCH: String-Encoding (langsam, groß)
std::string encoded = serializeFloats(embedding);
entity.setField(&quot;embedding&quot;, encoded);
</code></pre>
<h3 id="base_entity-65-thread-safety">6.5 Thread Safety<a class="headerlink" href="#base_entity-65-thread-safety" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Ein <code>BaseEntity</code> pro Thread</strong> (keine Shared Ownership)</li>
<li>simdjson-Parser ist thread-local (automatisch)</li>
<li>Bei Shared Access: Locks verwenden</li>
</ul>
<pre><code class="language-cpp">// ✅ RICHTIG: Separate Instanzen
std::thread t1([&amp;]() {
    BaseEntity e1 = BaseEntity::deserialize(&quot;alice&quot;, blob);
});
std::thread t2([&amp;]() {
    BaseEntity e2 = BaseEntity::deserialize(&quot;bob&quot;, blob);
});

// ❌ FALSCH: Shared Instanz ohne Lock
BaseEntity shared(&quot;user&quot;);
std::thread t1([&amp;]() { shared.getField(&quot;name&quot;); });  // Race Condition!
std::thread t2([&amp;]() { shared.setField(&quot;age&quot;, 30); });
</code></pre>
<hr />
<h2 id="base_entity-7-zukunftige-erweiterungen">7. Zukünftige Erweiterungen<a class="headerlink" href="#base_entity-7-zukunftige-erweiterungen" title="Permanent link">&para;</a></h2>
<ul>
<li>[ ] <strong>Kompression</strong>: LZ4/Snappy für große Blobs</li>
<li>[ ] <strong>Schema-Validation</strong>: Optionale JSON-Schema-Prüfung</li>
<li>[ ] <strong>Nested Objects</strong>: Support für verschachtelte Maps/Arrays</li>
<li>[ ] <strong>Custom Types</strong>: Erweiterbare Type Tags (z. B. Geo-Points, UUIDs)</li>
<li>[ ] <strong>Memory-Mapped Access</strong>: Für sehr große Entities (&gt;1MB)</li>
<li>[ ] <strong>Path Constraints</strong>: Graph-Traversal-Constraints (siehe <a href="#path_constraints">Path Constraints</a>)</li>
</ul>
<hr />
<h2 id="base_entity-referenzen">Referenzen<a class="headerlink" href="#base_entity-referenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>include/storage/base_entity.h</code></li>
<li><strong>Key Schema:</strong> <code>include/storage/key_schema.h</code></li>
<li><strong>simdjson:</strong> https://github.com/simdjson/simdjson</li>
<li><strong>RocksDB Storage:</strong> <a href="#storage-rocksdb_layout">RocksDB Layout</a></li>
<li><strong>TTL-Indizes:</strong> <a href="#index_stats_maintenance">Index Stats &amp; Maintenance</a></li>
<li><strong>Retention:</strong> <a href="#time_series">Time-Series</a></li>
<li><strong>Path Constraints:</strong> <a href="#path_constraints">Graph Traversal Constraints</a></li>
</ul></section><section class="print-page" id="path_constraints" heading-number="3.2"><h1 id="path_constraints-graph-traversal-path-constraints">Graph Traversal Path Constraints<a class="headerlink" href="#path_constraints-graph-traversal-path-constraints" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 1.0 Draft<br />
<strong>Datum:</strong> 28. Oktober 2025<br />
<strong>Status:</strong> Konzept – Noch nicht implementiert</p>
<hr />
<h2 id="path_constraints-motivation">Motivation<a class="headerlink" href="#path_constraints-motivation" title="Permanent link">&para;</a></h2>
<p>Aktuell werden FILTER-Ausdrücke in Traversals <strong>nur am letzten Level</strong> vor dem Enqueue angewendet (konservatives Pruning). Dies ist sicher, aber lässt Optimierungspotenzial auf Zwischenebenen ungenutzt.</p>
<p><strong>Pfad-Constraints</strong> ermöglichen aggressiveres Pruning auf allen Tiefen, indem Prädikate entlang des gesamten Pfads gelten.</p>
<hr />
<h2 id="path_constraints-problem-naive-anwendung-ist-unsicher">Problem: Naive Anwendung ist unsicher<a class="headerlink" href="#path_constraints-problem-naive-anwendung-ist-unsicher" title="Permanent link">&para;</a></h2>
<h3 id="path_constraints-beispiel-unsicheres-edge-pruning">Beispiel: Unsicheres Edge-Pruning<a class="headerlink" href="#path_constraints-beispiel-unsicheres-edge-pruning" title="Permanent link">&para;</a></h3>
<p><strong>Query:</strong></p>
<pre><code class="language-aql">FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social'
  FILTER e.type == 'follows'
  RETURN v
</code></pre>
<p><strong>Naive (falsche) Interpretation:</strong>
- "Schneide alle Kanten ab, bei denen <code>e.type != 'follows'</code>"
- <strong>Problem:</strong> Bei depth=1 ist <code>e</code> die Kante von user1 → v1, aber bei depth=2 ist <code>e</code> die Kante zum aktuellen Knoten (v2), nicht die gesamte Pfadhistorie.</p>
<p><strong>Ergebnis:</strong> Zu viele Pfade abgeschnitten, die über alternative Routen erreichbar wären.</p>
<hr />
<h2 id="path_constraints-losung-pfad-constraints-explizit-definieren">Lösung: Pfad-Constraints explizit definieren<a class="headerlink" href="#path_constraints-losung-pfad-constraints-explizit-definieren" title="Permanent link">&para;</a></h2>
<h3 id="path_constraints-1-constraint-typen">1. Constraint-Typen<a class="headerlink" href="#path_constraints-1-constraint-typen" title="Permanent link">&para;</a></h3>
<h4 id="path_constraints-11-last-edge-constraint-bereits-implementiert">1.1 Last-Edge Constraint (bereits implementiert)<a class="headerlink" href="#path_constraints-11-last-edge-constraint-bereits-implementiert" title="Permanent link">&para;</a></h4>
<p><strong>Semantik:</strong> FILTER gilt nur für die <strong>eingehende Kante</strong> zur aktuellen Zeile (depth).</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-aql">FILTER e.type == 'follows'  -- nur am letzten Level sicher
</code></pre>
<p><strong>Anwendung:</strong>
- Am letzten Level vor Enqueue prüfen (✅ implementiert)
- Auf Zwischenebenen: <strong>nicht</strong> prunen (würde Pfade abschneiden)</p>
<hr />
<h4 id="path_constraints-12-all-edges-constraint-pfad-weites-pradikat">1.2 All-Edges Constraint (Pfad-weites Prädikat)<a class="headerlink" href="#path_constraints-12-all-edges-constraint-pfad-weites-pradikat" title="Permanent link">&para;</a></h4>
<p><strong>Semantik:</strong> FILTER gilt für <strong>alle Kanten</strong> entlang des Pfads von Start bis aktueller Zeile.</p>
<p><strong>Syntax (zukünftig):</strong></p>
<pre><code class="language-aql">FILTER PATH.ALL(e, e.type == 'follows')
</code></pre>
<p><strong>Bedeutung:</strong>
- Prüfe bei jedem Expand: Ist die neue Kante ein <code>follows</code>?
- Wenn nein: Pfad ist ungültig → nicht enqueuen
- <strong>Sicher auf allen Tiefen!</strong></p>
<p><strong>Implementierung:</strong>
- Beim Enqueue: Prüfe <code>a.edgeId</code> gegen Constraint
- Tracking: Optional Pfad-Historie (Liste der edgeIds) mitführen, falls Constraints auf "vorherige Kante" prüfen</p>
<hr />
<h4 id="path_constraints-13-any-edge-constraint">1.3 Any-Edge Constraint<a class="headerlink" href="#path_constraints-13-any-edge-constraint" title="Permanent link">&para;</a></h4>
<p><strong>Semantik:</strong> Mindestens <strong>eine Kante</strong> entlang des Pfads erfüllt Prädikat.</p>
<p><strong>Syntax (zukünftig):</strong></p>
<pre><code class="language-aql">FILTER PATH.ANY(e, e.weight &gt; 10)
</code></pre>
<p><strong>Implementierung:</strong>
- Pfad-State: Boolean Flag <code>hasSeenHeavyEdge</code>
- Beim Enqueue: Update Flag
- Bei Result-Zeile: Prüfe Flag</p>
<hr />
<h4 id="path_constraints-14-no-vertex-constraint-blockierte-knoten">1.4 No-Vertex Constraint (Blockierte Knoten)<a class="headerlink" href="#path_constraints-14-no-vertex-constraint-blockierte-knoten" title="Permanent link">&para;</a></h4>
<p><strong>Semantik:</strong> <strong>Kein Vertex</strong> entlang des Pfads darf Prädikat verletzen.</p>
<p><strong>Syntax (zukünftig):</strong></p>
<pre><code class="language-aql">FILTER PATH.NONE(v, v.blocked == true)
</code></pre>
<p><strong>Implementierung:</strong>
- Beim Enqueue: Prüfe neuen Vertex <code>nb</code> gegen Constraint
- Wenn <code>nb.blocked == true</code>: Nicht enqueuen
- <strong>Sicher auf allen Tiefen!</strong></p>
<hr />
<h3 id="path_constraints-2-sichere-pruning-regeln">2. Sichere Pruning-Regeln<a class="headerlink" href="#path_constraints-2-sichere-pruning-regeln" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Constraint-Typ</th>
<th>Anwendungstiefe</th>
<th>Implementierung</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Last-Edge</strong> (e.field OP value)</td>
<td>Nur letztes Level</td>
<td>✅ Implementiert (evalSingleE)</td>
</tr>
<tr>
<td><strong>Last-Vertex</strong> (v.field OP value)</td>
<td>Nur letztes Level</td>
<td>✅ Implementiert (evalSingleV)</td>
</tr>
<tr>
<td><strong>PATH.ALL(e, ...)</strong></td>
<td>Alle Tiefen</td>
<td>🔜 Geplant (Expand-Zeit-Check)</td>
</tr>
<tr>
<td><strong>PATH.NONE(v, ...)</strong></td>
<td>Alle Tiefen</td>
<td>🔜 Geplant (Expand-Zeit-Check)</td>
</tr>
<tr>
<td><strong>PATH.ANY(e, ...)</strong></td>
<td>Alle Tiefen (State)</td>
<td>🔜 Geplant (Flag-basiert)</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="path_constraints-3-ast-erweiterungen-parser">3. AST-Erweiterungen (Parser)<a class="headerlink" href="#path_constraints-3-ast-erweiterungen-parser" title="Permanent link">&para;</a></h3>
<h4 id="path_constraints-31-neue-expression-typen">3.1 Neue Expression-Typen<a class="headerlink" href="#path_constraints-31-neue-expression-typen" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct PathConstraintExpr : Expression {
    enum class Type { All, Any, None };
    Type type;
    char varName;  // 'e' oder 'v'
    std::unique_ptr&lt;Expression&gt; predicate;
};
</code></pre>
<p><strong>Parser-Syntax:</strong></p>
<pre><code class="language-aql">PATH.ALL(e, e.type == 'follows')
PATH.NONE(v, v.blocked == true)
PATH.ANY(e, e.weight &gt; 10)
</code></pre>
<hr />
<h4 id="path_constraints-32-ast-classifier-filter-analyse">3.2 AST-Classifier (Filter-Analyse)<a class="headerlink" href="#path_constraints-32-ast-classifier-filter-analyse" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct FilterClassification {
    std::vector&lt;Expression*&gt; lastEdgeOnly;
    std::vector&lt;Expression*&gt; lastVertexOnly;
    std::vector&lt;Expression*&gt; pathAllEdge;
    std::vector&lt;Expression*&gt; pathNoneVertex;
    std::vector&lt;Expression*&gt; pathAnyEdge;
    std::vector&lt;Expression*&gt; mixed;  // AND/OR kombiniert, keine einfache Klassifikation
};

FilterClassification classifyFilters(const std::vector&lt;std::unique_ptr&lt;FilterClause&gt;&gt;&amp; filters);
</code></pre>
<hr />
<h3 id="path_constraints-4-bfs-anpassungen">4. BFS-Anpassungen<a class="headerlink" href="#path_constraints-4-bfs-anpassungen" title="Permanent link">&para;</a></h3>
<h4 id="path_constraints-41-expand-zeit-checks-pathallnone">4.1 Expand-Zeit-Checks (PATH.ALL/NONE)<a class="headerlink" href="#path_constraints-41-expand-zeit-checks-pathallnone" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">auto enqueueOut = [&amp;](const std::vector&lt;AdjacencyInfo&gt;&amp; adj) {
    for (const auto&amp; a : adj) {
        // PATH.ALL(e, e.type == 'follows')
        for (const auto&amp; pathAllE : pathAllEdgeConstraints) {
            if (!evalEdgeConstraint(a.edgeId, pathAllE)) {
                prunedAllDepths++;
                continue;  // sicher auf allen Tiefen!
            }
        }

        // PATH.NONE(v, v.blocked == true)
        for (const auto&amp; pathNoneV : pathNoneVertexConstraints) {
            if (evalVertexConstraint(a.targetPk, pathNoneV)) {
                prunedAllDepths++;
                continue;  // blockierter Vertex → skip
            }
        }

        // Konservative Prüfungen (nur letztes Level)
        if (depth + 1 == t.maxDepth) {
            // ... (wie bisher)
        }

        if (visited.insert(a.targetPk).second) {
            parent[a.targetPk] = {node, a.edgeId};
            qnodes.push({a.targetPk, depth + 1});
            enqueuedPerDepth[depth + 1]++;
        }
    }
};
</code></pre>
<hr />
<h4 id="path_constraints-42-state-basierte-constraints-pathany">4.2 State-basierte Constraints (PATH.ANY)<a class="headerlink" href="#path_constraints-42-state-basierte-constraints-pathany" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct PathState {
    bool hasSeenHeavyEdge = false;
    // weitere Flags je Constraint
};

std::unordered_map&lt;std::string, PathState&gt; pathStates;

// Beim Enqueue:
PathState newState = pathStates[node];
if (checkEdgeWeight(a.edgeId) &gt; 10) newState.hasSeenHeavyEdge = true;
pathStates[a.targetPk] = newState;

// Bei Result-Zeile:
if (pathAnyEdgeConstraints.hasHeavyEdge &amp;&amp; !pathStates[node].hasSeenHeavyEdge) {
    pass = false;  // PATH.ANY nicht erfüllt
}
</code></pre>
<hr />
<h3 id="path_constraints-5-performance-implikationen">5. Performance-Implikationen<a class="headerlink" href="#path_constraints-5-performance-implikationen" title="Permanent link">&para;</a></h3>
<h4 id="path_constraints-vorteile">Vorteile<a class="headerlink" href="#path_constraints-vorteile" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Frontier-Reduktion:</strong> Aggressives Pruning auf allen Tiefen</li>
<li><strong>Frühzeitiger Abbruch:</strong> Ungültige Pfade werden sofort verworfen</li>
<li><strong>Weniger Entity-Loads:</strong> Nur validierte Pfade landen in Result-Set</li>
</ul>
<h4 id="path_constraints-kosten">Kosten<a class="headerlink" href="#path_constraints-kosten" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Expand-Zeit-Overhead:</strong> Jede Kante wird gegen PATH.ALL/NONE geprüft</li>
<li><strong>Memory:</strong> PathState für PATH.ANY (HashMap, kleine Keys)</li>
</ul>
<p><strong>Faustregel:</strong>
- Nutzen &gt; Kosten, wenn Constraints selektiv sind (z. B. nur 10% der Kanten sind <code>follows</code>)</p>
<hr />
<h3 id="path_constraints-6-implementierungs-roadmap">6. Implementierungs-Roadmap<a class="headerlink" href="#path_constraints-6-implementierungs-roadmap" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Phase 1:</strong> Parser-Erweiterung (PATH.ALL/NONE/ANY Syntax)</li>
<li><strong>Phase 2:</strong> AST-Classifier (Filter-Typen erkennen)</li>
<li><strong>Phase 3:</strong> BFS Expand-Zeit-Checks (PATH.ALL/NONE)</li>
<li><strong>Phase 4:</strong> State-Tracking (PATH.ANY)</li>
<li><strong>Phase 5:</strong> Metriken (<code>pruned_all_depths</code>, <code>path_state_size</code>)</li>
<li><strong>Phase 6:</strong> Tests &amp; Benchmarks (Vergleich mit/ohne Constraints)</li>
</ol>
<hr />
<h3 id="path_constraints-7-beispiel-queries">7. Beispiel-Queries<a class="headerlink" href="#path_constraints-7-beispiel-queries" title="Permanent link">&para;</a></h3>
<h4 id="path_constraints-nur-follows-kanten-erlauben">Nur follows-Kanten erlauben<a class="headerlink" href="#path_constraints-nur-follows-kanten-erlauben" title="Permanent link">&para;</a></h4>
<pre><code class="language-aql">FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social'
  FILTER PATH.ALL(e, e.type == 'follows')
  RETURN v
</code></pre>
<p><strong>Effekt:</strong> BFS expandiert nur über <code>follows</code>-Kanten, alle anderen werden auf <strong>allen Tiefen</strong> gedroppt.</p>
<hr />
<h4 id="path_constraints-keine-blockierten-vertices-im-pfad">Keine blockierten Vertices im Pfad<a class="headerlink" href="#path_constraints-keine-blockierten-vertices-im-pfad" title="Permanent link">&para;</a></h4>
<pre><code class="language-aql">FOR v IN 1..5 OUTBOUND 'user1' GRAPH 'social'
  FILTER PATH.NONE(v, v.blocked == true)
  RETURN v
</code></pre>
<p><strong>Effekt:</strong> Pfade, die einen blockierten Vertex passieren, werden sofort verworfen.</p>
<hr />
<h4 id="path_constraints-mindestens-eine-starke-beziehung">Mindestens eine starke Beziehung<a class="headerlink" href="#path_constraints-mindestens-eine-starke-beziehung" title="Permanent link">&para;</a></h4>
<pre><code class="language-aql">FOR v IN 1..4 OUTBOUND 'user1' GRAPH 'social'
  FILTER PATH.ANY(e, e.weight &gt; 10)
  RETURN v
</code></pre>
<p><strong>Effekt:</strong> Nur Pfade mit mindestens einer starken Kante (weight &gt; 10) landen im Result.</p>
<hr />
<h2 id="path_constraints-zusammenfassung">Zusammenfassung<a class="headerlink" href="#path_constraints-zusammenfassung" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Aktuelle Implementierung</th>
<th>Pfad-Constraints (geplant)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pruning nur am letzten Level</td>
<td>Pruning auf <strong>allen Tiefen</strong></td>
</tr>
<tr>
<td>Unsicher für Zwischenebenen</td>
<td>Sichere Semantik durch PATH.ALL/NONE</td>
</tr>
<tr>
<td>Einfach (kein State)</td>
<td>State-Tracking für PATH.ANY</td>
</tr>
<tr>
<td>Konservativ (viele False Positives)</td>
<td>Aggressiv (nur valide Pfade expandiert)</td>
</tr>
</tbody>
</table>
<p><strong>Empfehlung:</strong>
- Phase 1-3 implementieren (PATH.ALL/NONE) für sofortigen Nutzen
- Phase 4 (PATH.ANY) optional, falls Use-Cases existieren
- Metriken sammeln: <code>pruned_all_depths</code> vs. <code>pruned_last_level</code> Vergleich</p>
<hr />
<p><strong>Siehe auch:</strong>
- <a href="#aql_explain_profile">AQL EXPLAIN &amp; PROFILE</a>
- <a href="#todo.md-performance--planung">BFS Pruning (aktuell)</a></p></section><section class="print-page" id="property_graph_model" heading-number="3.3"><h1 id="property_graph_model-property-graph-model-multi-graph-federation">Property Graph Model &amp; Multi-Graph Federation<a class="headerlink" href="#property_graph_model-property-graph-model-multi-graph-federation" title="Permanent link">&para;</a></h1>
<p><strong>Status:</strong> ✅ Implemented &amp; Tested (13/13 tests passing)<br />
<strong>Feature:</strong> Property Graph Model with Node Labels, Relationship Types, and Multi-Graph Federation<br />
<strong>Date:</strong> 2025-01-15</p>
<hr />
<h2 id="property_graph_model-overview">Overview<a class="headerlink" href="#property_graph_model-overview" title="Permanent link">&para;</a></h2>
<p>This feature extends Themis's graph capabilities with <strong>Property Graph Model</strong> semantics and <strong>Multi-Graph Federation</strong>. You can now:</p>
<ul>
<li>Assign <strong>multiple labels</strong> to nodes (e.g., <code>:Person</code>, <code>:Employee</code>)</li>
<li>Define <strong>typed relationships</strong> (e.g., <code>FOLLOWS</code>, <code>LIKES</code>, <code>REPORTS_TO</code>)</li>
<li>Manage <strong>multiple isolated graphs</strong> with cross-graph queries</li>
<li>Perform <strong>federated pattern matching</strong> across graphs</li>
</ul>
<h3 id="property_graph_model-use-cases">Use Cases<a class="headerlink" href="#property_graph_model-use-cases" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Social Networks:</strong> <code>:Person -[FOLLOWS]-&gt; :Person</code>, <code>:User -[LIKES]-&gt; :Post</code></li>
<li><strong>Knowledge Graphs:</strong> <code>:Entity -[RELATES_TO]-&gt; :Entity</code>, <code>:Concept -[IS_A]-&gt; :Category</code></li>
<li><strong>Enterprise Graphs:</strong> <code>:Employee -[REPORTS_TO]-&gt; :Manager</code>, <code>:Department -[CONTAINS]-&gt; :Team</code></li>
<li><strong>Multi-Tenant Systems:</strong> Separate graphs per tenant with cross-tenant analytics</li>
</ul>
<hr />
<h2 id="property_graph_model-architecture">Architecture<a class="headerlink" href="#property_graph_model-architecture" title="Permanent link">&para;</a></h2>
<h3 id="property_graph_model-key-schema-design">Key Schema Design<a class="headerlink" href="#property_graph_model-key-schema-design" title="Permanent link">&para;</a></h3>
<pre><code># Nodes (with labels)
node:&lt;graph_id&gt;:&lt;pk&gt; -&gt; BaseEntity(id, name, _labels, ...)

# Edges (with types)
edge:&lt;graph_id&gt;:&lt;edge_id&gt; -&gt; BaseEntity(id, _from, _to, _type, ...)

# Label Index (for fast label-based queries)
label:&lt;graph_id&gt;:&lt;label&gt;:&lt;pk&gt; -&gt; (empty)

# Type Index (for fast type-based queries)
type:&lt;graph_id&gt;:&lt;type&gt;:&lt;edge_id&gt; -&gt; (empty)

# Graph Adjacency Indices (federated)
graph:out:&lt;graph_id&gt;:&lt;from_pk&gt;:&lt;edge_id&gt; -&gt; &lt;to_pk&gt;
graph:in:&lt;graph_id&gt;:&lt;to_pk&gt;:&lt;edge_id&gt; -&gt; &lt;from_pk&gt;
</code></pre>
<p><strong>Design Principles:</strong>
- <strong>Graph Isolation:</strong> <code>graph_id</code> prefix ensures complete isolation between graphs
- <strong>Label Multiplicity:</strong> Nodes can have 0+ labels (stored as comma-separated string)
- <strong>Type Singularity:</strong> Edges have exactly one type (or none)
- <strong>Index Efficiency:</strong> Separate indices for labels/types enable O(N_label)/O(E_type) queries</p>
<hr />
<h2 id="property_graph_model-api-reference">API Reference<a class="headerlink" href="#property_graph_model-api-reference" title="Permanent link">&para;</a></h2>
<h3 id="property_graph_model-property-graph-manager">Property Graph Manager<a class="headerlink" href="#property_graph_model-property-graph-manager" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &quot;index/property_graph.h&quot;

PropertyGraphManager pgm(db);
</code></pre>
<h3 id="property_graph_model-node-label-operations">Node Label Operations<a class="headerlink" href="#property_graph_model-node-label-operations" title="Permanent link">&para;</a></h3>
<h4 id="property_graph_model-add-node-with-labels">Add Node with Labels<a class="headerlink" href="#property_graph_model-add-node-with-labels" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">Status addNode(const BaseEntity&amp; node, std::string_view graph_id = &quot;default&quot;);
</code></pre>
<p><strong>Parameters:</strong>
- <code>node</code>: BaseEntity with <code>_labels</code> field (comma-separated string)
- <code>graph_id</code>: Graph identifier (default: "default")</p>
<p><strong>Returns:</strong> Status (ok/error)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">BaseEntity alice(&quot;alice&quot;);
alice.setField(&quot;id&quot;, &quot;alice&quot;);
alice.setField(&quot;name&quot;, &quot;Alice Smith&quot;);
alice.setField(&quot;age&quot;, 30);
alice.setField(&quot;_labels&quot;, &quot;Person,Employee,Manager&quot;);

auto st = pgm.addNode(alice, &quot;corporate&quot;);
// Creates 3 label index entries:
// - label:corporate:Person:alice
// - label:corporate:Employee:alice
// - label:corporate:Manager:alice
</code></pre>
<hr />
<h4 id="property_graph_model-add-label-to-existing-node">Add Label to Existing Node<a class="headerlink" href="#property_graph_model-add-label-to-existing-node" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">Status addNodeLabel(std::string_view pk, std::string_view label, 
                    std::string_view graph_id = &quot;default&quot;);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto st = pgm.addNodeLabel(&quot;alice&quot;, &quot;Director&quot;, &quot;corporate&quot;);
// Updates node: _labels = &quot;Person,Employee,Manager,Director&quot;
// Creates index: label:corporate:Director:alice
</code></pre>
<hr />
<h4 id="property_graph_model-remove-label-from-node">Remove Label from Node<a class="headerlink" href="#property_graph_model-remove-label-from-node" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">Status removeNodeLabel(std::string_view pk, std::string_view label,
                       std::string_view graph_id = &quot;default&quot;);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto st = pgm.removeNodeLabel(&quot;alice&quot;, &quot;Employee&quot;, &quot;corporate&quot;);
// Updates node: _labels = &quot;Person,Manager,Director&quot;
// Deletes index: label:corporate:Employee:alice
</code></pre>
<hr />
<h4 id="property_graph_model-query-nodes-by-label">Query Nodes by Label<a class="headerlink" href="#property_graph_model-query-nodes-by-label" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;std::string&gt;&gt; 
getNodesByLabel(std::string_view label, std::string_view graph_id = &quot;default&quot;) const;
</code></pre>
<p><strong>Returns:</strong> Vector of primary keys matching label</p>
<p><strong>Time Complexity:</strong> O(N_label) where N_label = nodes with label</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto [st, people] = pgm.getNodesByLabel(&quot;Person&quot;, &quot;corporate&quot;);
// Result: [&quot;alice&quot;, &quot;bob&quot;, &quot;charlie&quot;, ...]
</code></pre>
<hr />
<h4 id="property_graph_model-check-if-node-has-label">Check if Node Has Label<a class="headerlink" href="#property_graph_model-check-if-node-has-label" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">std::pair&lt;Status, bool&gt; 
hasNodeLabel(std::string_view pk, std::string_view label,
             std::string_view graph_id = &quot;default&quot;) const;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto [st, hasLabel] = pgm.hasNodeLabel(&quot;alice&quot;, &quot;Manager&quot;, &quot;corporate&quot;);
// Result: true (alice is a Manager)
</code></pre>
<hr />
<h3 id="property_graph_model-relationship-type-operations">Relationship Type Operations<a class="headerlink" href="#property_graph_model-relationship-type-operations" title="Permanent link">&para;</a></h3>
<h4 id="property_graph_model-add-edge-with-type">Add Edge with Type<a class="headerlink" href="#property_graph_model-add-edge-with-type" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">Status addEdge(const BaseEntity&amp; edge, std::string_view graph_id = &quot;default&quot;);
</code></pre>
<p><strong>Parameters:</strong>
- <code>edge</code>: BaseEntity with <code>_from</code>, <code>_to</code>, <code>_type</code> fields
- <code>graph_id</code>: Graph identifier</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">BaseEntity follows(&quot;follows_1&quot;);
follows.setField(&quot;id&quot;, &quot;follows_1&quot;);
follows.setField(&quot;_from&quot;, &quot;alice&quot;);
follows.setField(&quot;_to&quot;, &quot;bob&quot;);
follows.setField(&quot;_type&quot;, &quot;FOLLOWS&quot;);
follows.setField(&quot;since&quot;, 2020);
follows.setField(&quot;strength&quot;, 0.8);

auto st = pgm.addEdge(follows, &quot;social&quot;);
// Creates indices:
// - edge:social:follows_1 -&gt; BaseEntity
// - graph:out:social:alice:follows_1 -&gt; bob
// - graph:in:social:bob:follows_1 -&gt; alice
// - type:social:FOLLOWS:follows_1 -&gt; (empty)
</code></pre>
<hr />
<h4 id="property_graph_model-query-edges-by-type">Query Edges by Type<a class="headerlink" href="#property_graph_model-query-edges-by-type" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct EdgeInfo {
    std::string edgeId;
    std::string fromPk;
    std::string toPk;
    std::string type;
    std::string graph_id;
};

std::pair&lt;Status, std::vector&lt;EdgeInfo&gt;&gt;
getEdgesByType(std::string_view type, std::string_view graph_id = &quot;default&quot;) const;
</code></pre>
<p><strong>Returns:</strong> All edges with specified type</p>
<p><strong>Time Complexity:</strong> O(E_type) where E_type = edges with type</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto [st, followsEdges] = pgm.getEdgesByType(&quot;FOLLOWS&quot;, &quot;social&quot;);
// Result: [
//   {edgeId: &quot;follows_1&quot;, fromPk: &quot;alice&quot;, toPk: &quot;bob&quot;, type: &quot;FOLLOWS&quot;},
//   {edgeId: &quot;follows_2&quot;, fromPk: &quot;bob&quot;, toPk: &quot;charlie&quot;, type: &quot;FOLLOWS&quot;},
//   ...
// ]
</code></pre>
<hr />
<h4 id="property_graph_model-query-typed-outgoing-edges-from-node">Query Typed Outgoing Edges from Node<a class="headerlink" href="#property_graph_model-query-typed-outgoing-edges-from-node" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;EdgeInfo&gt;&gt;
getTypedOutEdges(std::string_view fromPk, std::string_view type,
                 std::string_view graph_id = &quot;default&quot;) const;
</code></pre>
<p><strong>Returns:</strong> Outgoing edges from node with specified type</p>
<p><strong>Time Complexity:</strong> O(d_type) where d_type = out-degree for type</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto [st, aliceFollows] = pgm.getTypedOutEdges(&quot;alice&quot;, &quot;FOLLOWS&quot;, &quot;social&quot;);
// Result: All FOLLOWS edges originating from alice
</code></pre>
<hr />
<h3 id="property_graph_model-multi-graph-federation">Multi-Graph Federation<a class="headerlink" href="#property_graph_model-multi-graph-federation" title="Permanent link">&para;</a></h3>
<h4 id="property_graph_model-list-all-graphs">List All Graphs<a class="headerlink" href="#property_graph_model-list-all-graphs" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;std::string&gt;&gt; listGraphs() const;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto [st, graphs] = pgm.listGraphs();
// Result: [&quot;default&quot;, &quot;social&quot;, &quot;corporate&quot;, &quot;knowledge&quot;]
</code></pre>
<hr />
<h4 id="property_graph_model-get-graph-statistics">Get Graph Statistics<a class="headerlink" href="#property_graph_model-get-graph-statistics" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct GraphStats {
    std::string graph_id;
    size_t node_count;
    size_t edge_count;
    size_t label_count;
    size_t type_count;
};

std::pair&lt;Status, GraphStats&gt; getGraphStats(std::string_view graph_id) const;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">auto [st, stats] = pgm.getGraphStats(&quot;social&quot;);
// Result: {
//   graph_id: &quot;social&quot;,
//   node_count: 1500,
//   edge_count: 8200,
//   label_count: 5,  // Person, Post, Comment, Tag, Group
//   type_count: 7    // FOLLOWS, LIKES, COMMENTS, TAGGED, MEMBER_OF, ...
// }
</code></pre>
<hr />
<h4 id="property_graph_model-federated-pattern-matching">Federated Pattern Matching<a class="headerlink" href="#property_graph_model-federated-pattern-matching" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct FederationPattern {
    std::string graph_id;
    std::string label_or_type;  // Node label or edge type
    std::string pattern_type;   // &quot;node&quot; or &quot;edge&quot;
};

struct FederationResult {
    std::vector&lt;NodeInfo&gt; nodes;
    std::vector&lt;EdgeInfo&gt; edges;
};

std::pair&lt;Status, FederationResult&gt;
federatedQuery(const std::vector&lt;FederationPattern&gt;&amp; patterns) const;
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">// Find all Person nodes in social graph and Employee nodes in corporate graph
// Plus all FOLLOWS edges in social and REPORTS_TO edges in corporate
std::vector&lt;PropertyGraphManager::FederationPattern&gt; patterns = {
    {&quot;social&quot;, &quot;Person&quot;, &quot;node&quot;},
    {&quot;corporate&quot;, &quot;Employee&quot;, &quot;node&quot;},
    {&quot;social&quot;, &quot;FOLLOWS&quot;, &quot;edge&quot;},
    {&quot;corporate&quot;, &quot;REPORTS_TO&quot;, &quot;edge&quot;}
};

auto [st, result] = pgm.federatedQuery(patterns);
// Result: {
//   nodes: [NodeInfo{pk: &quot;alice&quot;, labels: [&quot;Person&quot;], graph_id: &quot;social&quot;}, ...],
//   edges: [EdgeInfo{edgeId: &quot;follows_1&quot;, type: &quot;FOLLOWS&quot;, ...}, ...]
// }
</code></pre>
<hr />
<h3 id="property_graph_model-batch-operations">Batch Operations<a class="headerlink" href="#property_graph_model-batch-operations" title="Permanent link">&para;</a></h3>
<h4 id="property_graph_model-add-multiple-nodes-atomic">Add Multiple Nodes (Atomic)<a class="headerlink" href="#property_graph_model-add-multiple-nodes-atomic" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">Status addNodesBatch(const std::vector&lt;BaseEntity&gt;&amp; nodes,
                     std::string_view graph_id = &quot;default&quot;);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">std::vector&lt;BaseEntity&gt; people;
for (int i = 0; i &lt; 1000; ++i) {
    BaseEntity person(&quot;person_&quot; + std::to_string(i));
    person.setField(&quot;id&quot;, &quot;person_&quot; + std::to_string(i));
    person.setField(&quot;_labels&quot;, &quot;Person&quot;);
    people.push_back(person);
}

auto st = pgm.addNodesBatch(people, &quot;social&quot;);
// Atomic: All 1000 nodes + label indices added in one transaction
</code></pre>
<hr />
<h4 id="property_graph_model-add-multiple-edges-atomic">Add Multiple Edges (Atomic)<a class="headerlink" href="#property_graph_model-add-multiple-edges-atomic" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">Status addEdgesBatch(const std::vector&lt;BaseEntity&gt;&amp; edges,
                     std::string_view graph_id = &quot;default&quot;);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">std::vector&lt;BaseEntity&gt; relationships;
for (int i = 0; i &lt; 100; ++i) {
    BaseEntity follows(&quot;follows_&quot; + std::to_string(i));
    follows.setField(&quot;id&quot;, &quot;follows_&quot; + std::to_string(i));
    follows.setField(&quot;_from&quot;, &quot;person_&quot; + std::to_string(i));
    follows.setField(&quot;_to&quot;, &quot;person_&quot; + std::to_string(i + 1));
    follows.setField(&quot;_type&quot;, &quot;FOLLOWS&quot;);
    relationships.push_back(follows);
}

auto st = pgm.addEdgesBatch(relationships, &quot;social&quot;);
// Atomic: All 100 edges + type/adjacency indices added in one transaction
</code></pre>
<hr />
<h2 id="property_graph_model-usage-examples">Usage Examples<a class="headerlink" href="#property_graph_model-usage-examples" title="Permanent link">&para;</a></h2>
<h3 id="property_graph_model-example-1-social-network-graph">Example 1: Social Network Graph<a class="headerlink" href="#property_graph_model-example-1-social-network-graph" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">PropertyGraphManager pgm(db);

// Create Person nodes
BaseEntity alice(&quot;alice&quot;);
alice.setField(&quot;id&quot;, &quot;alice&quot;);
alice.setField(&quot;name&quot;, &quot;Alice&quot;);
alice.setField(&quot;_labels&quot;, &quot;Person,Influencer&quot;);
pgm.addNode(alice, &quot;social&quot;);

BaseEntity bob(&quot;bob&quot;);
bob.setField(&quot;id&quot;, &quot;bob&quot;);
bob.setField(&quot;name&quot;, &quot;Bob&quot;);
bob.setField(&quot;_labels&quot;, &quot;Person&quot;);
pgm.addNode(bob, &quot;social&quot;);

// Create typed relationships
BaseEntity follows(&quot;follows_1&quot;);
follows.setField(&quot;id&quot;, &quot;follows_1&quot;);
follows.setField(&quot;_from&quot;, &quot;alice&quot;);
follows.setField(&quot;_to&quot;, &quot;bob&quot;);
follows.setField(&quot;_type&quot;, &quot;FOLLOWS&quot;);
follows.setField(&quot;since&quot;, 2020);
pgm.addEdge(follows, &quot;social&quot;);

BaseEntity likes(&quot;likes_1&quot;);
likes.setField(&quot;id&quot;, &quot;likes_1&quot;);
likes.setField(&quot;_from&quot;, &quot;bob&quot;);
likes.setField(&quot;_to&quot;, &quot;alice&quot;);
likes.setField(&quot;_type&quot;, &quot;LIKES&quot;);
pgm.addEdge(likes, &quot;social&quot;);

// Query: Find all Influencers
auto [st1, influencers] = pgm.getNodesByLabel(&quot;Influencer&quot;, &quot;social&quot;);
// Result: [&quot;alice&quot;]

// Query: Find all FOLLOWS relationships
auto [st2, followsEdges] = pgm.getEdgesByType(&quot;FOLLOWS&quot;, &quot;social&quot;);
// Result: [{edgeId: &quot;follows_1&quot;, fromPk: &quot;alice&quot;, toPk: &quot;bob&quot;, ...}]

// Query: Who does alice follow?
auto [st3, aliceFollows] = pgm.getTypedOutEdges(&quot;alice&quot;, &quot;FOLLOWS&quot;, &quot;social&quot;);
// Result: [{toPk: &quot;bob&quot;, ...}]
</code></pre>
<hr />
<h3 id="property_graph_model-example-2-enterprise-org-chart">Example 2: Enterprise Org Chart<a class="headerlink" href="#property_graph_model-example-2-enterprise-org-chart" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Corporate graph with Employee-Manager hierarchy
BaseEntity emp1(&quot;emp1&quot;);
emp1.setField(&quot;id&quot;, &quot;emp1&quot;);
emp1.setField(&quot;name&quot;, &quot;John Doe&quot;);
emp1.setField(&quot;_labels&quot;, &quot;Employee,Developer&quot;);
pgm.addNode(emp1, &quot;corporate&quot;);

BaseEntity emp2(&quot;emp2&quot;);
emp2.setField(&quot;id&quot;, &quot;emp2&quot;);
emp2.setField(&quot;name&quot;, &quot;Jane Smith&quot;);
emp2.setField(&quot;_labels&quot;, &quot;Employee,Manager&quot;);
pgm.addNode(emp2, &quot;corporate&quot;);

BaseEntity reports(&quot;reports_1&quot;);
reports.setField(&quot;id&quot;, &quot;reports_1&quot;);
reports.setField(&quot;_from&quot;, &quot;emp1&quot;);
reports.setField(&quot;_to&quot;, &quot;emp2&quot;);
reports.setField(&quot;_type&quot;, &quot;REPORTS_TO&quot;);
pgm.addEdge(reports, &quot;corporate&quot;);

// Query: Find all Managers
auto [st, managers] = pgm.getNodesByLabel(&quot;Manager&quot;, &quot;corporate&quot;);
// Result: [&quot;emp2&quot;]

// Query: Find reporting structure
auto [st2, reportingEdges] = pgm.getEdgesByType(&quot;REPORTS_TO&quot;, &quot;corporate&quot;);
// Result: [{fromPk: &quot;emp1&quot;, toPk: &quot;emp2&quot;, type: &quot;REPORTS_TO&quot;}]
</code></pre>
<hr />
<h3 id="property_graph_model-example-3-cross-graph-federation">Example 3: Cross-Graph Federation<a class="headerlink" href="#property_graph_model-example-3-cross-graph-federation" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Setup social graph
BaseEntity alice_social(&quot;alice&quot;);
alice_social.setField(&quot;id&quot;, &quot;alice&quot;);
alice_social.setField(&quot;_labels&quot;, &quot;Person&quot;);
pgm.addNode(alice_social, &quot;social&quot;);

// Setup corporate graph
BaseEntity alice_corp(&quot;alice&quot;);
alice_corp.setField(&quot;id&quot;, &quot;alice&quot;);
alice_corp.setField(&quot;_labels&quot;, &quot;Employee&quot;);
pgm.addNode(alice_corp, &quot;corporate&quot;);

// Federated query: Find Person in social AND Employee in corporate
std::vector&lt;PropertyGraphManager::FederationPattern&gt; patterns = {
    {&quot;social&quot;, &quot;Person&quot;, &quot;node&quot;},
    {&quot;corporate&quot;, &quot;Employee&quot;, &quot;node&quot;}
};

auto [st, result] = pgm.federatedQuery(patterns);
// Result combines data from both graphs:
// nodes: [
//   {pk: &quot;alice&quot;, labels: [&quot;Person&quot;], graph_id: &quot;social&quot;},
//   {pk: &quot;alice&quot;, labels: [&quot;Employee&quot;], graph_id: &quot;corporate&quot;}
// ]
</code></pre>
<hr />
<h2 id="property_graph_model-performance-characteristics">Performance Characteristics<a class="headerlink" href="#property_graph_model-performance-characteristics" title="Permanent link">&para;</a></h2>
<h3 id="property_graph_model-label-queries">Label Queries<a class="headerlink" href="#property_graph_model-label-queries" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Time Complexity:</strong> O(N_label) where N_label = nodes with label</li>
<li><strong>Space Complexity:</strong> O(N_label × L) where L = avg labels per node</li>
<li><strong>Index Structure:</strong> Prefix scan on <code>label:&lt;graph_id&gt;:&lt;label&gt;:*</code></li>
</ul>
<p><strong>Optimization:</strong>
- Labels stored as comma-separated string (trade-off: compact vs. array parsing)
- Label index enables fast <code>getNodesByLabel()</code> queries
- Multi-label nodes create multiple index entries (denormalized)</p>
<h3 id="property_graph_model-type-queries">Type Queries<a class="headerlink" href="#property_graph_model-type-queries" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Time Complexity:</strong> O(E_type) where E_type = edges with type</li>
<li><strong>Space Complexity:</strong> O(E_type)</li>
<li><strong>Index Structure:</strong> Prefix scan on <code>type:&lt;graph_id&gt;:&lt;type&gt;:*</code></li>
</ul>
<p><strong>Optimization:</strong>
- Type index enables fast <code>getEdgesByType()</code> queries
- Typed traversal filters edges client-side (TODO: server-side filtering)</p>
<h3 id="property_graph_model-multi-graph-operations">Multi-Graph Operations<a class="headerlink" href="#property_graph_model-multi-graph-operations" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Graph Isolation:</strong> O(1) via <code>graph_id</code> prefix</li>
<li><strong>List Graphs:</strong> O(N) where N = total nodes (full scan to extract graph_ids)</li>
<li><strong>Graph Stats:</strong> O(N + E + L + T) for counts (prefix scans)</li>
<li><strong>Federation:</strong> O(P × (N_p + E_p)) where P = patterns, N_p/E_p = matches per pattern</li>
</ul>
<p><strong>Optimization Opportunities:</strong>
- Maintain graph metadata index (graph registry)
- Cache graph stats in memory
- Parallel federation queries (concurrent pattern matching)</p>
<hr />
<h2 id="property_graph_model-cypher-like-query-examples">Cypher-Like Query Examples<a class="headerlink" href="#property_graph_model-cypher-like-query-examples" title="Permanent link">&para;</a></h2>
<p>While Themis doesn't support Cypher syntax directly, here's how to express common patterns:</p>
<h3 id="property_graph_model-pattern-match-pperson-return-p">Pattern: <code>MATCH (p:Person) RETURN p</code><a class="headerlink" href="#property_graph_model-pattern-match-pperson-return-p" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto [st, people] = pgm.getNodesByLabel(&quot;Person&quot;);
for (const auto&amp; pk : people) {
    // Load full node entity if needed
    std::string nodeKey = &quot;node:default:&quot; + pk;
    auto blob = db.get(nodeKey);
    BaseEntity person = BaseEntity::deserialize(pk, *blob);
    // Use person data...
}
</code></pre>
<h3 id="property_graph_model-pattern-match-rfollows-return-r">Pattern: <code>MATCH ()-[r:FOLLOWS]-&gt;() RETURN r</code><a class="headerlink" href="#property_graph_model-pattern-match-rfollows-return-r" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto [st, followsEdges] = pgm.getEdgesByType(&quot;FOLLOWS&quot;);
for (const auto&amp; edge : followsEdges) {
    // edge.fromPk, edge.toPk, edge.edgeId available
}
</code></pre>
<h3 id="property_graph_model-pattern-match-aperson-rfollows-bperson-return-a-r-b">Pattern: <code>MATCH (a:Person)-[r:FOLLOWS]-&gt;(b:Person) RETURN a, r, b</code><a class="headerlink" href="#property_graph_model-pattern-match-aperson-rfollows-bperson-return-a-r-b" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto [st1, people] = pgm.getNodesByLabel(&quot;Person&quot;);
auto [st2, followsEdges] = pgm.getEdgesByType(&quot;FOLLOWS&quot;);

// Filter edges where both endpoints are Person
for (const auto&amp; edge : followsEdges) {
    bool fromIsPerson = std::find(people.begin(), people.end(), edge.fromPk) != people.end();
    bool toIsPerson = std::find(people.begin(), people.end(), edge.toPk) != people.end();

    if (fromIsPerson &amp;&amp; toIsPerson) {
        // Matching pattern: Person -[FOLLOWS]-&gt; Person
    }
}
</code></pre>
<h3 id="property_graph_model-pattern-match-a-follows-b-follows-c-return-a-c">Pattern: <code>MATCH (a)-[:FOLLOWS]-&gt;(b)-[:FOLLOWS]-&gt;(c) RETURN a, c</code><a class="headerlink" href="#property_graph_model-pattern-match-a-follows-b-follows-c-return-a-c" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// 2-hop traversal with type filtering
auto [st, edges] = pgm.getTypedOutEdges(&quot;alice&quot;, &quot;FOLLOWS&quot;);
for (const auto&amp; edge1 : edges) {
    std::string intermediate = edge1.toPk;
    auto [st2, edges2] = pgm.getTypedOutEdges(intermediate, &quot;FOLLOWS&quot;);
    for (const auto&amp; edge2 : edges2) {
        // alice -&gt; intermediate -&gt; edge2.toPk (2-hop path)
    }
}
</code></pre>
<hr />
<h2 id="property_graph_model-migration-guide">Migration Guide<a class="headerlink" href="#property_graph_model-migration-guide" title="Permanent link">&para;</a></h2>
<h3 id="property_graph_model-from-simple-graph-to-property-graph">From Simple Graph to Property Graph<a class="headerlink" href="#property_graph_model-from-simple-graph-to-property-graph" title="Permanent link">&para;</a></h3>
<p><strong>Before (Simple Graph):</strong></p>
<pre><code class="language-cpp">GraphIndexManager graph(db);

BaseEntity edge(&quot;e1&quot;);
edge.setField(&quot;_from&quot;, &quot;alice&quot;);
edge.setField(&quot;_to&quot;, &quot;bob&quot;);
graph.addEdge(edge);

auto [st, neighbors] = graph.outNeighbors(&quot;alice&quot;);
</code></pre>
<p><strong>After (Property Graph):</strong></p>
<pre><code class="language-cpp">PropertyGraphManager pgm(db);

// Add nodes with labels
BaseEntity alice(&quot;alice&quot;);
alice.setField(&quot;id&quot;, &quot;alice&quot;);
alice.setField(&quot;_labels&quot;, &quot;Person&quot;);
pgm.addNode(alice);

BaseEntity bob(&quot;bob&quot;);
bob.setField(&quot;id&quot;, &quot;bob&quot;);
bob.setField(&quot;_labels&quot;, &quot;Person&quot;);
pgm.addNode(bob);

// Add edge with type
BaseEntity edge(&quot;e1&quot;);
edge.setField(&quot;id&quot;, &quot;e1&quot;);
edge.setField(&quot;_from&quot;, &quot;alice&quot;);
edge.setField(&quot;_to&quot;, &quot;bob&quot;);
edge.setField(&quot;_type&quot;, &quot;FOLLOWS&quot;);
pgm.addEdge(edge);

// Query by label
auto [st, people] = pgm.getNodesByLabel(&quot;Person&quot;);

// Query by type
auto [st2, followsEdges] = pgm.getEdgesByType(&quot;FOLLOWS&quot;);
</code></pre>
<p><strong>Key Changes:</strong>
1. Nodes require explicit <code>addNode()</code> call (not just edges)
2. Nodes can have <code>_labels</code> field (comma-separated)
3. Edges can have <code>_type</code> field
4. New query methods: <code>getNodesByLabel()</code>, <code>getEdgesByType()</code>
5. Multi-graph support via <code>graph_id</code> parameter</p>
<hr />
<h2 id="property_graph_model-integration-with-existing-features">Integration with Existing Features<a class="headerlink" href="#property_graph_model-integration-with-existing-features" title="Permanent link">&para;</a></h2>
<h3 id="property_graph_model-works-with-temporal-graphs">Works With Temporal Graphs<a class="headerlink" href="#property_graph_model-works-with-temporal-graphs" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Temporal edge with type
BaseEntity edge(&quot;e1&quot;);
edge.setField(&quot;id&quot;, &quot;e1&quot;);
edge.setField(&quot;_from&quot;, &quot;alice&quot;);
edge.setField(&quot;_to&quot;, &quot;bob&quot;);
edge.setField(&quot;_type&quot;, &quot;FOLLOWS&quot;);
edge.setField(&quot;valid_from&quot;, 1609459200000);  // 2021-01-01
edge.setField(&quot;valid_to&quot;, 1640995200000);    // 2022-01-01
pgm.addEdge(edge);

// Query: FOLLOWS edges active in 2021
auto [st, followsEdges] = pgm.getEdgesByType(&quot;FOLLOWS&quot;);
// Then filter by valid_from/valid_to (client-side)

// TODO: Combine with getEdgesInTimeRange() for server-side filtering
</code></pre>
<h3 id="property_graph_model-works-with-recursive-path-queries">Works With Recursive Path Queries<a class="headerlink" href="#property_graph_model-works-with-recursive-path-queries" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Recursive query with type filtering
RecursivePathQuery rpq;
rpq.start_node = &quot;alice&quot;;
rpq.end_node = &quot;charlie&quot;;
rpq.max_depth = 3;
// Then filter path edges by type using getEdgesByType()

// TODO: Add type parameter to executeRecursivePathQuery()
</code></pre>
<hr />
<h2 id="property_graph_model-known-limitations">Known Limitations<a class="headerlink" href="#property_graph_model-known-limitations" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Labels as String:</strong> Labels stored as comma-separated string (not array)</li>
<li><strong>Workaround:</strong> Parse string manually or extend BaseEntity</li>
<li><strong>No Server-Side Type Filtering in Traversal:</strong> <code>getTypedOutEdges()</code> loads all edges then filters</li>
<li><strong>Future:</strong> Add type-aware BFS/Dijkstra</li>
<li><strong>No Property Constraints:</strong> Cannot enforce label/type schemas</li>
<li><strong>Future:</strong> Add schema validation</li>
<li><strong>Federation is Simplified:</strong> No complex joins (only union of patterns)</li>
<li><strong>Future:</strong> Add join operators (nested loop, hash join)</li>
<li><strong>No Cypher Parser:</strong> Manual API calls required</li>
<li><strong>Future:</strong> Cypher-to-API translator</li>
</ol>
<hr />
<h2 id="property_graph_model-future-enhancements">Future Enhancements<a class="headerlink" href="#property_graph_model-future-enhancements" title="Permanent link">&para;</a></h2>
<h3 id="property_graph_model-1-array-based-labels">1. Array-Based Labels<a class="headerlink" href="#property_graph_model-1-array-based-labels" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Comma-separated string requires parsing<br />
<strong>Solution:</strong> Extend BaseEntity to support <code>std::vector&lt;std::string&gt;</code></p>
<pre><code class="language-cpp">alice.setField(&quot;_labels&quot;, std::vector&lt;std::string&gt;{&quot;Person&quot;, &quot;Employee&quot;});
</code></pre>
<h3 id="property_graph_model-2-type-aware-graph-traversal">2. Type-Aware Graph Traversal<a class="headerlink" href="#property_graph_model-2-type-aware-graph-traversal" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> BFS/Dijkstra don't filter by type<br />
<strong>Solution:</strong> Add type parameter to traversal algorithms</p>
<pre><code class="language-cpp">auto [st, path] = graph.dijkstra(&quot;alice&quot;, &quot;bob&quot;, &quot;FOLLOWS&quot;);
// Only traverse FOLLOWS edges
</code></pre>
<h3 id="property_graph_model-3-schema-validation">3. Schema Validation<a class="headerlink" href="#property_graph_model-3-schema-validation" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> No enforcement of valid labels/types<br />
<strong>Solution:</strong> Add schema definition and validation</p>
<pre><code class="language-cpp">PropertyGraphSchema schema;
schema.defineNodeLabel(&quot;Person&quot;, {{&quot;name&quot;, &quot;string&quot;}, {&quot;age&quot;, &quot;int&quot;}});
schema.defineEdgeType(&quot;FOLLOWS&quot;, {{&quot;since&quot;, &quot;int&quot;}});
pgm.setSchema(schema);

// Validation on insert
pgm.addNode(invalidNode);  // Error: Missing required field 'name'
</code></pre>
<h3 id="property_graph_model-4-complex-federated-joins">4. Complex Federated Joins<a class="headerlink" href="#property_graph_model-4-complex-federated-joins" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Only union of patterns supported<br />
<strong>Solution:</strong> Add join operators</p>
<pre><code class="language-cpp">FederatedJoinQuery fjq;
fjq.addPattern(&quot;social&quot;, &quot;Person&quot;, &quot;node&quot;);
fjq.addPattern(&quot;corporate&quot;, &quot;Employee&quot;, &quot;node&quot;);
fjq.setJoinKey(&quot;id&quot;);  // Join on node primary key
auto [st, result] = pgm.federatedJoin(fjq);
// Result: Person nodes that are also Employees
</code></pre>
<h3 id="property_graph_model-5-cypher-query-language">5. Cypher Query Language<a class="headerlink" href="#property_graph_model-5-cypher-query-language" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Manual API calls verbose<br />
<strong>Solution:</strong> Cypher-to-API translator</p>
<pre><code class="language-cpp">std::string cypher = &quot;MATCH (p:Person)-[r:FOLLOWS]-&gt;(f:Person) RETURN p, f&quot;;
auto [st, result] = pgm.executeCypher(cypher, &quot;social&quot;);
</code></pre>
<hr />
<h2 id="property_graph_model-changelog">Changelog<a class="headerlink" href="#property_graph_model-changelog" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>2025-01-15:</strong> Initial implementation</li>
<li>Added <code>PropertyGraphManager</code> class</li>
<li>Implemented node labels (<code>_labels</code> field)</li>
<li>Implemented relationship types (<code>_type</code> field)</li>
<li>Added multi-graph federation (<code>graph_id</code> prefix)</li>
<li>Created label/type indices</li>
<li>Implemented federated pattern matching</li>
<li>Added batch operations</li>
<li>Created 13 comprehensive tests (all passing)</li>
<li>Documentation created</li>
</ul>
<hr />
<h2 id="property_graph_model-see-also">See Also<a class="headerlink" href="#property_graph_model-see-also" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#indexes-graph-index">Graph Index</a> - Base graph adjacency index</li>
<li><a href="#temporal_time_range_queries">Temporal Graphs</a> - Time-window queries</li>
<li><a href="#recursive_path_queries">Recursive Path Queries</a> - Multi-hop traversal</li>
<li><a href="#base_entity">Base Entity</a> - Flexible schema-less storage</li>
</ul></section></section>
                    <section class='print-page md-section' id='section-4' heading-number='4'>
                        <h1>Storage & MVCC<a class='headerlink' href='#section-4' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="storage-geo_relational_schema" heading-number="4.1"><h1 id="storage-geo_relational_schema-relationales-schema-fur-geo-daten-post-go-live">Relationales Schema für Geo-Daten (Post-Go-Live)<a class="headerlink" href="#storage-geo_relational_schema-relationales-schema-fur-geo-daten-post-go-live" title="Permanent link">&para;</a></h1>
<p>Dieses Dokument definiert ein abfragefreundliches relationales Schema für Punkt-, Linien- und Polygon-Daten inklusive Indexierung und Beispielabfragen. Es dient als Zielbild für die Ablage nach dem Ingestion-Prozess.</p>
<h2 id="storage-geo_relational_schema-ziele">Ziele<a class="headerlink" href="#storage-geo_relational_schema-ziele" title="Permanent link">&para;</a></h2>
<ul>
<li>Saubere Trennung von Geometrietypen (Point/LineString/Polygon)</li>
<li>Schnelle räumliche Abfragen (R-Tree/GiST) und begriffliche Filter (B-Tree/FTS/Trigram)</li>
<li>Kompatibel mit EPSG:4326 (lon/lat); Bounding-Box pro Feature</li>
<li>Unterstützt Suchszenarien wie: "LSG", "Fließgewässer", nahe (lon, lat)</li>
</ul>
<h2 id="storage-geo_relational_schema-tabellenentwurf-neutral">Tabellenentwurf (neutral)<a class="headerlink" href="#storage-geo_relational_schema-tabellenentwurf-neutral" title="Permanent link">&para;</a></h2>
<h3 id="storage-geo_relational_schema-features">features<a class="headerlink" href="#storage-geo_relational_schema-features" title="Permanent link">&para;</a></h3>
<ul>
<li><code>feature_id</code> (PK, UUID/ULID)</li>
<li><code>source_id</code> (TEXT)</li>
<li><code>source_pk</code> (TEXT)</li>
<li><code>class</code> (TEXT) — z. B. "LSG", "Fließgewässer"</li>
<li><code>name</code> (TEXT)</li>
<li><code>bbox_min_lon</code> (DOUBLE)</li>
<li><code>bbox_min_lat</code> (DOUBLE)</li>
<li><code>bbox_max_lon</code> (DOUBLE)</li>
<li><code>bbox_max_lat</code> (DOUBLE)</li>
<li><code>tags</code> (JSON)</li>
<li><code>created_at</code> (TIMESTAMP)</li>
</ul>
<h3 id="storage-geo_relational_schema-points">points<a class="headerlink" href="#storage-geo_relational_schema-points" title="Permanent link">&para;</a></h3>
<ul>
<li><code>feature_id</code> (FK → features)</li>
<li><code>lon</code> (DOUBLE)</li>
<li><code>lat</code> (DOUBLE)</li>
</ul>
<h3 id="storage-geo_relational_schema-lines">lines<a class="headerlink" href="#storage-geo_relational_schema-lines" title="Permanent link">&para;</a></h3>
<ul>
<li><code>feature_id</code> (FK → features)</li>
<li><code>geom_wkt</code> (TEXT) — WKT LineString; optional: normalisierte Stützpunkte in separater Tabelle</li>
</ul>
<h3 id="storage-geo_relational_schema-polygons">polygons<a class="headerlink" href="#storage-geo_relational_schema-polygons" title="Permanent link">&para;</a></h3>
<ul>
<li><code>feature_id</code> (FK → features)</li>
<li><code>geom_wkt</code> (TEXT) — WKT Polygon (Außenring + Innenringe)</li>
</ul>
<h3 id="storage-geo_relational_schema-terms-begriffe-fur-volltextfacetten">terms (Begriffe für Volltext/Facetten)<a class="headerlink" href="#storage-geo_relational_schema-terms-begriffe-fur-volltextfacetten" title="Permanent link">&para;</a></h3>
<ul>
<li><code>feature_id</code> (FK → features)</li>
<li><code>term</code> (TEXT)</li>
<li><code>lang</code> (TEXT, optional)</li>
</ul>
<h3 id="storage-geo_relational_schema-synonyms-synonym-alias-lexikon">synonyms (Synonym-/Alias-Lexikon)<a class="headerlink" href="#storage-geo_relational_schema-synonyms-synonym-alias-lexikon" title="Permanent link">&para;</a></h3>
<ul>
<li><code>term</code> (TEXT)</li>
<li><code>canonical</code> (TEXT)</li>
<li><code>lang</code> (TEXT)</li>
</ul>
<p>Hinweis: In PostGIS-Umgebungen können <code>geom_wkt</code>-Spalten als <code>geometry</code>-Typ modelliert werden (GiST-Index). In einfacheren Setups bleiben WKT + BBox; räumliche Filter laufen über BBox-First-Filter + optionale Software-Präzisierung.</p>
<h2 id="storage-geo_relational_schema-beispiel-ddl-postgresqlpostgis-optional">Beispiel-DDL (PostgreSQL/PostGIS optional)<a class="headerlink" href="#storage-geo_relational_schema-beispiel-ddl-postgresqlpostgis-optional" title="Permanent link">&para;</a></h2>
<pre><code class="language-sql">-- Basis (ohne PostGIS)
CREATE TABLE features (
  feature_id TEXT PRIMARY KEY,
  source_id TEXT NOT NULL,
  source_pk TEXT NOT NULL,
  class TEXT,
  name TEXT,
  bbox_min_lon DOUBLE PRECISION,
  bbox_min_lat DOUBLE PRECISION,
  bbox_max_lon DOUBLE PRECISION,
  bbox_max_lat DOUBLE PRECISION,
  tags JSONB,
  created_at TIMESTAMP DEFAULT now()
);
CREATE INDEX ix_features_class ON features(class);
CREATE INDEX ix_features_name ON features(name);
CREATE INDEX ix_features_bbox ON features(bbox_min_lon, bbox_min_lat, bbox_max_lon, bbox_max_lat);

CREATE TABLE points (
  feature_id TEXT REFERENCES features(feature_id) ON DELETE CASCADE,
  lon DOUBLE PRECISION NOT NULL,
  lat DOUBLE PRECISION NOT NULL
);
CREATE INDEX ix_points_lonlat ON points(lon, lat);

CREATE TABLE lines (
  feature_id TEXT REFERENCES features(feature_id) ON DELETE CASCADE,
  geom_wkt TEXT NOT NULL
);

CREATE TABLE polygons (
  feature_id TEXT REFERENCES features(feature_id) ON DELETE CASCADE,
  geom_wkt TEXT NOT NULL
);

CREATE TABLE terms (
  feature_id TEXT REFERENCES features(feature_id) ON DELETE CASCADE,
  term TEXT NOT NULL,
  lang TEXT
);
CREATE INDEX ix_terms_term ON terms(term);

CREATE TABLE synonyms (
  term TEXT,
  canonical TEXT,
  lang TEXT
);
CREATE INDEX ix_synonyms_term ON synonyms(term);

-- Optional: FTS/Trigram (PostgreSQL-abhängig)
-- CREATE EXTENSION pg_trgm;
-- CREATE INDEX ix_features_name_trgm ON features USING gin (name gin_trgm_ops);
</code></pre>
<pre><code class="language-sql">-- Variante mit PostGIS
-- CREATE EXTENSION postgis;
CREATE TABLE features (
  feature_id TEXT PRIMARY KEY,
  source_id TEXT NOT NULL,
  source_pk TEXT NOT NULL,
  class TEXT,
  name TEXT,
  bbox_min_lon DOUBLE PRECISION,
  bbox_min_lat DOUBLE PRECISION,
  bbox_max_lon DOUBLE PRECISION,
  bbox_max_lat DOUBLE PRECISION,
  tags JSONB,
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE lines (
  feature_id TEXT REFERENCES features(feature_id) ON DELETE CASCADE,
  geom geometry(LineString, 4326) NOT NULL
);
CREATE INDEX ix_lines_geom_gist ON lines USING gist (geom);

CREATE TABLE polygons (
  feature_id TEXT REFERENCES features(feature_id) ON DELETE CASCADE,
  geom geometry(Polygon, 4326) NOT NULL
);
CREATE INDEX ix_polygons_geom_gist ON polygons USING gist (geom);

CREATE TABLE points (
  feature_id TEXT REFERENCES features(feature_id) ON DELETE CASCADE,
  geom geometry(Point, 4326) NOT NULL
);
CREATE INDEX ix_points_geom_gist ON points USING gist (geom);
</code></pre>
<h2 id="storage-geo_relational_schema-beispiel-abfragen">Beispiel-Abfragen<a class="headerlink" href="#storage-geo_relational_schema-beispiel-abfragen" title="Permanent link">&para;</a></h2>
<h3 id="storage-geo_relational_schema-1-lsg-in-der-nahe-eines-punkts-lon45-lat16">1) "LSG" in der Nähe eines Punkts (lon=45, lat=16)<a class="headerlink" href="#storage-geo_relational_schema-1-lsg-in-der-nahe-eines-punkts-lon45-lat16" title="Permanent link">&para;</a></h3>
<ul>
<li>Neutral (BBox-First, grob):</li>
</ul>
<pre><code class="language-sql">SELECT f.*
FROM features f
WHERE f.class = 'LSG'
  AND 45 BETWEEN f.bbox_min_lon AND f.bbox_max_lon
  AND 16 BETWEEN f.bbox_min_lat AND f.bbox_max_lat;
</code></pre>
<ul>
<li>PostGIS (präzise):</li>
</ul>
<pre><code class="language-sql">SELECT f.*
FROM features f
JOIN polygons p ON p.feature_id = f.feature_id
WHERE f.class = 'LSG'
  AND ST_Contains(p.geom, ST_SetSRID(ST_MakePoint(45, 16), 4326));
</code></pre>
<h3 id="storage-geo_relational_schema-2-fliegewasser-nahe-punkt-linestring-distanz">2) "Fließgewässer" nahe Punkt (LineString Distanz)<a class="headerlink" href="#storage-geo_relational_schema-2-fliegewasser-nahe-punkt-linestring-distanz" title="Permanent link">&para;</a></h3>
<pre><code class="language-sql">SELECT f.*
FROM features f
JOIN lines l ON l.feature_id = f.feature_id
WHERE f.class = 'Fließgewässer'
  AND ST_DWithin(l.geom, ST_SetSRID(ST_MakePoint(45,16), 4326), 1000); -- 1000m
</code></pre>
<h3 id="storage-geo_relational_schema-3-begriffssuche-mit-synonymen">3) Begriffssuche mit Synonymen<a class="headerlink" href="#storage-geo_relational_schema-3-begriffssuche-mit-synonymen" title="Permanent link">&para;</a></h3>
<pre><code class="language-sql">-- Synonymauflösung (einfach)
SELECT f.*
FROM features f
JOIN terms t ON t.feature_id = f.feature_id
LEFT JOIN synonyms s ON s.term = t.term
WHERE (t.term = 'LSG' OR s.canonical = 'LSG');
</code></pre>
<h2 id="storage-geo_relational_schema-etl-mapping-aus-ingestion">ETL-Mapping (aus Ingestion)<a class="headerlink" href="#storage-geo_relational_schema-etl-mapping-aus-ingestion" title="Permanent link">&para;</a></h2>
<ul>
<li><code>class</code>, <code>name</code>, <code>tags</code> aus <code>mappings</code> übernehmen</li>
<li><code>bbox_*</code> aus normalisierter Geometrie berechnen</li>
<li>Punkt-/Linie-/Polygon nach Typ in jeweilige Tabelle schreiben (1:n möglich)</li>
<li>Begriffe (terms) befüllen: <code>name</code>, <code>class</code>, extrahierte Schlagworte</li>
<li>Synonyme als Lookup (z. B. aus <code>geo_classes_v1</code>)</li>
</ul>
<h2 id="storage-geo_relational_schema-indexierung-performance">Indexierung &amp; Performance<a class="headerlink" href="#storage-geo_relational_schema-indexierung-performance" title="Permanent link">&para;</a></h2>
<ul>
<li>BBox-Index beschleunigt Grobfilterung vor genauer Geometrieprüfung</li>
<li>B-Tree auf <code>class</code>, <code>name</code>; optional FTS/Trigram für unscharfe Suchbegriffe</li>
<li>GiST/SpGist für Geometriespalten (PostGIS)</li>
</ul>
<h2 id="storage-geo_relational_schema-governance-qualitat">Governance &amp; Qualität<a class="headerlink" href="#storage-geo_relational_schema-governance-qualitat" title="Permanent link">&para;</a></h2>
<ul>
<li><code>source_id</code> + <code>source_pk</code> für Idempotenz/Lineage</li>
<li><code>feature_id</code> als stabile interne ID (UUID/ULID)</li>
<li>Validierung: Geometrie-Validität, CRS=EPSG:4326, BBox vorhanden</li>
</ul>
<h2 id="storage-geo_relational_schema-offene-punkte">Offene Punkte<a class="headerlink" href="#storage-geo_relational_schema-offene-punkte" title="Permanent link">&para;</a></h2>
<ul>
<li>Optional: MultiGeometrien (MultiPoint/MultiLineString/MultiPolygon)</li>
<li>Optional: Generalisierung (Levels of Detail) für schnelle Kartenansichten</li>
<li>Optional: Historisierung/Versionierung (Valid-From/To)</li>
</ul></section><section class="print-page" id="storage-rocksdb_layout" heading-number="4.2"><h1 id="storage-rocksdb_layout-rocksdb-storage-layout-betrieb">RocksDB Storage – Layout &amp; Betrieb<a class="headerlink" href="#storage-rocksdb_layout-rocksdb-storage-layout-betrieb" title="Permanent link">&para;</a></h1>
<p>Dieser Leitfaden beschreibt das physische Storage-Verhalten der ThemisDB-Engine auf Basis von RocksDB: Schlüsselpräfixe, WAL, Snapshots und Compaction.</p>
<h2 id="storage-rocksdb_layout-schlusselraume-prafixe">Schlüsselräume &amp; Präfixe<a class="headerlink" href="#storage-rocksdb_layout-schlusselraume-prafixe" title="Permanent link">&para;</a></h2>
<p>Themis nutzt ein Präfix-Schema zur logischen Trennung von Datenbereichen:</p>
<ul>
<li>Entities (Primärdaten): <code>entity:&lt;table&gt;:&lt;pk&gt;</code> → Blob (BaseEntity-Serialisierung)</li>
<li>Secondary Index: <code>idx:&lt;table&gt;:&lt;column&gt;:&lt;value&gt;:&lt;pk&gt;</code></li>
<li>Range Index: <code>ridx:&lt;table&gt;:&lt;column&gt;:&lt;value&gt;:&lt;pk&gt;</code></li>
<li>Sparse/TTL/Fulltext: <code>sidx:</code>/<code>ttlidx:</code>/<code>ftidx:</code> entsprechend der Funktion</li>
<li>Graph Adjazenz: <code>graph:out:&lt;from_pk&gt;:&lt;edge_id&gt;</code> → <code>&lt;to_pk&gt;</code>, <code>graph:in:&lt;to_pk&gt;:&lt;edge_id&gt;</code> → <code>&lt;from_pk&gt;</code></li>
<li>Vector Index (Metadaten/Mapping): <code>vector:&lt;table&gt;:&lt;pk&gt;</code> → Vektorinfo (Embedding out-of-store in Index-Struktur)</li>
<li>Changefeed (Audit): <code>changefeed:&lt;sequence&gt;</code> → Event JSON</li>
<li>Time-Series (TSStore): <code>ts:&lt;metric&gt;:&lt;timestamp&gt;:&lt;tags&gt;</code> → Wert(e)</li>
</ul>
<p>Siehe auch: <code>docs/indexes.md</code>, <code>docs/temporal_time_range_queries.md</code>, <code>docs/change_data_capture.md</code>, <code>docs/time_series.md</code>.</p>
<h2 id="storage-rocksdb_layout-column-families-cf">Column Families (CF)<a class="headerlink" href="#storage-rocksdb_layout-column-families-cf" title="Permanent link">&para;</a></h2>
<ul>
<li>Standardbetrieb: Default Column Family (CF)</li>
<li>Optional (für große Workloads): Trennung in CFs (z. B. <code>cf_entities</code>, <code>cf_indexes</code>, <code>cf_graph</code>, <code>cf_changefeed</code>, <code>cf_ts</code>) kann LSM-Compactions separieren.</li>
<li>Hinweis: Aktuell verwendet Themis standardmäßig die Default CF; CF-Trennung ist als Betriebsoptimierung möglich und sollte konsistent in Engine-Config &amp; Backups berücksichtigt werden.</li>
</ul>
<h2 id="storage-rocksdb_layout-write-ahead-log-wal">Write-Ahead Log (WAL)<a class="headerlink" href="#storage-rocksdb_layout-write-ahead-log-wal" title="Permanent link">&para;</a></h2>
<ul>
<li>WAL stellt Durability sicher und dient für Recovery nach Abstürzen.</li>
<li>Empfohlen:</li>
<li><code>wal_bytes_per_sync</code> und <code>bytes_per_sync</code> passend zur Hardware</li>
<li><code>max_total_wal_size</code> dimensionieren (Spitzen abfangen, aber Platte nicht vollschreiben)</li>
<li>Sync-Strategie nach Latenzanforderungen (<code>disableWAL=false</code>, fsync je nach Durability-Ziel)</li>
</ul>
<h2 id="storage-rocksdb_layout-snapshots-mvcc">Snapshots &amp; MVCC<a class="headerlink" href="#storage-rocksdb_layout-snapshots-mvcc" title="Permanent link">&para;</a></h2>
<ul>
<li>Snapshots fixieren ein Sichtfenster für Reads (Snapshot-Isolation)</li>
<li>Transaktionen verwenden Snapshots, um Repeatable Reads zu ermöglichen</li>
<li>Long-running Snapshots erhöhen Read Amplification: Überwachung und Begrenzung empfehlenswert</li>
</ul>
<h2 id="storage-rocksdb_layout-compaction-performance">Compaction &amp; Performance<a class="headerlink" href="#storage-rocksdb_layout-compaction-performance" title="Permanent link">&para;</a></h2>
<ul>
<li>Trennung heißer/cold Daten (optional via CF) kann Write Amplification reduzieren</li>
<li>Kompressions-Strategie (z. B. LZ4 für L0/L1, ZSTD für tiefere Ebenen) je nach Profil</li>
<li>Bloom Filter für Punktabfragen (Secondary Index) aktivieren</li>
<li>Prefix-Extractor gemäß Key-Schema (z. B. bis zum <code>:value:</code>-Teil bei <code>idx:</code>) beschleunigt Prefix-Scans</li>
</ul>
<h2 id="storage-rocksdb_layout-backups-restore">Backups &amp; Restore<a class="headerlink" href="#storage-rocksdb_layout-backups-restore" title="Permanent link">&para;</a></h2>
<ul>
<li>RocksDB Backups (SST + MANIFEST + OPTIONS + ggf. WAL) regelmäßig erstellen</li>
<li>Konsistenz über alle CFs sicherstellen (falls eingesetzt)</li>
<li>Vor Restore: Version/Options-Kompatibilität prüfen</li>
</ul>
<h2 id="storage-rocksdb_layout-monitoring">Monitoring<a class="headerlink" href="#storage-rocksdb_layout-monitoring" title="Permanent link">&para;</a></h2>
<ul>
<li>Wichtige Kennzahlen: L0 File Count, Compaction Pending, Stall Time, WAL Größe, Read-/Write-Amp</li>
<li>Prometheus-Export aus Themis (<code>/metrics</code>) ergänzen um Storage-Kennzahlen (Roadmap)</li>
</ul>
<h2 id="storage-rocksdb_layout-troubleshooting-kurz">Troubleshooting (Kurz)<a class="headerlink" href="#storage-rocksdb_layout-troubleshooting-kurz" title="Permanent link">&para;</a></h2>
<ul>
<li>Hohe Latenzen bei Scans: Prefix-Extractor/Bloom prüfen; CF-Trennung für Indizes erwägen</li>
<li>Speicherverbrauch stark: Kompression/Block-Cache-Tuning; Retention (Changefeed/TS) aktivieren</li>
<li>Lange Snapshots: Transaktionslaufzeiten begrenzen; <code>cleanupOldTransactions</code> nutzen</li>
</ul>
<p>Weiterlesen:
- <code>docs/mvcc_design.md</code>
- <code>docs/transactions.md</code>
- RocksDB Tuning Guides (Block Cache, MemTables, Compaction)</p></section><section class="print-page" id="mvcc_design" heading-number="4.3"><h1 id="mvcc_design-mvcc-design-fur-themis">MVCC Design für THEMIS<a class="headerlink" href="#mvcc_design-mvcc-design-fur-themis" title="Permanent link">&para;</a></h1>
<h2 id="mvcc_design-implementierungsstatus-produktionsreif">✅ IMPLEMENTIERUNGSSTATUS: PRODUKTIONSREIF<a class="headerlink" href="#mvcc_design-implementierungsstatus-produktionsreif" title="Permanent link">&para;</a></h2>
<p><strong>Stand: 2. November 2025</strong></p>
<p>MVCC ist implementiert (Snapshot-Isolation, Konflikterkennung). Die aktuell produktive Variante entspricht der in „Option 1“ beschriebenen Engine-gestützten Lösung. Details zum physischen Layout und zu WAL/Snapshots siehe „RocksDB Storage“.</p>
<h3 id="mvcc_design-test-resultate">Test-Resultate<a class="headerlink" href="#mvcc_design-test-resultate" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Transaction Tests</strong>: 27/27 PASS (100%)</li>
<li><strong>MVCC Tests</strong>: 12/12 PASS (100%)</li>
<li><strong>Performance</strong>: Minimal Overhead gegenüber WriteBatch</li>
<li>SingleEntity: MVCC ~3.4k/s vs WriteBatch ~3.1k/s</li>
<li>Batch 100: WriteBatch ~27.8k/s</li>
<li>Rollback: MVCC ~35.3k/s</li>
<li>Snapshot Reads: ~44k/s</li>
</ul>
<hr />
<h2 id="mvcc_design-ubersicht">Übersicht<a class="headerlink" href="#mvcc_design-ubersicht" title="Permanent link">&para;</a></h2>
<p>MVCC (Multi-Version Concurrency Control) ermöglicht parallele Transaktionen ohne Locks durch Versionierung aller Daten.</p>
<h2 id="mvcc_design-implementierte-losung-engine-gestutzte-mvcc">Implementierte Lösung: Engine-gestützte MVCC<a class="headerlink" href="#mvcc_design-implementierte-losung-engine-gestutzte-mvcc" title="Permanent link">&para;</a></h2>
<p>Kerneigenschaften:</p>
<ul>
<li><strong>Snapshot Isolation</strong>: Konsistentes Sichtfenster pro Transaktion</li>
<li><strong>Conflict Detection</strong>: Write-Write-Konflikte werden erkannt</li>
<li><strong>Lock/Timeouts</strong>: konfigurierbar</li>
<li><strong>ACID-Garantien</strong>: Atomarität über alle beteiligten Indizes</li>
</ul>
<h3 id="mvcc_design-architektur">Architektur<a class="headerlink" href="#mvcc_design-architektur" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────┐
│         TransactionManager                   │
│  (High-Level Transaction API)                │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│      RocksDBWrapper::TransactionWrapper     │
│  • get(key) - snapshot reads                │
│  • put(key, value) - conflict detection     │
│  • del(key) - transactional deletes         │
│  • commit() - atomic persistence            │
│  • rollback() - automatic cleanup           │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│          RocksDB TransactionDB              │
│  • Pessimistic Locking                      │
│  • Snapshot Isolation                       │
│  • Write-Write Conflict Detection           │
└─────────────────────────────────────────────┘
</code></pre>
<h3 id="mvcc_design-indexe-mit-mvcc">Indexe mit MVCC<a class="headerlink" href="#mvcc_design-indexe-mit-mvcc" title="Permanent link">&para;</a></h3>
<p>Alle Index-Manager unterstützen MVCC-Transaktionen:</p>
<ul>
<li><strong>SecondaryIndexManager</strong>: Equality, Range, Sparse, Geo, TTL, Fulltext</li>
<li><strong>GraphIndexManager</strong>: Kanten und Adjazenz-Indizes</li>
<li><strong>VectorIndexManager</strong>: HNSW + Cache-Updates</li>
</ul>
<p>Alle Index-Operationen sind <strong>atomar</strong> mit der Haupttransaktion - Rollback entfernt alle Änderungen vollständig.</p>
<hr />
<h2 id="mvcc_design-aktuelle-situation-vs-mvcc">Aktuelle Situation vs. MVCC<a class="headerlink" href="#mvcc_design-aktuelle-situation-vs-mvcc" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-vor-mvcc-saga-pattern">Vor MVCC (SAGA Pattern)<a class="headerlink" href="#mvcc_design-vor-mvcc-saga-pattern" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ Eventual Consistency durch Compensating Actions</li>
<li>✅ Vector Cache Consistency</li>
<li>❌ Last-Write-Wins bei konkurrierenden Writes</li>
<li>❌ Keine Snapshot Isolation</li>
<li>❌ Write-Write Conflicts werden nicht erkannt</li>
</ul>
<h3 id="mvcc_design-mit-mvcc-implementiert">Mit MVCC (Implementiert)<a class="headerlink" href="#mvcc_design-mit-mvcc-implementiert" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ Vollständige Snapshot Isolation</li>
<li>✅ Write-Write Conflict Detection</li>
<li>✅ Concurrent Reads blockieren nie</li>
<li>✅ Atomare Rollbacks (inkl. Indizes)</li>
<li>✅ SAGA Pattern für Vector Cache (hybride Lösung)</li>
<li>⚠️  Höherer Speicherverbrauch durch RocksDB Locks</li>
<li>⚠️  Kein Point-in-Time Recovery (RocksDB Limitation)</li>
</ul>
<hr />
<h2 id="mvcc_design-design-optionen-archiv">Design-Optionen (Archiv)<a class="headerlink" href="#mvcc_design-design-optionen-archiv" title="Permanent link">&para;</a></h2>
<p>Die ursprünglich evaluierten Optionen sind unten dokumentiert. <strong>Option 1 (RocksDB TransactionDB)</strong> wurde implementiert.</p>
<h2 id="mvcc_design-kernkomponenten-skizze">Kernkomponenten (Skizze)<a class="headerlink" href="#mvcc_design-kernkomponenten-skizze" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-1-engine-konfiguration-beispiel">1. Engine-Konfiguration (Beispiel)<a class="headerlink" href="#mvcc_design-1-engine-konfiguration-beispiel" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// In RocksDBWrapper::open()
rocksdb::TransactionDBOptions txn_db_options;
txn_db_options.transaction_lock_timeout = 1000;      // 1s Lock Timeout
txn_db_options.default_lock_timeout = 1000;          // 1s für alle Locks

rocksdb::TransactionOptions txn_options;
txn_options.set_snapshot = true;                     // Automatisches Snapshot
txn_options.deadlock_detect = true;                  // Deadlock Prevention

rocksdb::TransactionDB* txn_db;
rocksdb::TransactionDB::Open(options, txn_db_options, db_path, &amp;txn_db);
</code></pre>
<h3 id="mvcc_design-2-transaktions-api-skizze">2. Transaktions-API (Skizze)<a class="headerlink" href="#mvcc_design-2-transaktions-api-skizze" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class TransactionWrapper {
public:
    // Reads (mit Snapshot Isolation)
    std::optional&lt;std::vector&lt;uint8_t&gt;&gt; get(const std::string&amp; key);

    // Writes (mit Conflict Detection)
    bool put(const std::string&amp; key, const std::vector&lt;uint8_t&gt;&amp; value);
    bool del(const std::string&amp; key);

    // Commit/Rollback
    bool commit();     // false = Conflict detected
    void rollback();   // Immer erfolgreich

    // Snapshot Management
    const rocksdb::Snapshot* getSnapshot() const;
    bool isActive() const;
};
</code></pre>
<h3 id="mvcc_design-3-conflict-detection-flow">3. Conflict Detection Flow<a class="headerlink" href="#mvcc_design-3-conflict-detection-flow" title="Permanent link">&para;</a></h3>
<pre><code>Thread A                    Thread B
────────────────────────────────────────────
txn_a = begin()
  snapshot_a = get_snapshot()
                              txn_b = begin()
                                snapshot_b = get_snapshot()

put(&quot;user:1&quot;, data_a)       put(&quot;user:1&quot;, data_b)
  ✅ Lock acquired            ⏳ Waiting for lock...

commit()                    
  ✅ Lock released
  ✅ Committed
                              ❌ Conflict detected!
                              ❌ Abort &amp; Rollback
</code></pre>
<h3 id="mvcc_design-4-index-integration">4. Index-Integration<a class="headerlink" href="#mvcc_design-4-index-integration" title="Permanent link">&para;</a></h3>
<p>Alle Index-Operationen verwenden dieselbe MVCC-Transaktion:</p>
<pre><code class="language-cpp">// In TransactionManager::Transaction::putEntity()
auto txn = mvcc_txn_;  // Shared MVCC transaction

// Primary data
txn-&gt;put(entityKey, entityData);

// Secondary indexes (atomisch mit primary data)
secIdx_.put(table, entity, *txn);  // MVCC variant

// Graph indexes (atomisch)
graphIdx_.addEdge(edge, *txn);     // MVCC variant

// Vector indexes (atomisch)
vecIdx_.addEntity(entity, *txn);   // MVCC variant

// Commit alles zusammen
txn-&gt;commit();  // Alles oder nichts
</code></pre>
<hr />
<h2 id="mvcc_design-originales-design-archiv-nicht-implementiert">Originales Design (Archiv - Nicht implementiert)<a class="headerlink" href="#mvcc_design-originales-design-archiv-nicht-implementiert" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-option-23-custom-version-management">Option 2/3: Custom Version Management<a class="headerlink" href="#mvcc_design-option-23-custom-version-management" title="Permanent link">&para;</a></h3>
<p>Die folgenden Designs wurden evaluiert aber nicht gewählt:</p>
<pre><code>pending_writes_[pk] = new_version;
return Status::OK();
</code></pre>
<p>}</p>
<pre><code>
### 4. Commit-Protokoll

```cpp
Status Transaction::commit() {
    // 1. Atomare Version-Nummer holen
    uint64_t commit_version = global_version_counter_.fetch_add(1);

    // 2. Write-Write Conflicts prüfen
    for (auto&amp; [pk, new_version] : pending_writes_) {
        auto latest = db_.getLatestVersion(pk);
        if (latest &amp;&amp; latest-&gt;version_start &gt; begin_version_) {
            rollback();
            return Status::Error(&quot;Serialization failure - retry transaction&quot;);
        }
    }

    // 3. Alte Versionen &quot;abschließen&quot;
    WriteBatch batch;
    for (auto&amp; [pk, new_version] : pending_writes_) {
        auto old_version = db_.getLatestVersion(pk);
        if (old_version) {
            // Alte Version: version_end = commit_version
            old_version-&gt;version_end = commit_version;
            batch.put(makeVersionKey(pk, old_version-&gt;version_start), 
                     serialize(*old_version));
        }

        // Neue Version: version_start = commit_version
        new_version.version_start = commit_version;
        batch.put(makeVersionKey(pk, commit_version), 
                 serialize(new_version));
    }

    // 4. Atomarer Commit
    return batch.commit();
}
</code></pre>
<h3 id="mvcc_design-5-garbage-collection">5. Garbage Collection<a class="headerlink" href="#mvcc_design-5-garbage-collection" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class MVCCGarbageCollector {
    // Älteste aktive Transaktion finden
    uint64_t getOldestActiveTransaction() {
        std::lock_guard lock(txn_mutex_);
        uint64_t min_version = UINT64_MAX;
        for (auto&amp; [txn_id, txn] : active_transactions_) {
            min_version = std::min(min_version, txn-&gt;begin_version);
        }
        return min_version;
    }

    // Alte Versionen löschen
    void collectGarbage() {
        uint64_t gc_horizon = getOldestActiveTransaction();

        // Alle Versionen mit version_end &lt; gc_horizon können gelöscht werden
        for (auto&amp; [pk, versions] : version_map_) {
            versions.erase(
                std::remove_if(versions.begin(), versions.end(),
                    [gc_horizon](const VersionedEntity&amp; v) {
                        return v.version_end &lt; gc_horizon;
                    }),
                versions.end()
            );
        }
    }
};
</code></pre>
<h2 id="mvcc_design-storage-hinweise">Storage-Hinweise<a class="headerlink" href="#mvcc_design-storage-hinweise" title="Permanent link">&para;</a></h2>
<p>Siehe ergänzend: <a href="#storage-rocksdb_layout">RocksDB Storage</a> für WAL, Snapshots und Compaction sowie Schlüsselpräfixe (entities, idx, ridx, graph, vector, changefeed, ts).</p>
<pre><code class="language-cpp">#include &lt;rocksdb/utilities/transaction_db.h&gt;

class MVCCWrapper {
    rocksdb::TransactionDB* txn_db_;

    // RocksDB TransactionDB bietet:
    // - Built-in MVCC
    // - Optimistic/Pessimistic Concurrency Control
    // - Snapshot Isolation
    // - Conflict Detection
};
</code></pre>
<p>Hinweis: Engine-spezifische Tuning-Parameter (z. B. Lock-Timeouts, Snapshot-Handling) sollten anhand der Ziel-Workloads validiert werden.</p>
<h3 id="mvcc_design-option-2-manuelle-mvcc-implementierung">Option 2: Manuelle MVCC-Implementierung<a class="headerlink" href="#mvcc_design-option-2-manuelle-mvcc-implementierung" title="Permanent link">&para;</a></h3>
<p>Eigene Versionsverwaltung über RocksDB Keys:</p>
<pre><code class="language-cpp">// Key-Format: entity:{table}:{pk}:v{version}
// Beispiel:   entity:users:user_123:v0000000000000042

class ManualMVCC {
    // Version-Range Scan
    std::vector&lt;VersionedEntity&gt; getAllVersions(const std::string&amp; pk) {
        std::string prefix = &quot;entity:&quot; + table + &quot;:&quot; + pk + &quot;:v&quot;;
        std::vector&lt;VersionedEntity&gt; versions;
        db_.scanPrefix(prefix, [&amp;](auto key, auto value) {
            versions.push_back(deserialize(value));
            return true;
        });
        return versions;
    }
};
</code></pre>
<p><strong>Vorteile:</strong>
- ✅ Volle Kontrolle
- ✅ Keine Breaking Changes
- ✅ Optimierbar für spezifische Workloads</p>
<p><strong>Nachteile:</strong>
- ❌ Komplex zu implementieren
- ❌ Mehr Fehlerquellen
- ❌ GC muss selbst implementiert werden</p>
<h2 id="mvcc_design-index-anpassungen">Index-Anpassungen<a class="headerlink" href="#mvcc_design-index-anpassungen" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-secondary-index-mit-mvcc">Secondary Index mit MVCC<a class="headerlink" href="#mvcc_design-secondary-index-mit-mvcc" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Aktuell: idx:users:age:25 -&gt; [&quot;user_123&quot;, &quot;user_456&quot;]
// MVCC:    idx:users:age:25:v42 -&gt; [&quot;user_123:v42&quot;, &quot;user_456:v39&quot;]

class MVCCSecondaryIndex {
    Status addToIndex(const BaseEntity&amp; entity, uint64_t version) {
        // Index-Entry muss auch versioniert sein
        std::string idx_key = makeIndexKey(field, value, version);
        std::string pk_with_version = entity.getPrimaryKey() + &quot;:v&quot; + 
                                      std::to_string(version);
        // ...
    }
};
</code></pre>
<h3 id="mvcc_design-vector-index-mit-mvcc">Vector Index mit MVCC<a class="headerlink" href="#mvcc_design-vector-index-mit-mvcc" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class MVCCVectorIndex {
    struct VersionedVector {
        std::string pk;
        uint64_t version;
        std::vector&lt;float&gt; embedding;
    };

    // HNSW Index: Nur aktuelle Versionen
    std::unordered_map&lt;uint64_t, std::vector&lt;VersionedVector&gt;&gt; version_snapshots_;

    std::vector&lt;SearchResult&gt; search(
        const std::vector&lt;float&gt;&amp; query,
        uint64_t snapshot_version,
        size_t k
    ) {
        // Filter: Nur Vektoren die in snapshot_version sichtbar sind
        auto visible_vectors = getVisibleVectors(snapshot_version);
        return hnsw_index_.search(query, k, visible_vectors);
    }
};
</code></pre>
<h3 id="mvcc_design-graph-index-mit-mvcc">Graph Index mit MVCC<a class="headerlink" href="#mvcc_design-graph-index-mit-mvcc" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class MVCCGraphIndex {
    // Kanten versionieren
    struct VersionedEdge {
        std::string edge_id;
        std::string from_node;
        std::string to_node;
        uint64_t version_start;
        uint64_t version_end;
    };

    // Graph-Traversierung mit Snapshot
    std::vector&lt;std::string&gt; traverse(
        const std::string&amp; start_node,
        uint64_t snapshot_version
    ) {
        // Nur Kanten verwenden, die in snapshot_version sichtbar sind
        auto visible_edges = getVisibleEdges(snapshot_version);
        return bfs(start_node, visible_edges);
    }
};
</code></pre>
<h2 id="mvcc_design-migration-plan">Migration Plan<a class="headerlink" href="#mvcc_design-migration-plan" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-phase-1-foundation-2-3-wochen">Phase 1: Foundation (2-3 Wochen)<a class="headerlink" href="#mvcc_design-phase-1-foundation-2-3-wochen" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>RocksDB TransactionDB Migration</strong></li>
<li><code>RocksDBWrapper</code> zu <code>TransactionDB</code> migrieren</li>
<li>Snapshot-Management implementieren</li>
<li>
<p>Bestehende Tests anpassen</p>
</li>
<li>
<p><strong>TransactionManager Refactoring</strong></p>
</li>
<li><code>begin()</code> gibt <code>rocksdb::Transaction*</code> zurück</li>
<li>Snapshot beim <code>begin()</code> erstellen</li>
<li>Commit/Rollback über TransactionDB</li>
</ol>
<h3 id="mvcc_design-phase-2-index-integration-2-3-wochen">Phase 2: Index Integration (2-3 Wochen)<a class="headerlink" href="#mvcc_design-phase-2-index-integration-2-3-wochen" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Secondary Index MVCC</strong></li>
<li>Index-Einträge versionieren</li>
<li>Range-Queries mit Snapshot</li>
<li>
<p>Visibility-Filter</p>
</li>
<li>
<p><strong>Vector Index MVCC</strong></p>
</li>
<li>Version-aware HNSW</li>
<li>Snapshot-basierte Suche</li>
<li>
<p>In-Memory Cache pro Version</p>
</li>
<li>
<p><strong>Graph Index MVCC</strong></p>
</li>
<li>Versionierte Kanten</li>
<li>Snapshot-Traversierung</li>
<li>Temporal Graph Queries</li>
</ol>
<h3 id="mvcc_design-phase-3-advanced-features-1-2-wochen">Phase 3: Advanced Features (1-2 Wochen)<a class="headerlink" href="#mvcc_design-phase-3-advanced-features-1-2-wochen" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Garbage Collection</strong></li>
<li>Background Thread</li>
<li>Version-Pruning</li>
<li>
<p>Configurable Retention</p>
</li>
<li>
<p><strong>Performance Optimization</strong></p>
</li>
<li>Version-Caching</li>
<li>Optimistic Locking</li>
<li>Batch Conflict Detection</li>
</ol>
<h3 id="mvcc_design-phase-4-testing-documentation-1-woche">Phase 4: Testing &amp; Documentation (1 Woche)<a class="headerlink" href="#mvcc_design-phase-4-testing-documentation-1-woche" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Test Suite</strong></li>
<li>Concurrent Transaction Tests</li>
<li>Conflict Detection Tests</li>
<li>
<p>Snapshot Isolation Tests</p>
</li>
<li>
<p><strong>Documentation</strong></p>
</li>
<li>MVCC Architecture Guide</li>
<li>Migration Guide</li>
<li>Performance Tuning Guide</li>
</ol>
<h2 id="mvcc_design-benotigte-anderungen">Benötigte Änderungen<a class="headerlink" href="#mvcc_design-benotigte-anderungen" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-dateien-zu-erstellen">Dateien zu erstellen:<a class="headerlink" href="#mvcc_design-dateien-zu-erstellen" title="Permanent link">&para;</a></h3>
<ul>
<li><code>include/transaction/mvcc_manager.h</code> - MVCC Coordination</li>
<li><code>src/transaction/mvcc_manager.cpp</code></li>
<li><code>include/storage/versioned_entity.h</code> - Version-aware Entity</li>
<li><code>src/storage/versioned_entity.cpp</code></li>
<li><code>include/transaction/garbage_collector.h</code> - GC</li>
<li><code>src/transaction/garbage_collector.cpp</code></li>
</ul>
<h3 id="mvcc_design-dateien-zu-andern">Dateien zu ändern:<a class="headerlink" href="#mvcc_design-dateien-zu-andern" title="Permanent link">&para;</a></h3>
<ul>
<li><code>include/storage/rocksdb_wrapper.h</code> - TransactionDB statt DB</li>
<li><code>src/storage/rocksdb_wrapper.cpp</code></li>
<li><code>include/transaction/transaction_manager.h</code> - Snapshot Support</li>
<li><code>src/transaction/transaction_manager.cpp</code></li>
<li><code>include/index/secondary_index.h</code> - Versionierte Indizes</li>
<li><code>src/index/secondary_index.cpp</code></li>
<li><code>include/index/vector_index.h</code> - Snapshot-aware Search</li>
<li><code>src/index/vector_index.cpp</code></li>
<li><code>include/index/graph_index.h</code> - Temporal Graphs</li>
<li><code>src/index/graph_index.cpp</code></li>
</ul>
<h3 id="mvcc_design-dependencies">Dependencies:<a class="headerlink" href="#mvcc_design-dependencies" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">// vcpkg.json
{
  &quot;dependencies&quot;: [
    &quot;rocksdb[core,lz4,zlib,zstd,transactions]&quot;  // +transactions feature
  ]
}
</code></pre>
<h2 id="mvcc_design-performance-uberlegungen">Performance-Überlegungen<a class="headerlink" href="#mvcc_design-performance-uberlegungen" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-speicher-overhead">Speicher-Overhead<a class="headerlink" href="#mvcc_design-speicher-overhead" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Pro Version</strong>: ~100 Bytes Metadata + Entity-Größe</li>
<li><strong>Beispiel</strong>: 1M Entities, 10 Versionen = ~1GB zusätzlicher Speicher</li>
<li><strong>Mitigation</strong>: Aggressive GC, Configurable Retention</li>
</ul>
<h3 id="mvcc_design-write-amplification">Write Amplification<a class="headerlink" href="#mvcc_design-write-amplification" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Aktuell</strong>: 1 Write = 1 RocksDB Put</li>
<li><strong>MVCC</strong>: 1 Write = 2 Puts (alte Version update + neue Version insert)</li>
<li><strong>Mitigation</strong>: RocksDB Compaction optimieren</li>
</ul>
<h3 id="mvcc_design-read-performance">Read Performance<a class="headerlink" href="#mvcc_design-read-performance" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Snapshot Reads</strong>: +5-10% Overhead (Version-Check)</li>
<li><strong>Range Queries</strong>: +10-20% Overhead (Visibility-Filter)</li>
<li><strong>Mitigation</strong>: Version-Cache, Bloom Filters</li>
</ul>
<h2 id="mvcc_design-alternativen">Alternativen<a class="headerlink" href="#mvcc_design-alternativen" title="Permanent link">&para;</a></h2>
<h3 id="mvcc_design-1-hybrid-saga-optimistic-locking">1. Hybrid: SAGA + Optimistic Locking<a class="headerlink" href="#mvcc_design-1-hybrid-saga-optimistic-locking" title="Permanent link">&para;</a></h3>
<ul>
<li>SAGA Pattern behalten</li>
<li>Nur Write-Write Conflict Detection hinzufügen</li>
<li>Kein vollständiges MVCC</li>
<li><strong>Aufwand</strong>: 1 Woche, <strong>Benefit</strong>: 70% von MVCC</li>
</ul>
<h3 id="mvcc_design-2-postgresql-style-mvcc">2. PostgreSQL-Style MVCC<a class="headerlink" href="#mvcc_design-2-postgresql-style-mvcc" title="Permanent link">&para;</a></h3>
<ul>
<li>Tuple-Versionierung in-place</li>
<li>Vacuum statt GC</li>
<li><strong>Aufwand</strong>: 4-6 Wochen, <strong>Benefit</strong>: Bessere Performance</li>
</ul>
<h3 id="mvcc_design-3-rocksdb-optimistictransactiondb">3. RocksDB OptimisticTransactionDB<a class="headerlink" href="#mvcc_design-3-rocksdb-optimistictransactiondb" title="Permanent link">&para;</a></h3>
<ul>
<li>Leichtgewichtiger als TransactionDB</li>
<li>Nur Conflict Detection, kein Locking</li>
<li><strong>Aufwand</strong>: 2-3 Wochen, <strong>Benefit</strong>: 80% von MVCC</li>
</ul>
<h2 id="mvcc_design-empfehlung">Empfehlung<a class="headerlink" href="#mvcc_design-empfehlung" title="Permanent link">&para;</a></h2>
<p><strong>Start: Hybrid-Ansatz (SAGA + Optimistic Locking)</strong></p>
<ol>
<li><strong>Kurzfristig</strong> (1-2 Wochen):</li>
<li>Write-Write Conflict Detection zu SAGA hinzufügen</li>
<li>Version-Counter in TransactionManager</li>
<li>Conflict-Check vor Commit</li>
<li>
<p><strong>Ergebnis</strong>: 70% MVCC-Benefit, minimaler Aufwand</p>
</li>
<li>
<p><strong>Mittelfristig</strong> (1-2 Monate):</p>
</li>
<li>Migration zu RocksDB OptimisticTransactionDB</li>
<li>Snapshot Isolation implementieren</li>
<li>Index-Versionierung</li>
<li>
<p><strong>Ergebnis</strong>: Vollständiges MVCC</p>
</li>
<li>
<p><strong>Langfristig</strong> (3-6 Monate):</p>
</li>
<li>Garbage Collection optimieren</li>
<li>Temporal Queries (Time-Travel)</li>
<li>Performance Tuning</li>
<li><strong>Ergebnis</strong>: Production-ready MVCC</li>
</ol>
<h2 id="mvcc_design-nachste-schritte">Nächste Schritte<a class="headerlink" href="#mvcc_design-nachste-schritte" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Proof of Concept</strong>: RocksDB TransactionDB Test (1 Tag)</li>
<li><strong>Benchmark</strong>: SAGA vs. Optimistic vs. Full MVCC (2 Tage)</li>
<li><strong>Entscheidung</strong>: Hybrid oder Full MVCC</li>
<li><strong>Implementation</strong>: Nach gewähltem Ansatz</li>
</ol>
<h2 id="mvcc_design-ressourcen">Ressourcen<a class="headerlink" href="#mvcc_design-ressourcen" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://github.com/facebook/rocksdb/wiki/Transactions">RocksDB Transactions Wiki</a></li>
<li><a href="https://www.postgresql.org/docs/current/mvcc.html">PostgreSQL MVCC Internals</a></li>
<li><a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer.html">Cockroach MVCC Design</a></li>
<li><a href="https://research.google/pubs/pub36726/">Percolator Paper</a> - Google's MVCC System</li>
</ul></section><section class="print-page" id="transactions" heading-number="4.4"><h1 id="transactions-transaction-management-in-themis">Transaction Management in THEMIS<a class="headerlink" href="#transactions-transaction-management-in-themis" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 1.1<br />
<strong>Datum:</strong> 2. November 2025</p>
<h2 id="transactions-uberblick">Überblick<a class="headerlink" href="#transactions-uberblick" title="Permanent link">&para;</a></h2>
<p>THEMIS bietet ACID-konforme Transaktionen über alle Index-Typen hinweg (Relational, Graph, Vector). Transaktionen basieren auf MVCC mit Snapshot-Isolation und Konflikterkennung; Updates über Sekundär-, Graph- und Vektorindizes erfolgen atomar innerhalb der Transaktion.</p>
<h3 id="transactions-kernfeatures">Kernfeatures<a class="headerlink" href="#transactions-kernfeatures" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Atomicity</strong>: Alle Operationen innerhalb einer Transaktion werden atomar ausgeführt (all-or-nothing)</li>
<li><strong>MVCC &amp; Isolation</strong>: ReadCommitted (default) und Snapshot-Isolation mit konsistentem Sichtfenster</li>
<li><strong>Konflikterkennung</strong>: Write-Write-Konflikte werden beim Commit/Put erkannt und führen zu Fehlern/Abbrüchen</li>
<li><strong>Session-Management</strong>: Transaktionen sind über eindeutige Transaction-IDs identifizierbar</li>
<li><strong>Statistics Tracking</strong>: Umfassende Metriken (begun, committed, aborted, durations, success rate)</li>
<li><strong>Auto-Rollback</strong>: RAII-Pattern für automatisches Rollback bei Exception/Destruktion</li>
<li><strong>Multi-Index Support</strong>: Konsistente Updates über Secondary, Graph und Vector-Indizes</li>
</ul>
<hr />
<h2 id="transactions-architektur">Architektur<a class="headerlink" href="#transactions-architektur" title="Permanent link">&para;</a></h2>
<h3 id="transactions-transactionmanager">TransactionManager<a class="headerlink" href="#transactions-transactionmanager" title="Permanent link">&para;</a></h3>
<p>Zentrale Komponente für Session-basiertes Transaction-Management:</p>
<pre><code class="language-cpp">class TransactionManager {
public:
    // Session-based API (empfohlen für HTTP/Multi-Client)
    TransactionId beginTransaction(IsolationLevel isolation = IsolationLevel::ReadCommitted);
    Status commitTransaction(TransactionId id);
    void rollbackTransaction(TransactionId id);
    std::shared_ptr&lt;Transaction&gt; getTransaction(TransactionId id);

    // Direct API (für Single-Threaded/Embedded)
    Transaction begin(IsolationLevel isolation = IsolationLevel::ReadCommitted);

    // Statistics
    Stats getStats() const;
    void cleanupOldTransactions(std::chrono::seconds max_age);
};
</code></pre>
<h3 id="transactions-transaction-class">Transaction Class<a class="headerlink" href="#transactions-transaction-class" title="Permanent link">&para;</a></h3>
<p>Stellt Operationen innerhalb einer Transaktion bereit:</p>
<pre><code class="language-cpp">class Transaction {
public:
    // Metadata
    TransactionId getId() const;
    IsolationLevel getIsolationLevel() const;
    uint64_t getDurationMs() const;

    // Relational Operations
    Status putEntity(std::string_view table, const BaseEntity&amp; entity);
    Status eraseEntity(std::string_view table, std::string_view pk);

    // Graph Operations
    Status addEdge(const BaseEntity&amp; edgeEntity);
    Status deleteEdge(std::string_view edgeId);

    // Vector Operations
    Status addVector(const BaseEntity&amp; entity, std::string_view vectorField = &quot;embedding&quot;);
    Status updateVector(const BaseEntity&amp; entity, std::string_view vectorField = &quot;embedding&quot;);
    Status removeVector(std::string_view pk);

    // Finalization
    Status commit();
    void rollback();
};
</code></pre>
<h3 id="transactions-isolation-levels">Isolation Levels<a class="headerlink" href="#transactions-isolation-levels" title="Permanent link">&para;</a></h3>
<h4 id="transactions-readcommitted-default">ReadCommitted (Default)<a class="headerlink" href="#transactions-readcommitted-default" title="Permanent link">&para;</a></h4>
<ul>
<li>Lesezugriffe sehen nur committed data</li>
<li>Keine Dirty Reads</li>
<li>Non-Repeatable Reads möglich</li>
<li>Geeignet für: Standard OLTP-Workloads</li>
</ul>
<h4 id="transactions-snapshot">Snapshot<a class="headerlink" href="#transactions-snapshot" title="Permanent link">&para;</a></h4>
<ul>
<li>Point-in-time Konsistenz (Sichtfenster fixiert beim Begin)</li>
<li>Repeatable Reads innerhalb der Transaktion</li>
<li>Höhere Isolation, potenziell höherer Overhead</li>
<li>Geeignet für: Analytische Queries, konsistente Reports</li>
</ul>
<hr />
<h2 id="transactions-http-rest-api">HTTP REST API<a class="headerlink" href="#transactions-http-rest-api" title="Permanent link">&para;</a></h2>
<h3 id="transactions-post-transactionbegin">POST /transaction/begin<a class="headerlink" href="#transactions-post-transactionbegin" title="Permanent link">&para;</a></h3>
<p>Startet eine neue Transaktion.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-json">{
  &quot;isolation&quot;: &quot;read_committed&quot;  // optional, default: &quot;read_committed&quot;
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;transaction_id&quot;: 42,
  &quot;isolation&quot;: &quot;read_committed&quot;,
  &quot;status&quot;: &quot;begun&quot;
}
</code></pre>
<p><strong>cURL Beispiel:</strong></p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/transaction/begin \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;isolation&quot;: &quot;snapshot&quot;}'
</code></pre>
<hr />
<h3 id="transactions-post-transactioncommit">POST /transaction/commit<a class="headerlink" href="#transactions-post-transactioncommit" title="Permanent link">&para;</a></h3>
<p>Committed eine Transaktion.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-json">{
  &quot;transaction_id&quot;: 42
}
</code></pre>
<p><strong>Response (Success):</strong></p>
<pre><code class="language-json">{
  &quot;transaction_id&quot;: 42,
  &quot;status&quot;: &quot;committed&quot;,
  &quot;message&quot;: &quot;Transaction committed successfully&quot;
}
</code></pre>
<p><strong>Response (Error):</strong></p>
<pre><code class="language-json">{
  &quot;transaction_id&quot;: 42,
  &quot;status&quot;: &quot;error&quot;,
  &quot;error&quot;: &quot;Transaction not found or already completed&quot;
}
</code></pre>
<p><strong>cURL Beispiel:</strong></p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/transaction/commit \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;transaction_id&quot;: 42}'
</code></pre>
<hr />
<h3 id="transactions-post-transactionrollback">POST /transaction/rollback<a class="headerlink" href="#transactions-post-transactionrollback" title="Permanent link">&para;</a></h3>
<p>Rollt eine Transaktion zurück.</p>
<p><strong>Request:</strong></p>
<pre><code class="language-json">{
  &quot;transaction_id&quot;: 42
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;transaction_id&quot;: 42,
  &quot;status&quot;: &quot;rolled_back&quot;,
  &quot;message&quot;: &quot;Transaction rolled back successfully&quot;
}
</code></pre>
<p><strong>cURL Beispiel:</strong></p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/transaction/rollback \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;transaction_id&quot;: 42}'
</code></pre>
<hr />
<h3 id="transactions-get-transactionstats">GET /transaction/stats<a class="headerlink" href="#transactions-get-transactionstats" title="Permanent link">&para;</a></h3>
<p>Liefert Statistiken über alle Transaktionen.</p>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;total_begun&quot;: 1523,
  &quot;total_committed&quot;: 1401,
  &quot;total_aborted&quot;: 122,
  &quot;active_count&quot;: 3,
  &quot;avg_duration_ms&quot;: 45,
  &quot;max_duration_ms&quot;: 523,
  &quot;success_rate&quot;: 0.92
}
</code></pre>
<p><strong>cURL Beispiel:</strong></p>
<pre><code class="language-bash">curl http://localhost:8080/transaction/stats
</code></pre>
<hr />
<h2 id="transactions-use-cases-best-practices">Use Cases &amp; Best Practices<a class="headerlink" href="#transactions-use-cases-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="transactions-1-atomares-multi-entity-update">1. Atomares Multi-Entity Update<a class="headerlink" href="#transactions-1-atomares-multi-entity-update" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Mehrere Entities mit verschiedenen Indizes müssen atomar gespeichert werden.</p>
<p><strong>Lösung:</strong></p>
<pre><code class="language-bash"># Begin transaction
TXN_ID=$(curl -s -X POST http://localhost:8080/transaction/begin | jq -r '.transaction_id')

# Insert entities via transaction (hypothetisch - API-Erweiterung erforderlich)
# Aktuell: Direkte C++ API verwenden

# C++ Code:
auto txn_id = tx_manager-&gt;beginTransaction();
auto txn = tx_manager-&gt;getTransaction(txn_id);

BaseEntity user(&quot;user123&quot;);
user.setField(&quot;name&quot;, std::string(&quot;Alice&quot;));
user.setField(&quot;city&quot;, std::string(&quot;Berlin&quot;));
txn-&gt;putEntity(&quot;users&quot;, user);

BaseEntity order(&quot;order456&quot;);
order.setField(&quot;user_id&quot;, std::string(&quot;user123&quot;));
order.setField(&quot;total&quot;, 99.99);
txn-&gt;putEntity(&quot;orders&quot;, order);

// Commit via HTTP
curl -X POST http://localhost:8080/transaction/commit \
  -d &quot;{\&quot;transaction_id\&quot;: $TXN_ID}&quot;
</code></pre>
<hr />
<h3 id="transactions-2-graph-operationen-mit-rollback">2. Graph-Operationen mit Rollback<a class="headerlink" href="#transactions-2-graph-operationen-mit-rollback" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Mehrere Graph-Edges sollen atomar hinzugefügt werden, bei Fehler Rollback.</p>
<p><strong>C++ Beispiel:</strong></p>
<pre><code class="language-cpp">auto txn_id = tx_manager-&gt;beginTransaction();
auto txn = tx_manager-&gt;getTransaction(txn_id);

try {
    // Add multiple edges
    BaseEntity edge1(&quot;edge1&quot;);
    edge1.setField(&quot;_from&quot;, std::string(&quot;user1&quot;));
    edge1.setField(&quot;_to&quot;, std::string(&quot;user2&quot;));
    edge1.setField(&quot;type&quot;, std::string(&quot;follows&quot;));
    txn-&gt;addEdge(edge1);

    BaseEntity edge2(&quot;edge2&quot;);
    edge2.setField(&quot;_from&quot;, std::string(&quot;user1&quot;));
    edge2.setField(&quot;_to&quot;, std::string(&quot;user3&quot;));
    edge2.setField(&quot;type&quot;, std::string(&quot;follows&quot;));
    txn-&gt;addEdge(edge2);

    // Validate business logic
    if (!validateFollowerLimit(txn)) {
        tx_manager-&gt;rollbackTransaction(txn_id);
        return Status::Error(&quot;Follower limit exceeded&quot;);
    }

    // Commit if all OK
    return tx_manager-&gt;commitTransaction(txn_id);
} catch (...) {
    tx_manager-&gt;rollbackTransaction(txn_id);
    throw;
}
</code></pre>
<hr />
<h3 id="transactions-3-vector-index-mit-transaktionen">3. Vector-Index mit Transaktionen<a class="headerlink" href="#transactions-3-vector-index-mit-transaktionen" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Vector-Embedding und Metadaten sollen atomar gespeichert werden.</p>
<p><strong>C++ Beispiel:</strong></p>
<pre><code class="language-cpp">auto txn_id = tx_manager-&gt;beginTransaction();
auto txn = tx_manager-&gt;getTransaction(txn_id);

// Document with embedding
BaseEntity doc(&quot;doc123&quot;);
doc.setField(&quot;title&quot;, std::string(&quot;AI Research Paper&quot;));
doc.setField(&quot;author&quot;, std::string(&quot;Dr. Smith&quot;));
std::vector&lt;float&gt; embedding = {0.23f, 0.45f, 0.67f, /* ... 768 dims */};
doc.setField(&quot;embedding&quot;, embedding);

// Store entity (relational)
auto status = txn-&gt;putEntity(&quot;documents&quot;, doc);
if (!status.ok) {
    tx_manager-&gt;rollbackTransaction(txn_id);
    return status;
}

// Store vector (vector index)
status = txn-&gt;addVector(doc, &quot;embedding&quot;);
if (!status.ok) {
    tx_manager-&gt;rollbackTransaction(txn_id);
    return status;
}

// Commit both atomically
return tx_manager-&gt;commitTransaction(txn_id);
</code></pre>
<hr />
<h3 id="transactions-4-long-running-transactions-cleanup">4. Long-Running Transactions &amp; Cleanup<a class="headerlink" href="#transactions-4-long-running-transactions-cleanup" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Vergessene/abgestürzte Clients hinterlassen offene Transaktionen.</p>
<p><strong>Best Practice:</strong></p>
<pre><code class="language-cpp">// Periodischer Cleanup (z.B. via Cronjob oder Background-Thread)
tx_manager-&gt;cleanupOldTransactions(std::chrono::hours(1));

// Metriken überwachen
auto stats = tx_manager-&gt;getStats();
if (stats.active_count &gt; 100) {
    THEMIS_WARN(&quot;High number of active transactions: {}&quot;, stats.active_count);
}
</code></pre>
<p><strong>HTTP Monitoring:</strong></p>
<pre><code class="language-bash"># Statistiken abrufen
curl http://localhost:8080/transaction/stats | jq '.active_count'

# Alert bei hoher Anzahl
if [ $(curl -s http://localhost:8080/transaction/stats | jq '.active_count') -gt 50 ]; then
  echo &quot;WARNING: Too many active transactions&quot;
fi
</code></pre>
<hr />
<h2 id="transactions-performance-uberlegungen">Performance-Überlegungen<a class="headerlink" href="#transactions-performance-uberlegungen" title="Permanent link">&para;</a></h2>
<h3 id="transactions-mvcc-overhead">MVCC Overhead<a class="headerlink" href="#transactions-mvcc-overhead" title="Permanent link">&para;</a></h3>
<ul>
<li>Snapshot-Verwaltung und Konflikterkennung erzeugen geringen Overhead gegenüber einfachen Writes</li>
<li>Benefit: Korrektheit unter Parallelität (kein Last-Write-Wins), konsistente Sicht</li>
</ul>
<h3 id="transactions-isolation-level-trade-offs">Isolation Level Trade-offs<a class="headerlink" href="#transactions-isolation-level-trade-offs" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Isolation Level</th>
<th>Read Overhead</th>
<th>Write Overhead</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReadCommitted</td>
<td>Minimal</td>
<td>Minimal</td>
<td>OLTP, Standard-Queries</td>
</tr>
<tr>
<td>Snapshot</td>
<td>+5-10%</td>
<td>+5-10%</td>
<td>Reports, Analytics</td>
</tr>
</tbody>
</table>
<h3 id="transactions-index-spezifische-kosten">Index-spezifische Kosten<a class="headerlink" href="#transactions-index-spezifische-kosten" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Secondary Index</strong>: ~0.05ms pro Index-Entry (Put/Delete)</li>
<li><strong>Graph Index</strong>: ~0.1ms pro Edge (2x Index-Entries: out + in)</li>
<li><strong>Vector Index</strong>: ~0.5-2ms (abhängig von HNSW-Parametern, Dimension)</li>
</ul>
<hr />
<h2 id="transactions-bekannte-einschrankungen">Bekannte Einschränkungen<a class="headerlink" href="#transactions-bekannte-einschrankungen" title="Permanent link">&para;</a></h2>
<h3 id="transactions-1-vector-index-in-memory-cache">1. Vector Index In-Memory Cache<a class="headerlink" href="#transactions-1-vector-index-in-memory-cache" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong><br />
Der Vector-Index hält einen In-Memory Cache (HNSW-Struktur, <code>cache_</code> map). Bei Rollback werden RocksDB-Änderungen rückgängig gemacht, aber der Cache bleibt inkonsistent.</p>
<p><strong>Auswirkung:</strong>
- Nach Rollback können Vector-Searches falsch-positive Ergebnisse liefern
- Cache enthält Vektoren, die in RocksDB nicht existieren</p>
<p><strong>Workaround:</strong></p>
<pre><code class="language-cpp">// Nach Rollback: Vector-Index neu laden
vector_index-&gt;rebuildFromStorage();
</code></pre>
<p><strong>Zukünftige Verbesserung:</strong><br />
Callback-Mechanismus für commit/rollback, um Cache synchron zu halten.</p>
<hr />
<h3 id="transactions-2-konflikte-unter-parallelitat">2. Konflikte unter Parallelität<a class="headerlink" href="#transactions-2-konflikte-unter-parallelitat" title="Permanent link">&para;</a></h3>
<p><strong>Verhalten:</strong><br />
Write-Write-Konflikte werden erkannt und führen zu Fehlern beim Commit/Put. Clients sollten Retry-Logik mit Backoff implementieren, wenn eine Transaktion aufgrund eines Konflikts abgelehnt wird.</p>
<hr />
<h3 id="transactions-3-transaction-timeout">3. Transaction Timeout<a class="headerlink" href="#transactions-3-transaction-timeout" title="Permanent link">&para;</a></h3>
<p><strong>Limitation:</strong><br />
Keine automatischen Timeouts für aktive Transaktionen implementiert.</p>
<p><strong>Empfehlung:</strong></p>
<pre><code class="language-cpp">// Client-seitig: Timeout überwachen
auto start = std::chrono::system_clock::now();
auto txn_id = tx_manager-&gt;beginTransaction();

// ... operations ...

auto duration = std::chrono::system_clock::now() - start;
if (duration &gt; std::chrono::seconds(30)) {
    tx_manager-&gt;rollbackTransaction(txn_id);
    return Status::Error(&quot;Transaction timeout&quot;);
}
</code></pre>
<hr />
<h2 id="transactions-fehlerbehandlung">Fehlerbehandlung<a class="headerlink" href="#transactions-fehlerbehandlung" title="Permanent link">&para;</a></h2>
<h3 id="transactions-commit-failures">Commit Failures<a class="headerlink" href="#transactions-commit-failures" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto status = tx_manager-&gt;commitTransaction(txn_id);
if (!status.ok) {
    // Mögliche Ursachen:
    // - Transaction nicht gefunden
    // - Bereits committed/rolled back
    // - RocksDB Write-Fehler (Disk-Full, Permissions)

    THEMIS_ERROR(&quot;Commit failed: {}&quot;, status.message);

    // Cleanup
    tx_manager-&gt;rollbackTransaction(txn_id);  // Safe auch bei bereits abgeschlossener Txn
}
</code></pre>
<h3 id="transactions-network-failures-http">Network Failures (HTTP)<a class="headerlink" href="#transactions-network-failures-http" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Retry-Logic mit Exponential Backoff
for i in {1..3}; do
  if curl -X POST http://localhost:8080/transaction/commit \
       -d &quot;{\&quot;transaction_id\&quot;: $TXN_ID}&quot; \
       --max-time 5; then
    break
  fi
  sleep $((2**i))
done
</code></pre>
<h3 id="transactions-auto-rollback-bei-exception">Auto-Rollback bei Exception<a class="headerlink" href="#transactions-auto-rollback-bei-exception" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">{
    auto txn = tx_manager-&gt;begin();  // Direct API

    txn.putEntity(&quot;users&quot;, user);

    // Exception thrown -&gt; Destruktor ruft automatisch rollback()
    throw std::runtime_error(&quot;Business logic error&quot;);

}  // txn Destruktor: THEMIS_WARN + rollback()
</code></pre>
<hr />
<h2 id="transactions-metriken-monitoring">Metriken &amp; Monitoring<a class="headerlink" href="#transactions-metriken-monitoring" title="Permanent link">&para;</a></h2>
<h3 id="transactions-prometheus-integration">Prometheus-Integration<a class="headerlink" href="#transactions-prometheus-integration" title="Permanent link">&para;</a></h3>
<p>Transaction-Statistiken sind via <code>/metrics</code> Endpoint verfügbar:</p>
<pre><code># TYPE vccdb_transactions_begun_total counter
vccdb_transactions_begun_total 1523

# TYPE vccdb_transactions_committed_total counter
vccdb_transactions_committed_total 1401

# TYPE vccdb_transactions_aborted_total counter
vccdb_transactions_aborted_total 122

# TYPE vccdb_transactions_active gauge
vccdb_transactions_active 3

# TYPE vccdb_transaction_duration_ms histogram
vccdb_transaction_duration_ms_bucket{le=&quot;10&quot;} 834
vccdb_transaction_duration_ms_bucket{le=&quot;50&quot;} 1245
vccdb_transaction_duration_ms_bucket{le=&quot;100&quot;} 1398
vccdb_transaction_duration_ms_bucket{le=&quot;+Inf&quot;} 1523
vccdb_transaction_duration_ms_sum 68035
vccdb_transaction_duration_ms_count 1523
</code></pre>
<h3 id="transactions-grafana-dashboard">Grafana Dashboard<a class="headerlink" href="#transactions-grafana-dashboard" title="Permanent link">&para;</a></h3>
<p>Empfohlene Metriken:
- <strong>Transaction Rate</strong>: <code>rate(vccdb_transactions_begun_total[5m])</code>
- <strong>Success Rate</strong>: <code>vccdb_transactions_committed_total / vccdb_transactions_begun_total</code>
- <strong>Active Transactions</strong>: <code>vccdb_transactions_active</code>
- <strong>Avg Duration</strong>: <code>vccdb_transaction_duration_ms_sum / vccdb_transaction_duration_ms_count</code></p>
<hr />
<h2 id="transactions-migrationshinweise">Migrationshinweise<a class="headerlink" href="#transactions-migrationshinweise" title="Permanent link">&para;</a></h2>
<h3 id="transactions-von-direct-api-zu-session-based-api">Von Direct API zu Session-based API<a class="headerlink" href="#transactions-von-direct-api-zu-session-based-api" title="Permanent link">&para;</a></h3>
<p><strong>Vorher (Direct):</strong></p>
<pre><code class="language-cpp">auto txn = tx_manager-&gt;begin();
txn.putEntity(&quot;users&quot;, user);
txn.commit();
</code></pre>
<p><strong>Nachher (Session-based, HTTP-kompatibel):</strong></p>
<pre><code class="language-cpp">auto txn_id = tx_manager-&gt;beginTransaction();
auto txn = tx_manager-&gt;getTransaction(txn_id);
txn-&gt;putEntity(&quot;users&quot;, user);
tx_manager-&gt;commitTransaction(txn_id);
</code></pre>
<p><strong>Vorteil:</strong> Transaction-ID kann über HTTP/Network übertragen werden.</p>
<hr />
<h2 id="transactions-weiterfuhrende-dokumentation">Weiterführende Dokumentation<a class="headerlink" href="#transactions-weiterfuhrende-dokumentation" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#architecture">Architecture Overview</a> - Systemarchitektur</li>
<li><a href="#mvcc_design">MVCC Design</a> - Hintergründe &amp; Optionen</li>
<li><a href="#storage-rocksdb_layout">RocksDB Storage</a> - WAL/Snapshots/Compaction</li>
<li><a href="#deployment">Deployment Guide</a> - Production Setup</li>
<li><a href="../openapi.yaml">OpenAPI Specification</a> - Vollständige API-Referenz</li>
<li><a href="#base_entity">Base Entity Documentation</a> - Entity-Serialisierung</li>
</ul>
<hr />
<h2 id="transactions-changelog">Changelog<a class="headerlink" href="#transactions-changelog" title="Permanent link">&para;</a></h2>
<h3 id="transactions-version-10-28-oktober-2025">Version 1.0 (28. Oktober 2025)<a class="headerlink" href="#transactions-version-10-28-oktober-2025" title="Permanent link">&para;</a></h3>
<ul>
<li>Initial release</li>
<li>Session-based Transaction Management</li>
<li>Isolation Levels: ReadCommitted, Snapshot</li>
<li>Multi-Index Support: Secondary, Graph, Vector</li>
<li>HTTP REST API: begin, commit, rollback, stats</li>
<li>Comprehensive Statistics &amp; Monitoring</li>
<li>23 Unit-Tests (100% Pass-Rate)</li>
</ul></section><section class="print-page" id="time_series" heading-number="4.5"><h1 id="time_series-time-series-engine-tsstore">Time-Series Engine (TSStore)<a class="headerlink" href="#time_series-time-series-engine-tsstore" title="Permanent link">&para;</a></h1>
<p>Stand: Implementiert und per HTTP-API nutzbar. Diese Seite ist mit dem Quellcode abgeglichen.</p>
<h2 id="time_series-uberblick">Überblick<a class="headerlink" href="#time_series-uberblick" title="Permanent link">&para;</a></h2>
<p>Funktionen:
- Speicherung von Zeitreihenpunkten in RocksDB (Schlüssel-Schema <code>ts:{metric}:{entity}:{timestamp_ms}</code>)
- Abfragen über Zeitbereiche mit Filter (Metric, Entity, Tags) und Limit
- On-the-fly Aggregationen: min, max, avg, sum, count
- Manuelle Retention (global oder pro Metric)
- Kontinuierliche Aggregationen (abgeleitete Metriken) – MVP-Hilfsklasse
- Optionaler Gorilla-Codec (für zukünftige Blockspeicherung)</p>
<p>Hinweis zur Implementierung:
- Canonical ist <code>TSStore</code> (mit Tags/Metadata). <code>TimeSeriesStore</code> ist eine einfachere Variante und wird serverseitig nur für Übergangstypen verwendet.</p>
<h2 id="time_series-komponenten">Komponenten<a class="headerlink" href="#time_series-komponenten" title="Permanent link">&para;</a></h2>
<ul>
<li>TSStore (<code>include/timeseries/tsstore.h</code>): Haupt-API (DataPoint, QueryOptions, AggregationResult)</li>
<li>TimeSeriesStore (<code>include/timeseries/timeseries.h</code>): einfache Struktur (nur Wert/Meta), legacy</li>
<li>RetentionManager (<code>include/timeseries/retention.h</code>): setzt per-Metrik-Retention um</li>
<li>ContinuousAggregateManager (<code>include/timeseries/continuous_agg.h</code>): erstellt abgeleitete Metriken in Fenstern</li>
<li>Gorilla-Codec (Tests/Utils): Kompression für (timestamp,double)</li>
</ul>
<h2 id="time_series-datenmodell-tsstore">Datenmodell (TSStore)<a class="headerlink" href="#time_series-datenmodell-tsstore" title="Permanent link">&para;</a></h2>
<p>Key: <code>ts:{metric}:{entity}:{timestamp_ms}</code></p>
<p>DataPoint:</p>
<pre><code class="language-json">{
  &quot;metric&quot;: &quot;cpu&quot;,
  &quot;entity&quot;: &quot;server01&quot;,
  &quot;timestamp_ms&quot;: 1700000000000,
  &quot;value&quot;: 0.73,
  &quot;tags&quot;: { &quot;env&quot;: &quot;prod&quot; },
  &quot;metadata&quot;: {}
}
</code></pre>
<p>QueryOptions:</p>
<pre><code class="language-json">{
  &quot;metric&quot;: &quot;cpu&quot;,
  &quot;entity&quot;: &quot;server01&quot;,      // optional in TSStore, im HTTP-API derzeit erforderlich
  &quot;from_ms&quot;: 0,
  &quot;to_ms&quot;: 9223372036854775807,
  &quot;limit&quot;: 1000,
  &quot;tag_filter&quot;: { &quot;env&quot;: &quot;prod&quot; } // exakter Match
}
</code></pre>
<p>AggregationResult:</p>
<pre><code class="language-json">{
  &quot;min&quot;: 0.1,
  &quot;max&quot;: 0.9,
  &quot;avg&quot;: 0.5,
  &quot;sum&quot;: 5.0,
  &quot;count&quot;: 10,
  &quot;first_timestamp_ms&quot;: 1700000000000,
  &quot;last_timestamp_ms&quot;: 1700000060000
}
</code></pre>
<p>Wichtige Methoden (TSStore):
- <code>putDataPoint(DataPoint)</code> / <code>putDataPoints([...])</code>
- <code>query(QueryOptions)</code> → <code>(Status, vector&lt;DataPoint&gt;)</code>
- <code>aggregate(QueryOptions)</code> → <code>(Status, AggregationResult)</code>
- <code>getStats()</code> → <code>Stats</code>
- <code>deleteOldData(cutoff_ms)</code> / <code>deleteOldDataForMetric(metric, cutoff_ms)</code> / <code>deleteMetric(metric)</code></p>
<h2 id="time_series-http-endpoints-server">HTTP-Endpoints (Server)<a class="headerlink" href="#time_series-http-endpoints-server" title="Permanent link">&para;</a></h2>
<p>Zeitreihen sind über folgende Endpunkte nutzbar (Feature-Flag <code>features.timeseries=true</code>):</p>
<ul>
<li>POST <code>/ts/put</code></li>
<li>Body:
    <code>json
    { "metric": "cpu", "entity": "srv1", "value": 0.7, "timestamp_ms": 1700000000000, "metadata": { "env": "prod" } }</code></li>
<li>
<p>Antwort: <code>201 Created</code> mit <code>{ success, metric, entity, timestamp_ms }</code></p>
</li>
<li>
<p>POST <code>/ts/query</code></p>
</li>
<li>Body:
    <code>json
    { "metric": "cpu", "entity": "srv1", "from_ms": 1700000000000, "to_ms": 1700003600000, "limit": 1000 }</code></li>
<li>
<p>Antwort: <code>200 OK</code> mit <code>{ metric, entity, count, data: [ { timestamp_ms, value, tags } ] }</code></p>
</li>
<li>
<p>POST <code>/ts/aggregate</code></p>
</li>
<li>Body wie bei <code>/ts/query</code> (entity erforderlich)</li>
<li>Antwort: <code>200 OK</code> mit <code>{ metric, entity, aggregation: { min,max,avg,sum,count,first_timestamp_ms,last_timestamp_ms } }</code></li>
</ul>
<p>Hinweise:
- Tag-Filter sind in der TSStore-API vorhanden (<code>tag_filter</code>), in den aktuellen HTTP-Endpunkten aber (noch) nicht explizit verdrahtet.
- Die Server-Handler verwenden intern <code>TSStore</code> (<code>putDataPoint</code>, <code>query</code>, <code>aggregate</code>).</p>
<h2 id="time_series-retention">Retention<a class="headerlink" href="#time_series-retention" title="Permanent link">&para;</a></h2>
<ul>
<li>Global: <code>deleteOldData(cutoff_ms)</code></li>
<li>Pro Metric: <code>deleteOldDataForMetric(metric, cutoff_ms)</code></li>
<li>Manager: <code>RetentionManager</code> mit <code>RetentionPolicy.per_metric[metric] = &lt;Duration&gt;</code></li>
</ul>
<p>Beispiel:</p>
<pre><code class="language-cpp">RetentionPolicy pol;
pol.per_metric[&quot;cpu&quot;] = std::chrono::minutes(30);
pol.per_metric[&quot;mem&quot;] = std::chrono::hours(2);
RetentionManager rm(&amp;tsstore, pol);
size_t deleted = rm.apply();
</code></pre>
<h2 id="time_series-kontinuierliche-aggregationen-mvp">Kontinuierliche Aggregationen (MVP)<a class="headerlink" href="#time_series-kontinuierliche-aggregationen-mvp" title="Permanent link">&para;</a></h2>
<ul>
<li>Abgeleitete Metrik: <code>{metric}__agg_{window_ms}</code></li>
<li>Ein Punkt pro Fensterende; <code>value = avg</code>, übrige Kennzahlen in <code>metadata</code></li>
</ul>
<pre><code class="language-cpp">ContinuousAggregateManager mgr(&amp;tsstore);
AggConfig cfg{ .metric = &quot;temp&quot;, .entity = std::string(&quot;sensorA&quot;), .window = {std::chrono::minutes(1)} };
mgr.refresh(cfg, from_ms, to_ms);
</code></pre>
<h2 id="time_series-gorilla-codec-optional">Gorilla-Codec (optional)<a class="headerlink" href="#time_series-gorilla-codec-optional" title="Permanent link">&para;</a></h2>
<ul>
<li>Timestamps: Delta-of-Delta, ZigZag + Varint</li>
<li>Werte: XOR der IEEE‑754 Repräsentation mit Leading/Trailing‑Zero‑Packing</li>
</ul>
<pre><code class="language-cpp">GorillaEncoder enc;
enc.add(ts, value);
auto bytes = enc.finish();
GorillaDecoder dec(bytes);
while (auto p = dec.next()) { /* ... */ }
</code></pre>
<h2 id="time_series-tests">Tests<a class="headerlink" href="#time_series-tests" title="Permanent link">&para;</a></h2>
<ul>
<li><code>tests/test_tsstore.cpp</code> – TSStore: CRUD, Query, Aggregation, Stats</li>
<li><code>tests/test_timeseries_retention.cpp</code> – Retention pro Metric</li>
<li><code>tests/test_gorilla.cpp</code> – Codec‑Roundtrip/Kompression</li>
</ul>
<h2 id="time_series-limitierungen-aktuell">Limitierungen (aktuell)<a class="headerlink" href="#time_series-limitierungen-aktuell" title="Permanent link">&para;</a></h2>
<ul>
<li>Kein automatisches Downsampling/TTL – Retention ist manuell bzw. per Job</li>
<li>HTTP-Endpunkte erfordern <code>entity</code>; TSStore unterstützt zudem Tag‑Filter (noch nicht im Endpoint)</li>
<li>Kompression standardmäßig deaktiviert (<code>CompressionType::None</code>)</li>
</ul></section><section class="print-page" id="memory_tuning" heading-number="4.6"><h1 id="memory_tuning-speicherhierarchie-optimierung-rocksdb-tuning">Speicherhierarchie-Optimierung &amp; RocksDB Tuning<a class="headerlink" href="#memory_tuning-speicherhierarchie-optimierung-rocksdb-tuning" title="Permanent link">&para;</a></h1>
<p>Dieser Leitfaden beschreibt, wie du die Speicherhierarchie für THEMIS mit RocksDB effektiv konfigurierst.</p>
<h2 id="memory_tuning-rocksdb-kompression">RocksDB Kompression<a class="headerlink" href="#memory_tuning-rocksdb-kompression" title="Permanent link">&para;</a></h2>
<h3 id="memory_tuning-verfugbare-algorithmen">Verfügbare Algorithmen<a class="headerlink" href="#memory_tuning-verfugbare-algorithmen" title="Permanent link">&para;</a></h3>
<p>THEMIS unterstützt folgende Kompressionsalgorithmen (konfigurierbar via <code>compression_default</code> und <code>compression_bottommost</code>):</p>
<table>
<thead>
<tr>
<th>Algorithmus</th>
<th>Kompressionsrate</th>
<th>CPU-Overhead</th>
<th>Write-Speed</th>
<th>Read-Speed</th>
<th>Empfehlung</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>None</strong></td>
<td>1.0x (keine)</td>
<td>Minimal</td>
<td>⚡ Sehr schnell</td>
<td>⚡ Sehr schnell</td>
<td>Nur für sehr schnelle SSDs mit viel Speicher</td>
</tr>
<tr>
<td><strong>LZ4</strong></td>
<td>2-3x</td>
<td>Niedrig</td>
<td>⚡ Schnell</td>
<td>⚡ Schnell</td>
<td>✅ <strong>Empfohlen für Level 0-5</strong></td>
</tr>
<tr>
<td><strong>ZSTD</strong></td>
<td>3-5x</td>
<td>Mittel</td>
<td>Mittel</td>
<td>Schnell</td>
<td>✅ <strong>Empfohlen für Level 6+ (bottommost)</strong></td>
</tr>
<tr>
<td><strong>Snappy</strong></td>
<td>2-2.5x</td>
<td>Niedrig</td>
<td>Schnell</td>
<td>Schnell</td>
<td>Alternative zu LZ4</td>
</tr>
<tr>
<td><strong>Zlib</strong></td>
<td>3-4x</td>
<td>Hoch</td>
<td>Langsam</td>
<td>Mittel</td>
<td>⚠️ Nicht empfohlen</td>
</tr>
</tbody>
</table>
<h3 id="memory_tuning-benchmark-ergebnisse">Benchmark-Ergebnisse<a class="headerlink" href="#memory_tuning-benchmark-ergebnisse" title="Permanent link">&para;</a></h3>
<p>Test: 10.000 Entities à ~2KB (gemischte JSON-Daten mit Text)</p>
<pre><code>Compression         DB Size (MB)    Ratio    Write (MB/s)    Read (MB/s)
------------------------------------------------------------------------------
none / none             ~45         1.0x        34.5           125.3
lz4 / zstd              ~19         2.4x        33.8           118.4
zstd / zstd             ~15         2.9x        32.3           112.7
snappy / zstd           ~19         2.3x        33.1           115.9
</code></pre>
<p><strong>Empfehlung:</strong> <code>compression_default = "lz4"</code> + <code>compression_bottommost = "zstd"</code> für besten Trade-off zwischen Speicherplatz und Performance.</p>
<h3 id="memory_tuning-konfiguration">Konfiguration<a class="headerlink" href="#memory_tuning-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">RocksDBWrapper::Config config;
config.compression_default = &quot;lz4&quot;;       // Für Level 0-5
config.compression_bottommost = &quot;zstd&quot;;   // Für Level 6+ (selten gelesen)
</code></pre>
<p>Bei der DB-Erstellung wird die Kompression automatisch aktiviert. Prüfen mit:</p>
<pre><code class="language-bash"># OPTIONS-Datei inspizieren
cat data/themis_server/OPTIONS-* | grep compression
</code></pre>
<h2 id="memory_tuning-ziele">Ziele<a class="headerlink" href="#memory_tuning-ziele" title="Permanent link">&para;</a></h2>
<ul>
<li>WAL (Write-Ahead-Log) auf schnelle NVMe</li>
<li>SSTables verteilt auf mehrere NVMe-Pfade (Hot/Cold möglich)</li>
<li>Großer Block-Cache im RAM, Index/Filter bevorzugt (High-Priority-Pool)</li>
<li>Direkte I/O für Flush/Compaction optional, um OS-Cache zu umgehen</li>
<li>Bloom-Filter und Partitioned-Filter für schnelle Point-Lookups</li>
</ul>
<h2 id="memory_tuning-relevante-konfiguration-rocksdbwrapperconfig">Relevante Konfiguration (<code>RocksDBWrapper::Config</code>)<a class="headerlink" href="#memory_tuning-relevante-konfiguration-rocksdbwrapperconfig" title="Permanent link">&para;</a></h2>
<ul>
<li>Verzeichnisse</li>
<li><code>db_path</code>: Hauptpfad für DB</li>
<li><code>wal_dir</code>: separates WAL-Verzeichnis (z. B. NVMe1) — leer = Standard unter <code>db_path</code></li>
<li>
<p><code>db_paths</code>: Liste aus <code>{ path, target_size_bytes }</code> (z. B. NVMe2, NVMe3)</p>
</li>
<li>
<p>Kompression</p>
</li>
<li><code>compression_default</code>: Algorithmus für Level 0-5 (empfohlen: "lz4")</li>
<li>
<p><code>compression_bottommost</code>: Algorithmus für Level 6+ (empfohlen: "zstd")</p>
</li>
<li>
<p>Caches/Filter</p>
</li>
<li><code>block_cache_size_mb</code>: Größe des Block-Caches in MB</li>
<li><code>cache_index_and_filter_blocks</code> (true)</li>
<li><code>pin_l0_filter_and_index_blocks_in_cache</code> (true)</li>
<li><code>partition_filters</code> (true)</li>
<li><code>high_pri_pool_ratio</code> (0.5): Anteil für Index/Filter im Cache</li>
<li>
<p><code>bloom_bits_per_key</code> (10)</p>
</li>
<li>
<p>Write Buffer / Compaction</p>
</li>
<li><code>memtable_size_mb</code> (z. B. 256)</li>
<li><code>max_write_buffer_number</code> (3)</li>
<li><code>min_write_buffer_number_to_merge</code> (1)</li>
<li><code>use_universal_compaction</code> (false/true)</li>
<li><code>dynamic_level_bytes</code> (true)</li>
<li><code>target_file_size_base_mb</code> (64)</li>
<li>
<p><code>max_bytes_for_level_base_mb</code> (256)</p>
</li>
<li>
<p>I/O</p>
</li>
<li><code>use_direct_reads</code> (false)</li>
<li>
<p><code>use_direct_io_for_flush_and_compaction</code> (false)</p>
</li>
<li>
<p>WAL</p>
</li>
<li>
<p><code>enable_wal</code> (true) — <code>write_options.sync</code></p>
</li>
<li>
<p>Kompression (best-effort)</p>
</li>
<li>Default: LZ4 (Levels), ZSTD (Bottommost)</li>
</ul>
<h2 id="memory_tuning-beispielkonfiguration">Beispielkonfiguration<a class="headerlink" href="#memory_tuning-beispielkonfiguration" title="Permanent link">&para;</a></h2>
<pre><code>themis::RocksDBWrapper::Config cfg;
cfg.db_path = &quot;D:/data/vccdb&quot;;            // Hauptpfad
cfg.wal_dir = &quot;E:/logs/vccdb_wal&quot;;       // WAL auf separater NVMe
cfg.db_paths = {
    {&quot;D:/data/vccdb&quot;,       500ull * 1024 * 1024 * 1024}, // 500 GB
    {&quot;F:/data/vccdb_hot&quot;,   500ull * 1024 * 1024 * 1024}  // 500 GB
};

cfg.memtable_size_mb = 512;
cfg.block_cache_size_mb = 4096; // 4 GB Cache
cfg.cache_index_and_filter_blocks = true;
cfg.pin_l0_filter_and_index_blocks_in_cache = true;
cfg.partition_filters = true;
cfg.high_pri_pool_ratio = 0.5;
cfg.bloom_bits_per_key = 10;

cfg.max_write_buffer_number = 4;
cfg.min_write_buffer_number_to_merge = 1;
cfg.use_universal_compaction = false;
cfg.dynamic_level_bytes = true;
cfg.target_file_size_base_mb = 128;
cfg.max_bytes_for_level_base_mb = 1024;

cfg.use_direct_reads = false;
cfg.use_direct_io_for_flush_and_compaction = true;
</code></pre>
<h2 id="memory_tuning-hinweise">Hinweise<a class="headerlink" href="#memory_tuning-hinweise" title="Permanent link">&para;</a></h2>
<ul>
<li>Direct I/O kann Performance verbessern, wenn der RocksDB-Block-Cache groß ist und OS-Cache thrashen würde. Testen!</li>
<li><code>db_paths</code> verteilt neue SSTables über Pfade entsprechend <code>target_size_bytes</code>.</li>
<li>Für GPU-ANN (Faiss-GPU) ist VRAM-Management separat (Task 6/Weiteres); hier nicht enthalten.</li>
<li>Prüfe <code>rocksdb.stats</code> (siehe <code>RocksDBWrapper::getStats</code>) nach Lasttests und passe Parameter an.</li>
</ul>
<pre><code>THEMIS_INFO(&quot;{}&quot;, db.getStats());
</code></pre>
<h2 id="memory_tuning-troubleshooting">Troubleshooting<a class="headerlink" href="#memory_tuning-troubleshooting" title="Permanent link">&para;</a></h2>
<ul>
<li>Langsame Point-Lookups: <code>bloom_bits_per_key</code> erhöhen, <code>cache_index_and_filter_blocks</code> aktivieren.</li>
<li>Hohe Latenzen beim Flush/Compaction: <code>use_direct_io_for_flush_and_compaction</code> testen; mehr Background-Jobs (<code>max_background_jobs</code>).</li>
<li>RAM zu knapp: <code>block_cache_size_mb</code> reduzieren, <code>memtable_size_mb</code> anpassen.
```</li>
</ul></section></section>
                    <section class='print-page md-section' id='section-5' heading-number='5'>
                        <h1>Indexe & Statistiken<a class='headerlink' href='#section-5' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="indexes" heading-number="5.1"><h1 id="indexes-indexe-uberblick-und-verwendung">Indexe – Überblick und Verwendung<a class="headerlink" href="#indexes-indexe-uberblick-und-verwendung" title="Permanent link">&para;</a></h1>
<p>Dieser Leitfaden beschreibt die in THEMIS verfügbaren Indexe (Sekundär-, Range-, Geo-, TTL-, Fulltext-, Graph- und Vektorindizes), ihre Key-Schemata und die korrekte Verwendung im Code.</p>
<h2 id="indexes-key-schemata-prafixe">Key-Schemata (Präfixe)<a class="headerlink" href="#indexes-key-schemata-prafixe" title="Permanent link">&para;</a></h2>
<ul>
<li>Equality (Single): <code>idx:&lt;table&gt;:&lt;column&gt;:&lt;value&gt;:&lt;PK&gt;</code></li>
<li>Equality (Composite): <code>idx:&lt;table&gt;:&lt;col1+col2&gt;:&lt;val1&gt;:&lt;val2&gt;:&lt;PK&gt;</code></li>
<li>Range (lexikografisch): <code>ridx:&lt;table&gt;:&lt;column&gt;:&lt;value&gt;:&lt;PK&gt;</code></li>
<li>Sparse: <code>sidx:&lt;table&gt;:&lt;column&gt;:&lt;value&gt;:&lt;PK&gt;</code></li>
<li>Geo (Geohash/Morton): <code>gidx:&lt;table&gt;:&lt;column&gt;:&lt;geohash&gt;:&lt;PK&gt;</code></li>
<li>TTL (Expiry): <code>ttlidx:&lt;table&gt;:&lt;column&gt;:&lt;timestamp&gt;:&lt;PK&gt;</code></li>
<li>Fulltext (invertiert): <code>ftidx:&lt;table&gt;:&lt;column&gt;:&lt;token&gt;:&lt;PK&gt;</code></li>
<li>Graph (Adjazenz, logisch):</li>
<li>Out: <code>graph:out:&lt;from_pk&gt;:&lt;edge_id&gt; -&gt; &lt;to_pk&gt;</code></li>
<li>In:  <code>graph:in:&lt;to_pk&gt;:&lt;edge_id&gt;   -&gt; &lt;from_pk&gt;</code></li>
<li>Vector (per Entity gespeichert): <code>objectName:&lt;PK&gt;</code> mit Feld <code>embedding</code></li>
</ul>
<p>Hinweise
- Composite-Indizes verwenden das gleiche Präfix wie Single-Column (<code>idx:</code>); die Spaltennamen werden im <code>column</code>-Teil durch <code>+</code> getrennt.
- Geo-Indizes erwarten Felder <code>&lt;column&gt;_lat</code> und <code>&lt;column&gt;_lon</code> als Strings (z. B. <code>"52.5"</code>, <code>"13.4"</code>).
- TTL-Indizes speichern Expire-Timestamps in Sekunden; die tatsächliche Löschung erfolgt über einen Cleanup-Lauf.
- Fulltext-Tokenizer: simples Whitespace/Punktuation-Splitting, Lowercasing, AND-Logik bei Suche.
 - Range-Scans sind lexikografisch (String-Encoding!). Für numerische Ordnung ggf. Zero-Padding oder Canonical-Encoding verwenden.
 - VectorIndex nutzt HNSW (falls mit THEMIS_HNSW_ENABLED gebaut) oder Fallback (Brute-Force) mit in-memory Cache.</p>
<h2 id="indexes-api-snippets-c">API-Snippets (C++)<a class="headerlink" href="#indexes-api-snippets-c" title="Permanent link">&para;</a></h2>
<p>Vorbereitung:</p>
<pre><code class="language-cpp">#include &quot;index/secondary_index.h&quot;
#include &quot;storage/base_entity.h&quot;
using themis::SecondaryIndexManager;
using themis::BaseEntity;
</code></pre>
<h3 id="indexes-equality-index-single-column">Equality-Index (Single-Column)<a class="headerlink" href="#indexes-equality-index-single-column" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">SecondaryIndexManager idx(db);
idx.createIndex(&quot;users&quot;, &quot;email&quot;, /*unique=*/false);

BaseEntity e(&quot;user42&quot;);
e.setField(&quot;email&quot;, &quot;u42@example.com&quot;);
idx.put(&quot;users&quot;, e);

auto [st, keys] = idx.scanKeysEqual(&quot;users&quot;, &quot;email&quot;, &quot;u42@example.com&quot;);
</code></pre>
<ul>
<li>Unique-Constraint: <code>createIndex(table, column, /*unique=*/true)</code> verhindert doppelte Values.</li>
</ul>
<h3 id="indexes-composite-index">Composite-Index<a class="headerlink" href="#indexes-composite-index" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">idx.createCompositeIndex(&quot;orders&quot;, {&quot;customer_id&quot;, &quot;status&quot;}, /*unique=*/false);

BaseEntity o(&quot;order1&quot;);
o.setField(&quot;customer_id&quot;, &quot;cust1&quot;);
o.setField(&quot;status&quot;, &quot;pending&quot;);
idx.put(&quot;orders&quot;, o);

auto [st, keys] = idx.scanKeysEqualComposite(&quot;orders&quot;, {&quot;customer_id&quot;,&quot;status&quot;}, {&quot;cust1&quot;,&quot;pending&quot;});
</code></pre>
<p>Wichtig: Composite benutzt <code>idx:</code> mit <code>column = col1+col2</code> und <code>value = val1:val2</code> (intern percent-encodiert, falls nötig).</p>
<h3 id="indexes-range-index">Range-Index<a class="headerlink" href="#indexes-range-index" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">idx.createRangeIndex(&quot;users&quot;, &quot;age&quot;);

auto [st, keys] = idx.scanKeysRange(
  &quot;users&quot;, &quot;age&quot;,
  /*lower*/ std::make_optional(std::string(&quot;18&quot;)),
  /*upper*/ std::make_optional(std::string(&quot;65&quot;)),
  /*includeLower*/ true, /*includeUpper*/ false,
  /*limit*/ 1000, /*reversed*/ false);
</code></pre>
<p>Range-Index ist unabhängig vom Equality-Index auf derselben Spalte.</p>
<h4 id="indexes-cursor-anker-pagination">Cursor-Anker (Pagination)<a class="headerlink" href="#indexes-cursor-anker-pagination" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">auto [st, page1] = idx.scanKeysRangeAnchored(
  &quot;users&quot;, &quot;age&quot;,
  /*lower*/ std::nullopt, /*upper*/ std::nullopt,
  /*inclL*/ true, /*inclU*/ true,
  /*limit*/ 50, /*reversed*/ false,
  /*anchor*/ std::nullopt
);

// Nächste Seite (weiter ab letztem (value, pk))
auto last = page1.back(); // PK der letzten Zeile
// den zuletzt gesehenen Wert (age) aus Entity lesen
auto [stE, ents] = idx.scanEntitiesEqual(&quot;users&quot;, &quot;pk&quot;, last);
std::string lastAge = ents.empty()?&quot;&quot;:ents[0].getString(&quot;age&quot;);
auto [st2, page2] = idx.scanKeysRangeAnchored(
  &quot;users&quot;, &quot;age&quot;,
  std::nullopt, std::nullopt,
  true, true,
  50, false,
  std::make_optional(std::make_pair(lastAge, last))
);
</code></pre>
<h3 id="indexes-sparse-index">Sparse-Index<a class="headerlink" href="#indexes-sparse-index" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">idx.createSparseIndex(&quot;users&quot;, &quot;nickname&quot;, /*unique=*/false);
</code></pre>
<p>Leere/fehlende Felder werden nicht indexiert – spart Speicher.</p>
<h3 id="indexes-geo-index">Geo-Index<a class="headerlink" href="#indexes-geo-index" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">idx.createGeoIndex(&quot;places&quot;, &quot;coords&quot;);

BaseEntity p(&quot;p1&quot;);
p.setField(&quot;coords_lat&quot;, &quot;52.52&quot;);
p.setField(&quot;coords_lon&quot;, &quot;13.40&quot;);
idx.put(&quot;places&quot;, p);

auto [st1, inBox] = idx.scanGeoBox(&quot;places&quot;, &quot;coords&quot;, 52.0, 53.0, 13.0, 14.0);
auto [st2, inRadius] = idx.scanGeoRadius(&quot;places&quot;, &quot;coords&quot;, 52.52, 13.40, 5.0 /*km*/);
</code></pre>
<h3 id="indexes-ttl-index">TTL-Index<a class="headerlink" href="#indexes-ttl-index" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">idx.createTTLIndex(&quot;sessions&quot;, &quot;last_seen&quot;, /*ttl_seconds=*/3600);

// Periodisch aufrufen (z. B. CRON/Timer)
auto [st, removed] = idx.cleanupExpiredEntities(&quot;sessions&quot;, &quot;last_seen&quot;);
</code></pre>
<ul>
<li>Beim Put wird ein Ablauf-Timestamp berechnet und als <code>ttlidx:</code>-Eintrag abgelegt.</li>
<li><code>cleanupExpiredEntities</code> löscht abgelaufene Entities und zugehörige Indizes atomar.</li>
</ul>
<h3 id="indexes-fulltext-index">Fulltext-Index<a class="headerlink" href="#indexes-fulltext-index" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">idx.createFulltextIndex(&quot;articles&quot;, &quot;body&quot;);

BaseEntity a(&quot;a1&quot;);
a.setField(&quot;body&quot;, &quot;Fast search with inverted index.&quot;);
idx.put(&quot;articles&quot;, a);

auto [st, hits] = idx.scanFulltext(&quot;articles&quot;, &quot;body&quot;, &quot;fast inverted&quot;);
</code></pre>
<p>Tokens werden whitespace-/punktuationsbasiert extrahiert; Suche nutzt AND-Logik über alle Tokens.</p>
<h2 id="indexes-graph-index-property-graph">Graph-Index (Property Graph)<a class="headerlink" href="#indexes-graph-index-property-graph" title="Permanent link">&para;</a></h2>
<p>Header: <code>index/graph_index.h</code></p>
<p>Funktionen:</p>
<ul>
<li><code>addEdge(edgeEntity)</code> / <code>deleteEdge(edgeId)</code> – atomar via WriteBatch/MVCC</li>
<li><code>outNeighbors(pk)</code> / <code>inNeighbors(pk)</code> – Nachbarschaftsabfragen</li>
<li>Traversierungen: <code>bfs</code>, <code>dijkstra</code>, <code>aStar</code></li>
<li>Zeitliche Varianten: <code>bfsAtTime</code>, <code>dijkstraAtTime</code>, <code>getEdgesInTimeRange</code></li>
</ul>
<p>Edge-Entity-Felder: <code>id</code>, <code>_from</code>, <code>_to</code>, optional <code>_weight</code>, <code>valid_from</code>, <code>valid_to</code></p>
<p>Beispiel:</p>
<pre><code class="language-cpp">GraphIndexManager gidx(db);

BaseEntity e(&quot;edge-1&quot;);
e.setField(&quot;_from&quot;, &quot;chunk-1&quot;);
e.setField(&quot;_to&quot;, &quot;chunk-2&quot;);
e.setField(&quot;_weight&quot;, &quot;1.0&quot;);
gidx.addEdge(e);

auto [st, outs] = gidx.outNeighbors(&quot;chunk-1&quot;);
</code></pre>
<p>Statistiken: <code>getTopologyNodeCount()</code>, <code>getTopologyEdgeCount()</code></p>
<h2 id="indexes-vektorindex-knnann">Vektorindex (KNN/ANN)<a class="headerlink" href="#indexes-vektorindex-knnann" title="Permanent link">&para;</a></h2>
<p>Header: <code>index/vector_index.h</code></p>
<p>Konfiguration und Aufbau:</p>
<pre><code class="language-cpp">VectorIndexManager vix(db);
vix.init(&quot;chunks&quot;, /*dim=*/768, VectorIndexManager::Metric::COSINE, /*M*/16, /*efC*/200, /*ef*/64);

// Entity mit Embedding hinzufügen
BaseEntity c(&quot;chunk-1&quot;);
c.setVector(&quot;embedding&quot;, std::vector&lt;float&gt;(768, 0.1f));
vix.addEntity(c);

// Suche
std::vector&lt;float&gt; q(768, 0.05f);
auto [st, res] = vix.searchKnn(q, 10);
</code></pre>
<p>Hinweise:</p>
<ul>
<li>HNSW optional (compile flag <code>THEMIS_HNSW_ENABLED</code>), sonst Brute-Force Fallback</li>
<li>Persistenz: <code>saveIndex/loadIndex</code> bzw. <code>setAutoSavePath</code> und <code>shutdown()</code></li>
<li>Laufzeit-Tuning: <code>setEfSearch()</code> (Tradeoff Genauigkeit/Latenz)</li>
</ul>
<h2 id="indexes-fehler-und-kantenfalle">Fehler- und Kantenfälle<a class="headerlink" href="#indexes-fehler-und-kantenfalle" title="Permanent link">&para;</a></h2>
<ul>
<li>Leere oder fehlende Felder: werden von Sparse und TTL korrekt behandelt (Sparse: skip; TTL: kein Eintrag).</li>
<li>Typkonflikte: Werte werden als Strings behandelt; sortierte Range-Scans sind lexikografisch (ggf. Vorverarbeitung/Zero-Padding nutzen).</li>
<li>Geo: Ungültige Zahlenwerte werden beim Rebuild/Put übersprungen.</li>
<li>Unique: Verstöße liefern Status mit <code>ok=false</code>.</li>
<li>Graph: Fehlende <code>_from</code>/<code>_to</code>-Felder führen zu <code>Status::Error</code>.</li>
<li>Vektor: Dimension muss konsistent zur Initialisierung sein; falsche Dimension ⇒ <code>Status::Error</code>.</li>
</ul></section><section class="print-page" id="index_stats_maintenance" heading-number="5.2"><h1 id="index_stats_maintenance-index-statistiken-wartung">Index-Statistiken &amp; Wartung<a class="headerlink" href="#index_stats_maintenance-index-statistiken-wartung" title="Permanent link">&para;</a></h1>
<p>Dieses Dokument erklärt die Statistik- und Wartungsfunktionen für Indizes.</p>
<h2 id="index_stats_maintenance-indexstats">IndexStats<a class="headerlink" href="#index_stats_maintenance-indexstats" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">struct IndexStats {
    std::string type;                 // &quot;regular&quot;, &quot;composite&quot;, &quot;range&quot;, &quot;sparse&quot;, &quot;geo&quot;, &quot;ttl&quot;, &quot;fulltext&quot;
    std::string table;                // Tablename
    std::string column;               // Spaltenname bzw. &quot;col1+col2&quot; für Composite
    size_t entry_count = 0;           // Anzahl Index-Einträge
    size_t estimated_size_bytes = 0;  // grobe Schätzung
    bool unique = false;              // Unique-Constraint
    std::string additional_info;      // Typ-spezifisch (z. B. Composite-Spaltenliste, &quot;sorted&quot;, &quot;inverted_index&quot;, TTL)
};
</code></pre>
<ul>
<li>Composite: <code>additional_info</code> enthält die Spaltenliste (z. B. <code>"customer_id, status"</code>).</li>
<li>Range: <code>additional_info = "sorted"</code></li>
<li>Fulltext: <code>additional_info = "inverted_index"</code></li>
<li>TTL: <code>additional_info = "ttl_seconds=&lt;N&gt;"</code></li>
</ul>
<p>Abruf der Statistiken:</p>
<pre><code class="language-cpp">SecondaryIndexManager idx(db);

auto s = idx.getIndexStats(&quot;users&quot;, &quot;email&quot;);
auto all = idx.getAllIndexStats(&quot;users&quot;);
</code></pre>
<p>Zusätzlich stehen Metriken und erweiterte Rebuild-Funktionen zur Verfügung (siehe unten).</p>
<h2 id="index_stats_maintenance-rebuild-eines-index">Rebuild eines Index<a class="headerlink" href="#index_stats_maintenance-rebuild-eines-index" title="Permanent link">&para;</a></h2>
<p>Rebuild löscht alle bestehenden Indexeinträge eines Indexes und baut sie aus den Entities neu auf.</p>
<pre><code class="language-cpp">idx.rebuildIndex(&quot;users&quot;, &quot;email&quot;);        // Single-Column
idx.rebuildIndex(&quot;orders&quot;, &quot;customer_id+status&quot;); // Composite
</code></pre>
<p>Wann sinnvoll?
- Nach manuellen Eingriffen (inkonsistente Index-Keys)
- Nach Bugfixes im Index-Aufbau</p>
<p>Implementierungsdetails:
- Entities werden unter Prefix <code>"&lt;table&gt;:"</code> gescannt (gemäß <code>KeySchema::makeRelationalKey</code>).
- Pro Entity wird der passende Index-Key neu erzeugt und gespeichert.</p>
<h2 id="index_stats_maintenance-reindex-der-gesamten-tabelle">Reindex der gesamten Tabelle<a class="headerlink" href="#index_stats_maintenance-reindex-der-gesamten-tabelle" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">idx.reindexTable(&quot;users&quot;);
</code></pre>
<ul>
<li>Sucht alle Meta-Keys (<code>idxmeta:</code>, <code>ridxmeta:</code>, <code>sidxmeta:</code>, <code>gidxmeta:</code>, <code>ttlidxmeta:</code>, <code>ftidxmeta:</code>) für die Tabelle und führt <code>rebuildIndex</code> je Spalte aus.</li>
</ul>
<h2 id="index_stats_maintenance-ttl-cleanup">TTL-Cleanup<a class="headerlink" href="#index_stats_maintenance-ttl-cleanup" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">auto [st, removed] = idx.cleanupExpiredEntities(&quot;sessions&quot;, &quot;last_seen&quot;);
</code></pre>
<ul>
<li>Löscht abgelaufene Entities und zugehörige Indexeinträge atomar.</li>
<li>Muss regelmäßig aufgerufen werden (Timer/Cron).</li>
</ul>
<h2 id="index_stats_maintenance-rebuild-metriken-query-metriken">Rebuild-Metriken &amp; Query-Metriken<a class="headerlink" href="#index_stats_maintenance-rebuild-metriken-query-metriken" title="Permanent link">&para;</a></h2>
<p>Header: <code>index/secondary_index.h</code></p>
<pre><code class="language-cpp">auto&amp; rbm = idx.getRebuildMetrics();
auto&amp; qm  = idx.getQueryMetrics();

// Counter auslesen (z. B. für Prometheus Exporter)
uint64_t rebuilds   = rbm.rebuild_count.load();
uint64_t durationMs = rbm.rebuild_duration_ms.load();
uint64_t processed  = rbm.rebuild_entities_processed.load();

uint64_t cursorAnchors = qm.cursor_anchor_hits_total.load();
uint64_t rangeSteps    = qm.range_scan_steps_total.load();
</code></pre>
<p>Empfohlene Prometheus-Namen:</p>
<ul>
<li><code>themis_index_rebuild_count</code></li>
<li><code>themis_index_rebuild_duration_ms_total</code></li>
<li><code>themis_index_rebuild_entities_processed_total</code></li>
<li><code>themis_index_cursor_anchor_hits_total</code></li>
<li><code>themis_index_range_scan_steps_total</code></li>
</ul>
<p>Diese Zähler können im HTTP-/Metrics-Endpunkt exponiert werden.</p>
<h2 id="index_stats_maintenance-rebuild-mit-progress-callback">Rebuild mit Progress-Callback<a class="headerlink" href="#index_stats_maintenance-rebuild-mit-progress-callback" title="Permanent link">&para;</a></h2>
<p>Für lange Rebuilds kann ein Fortschritts-Callback registriert werden, der den Fortschritt meldet und Abbruch erlaubt:</p>
<pre><code class="language-cpp">size_t calls = 0;
idx.rebuildIndex(&quot;users&quot;, &quot;email&quot;, [&amp;](size_t done, size_t total){
  ++calls;
  // Logging oder UI-Update
  return true; // false → Rebuild abbrechen
});
</code></pre>
<p>Siehe auch Testfälle in <code>tests/test_index_stats.cpp</code> (Callback wird aufgerufen und kann abbrechen).</p>
<h2 id="index_stats_maintenance-performance-hinweise">Performance-Hinweise<a class="headerlink" href="#index_stats_maintenance-performance-hinweise" title="Permanent link">&para;</a></h2>
<ul>
<li><code>estimated_size_bytes</code> ist eine einfache, konservative Schätzung (Entry-Anzahl * Durchschnittsgröße). Für exakte Größen Messungen auf Key-Ranges durchführen.</li>
<li><code>rebuildIndex</code> und <code>reindexTable</code> sind IO-intensiv. Für große Tabellen ggf. in Wartungsfenstern planen.</li>
<li>Optionaler Fortschritts-Callback kann ergänzt werden (siehe "Ausblick").</li>
</ul>
<p>Zusätzlich:
- Range-Scans mit <code>scanKeysRangeAnchored</code> minimieren Duplikate bei Pagination (Server-Side Cursor).
- Geo- und Fulltext-Indizes können während Rebuilds ausgelassen oder separat reindiziert werden, falls teuer.</p>
<h2 id="index_stats_maintenance-ausblick-progress-callback-optional">Ausblick: Progress-Callback (optional)<a class="headerlink" href="#index_stats_maintenance-ausblick-progress-callback-optional" title="Permanent link">&para;</a></h2>
<p>Geplante API-Idee:</p>
<pre><code class="language-cpp">void rebuildIndex(
    const std::string&amp; table,
    const std::string&amp; column,
    std::function&lt;bool(size_t done, size_t total)&gt; progress // return false -&gt; abbrechen
);
</code></pre>
<p>Verwendung:</p>
<pre><code class="language-cpp">idx.rebuildIndex(&quot;users&quot;, &quot;email&quot;, [](size_t done, size_t total){
  if (done % 10000 == 0) { /* log */ }
  return true; // weiter
});
</code></pre></section><section class="print-page" id="cursor_pagination" heading-number="5.3"><h1 id="cursor_pagination-cursor-based-pagination-in-themis">Cursor-Based Pagination in Themis<a class="headerlink" href="#cursor_pagination-cursor-based-pagination-in-themis" title="Permanent link">&para;</a></h1>
<h2 id="cursor_pagination-overview">Overview<a class="headerlink" href="#cursor_pagination-overview" title="Permanent link">&para;</a></h2>
<p>Themis unterstützt Cursor-basierte Pagination für AQL-Queries. Dabei wird auf Index-Ebene ein effizienter Startpunkt gesetzt (Start-after/Start-before), statt große Offsets zu überspringen.</p>
<h2 id="cursor_pagination-how-it-works-engine">How it works (Engine)<a class="headerlink" href="#cursor_pagination-how-it-works-engine" title="Permanent link">&para;</a></h2>
<ul>
<li>ORDER BY über eine Range-indexierte Spalte aktiviert einen indexbasierten Scan in Sortierreihenfolge.</li>
<li>Der Cursor enthält den Primary Key der zuletzt gelieferten Entity. Der Server lädt die Entity und extrahiert den Wert der Sortierspalte, um einen Anchor (value, pk) zu bilden.</li>
<li>Asc (ASC): Start strictly after (value, pk) – Einträge mit demselben Sortwert und höherem PK kommen danach.</li>
<li>Desc (DESC): Start strictly before (value, pk) – Einträge mit demselben Sortwert und niedrigerem PK kommen davor.</li>
<li>Für die Erkennung von <code>has_more</code> wird <code>LIMIT</code> intern als <code>count + 1</code> an die Engine übergeben und im HTTP-Pfad wieder auf <code>count</code> beschnitten.</li>
</ul>
<p>Diese Logik vermeidet das O(N)-Skipping großer Offsets und skaliert stabil über große Datenmengen.</p>
<h2 id="cursor_pagination-http-api">HTTP API<a class="headerlink" href="#cursor_pagination-http-api" title="Permanent link">&para;</a></h2>
<h3 id="cursor_pagination-request-parameters">Request Parameters<a class="headerlink" href="#cursor_pagination-request-parameters" title="Permanent link">&para;</a></h3>
<p>To enable cursor-based pagination, include the following parameters in your AQL query request:</p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;FOR user IN users SORT user.name ASC LIMIT 10 RETURN user&quot;,
  &quot;use_cursor&quot;: true,
  &quot;cursor&quot;: &quot;optional_cursor_token_from_previous_response&quot;
}
</code></pre>
<p><strong>Parameters:</strong>
- <code>use_cursor</code> (boolean): Set to <code>true</code> to enable cursor pagination
- <code>cursor</code> (string, optional): Token from previous response's <code>next_cursor</code> field to continue pagination</p>
<h3 id="cursor_pagination-response-format">Response Format<a class="headerlink" href="#cursor_pagination-response-format" title="Permanent link">&para;</a></h3>
<p>When <code>use_cursor</code> is enabled, the response format changes from the standard format to:</p>
<pre><code class="language-json">{
  &quot;items&quot;: [ /* array of result entities */ ],
  &quot;has_more&quot;: true,
  &quot;next_cursor&quot;: &quot;base64_encoded_cursor_token&quot;,
  &quot;batch_size&quot;: 10
}
</code></pre>
<p><strong>Response Fields:</strong>
- <code>items</code>: Array of result entities (same format as standard <code>entities</code> field)
- <code>has_more</code>: Boolean indicating if more results are available
- <code>next_cursor</code>: Cursor token to use for fetching the next page (only present if <code>has_more</code> is true)
- <code>batch_size</code>: Number of items in the current batch</p>
<h3 id="cursor_pagination-standard-response-format-without-cursor">Standard Response Format (without cursor)<a class="headerlink" href="#cursor_pagination-standard-response-format-without-cursor" title="Permanent link">&para;</a></h3>
<p>Without <code>use_cursor</code>, the response uses the traditional format:</p>
<pre><code class="language-json">{
  &quot;table&quot;: &quot;users&quot;,
  &quot;count&quot;: 10,
  &quot;entities&quot;: [ /* array of result entities */ ]
}
</code></pre>
<h2 id="cursor_pagination-example-usage">Example Usage<a class="headerlink" href="#cursor_pagination-example-usage" title="Permanent link">&para;</a></h2>
<h3 id="cursor_pagination-first-page">First Page<a class="headerlink" href="#cursor_pagination-first-page" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:8080/query/aql \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;query&quot;: &quot;FOR user IN users SORT user.name ASC LIMIT 10 RETURN user&quot;,
    &quot;use_cursor&quot;: true
  }'
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;items&quot;: [
    {&quot;_key&quot;: &quot;alice&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: &quot;25&quot;},
    {&quot;_key&quot;: &quot;bob&quot;, &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: &quot;30&quot;},
    ...
  ],
  &quot;has_more&quot;: true,
  &quot;next_cursor&quot;: &quot;eyJwayI6ImJvYiIsImNvbGxlY3Rpb24iOiJ1c2VycyIsInZlcnNpb24iOjF9&quot;,
  &quot;batch_size&quot;: 10
}
</code></pre>
<h3 id="cursor_pagination-subsequent-pages">Subsequent Pages<a class="headerlink" href="#cursor_pagination-subsequent-pages" title="Permanent link">&para;</a></h3>
<p>Use the <code>next_cursor</code> from the previous response:</p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/query/aql \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;query&quot;: &quot;FOR user IN users SORT user.name ASC LIMIT 10 RETURN user&quot;,
    &quot;use_cursor&quot;: true,
    &quot;cursor&quot;: &quot;eyJwayI6ImJvYiIsImNvbGxlY3Rpb24iOiJ1c2VycyIsInZlcnNpb24iOjF9&quot;
  }'
</code></pre>
<h3 id="cursor_pagination-last-page">Last Page<a class="headerlink" href="#cursor_pagination-last-page" title="Permanent link">&para;</a></h3>
<p>When there are no more results, <code>has_more</code> will be <code>false</code> and <code>next_cursor</code> will not be present:</p>
<pre><code class="language-json">{
  &quot;items&quot;: [
    {&quot;_key&quot;: &quot;zack&quot;, &quot;name&quot;: &quot;Zack&quot;, &quot;age&quot;: &quot;28&quot;}
  ],
  &quot;has_more&quot;: false,
  &quot;batch_size&quot;: 1
}
</code></pre>
<h2 id="cursor_pagination-cursor-format">Cursor Format<a class="headerlink" href="#cursor_pagination-cursor-format" title="Permanent link">&para;</a></h2>
<p>Cursors are Base64-encoded JSON objects containing:
- <code>pk</code>: Primary key of the last item in the current page
- <code>collection</code>: Name of the collection being queried
- <code>version</code>: Cursor format version (for future compatibility)</p>
<p>Example decoded cursor:</p>
<pre><code class="language-json">{
  &quot;pk&quot;: &quot;users:bob&quot;,
  &quot;collection&quot;: &quot;users&quot;,
  &quot;version&quot;: 1
}
</code></pre>
<h2 id="cursor_pagination-edge-cases-semantics">Edge Cases &amp; Semantics<a class="headerlink" href="#cursor_pagination-edge-cases-semantics" title="Permanent link">&para;</a></h2>
<ul>
<li>Ties (gleicher Sortwert): Reihenfolge ist deterministisch durch PK-Tiebreaker. Cursor-Anker verwendet (value, pk), dadurch keine Duplikate/Übersprünge zwischen Seiten.</li>
<li>DESC-Reihenfolge: Start-before-Verhalten spiegelt die absteigende Sortierung korrekt wider, <code>has_more</code> wird via <code>count+1</code> erkannt.</li>
<li>Kombination mit Filtern: Cursor-Position respektiert die aktive Filtermenge; Seiten sind konsistent mit den Filterbedingungen.</li>
<li>Ungültiger Cursor: Der Server antwortet mit HTTP 400 (Bad Request) und einer Fehlernachricht.</li>
</ul>
<h2 id="cursor_pagination-notes-limitations">Notes &amp; Limitations<a class="headerlink" href="#cursor_pagination-notes-limitations" title="Permanent link">&para;</a></h2>
<ul>
<li>Für Cursor-Pagination ist eine sortierende Spalte mit Range-Index empfohlen, damit der indexbasierte Scan greift.</li>
<li>Ohne ORDER BY kann <code>use_cursor</code> verwendet werden, jedoch ist die Ordnung dann implizit nach PK; für reproduzierbares Paging wird eine Sortierung empfohlen.</li>
</ul>
<h2 id="cursor_pagination-error-handling">Error Handling<a class="headerlink" href="#cursor_pagination-error-handling" title="Permanent link">&para;</a></h2>
<h3 id="cursor_pagination-invalid-cursor">Invalid Cursor<a class="headerlink" href="#cursor_pagination-invalid-cursor" title="Permanent link">&para;</a></h3>
<p>If an invalid or expired cursor token is provided, the server returns a 400 Bad Request:</p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;Invalid or expired cursor&quot;
}
</code></pre>
<h3 id="cursor_pagination-collection-mismatch">Collection Mismatch<a class="headerlink" href="#cursor_pagination-collection-mismatch" title="Permanent link">&para;</a></h3>
<p>If the cursor was generated for a different collection, the server returns a 400 Bad Request:</p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;Cursor collection mismatch (expected: users, got: products)&quot;
}
</code></pre>
<h2 id="cursor_pagination-best-practices">Best Practices<a class="headerlink" href="#cursor_pagination-best-practices" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Always check <code>has_more</code></strong>: Don't assume there are more results based on batch size alone</li>
<li><strong>Store cursors short-term</strong>: Cursors are stateless but may become invalid if underlying data changes significantly</li>
<li><strong>Use consistent queries</strong>: The same query should be used across pagination requests (same SORT, FILTER, etc.)</li>
<li><strong>Handle errors gracefully</strong>: If a cursor becomes invalid, restart pagination from the beginning</li>
<li><strong>Combine with LIMIT</strong>: Use reasonable LIMIT values to control page size (recommended: 10-100 items)</li>
</ol>
<h2 id="cursor_pagination-comparison-with-offset-pagination">Comparison with Offset Pagination<a class="headerlink" href="#cursor_pagination-comparison-with-offset-pagination" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Cursor-Based</th>
<th>Offset-Based</th>
</tr>
</thead>
<tbody>
<tr>
<td>Performance</td>
<td>O(1) resume</td>
<td>O(N) skip</td>
</tr>
<tr>
<td>Consistency</td>
<td>Stable across pages</td>
<td>May skip/duplicate if data changes</td>
</tr>
<tr>
<td>Stateless</td>
<td>Yes (token-based)</td>
<td>Yes</td>
</tr>
<tr>
<td>Use Case</td>
<td>Large datasets, real-time data</td>
<td>Small datasets, random access</td>
</tr>
<tr>
<td>Current Support</td>
<td>✅ Implemented</td>
<td>✅ Implemented</td>
</tr>
</tbody>
</table>
<h2 id="cursor_pagination-see-also">See Also<a class="headerlink" href="#cursor_pagination-see-also" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#aql_syntax">AQL Syntax Guide</a></li>
<li><a href="#aql_explain_profile">AQL EXPLAIN/PROFILE</a></li>
<li><a href="../openapi/openapi.yaml">HTTP API Reference</a></li>
</ul></section></section>
                    <section class='print-page md-section' id='section-6' heading-number='6'>
                        <h1>Query & AQL<a class='headerlink' href='#section-6' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="query_engine_aql" heading-number="6.1"><h1 id="query_engine_aql-query-engine-aql-themis">Query Engine &amp; AQL – THEMIS<a class="headerlink" href="#query_engine_aql-query-engine-aql-themis" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 2.0<br />
<strong>Status:</strong> Implementiert (MVP)<br />
<strong>Letzte Aktualisierung:</strong> 2. November 2025</p>
<hr />
<h2 id="query_engine_aql-uberblick">Überblick<a class="headerlink" href="#query_engine_aql-uberblick" title="Permanent link">&para;</a></h2>
<p>Das <strong>Query Engine &amp; AQL</strong>-System von THEMIS besteht aus mehreren Komponenten, die zusammen eine effiziente Ausführung von Multi-Modell-Queries ermöglichen:</p>
<ol>
<li><strong>AQL (Advanced Query Language)</strong> – SQL-ähnliche deklarative Query-Sprache</li>
<li><strong>AQL Parser</strong> – Lexer &amp; Parser für AQL → AST</li>
<li><strong>AQL Translator</strong> – AST → Ausführungspläne (ConjunctiveQuery, JoinQuery, TraversalQuery)</li>
<li><strong>Query Optimizer</strong> – Kardinalitätsschätzung &amp; Index-Auswahl</li>
<li><strong>Query Engine</strong> – Ausführung mit Index-/Full-Scan-Support</li>
</ol>
<hr />
<h2 id="query_engine_aql-1-aql-advanced-query-language">1. AQL – Advanced Query Language<a class="headerlink" href="#query_engine_aql-1-aql-advanced-query-language" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-11-design-prinzipien">1.1 Design-Prinzipien<a class="headerlink" href="#query_engine_aql-11-design-prinzipien" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ <strong>Einfach:</strong> SQL-ähnliche Syntax (FOR, FILTER, SORT, LIMIT, RETURN)</li>
<li>✅ <strong>Mächtig:</strong> Multi-Modell-Support (Relational, Graph, Vector)</li>
<li>✅ <strong>Optimierbar:</strong> Automatische Index-Auswahl via Optimizer</li>
<li>✅ <strong>Erweiterbar:</strong> Schrittweise Features (LET, COLLECT, Joins)</li>
</ul>
<h3 id="query_engine_aql-12-grundstruktur">1.2 Grundstruktur<a class="headerlink" href="#query_engine_aql-12-grundstruktur" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR variable IN collection
  [LET var = expression [, ...]]
  [FILTER condition]
  [SORT expression [ASC|DESC] [, ...]]
  [LIMIT offset, count]
  [RETURN expression]
</code></pre>
<p><strong>Execution-Reihenfolge:</strong>
1. <code>FOR</code> – Iteration über Collection/Index
2. <code>FILTER</code> – Prädikat-Evaluation (mit Index-Nutzung)
3. <code>SORT</code> – Sortierung (mit Range-Index wenn möglich)
4. <code>LIMIT</code> – Pagination/Offset
5. <code>RETURN</code> – Projektion</p>
<h3 id="query_engine_aql-13-query-typen">1.3 Query-Typen<a class="headerlink" href="#query_engine_aql-13-query-typen" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Typ</th>
<th>FOR-Klauseln</th>
<th>Features</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Relational</strong></td>
<td>1</td>
<td>FILTER, SORT, LIMIT, RETURN</td>
<td><code>FOR u IN users FILTER u.age &gt; 18</code></td>
</tr>
<tr>
<td><strong>Join</strong></td>
<td>2+</td>
<td>Multi-FOR, JOIN-Bedingungen</td>
<td><code>FOR u IN users FOR o IN orders FILTER o.user_id == u._key</code></td>
</tr>
<tr>
<td><strong>Graph Traversal</strong></td>
<td>1 (speziell)</td>
<td>BFS, Depth-Limits, FILTER auf v/e</td>
<td><code>FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social'</code></td>
</tr>
<tr>
<td><strong>Vector Search</strong></td>
<td>1</td>
<td>NEAR(), k-NN</td>
<td><code>FOR doc IN articles NEAR(doc.embedding, @vec, 10)</code></td>
</tr>
<tr>
<td><strong>Aggregation</strong></td>
<td>1</td>
<td>COLLECT, AGGREGATE (SUM/AVG/etc.)</td>
<td><code>FOR sale IN sales COLLECT cat = sale.category AGGREGATE total = SUM(sale.amount)</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="query_engine_aql-2-aql-parser">2. AQL Parser<a class="headerlink" href="#query_engine_aql-2-aql-parser" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-21-komponenten">2.1 Komponenten<a class="headerlink" href="#query_engine_aql-21-komponenten" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class AQLParser {
public:
    struct ParseResult {
        bool success;
        std::string error_message;
        std::shared_ptr&lt;Query&gt; ast;  // Root AST Node
    };

    ParseResult parse(std::string_view query);
};
</code></pre>
<h3 id="query_engine_aql-22-ast-struktur">2.2 AST-Struktur<a class="headerlink" href="#query_engine_aql-22-ast-struktur" title="Permanent link">&para;</a></h3>
<p><strong>Node-Typen:</strong></p>
<pre><code class="language-cpp">enum class ASTNodeType {
    // Query Nodes
    Query,              // Root
    ForNode,            // FOR variable IN collection
    FilterNode,         // FILTER condition
    SortNode,           // SORT expr [ASC|DESC]
    LimitNode,          // LIMIT offset, count
    ReturnNode,         // RETURN expression
    LetNode,            // LET variable = expression
    CollectNode,        // COLLECT ... AGGREGATE ...

    // Expressions
    BinaryOp,           // ==, !=, &gt;, &lt;, AND, OR, +, -, *, /
    UnaryOp,            // NOT, -
    FunctionCall,       // CONCAT, SUM, etc.
    FieldAccess,        // doc.field
    Literal,            // &quot;string&quot;, 123, true, null
    Variable,           // doc, user
    ArrayLiteral,       // [1, 2, 3]
    ObjectConstruct     // {name: doc.name, age: doc.age}
};
</code></pre>
<p><strong>Beispiel-AST:</strong></p>
<pre><code class="language-aql">FOR u IN users 
FILTER u.age &gt; 18 AND u.city == &quot;Berlin&quot;
RETURN u.name
</code></pre>
<p>→ AST:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Query&quot;,
  &quot;children&quot;: [
    {
      &quot;type&quot;: &quot;ForNode&quot;,
      &quot;variable&quot;: &quot;u&quot;,
      &quot;collection&quot;: &quot;users&quot;
    },
    {
      &quot;type&quot;: &quot;FilterNode&quot;,
      &quot;condition&quot;: {
        &quot;type&quot;: &quot;BinaryOp&quot;,
        &quot;operator&quot;: &quot;AND&quot;,
        &quot;left&quot;: {
          &quot;type&quot;: &quot;BinaryOp&quot;,
          &quot;operator&quot;: &quot;&gt;&quot;,
          &quot;left&quot;: {&quot;type&quot;: &quot;FieldAccess&quot;, &quot;variable&quot;: &quot;u&quot;, &quot;field&quot;: &quot;age&quot;},
          &quot;right&quot;: {&quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 18}
        },
        &quot;right&quot;: {
          &quot;type&quot;: &quot;BinaryOp&quot;,
          &quot;operator&quot;: &quot;==&quot;,
          &quot;left&quot;: {&quot;type&quot;: &quot;FieldAccess&quot;, &quot;variable&quot;: &quot;u&quot;, &quot;field&quot;: &quot;city&quot;},
          &quot;right&quot;: {&quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;Berlin&quot;}
        }
      }
    },
    {
      &quot;type&quot;: &quot;ReturnNode&quot;,
      &quot;expression&quot;: {&quot;type&quot;: &quot;FieldAccess&quot;, &quot;variable&quot;: &quot;u&quot;, &quot;field&quot;: &quot;name&quot;}
    }
  ]
}
</code></pre>
<h3 id="query_engine_aql-23-operatoren">2.3 Operatoren<a class="headerlink" href="#query_engine_aql-23-operatoren" title="Permanent link">&para;</a></h3>
<p><strong>Binary Operators:</strong></p>
<pre><code class="language-cpp">enum class BinaryOperator {
    // Comparison
    Eq, Neq, Lt, Lte, Gt, Gte,      // ==, !=, &lt;, &lt;=, &gt;, &gt;=

    // Logical
    And, Or, Xor,                    // AND, OR, XOR

    // Arithmetic
    Add, Sub, Mul, Div, Mod,         // +, -, *, /, %

    // Membership
    In                               // IN
};
</code></pre>
<p><strong>Unary Operators:</strong></p>
<pre><code class="language-cpp">enum class UnaryOperator {
    Not,                // NOT
    Minus,              // - (unary)
    Plus                // + (unary)
};
</code></pre>
<hr />
<h2 id="query_engine_aql-3-aql-translator">3. AQL Translator<a class="headerlink" href="#query_engine_aql-3-aql-translator" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-31-ubersetzungsstrategien">3.1 Übersetzungsstrategien<a class="headerlink" href="#query_engine_aql-31-ubersetzungsstrategien" title="Permanent link">&para;</a></h3>
<p>Der Translator wandelt AST in ausführbare Query-Pläne um:</p>
<pre><code class="language-cpp">class AQLTranslator {
public:
    struct TranslationResult {
        bool success;
        std::string error_message;

        // Single-FOR: Relational Query
        ConjunctiveQuery query;

        // Multi-FOR: Join Query
        std::optional&lt;JoinQuery&gt; join;

        // Graph: Traversal Query
        std::optional&lt;TraversalQuery&gt; traversal;
    };

    TranslationResult translate(std::shared_ptr&lt;Query&gt; ast);
};
</code></pre>
<h3 id="query_engine_aql-32-relational-query-translation">3.2 Relational Query Translation<a class="headerlink" href="#query_engine_aql-32-relational-query-translation" title="Permanent link">&para;</a></h3>
<p><strong>Eingabe:</strong></p>
<pre><code class="language-aql">FOR u IN users 
FILTER u.age &gt; 18 AND u.city == &quot;Berlin&quot;
SORT u.created_at DESC
LIMIT 10
RETURN u
</code></pre>
<p><strong>Ausgabe (ConjunctiveQuery):</strong></p>
<pre><code class="language-cpp">ConjunctiveQuery {
    table: &quot;users&quot;,
    predicates: [
        {column: &quot;city&quot;, op: Eq, value: &quot;Berlin&quot;}
    ],
    rangePredicates: [
        {column: &quot;age&quot;, lower: &quot;18&quot;, includeLower: false, op: Gt}
    ],
    orderBy: {
        column: &quot;created_at&quot;,
        desc: true,
        limit: 10
    }
}
</code></pre>
<h3 id="query_engine_aql-33-join-query-translation">3.3 Join Query Translation<a class="headerlink" href="#query_engine_aql-33-join-query-translation" title="Permanent link">&para;</a></h3>
<p><strong>Eingabe:</strong></p>
<pre><code class="language-aql">FOR u IN users
FOR o IN orders
FILTER o.user_id == u._key
RETURN {user: u.name, order: o.id}
</code></pre>
<p><strong>Ausgabe (JoinQuery):</strong></p>
<pre><code class="language-cpp">JoinQuery {
    for_nodes: [
        {variable: &quot;u&quot;, collection: &quot;users&quot;},
        {variable: &quot;o&quot;, collection: &quot;orders&quot;}
    ],
    filters: [
        {op: Eq, left: &quot;o.user_id&quot;, right: &quot;u._key&quot;}  // Join-Bedingung
    ],
    return_node: ObjectConstruct{...}
}
</code></pre>
<h3 id="query_engine_aql-34-graph-traversal-translation">3.4 Graph Traversal Translation<a class="headerlink" href="#query_engine_aql-34-graph-traversal-translation" title="Permanent link">&para;</a></h3>
<p><strong>Eingabe:</strong></p>
<pre><code class="language-aql">FOR v, e, p IN 1..3 OUTBOUND 'user1' GRAPH 'social'
FILTER v.age &gt; 18
RETURN v
</code></pre>
<p><strong>Ausgabe (TraversalQuery):</strong></p>
<pre><code class="language-cpp">TraversalQuery {
    variable: &quot;v&quot;,
    minDepth: 1,
    maxDepth: 3,
    direction: Outbound,
    startVertex: &quot;user1&quot;,
    graphName: &quot;social&quot;,
    filters: [{column: &quot;age&quot;, op: Gt, value: &quot;18&quot;}]
}
</code></pre>
<hr />
<h2 id="query_engine_aql-4-query-optimizer">4. Query Optimizer<a class="headerlink" href="#query_engine_aql-4-query-optimizer" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-41-kardinalitatsschatzung">4.1 Kardinalitätsschätzung<a class="headerlink" href="#query_engine_aql-41-kardinalitatsschatzung" title="Permanent link">&para;</a></h3>
<p>Der Optimizer schätzt Selektivitäten von Prädikaten und ordnet sie optimal:</p>
<pre><code class="language-cpp">class QueryOptimizer {
public:
    struct Estimation {
        PredicateEq pred;
        size_t estimatedCount;
        bool capped;  // true wenn &gt;= maxProbe
    };

    struct Plan {
        std::vector&lt;PredicateEq&gt; orderedPredicates;  // Sortiert nach Selektivität
        std::vector&lt;Estimation&gt; details;
    };

    Plan chooseOrderForAndQuery(const ConjunctiveQuery&amp; q, size_t maxProbe = 1000);
};
</code></pre>
<h3 id="query_engine_aql-42-optimierungs-strategie">4.2 Optimierungs-Strategie<a class="headerlink" href="#query_engine_aql-42-optimierungs-strategie" title="Permanent link">&para;</a></h3>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-aql">FOR u IN users 
FILTER u.age &gt; 18 AND u.city == &quot;Berlin&quot;
</code></pre>
<p><strong>Schätzung:</strong>
- <code>city == "Berlin"</code>: ~100 Treffer (selektiv!)
- <code>age &gt; 18</code>: ~5000 Treffer (weniger selektiv)</p>
<p><strong>Optimaler Plan:</strong>
1. Scan <code>city == "Berlin"</code> → 100 Keys
2. Für jeden Key: Check <code>age &gt; 18</code> → ~80 finale Treffer</p>
<p><strong>Vorteil:</strong> Nur 100 Entity-Loads statt 5000!</p>
<h3 id="query_engine_aql-43-index-auswahl">4.3 Index-Auswahl<a class="headerlink" href="#query_engine_aql-43-index-auswahl" title="Permanent link">&para;</a></h3>
<p><strong>Verfügbare Strategien:</strong></p>
<pre><code class="language-cpp">enum class QueryMode {
    IndexOptimized,      // Optimizer-gesteuert (Kardinalitätsschätzung)
    IndexParallel,       // Parallele Scans + AND-Merge (für kleine Datasets)
    FullScanFallback,    // Sequential Scan (nur mit allow_full_scan=true)
    IndexRangeAware      // Range-Index + Sortierung direkt
};
</code></pre>
<p><strong>Beispiel-Plan (EXPLAIN):</strong></p>
<pre><code class="language-json">{
  &quot;plan&quot;: {
    &quot;mode&quot;: &quot;index_optimized&quot;,
    &quot;order&quot;: [
      {&quot;column&quot;: &quot;city&quot;, &quot;value&quot;: &quot;Berlin&quot;},
      {&quot;column&quot;: &quot;age&quot;, &quot;value&quot;: &quot;18&quot;}
    ],
    &quot;estimates&quot;: [
      {&quot;column&quot;: &quot;city&quot;, &quot;value&quot;: &quot;Berlin&quot;, &quot;estimatedCount&quot;: 100, &quot;capped&quot;: false},
      {&quot;column&quot;: &quot;age&quot;, &quot;value&quot;: &quot;18&quot;, &quot;estimatedCount&quot;: 5000, &quot;capped&quot;: false}
    ]
  }
}
</code></pre>
<hr />
<h2 id="query_engine_aql-5-query-engine">5. Query Engine<a class="headerlink" href="#query_engine_aql-5-query-engine" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-51-ausfuhrungs-pipeline">5.1 Ausführungs-Pipeline<a class="headerlink" href="#query_engine_aql-51-ausfuhrungs-pipeline" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class QueryEngine {
public:
    struct Status {
        bool ok;
        std::string message;
    };

    // Relational Query (Single-FOR)
    std::pair&lt;Status, std::vector&lt;std::string&gt;&gt; 
    executeConjunctiveKeys(const ConjunctiveQuery&amp; q);

    std::pair&lt;Status, std::vector&lt;BaseEntity&gt;&gt; 
    executeConjunctiveEntities(const ConjunctiveQuery&amp; q);

    // Join Query (Multi-FOR)
    std::pair&lt;Status, std::vector&lt;nlohmann::json&gt;&gt; 
    executeJoin(const JoinQuery&amp; join);

    // Graph Traversal (BFS)
    std::pair&lt;Status, std::vector&lt;BaseEntity&gt;&gt; 
    executeTraversal(const TraversalQuery&amp; trav);
};
</code></pre>
<h3 id="query_engine_aql-52-relational-execution">5.2 Relational Execution<a class="headerlink" href="#query_engine_aql-52-relational-execution" title="Permanent link">&para;</a></h3>
<p><strong>Schritt-für-Schritt:</strong></p>
<ol>
<li><strong>Optimizer:</strong> Schätze Selektivitäten → Sortiere Prädikate</li>
<li><strong>Index-Scan:</strong> Starte mit selektivstem Prädikat</li>
<li><strong>Filter-Chain:</strong> Wende weitere Prädikate an</li>
<li><strong>Sort/Limit:</strong> Nutze Range-Index wenn möglich</li>
<li><strong>Return:</strong> Projiziere Felder</li>
</ol>
<p><strong>Code-Flow (vereinfacht):</strong></p>
<pre><code class="language-cpp">auto [status, keys] = idx.scanKeysEqual(&quot;users&quot;, &quot;city&quot;, &quot;Berlin&quot;);  // 100 Keys
std::vector&lt;std::string&gt; filtered;
for (const auto&amp; key : keys) {
    auto entity = loadEntity(key);
    if (entity.getFieldAsInt(&quot;age&quot;) &gt; 18) {  // Range-Filter
        filtered.push_back(key);
    }
}
// Sort/Limit...
</code></pre>
<h3 id="query_engine_aql-53-join-execution-nested-loop">5.3 Join Execution (Nested-Loop)<a class="headerlink" href="#query_engine_aql-53-join-execution-nested-loop" title="Permanent link">&para;</a></h3>
<p><strong>Algorithmus:</strong></p>
<pre><code class="language-cpp">std::vector&lt;nlohmann::json&gt; results;
for (const auto&amp; uKey : getUserKeys()) {
    auto user = loadEntity(&quot;users&quot;, uKey);
    for (const auto&amp; oKey : getOrderKeys()) {
        auto order = loadEntity(&quot;orders&quot;, oKey);
        if (order.getField(&quot;user_id&quot;) == user.getField(&quot;_key&quot;)) {  // Join-Bedingung
            results.push_back({
                {&quot;user&quot;, user.getField(&quot;name&quot;)},
                {&quot;order&quot;, order.getField(&quot;id&quot;)}
            });
        }
    }
}
</code></pre>
<p><strong>Performance-Hinweise:</strong>
- ⚠️ O(n×m) Komplexität (teuer bei großen Collections)
- 💡 Nutze Indizes auf Join-Spalten (<code>user_id</code>)
- 💡 Geplant: Hash-Join für große Collections</p>
<h3 id="query_engine_aql-54-graph-traversal-bfs">5.4 Graph Traversal (BFS)<a class="headerlink" href="#query_engine_aql-54-graph-traversal-bfs" title="Permanent link">&para;</a></h3>
<p><strong>BFS-Algorithmus mit Pruning:</strong></p>
<pre><code class="language-cpp">std::queue&lt;Node&gt; frontier;
std::unordered_set&lt;std::string&gt; visited;
frontier.push({startVertex, depth: 0});

while (!frontier.empty()) {
    auto node = frontier.front(); frontier.pop();
    if (visited.count(node.pk)) continue;
    visited.insert(node.pk);

    if (node.depth &gt;= minDepth) {
        auto entity = loadEntity(node.pk);
        if (evalFilters(entity)) {  // v.age &gt; 18
            results.push_back(entity);
        }
    }

    if (node.depth &lt; maxDepth) {
        auto neighbors = getNeighbors(node.pk, direction);
        for (const auto&amp; nb : neighbors) {
            if (node.depth + 1 == maxDepth) {
                // Konservatives Pruning am letzten Level
                auto e = loadEntity(nb.pk);
                if (!evalFilters(e)) {
                    pruned_last_level++;
                    continue;
                }
            }
            frontier.push({nb.pk, node.depth + 1});
        }
    }
}
</code></pre>
<p><strong>Metriken (siehe EXPLAIN):</strong>
- <code>edges_expanded</code>: Anzahl inspizierter Kanten
- <code>pruned_last_level</code>: Durch Filter gedroppt
- <code>frontier_processed_per_depth</code>: BFS-Expansion pro Level</p>
<hr />
<h2 id="query_engine_aql-6-explain-profile">6. EXPLAIN &amp; PROFILE<a class="headerlink" href="#query_engine_aql-6-explain-profile" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-61-explain-usage">6.1 EXPLAIN Usage<a class="headerlink" href="#query_engine_aql-61-explain-usage" title="Permanent link">&para;</a></h3>
<p><strong>HTTP Request:</strong></p>
<pre><code class="language-http">POST /query/aql
Content-Type: application/json

{
  &quot;query&quot;: &quot;FOR u IN users FILTER u.age &gt; 18 AND u.city == 'Berlin' RETURN u&quot;,
  &quot;explain&quot;: true
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;FOR u IN users FILTER u.age &gt; 18 AND u.city == 'Berlin' RETURN u&quot;,
  &quot;ast&quot;: {...},
  &quot;plan&quot;: {
    &quot;mode&quot;: &quot;index_optimized&quot;,
    &quot;order&quot;: [
      {&quot;column&quot;: &quot;city&quot;, &quot;value&quot;: &quot;Berlin&quot;},
      {&quot;column&quot;: &quot;age&quot;, &quot;value&quot;: &quot;18&quot;}
    ],
    &quot;estimates&quot;: [
      {&quot;column&quot;: &quot;city&quot;, &quot;value&quot;: &quot;Berlin&quot;, &quot;estimatedCount&quot;: 100, &quot;capped&quot;: false},
      {&quot;column&quot;: &quot;age&quot;, &quot;value&quot;: &quot;18&quot;, &quot;estimatedCount&quot;: 5000, &quot;capped&quot;: false}
    ]
  }
}
</code></pre>
<h3 id="query_engine_aql-62-traversal-metrics">6.2 Traversal Metrics<a class="headerlink" href="#query_engine_aql-62-traversal-metrics" title="Permanent link">&para;</a></h3>
<p><strong>Graph-Query:</strong></p>
<pre><code class="language-aql">FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social' 
FILTER v.age &gt; 30 
RETURN v
</code></pre>
<p><strong>Metrics:</strong></p>
<pre><code class="language-json">{
  &quot;metrics&quot;: {
    &quot;edges_expanded&quot;: 156,
    &quot;pruned_last_level&quot;: 23,
    &quot;filter_evaluations_total&quot;: 89,
    &quot;filter_short_circuits&quot;: 12,
    &quot;frontier_processed_per_depth&quot;: {
      &quot;0&quot;: 1,
      &quot;1&quot;: 5,
      &quot;2&quot;: 18,
      &quot;3&quot;: 65
    }
  }
}
</code></pre>
<p><strong>Interpretation:</strong>
- <strong>edges_expanded</strong>: 156 Kanten inspiziert (BFS-Kosten)
- <strong>pruned_last_level</strong>: 23 Vertices am letzten Level gedroppt (Filter wirkt!)
- <strong>filter_short_circuits</strong>: 12 AND-Short-Circuits (Effizienz)</p>
<h3 id="query_engine_aql-63-cursor-pagination-metrics">6.3 Cursor Pagination Metrics<a class="headerlink" href="#query_engine_aql-63-cursor-pagination-metrics" title="Permanent link">&para;</a></h3>
<p><strong>Relational Query mit Cursor:</strong></p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;FOR u IN users SORT u.created_at DESC LIMIT 10 RETURN u&quot;,
  &quot;use_cursor&quot;: true
}
</code></pre>
<p><strong>Plan-Details:</strong></p>
<pre><code class="language-json">{
  &quot;plan&quot;: {
    &quot;mode&quot;: &quot;index_rangeaware&quot;,
    &quot;cursor&quot;: {
      &quot;used&quot;: true,
      &quot;cursor_present&quot;: false,
      &quot;sort_column&quot;: &quot;created_at&quot;,
      &quot;effective_limit&quot;: 11,
      &quot;anchor_set&quot;: false,
      &quot;requested_count&quot;: 10
    }
  }
}
</code></pre>
<p><strong>Prometheus Metrics:</strong>
- <code>vccdb_cursor_anchor_hits_total</code>: Cursor-Anker-Verwendungen
- <code>vccdb_range_scan_steps_total</code>: Besuchte Index-Einträge
- <code>vccdb_page_fetch_time_ms_*</code>: Seitenerzeugung-Dauer</p>
<hr />
<h2 id="query_engine_aql-7-best-practices">7. Best Practices<a class="headerlink" href="#query_engine_aql-7-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-71-query-optimierung">7.1 Query-Optimierung<a class="headerlink" href="#query_engine_aql-71-query-optimierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">-- ✅ RICHTIG: Selektive Filter zuerst
FOR u IN users 
FILTER u.city == &quot;SmallTown&quot; AND u.age &gt; 18  -- city sehr selektiv!
RETURN u

-- ❌ FALSCH: Unselektive Filter zuerst
FOR u IN users 
FILTER u.age &gt; 18 AND u.city == &quot;SmallTown&quot;  -- age wenig selektiv
RETURN u
</code></pre>
<h3 id="query_engine_aql-72-index-nutzung">7.2 Index-Nutzung<a class="headerlink" href="#query_engine_aql-72-index-nutzung" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">-- ✅ RICHTIG: Index auf age + city
CREATE INDEX idx_users_age ON users(age)
CREATE INDEX idx_users_city ON users(city)

FOR u IN users 
FILTER u.age &gt; 18 AND u.city == &quot;Berlin&quot;  -- Beide Indizes genutzt!
RETURN u

-- ❌ FALSCH: Kein Index → Full Scan
FOR u IN users 
FILTER u.random_field == &quot;value&quot;  -- Kein Index!
RETURN u
</code></pre>
<h3 id="query_engine_aql-73-joins-minimieren">7.3 Joins minimieren<a class="headerlink" href="#query_engine_aql-73-joins-minimieren" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">-- ✅ RICHTIG: Filter vor Join
FOR u IN users 
FILTER u.active == true           -- Reduziert u-Set!
FOR o IN orders 
FILTER o.user_id == u._key
RETURN {user: u.name, order: o.id}

-- ❌ FALSCH: Kein Filter → Großer Cross-Product
FOR u IN users 
FOR o IN orders 
FILTER o.user_id == u._key        -- Erst nach Cross-Product!
RETURN {user: u.name, order: o.id}
</code></pre>
<h3 id="query_engine_aql-74-graph-traversals">7.4 Graph-Traversals<a class="headerlink" href="#query_engine_aql-74-graph-traversals" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">-- ✅ RICHTIG: Depth begrenzen
FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social'  -- Max 3 Hops
FILTER v.age &gt; 30
RETURN v

-- ❌ FALSCH: Unbegrenzte Depth
FOR v IN 1..10 OUTBOUND 'user1' GRAPH 'social'  -- Exponentielles Wachstum!
RETURN v
</code></pre>
<hr />
<h2 id="query_engine_aql-8-limitierungen-mvp">8. Limitierungen (MVP)<a class="headerlink" href="#query_engine_aql-8-limitierungen-mvp" title="Permanent link">&para;</a></h2>
<h3 id="query_engine_aql-81-aktuelle-einschrankungen">8.1 Aktuelle Einschränkungen<a class="headerlink" href="#query_engine_aql-81-aktuelle-einschrankungen" title="Permanent link">&para;</a></h3>
<ul>
<li>❌ <strong>OR-Support:</strong> Nur AND im Translator (OR in Arbeit)</li>
<li>❌ <strong>Feld-zu-Feld-Vergleiche:</strong> <code>u.city == o.city</code> nicht generisch (nur in Join-Bedingungen)</li>
<li>❌ <strong>Subqueries:</strong> Noch nicht implementiert</li>
<li>❌ <strong>Hash-Join:</strong> Nur Nested-Loop-Joins (O(n×m))</li>
<li>❌ <strong>Complex Functions:</strong> CONCAT, SUBSTRING in Entwicklung</li>
</ul>
<h3 id="query_engine_aql-82-geplante-erweiterungen">8.2 Geplante Erweiterungen<a class="headerlink" href="#query_engine_aql-82-geplante-erweiterungen" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] <strong>OR-Support:</strong> Disjunktive Prädikate</li>
<li>[ ] <strong>Hash-Join:</strong> Für große Collections</li>
<li>[ ] <strong>Subqueries:</strong> Nested Queries</li>
<li>[ ] <strong>Window Functions:</strong> ROW_NUMBER, RANK</li>
<li>[ ] <strong>CTEs (WITH):</strong> Common Table Expressions</li>
<li>[ ] <strong>UPSERT:</strong> INSERT ... ON CONFLICT UPDATE</li>
</ul>
<hr />
<h2 id="query_engine_aql-referenzen">Referenzen<a class="headerlink" href="#query_engine_aql-referenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>AQL Syntax:</strong> <a href="#aql_syntax">aql_syntax.md</a></li>
<li><strong>EXPLAIN &amp; PROFILE:</strong> <a href="#aql_explain_profile">aql_explain_profile.md</a></li>
<li><strong>Parser:</strong> <code>include/query/aql_parser.h</code></li>
<li><strong>Translator:</strong> <code>include/query/aql_translator.h</code></li>
<li><strong>Optimizer:</strong> <code>include/query/query_optimizer.h</code></li>
<li><strong>Engine:</strong> <code>include/query/query_engine.h</code></li>
<li><strong>Cursor Pagination:</strong> <a href="#cursor_pagination">cursor_pagination.md</a></li>
<li><strong>Indexes:</strong> <a href="#indexes">indexes.md</a></li>
</ul></section><section class="print-page" id="aql_syntax" heading-number="6.2"><h1 id="aql_syntax-aql-themis-query-language">AQL - THEMIS Query Language<a class="headerlink" href="#aql_syntax-aql-themis-query-language" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 1.0<br />
<strong>Datum:</strong> 30. Oktober 2025<br />
<strong>Inspiriert von:</strong> ArangoDB AQL, mit Fokus auf Multi-Modell-Queries</p>
<hr />
<h2 id="aql_syntax-uberblick">Überblick<a class="headerlink" href="#aql_syntax-uberblick" title="Permanent link">&para;</a></h2>
<p><strong>AQL (Advanced Query Language)</strong> ist eine deklarative SQL-ähnliche Sprache für THEMIS, optimiert für hybride Queries über relationale, Graph-, Vektor- und Dokument-Daten.</p>
<p><strong>Design-Prinzipien:</strong>
- ✅ <strong>Einfach:</strong> SQL-ähnliche Syntax für schnelle Adoption
- ✅ <strong>Mächtig:</strong> Multi-Modell-Support (Relational, Graph, Vector)
- ✅ <strong>Optimierbar:</strong> Automatische Index-Auswahl via Optimizer
- ✅ <strong>Erweiterbar:</strong> Schrittweise Erweiterung (Aggregationen, Joins, Subqueries)</p>
<hr />
<h2 id="aql_syntax-syntax-ubersicht">Syntax-Übersicht<a class="headerlink" href="#aql_syntax-syntax-ubersicht" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-grundstruktur">Grundstruktur<a class="headerlink" href="#aql_syntax-grundstruktur" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR variable IN collection
  [LET var = expression [, ...]]
  [FILTER condition]
  [SORT expression [ASC|DESC] [, ...]]
  [LIMIT offset, count]
  [RETURN expression]
</code></pre>
<p><strong>Execution-Reihenfolge:</strong>
1. <code>FOR</code> - Iteration über Collection/Index
2. <code>FILTER</code> - Prädikat-Evaluation (mit Index-Nutzung)
3. <code>SORT</code> - Sortierung (mit Index-Nutzung wenn möglich)
4. <code>LIMIT</code> - Pagination/Offset
5. <code>RETURN</code> - Projektion (Felder/Objekte/Arrays)</p>
<hr />
<h2 id="aql_syntax-mvp-einschrankungen-und-hinweise">MVP-Einschränkungen und Hinweise<a class="headerlink" href="#aql_syntax-mvp-einschrankungen-und-hinweise" title="Permanent link">&para;</a></h2>
<p>Damit Erwartungen klar sind, hier die wichtigsten Begrenzungen des aktuellen MVP:</p>
<ul>
<li>Kein generisches OR im Translator. AND wird unterstützt; OR ist in Arbeit und wird später ergänzt.</li>
<li>Feld-zu-Feld Vergleiche (z. B. <code>u.city == o.city</code>) sind im Translator nicht allgemein erlaubt. Ein spezieller Join-Pfad erlaubt jedoch Gleichheits‑Joins über genau zwei FOR‑Klauseln (siehe Abschnitt „Einfache Joins (MVP)“).</li>
<li>LET in FILTER: Falls einfache LET‑Bindungen in FILTER vorkommen, werden diese vor der Übersetzung extrahiert („pre‑extracted“). Bei <code>explain: true</code> signalisiert der Plan dies mit <code>plan.let_pre_extracted = true</code>.</li>
<li>Subqueries, OR, komplexe Ausdrücke/Funktionen sind (noch) eingeschränkt und werden iterativ erweitert.</li>
</ul>
<h2 id="aql_syntax-kern-klauseln">Kern-Klauseln<a class="headerlink" href="#aql_syntax-kern-klauseln" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-1-for-collection-iteration">1. FOR - Collection Iteration<a class="headerlink" href="#aql_syntax-1-for-collection-iteration" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR doc IN users
  RETURN doc

FOR u IN users
  FILTER u.age &gt; 18
  RETURN u.name
</code></pre>
<p><strong>Syntax:</strong>
- <code>variable</code> - Beliebiger Bezeichner (lowercase empfohlen)
- <code>collection</code> - Table-Name aus Storage-Layer</p>
<p><strong>Multi-Collection (Joins - MVP seit 31.10.2025):</strong></p>
<p>Themis unterstützt Nested-Loop-Joins über mehrere Collections via sequenzielle <code>FOR</code>-Klauseln:</p>
<pre><code class="language-aql">FOR u IN users
  FOR o IN orders
    FILTER o.user_id == u._key
    RETURN {user: u.name, order: o.id}
</code></pre>
<p><strong>Join-Arten (MVP):</strong>
- <strong>Equality Join:</strong> Verknüpfung über <code>FILTER var1.field == var2.field</code>
- <strong>Cross Product + Filter:</strong> Kartesisches Produkt mit nachträglicher Filterung</p>
<p><strong>Beispiel - User-City-Join:</strong></p>
<pre><code class="language-aql">FOR user IN users
  FOR city IN cities
    FILTER user.city_id == city._key
    RETURN {
      user_name: user.name,
      city_name: city.name,
      country: city.country
    }
</code></pre>
<p><strong>Performance-Hinweise:</strong>
- ⚠️ Nested-Loop kann <strong>teuer</strong> sein bei großen Datasets (O(n×m) Komplexität)
- 💡 Empfehlung: FILTER-Bedingungen so spezifisch wie möglich
- 💡 Zukünftig: Hash-Join-Optimierung für große Collections geplant
- 💡 Verwende Indizes auf Join-Spalten (z.B. <code>city_id</code>) wo möglich</p>
<p><strong>Multi-FOR Limitierungen (MVP):</strong>
- Maximal 2-3 FOR-Klauseln empfohlen (Performance)
- Join-Bedingung muss in FILTER sein (keine impliziten Joins)
- Nur Equality-Joins (<code>==</code>) optimiert</p>
<hr />
<h3 id="aql_syntax-2-filter-bedingungen">2. FILTER - Bedingungen<a class="headerlink" href="#aql_syntax-2-filter-bedingungen" title="Permanent link">&para;</a></h3>
<p><strong>Vergleichsoperatoren:</strong></p>
<pre><code class="language-aql">FILTER doc.age == 25          // Gleichheit
FILTER doc.age != 25          // Ungleichheit
FILTER doc.age &gt; 18           // Größer
FILTER doc.age &gt;= 18          // Größer-Gleich
FILTER doc.age &lt; 65           // Kleiner
FILTER doc.age &lt;= 65          // Kleiner-Gleich
</code></pre>
<p><strong>Logische Operatoren:</strong></p>
<pre><code class="language-aql">FILTER doc.age &gt; 18 AND doc.city == &quot;Berlin&quot;
FILTER doc.status == &quot;active&quot; OR doc.status == &quot;pending&quot;   // Hinweis: OR im MVP noch nicht unterstützt
FILTER NOT doc.deleted
</code></pre>
<p><strong>IN-Operator:</strong></p>
<pre><code class="language-aql">FILTER doc.status IN [&quot;active&quot;, &quot;pending&quot;, &quot;approved&quot;]
FILTER doc.age IN [18, 21, 25, 30]
</code></pre>
<p><strong>String-Operatoren:</strong></p>
<pre><code class="language-aql">FILTER LIKE(doc.name, &quot;Max%&quot;)           // Prefix-Match
FILTER CONTAINS(doc.description, &quot;AI&quot;)  // Substring
FILTER REGEX_TEST(doc.email, &quot;.*@example\.com&quot;)
</code></pre>
<p><strong>NULL-Checks:</strong></p>
<pre><code class="language-aql">FILTER doc.email != null
FILTER doc.phone == null
</code></pre>
<hr />
<h3 id="aql_syntax-3-sort-sortierung">3. SORT - Sortierung<a class="headerlink" href="#aql_syntax-3-sort-sortierung" title="Permanent link">&para;</a></h3>
<p><strong>Einfache Sortierung:</strong></p>
<pre><code class="language-aql">SORT doc.age                  // ASC (default)
SORT doc.age DESC
SORT doc.created_at DESC
</code></pre>
<p><strong>Multi-Column-Sort:</strong></p>
<pre><code class="language-aql">SORT doc.city ASC, doc.age DESC
SORT doc.priority DESC, doc.created_at ASC
</code></pre>
<p><strong>Index-Nutzung:</strong>
- Range-Index auf <code>age</code> → effiziente Sortierung
- Composite-Index <code>(city, age)</code> → optimale Multi-Column-Sort</p>
<hr />
<h3 id="aql_syntax-4-limit-pagination">4. LIMIT - Pagination<a class="headerlink" href="#aql_syntax-4-limit-pagination" title="Permanent link">&para;</a></h3>
<p><strong>Syntax:</strong></p>
<pre><code class="language-aql">LIMIT count                   // Erste N Ergebnisse
LIMIT offset, count           // Pagination
</code></pre>
<p><strong>Beispiele:</strong></p>
<pre><code class="language-aql">LIMIT 10                      // Erste 10
LIMIT 20, 10                  // Zeilen 21-30 (Seite 3)
</code></pre>
<p><strong>Best Practices:</strong>
- Immer mit <code>LIMIT</code> arbeiten (verhindert Full-Scans)
- Für große Offsets: Cursor-basierte Pagination bevorzugen</p>
<hr />
<h3 id="aql_syntax-5-return-projektion">5. RETURN - Projektion<a class="headerlink" href="#aql_syntax-5-return-projektion" title="Permanent link">&para;</a></h3>
<p><strong>Ganzes Dokument:</strong></p>
<pre><code class="language-aql">RETURN doc
</code></pre>
<p><strong>Einzelne Felder:</strong></p>
<pre><code class="language-aql">RETURN doc.name
RETURN doc.email
</code></pre>
<p><strong>Objekt-Konstruktion:</strong></p>
<pre><code class="language-aql">RETURN {
  name: doc.name,
  age: doc.age,
  city: doc.city
}
</code></pre>
<p><strong>Berechnete Felder:</strong></p>
<pre><code class="language-aql">RETURN {
  name: doc.name,
  age_in_months: doc.age * 12,
  full_address: CONCAT(doc.street, &quot;, &quot;, doc.city)
}
</code></pre>
<p><strong>Arrays:</strong></p>
<pre><code class="language-aql">RETURN [doc.name, doc.age, doc.city]
</code></pre>
<p>Unterstützte Ausdrücke im MVP:
- Literale: Zahl, String, Bool, null
- Variablen und Feldzugriff: <code>doc</code>, <code>doc.field</code>
- Objekt- und Array-Literale (verschachtelt möglich)
- Einfache Let-Bindings pro Zeile (siehe LET)</p>
<hr />
<h2 id="aql_syntax-erweiterte-features-phase-11">Erweiterte Features (Phase 1.1+)<a class="headerlink" href="#aql_syntax-erweiterte-features-phase-11" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-let-variable-binding-mvp-seit-31102025">LET - Variable Binding (MVP seit 31.10.2025)<a class="headerlink" href="#aql_syntax-let-variable-binding-mvp-seit-31102025" title="Permanent link">&para;</a></h3>
<p>Bindet pro Iteration Werte an Variablen, die in <code>FILTER</code> und <code>RETURN</code> genutzt werden können.</p>
<p><strong>Einfaches Beispiel:</strong></p>
<pre><code class="language-aql">FOR u IN users
  LET city_name = u.city
  RETURN {name: u.name, city: city_name}
</code></pre>
<p><strong>Berechnungen mit LET:</strong></p>
<pre><code class="language-aql">FOR product IN products
  LET total_value = product.price * product.quantity
  FILTER total_value &gt; 1000
  RETURN {
    product: product.name,
    value: total_value
  }
</code></pre>
<p><strong>Mehrere LET-Bindungen:</strong></p>
<pre><code class="language-aql">FOR sale IN sales
  LET net = sale.amount
  LET tax = net * 0.19
  LET gross = net + tax
  RETURN {sale_id: sale._key, net, tax, gross}
</code></pre>
<p><strong>LET in Joins:</strong></p>
<pre><code class="language-aql">FOR user IN users
  FOR order IN orders
    FILTER order.user_id == user._key
    LET full_name = CONCAT(user.first_name, &quot; &quot;, user.last_name)
    RETURN {customer: full_name, order_id: order._key}
</code></pre>
<p><strong>MVP-Einschränkungen:</strong>
- Unterstützt sind aktuell einfache Ausdrücke: Literale, Variablen, Feldzugriffe, Binäroperationen (+, -, *, /), Objekt-/Array-Literale
- LETs werden sequenziell ausgewertet; spätere LETs können frühere verwenden
- Komplexe Funktionen (CONCAT, SUBSTRING, etc.) in Entwicklung
- Explain: Wenn <code>LET</code>‑Variablen in <code>FILTER</code> zu einfachen Gleichheitsprädikaten vor der Übersetzung extrahiert wurden, enthält der Plan das Flag <code>plan.let_pre_extracted = true</code></p>
<hr />
<h3 id="aql_syntax-collect-aggregationen-mvp-seit-31102025">COLLECT - Aggregationen (MVP seit 31.10.2025)<a class="headerlink" href="#aql_syntax-collect-aggregationen-mvp-seit-31102025" title="Permanent link">&para;</a></h3>
<p>Gruppiert Ergebnisse und berechnet Aggregatfunktionen.</p>
<p><strong>Einfaches GROUP BY:</strong></p>
<pre><code class="language-aql">FOR user IN users
  COLLECT city = user.city
  RETURN {city, count: LENGTH(1)}
</code></pre>
<p><strong>COUNT-Aggregation:</strong></p>
<pre><code class="language-aql">FOR user IN users
  COLLECT city = user.city WITH COUNT INTO total
  RETURN {city, total}
</code></pre>
<p><strong>SUM-Aggregation:</strong></p>
<pre><code class="language-aql">FOR sale IN sales
  COLLECT category = sale.category
  AGGREGATE total_revenue = SUM(sale.amount)
  RETURN {category, total_revenue}
</code></pre>
<p><strong>Mehrere Aggregationen:</strong></p>
<pre><code class="language-aql">FOR order IN orders
  COLLECT status = order.status
  AGGREGATE 
    total_count = COUNT(),
    total_amount = SUM(order.amount),
    avg_amount = AVG(order.amount),
    min_amount = MIN(order.amount),
    max_amount = MAX(order.amount)
  RETURN {status, total_count, total_amount, avg_amount, min_amount, max_amount}
</code></pre>
<p><strong>COLLECT mit FILTER:</strong></p>
<pre><code class="language-aql">FOR user IN users
  FILTER user.age &gt; 18
  COLLECT city = user.city
  AGGREGATE adult_count = COUNT()
  RETURN {city, adult_count}
</code></pre>
<p><strong>Unterstützte Aggregatfunktionen (MVP):</strong>
- <code>COUNT()</code> - Anzahl der Gruppen-Elemente
- <code>SUM(expr)</code> - Summe eines numerischen Felds
- <code>AVG(expr)</code> - Durchschnitt eines numerischen Felds
- <code>MIN(expr)</code> - Minimum eines Felds
- <code>MAX(expr)</code> - Maximum eines Felds</p>
<p><strong>Performance-Hinweise:</strong>
- Hash-basiertes Grouping: O(n) Komplexität
- FILTER vor COLLECT reduziert Datenvolumen (wird automatisch optimiert)
- Für sehr große Gruppen: Memory-Nutzung beachten</p>
<p><strong>Geplante Erweiterungen:</strong>
- <code>STDDEV(expr)</code> - Standardabweichung
- <code>VARIANCE(expr)</code> - Varianz
- <code>PERCENTILE(expr, n)</code> - n-tes Perzentil
- <code>UNIQUE(expr)</code> - Distinct Values</p>
<p>Hinweise (MVP):
- Gruppierung erfolgt über exakte String-Matches der Group-Keys
- Mehrere GROUP BY-Felder via Tuple-Keys geplant
- HAVING-Clause (Post-Aggregation-Filter) in Entwicklung</p>
<hr />
<h2 id="aql_syntax-http-spezifische-parameter-fur-pagination">HTTP-spezifische Parameter für Pagination<a class="headerlink" href="#aql_syntax-http-spezifische-parameter-fur-pagination" title="Permanent link">&para;</a></h2>
<p>Bei Nutzung des HTTP-Endpunkts <code>POST /query/aql</code> können optionale Felder zur Pagination mitgegeben werden:</p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;FOR u IN users SORT u.age ASC LIMIT 10 RETURN u&quot;,
  &quot;use_cursor&quot;: true,
  &quot;cursor&quot;: &quot;&lt;token-aus-previous-response&gt;&quot;,
  &quot;allow_full_scan&quot;: false
}
</code></pre>
<ul>
<li><code>use_cursor</code> (bool): Aktiviert Cursor-basierte Pagination. Antwortformat enthält <code>{items, has_more, next_cursor, batch_size}</code>.</li>
<li><code>cursor</code> (string): Token aus <code>next_cursor</code> der vorherigen Seite. Gültig nur in Kombination mit <code>use_cursor: true</code>.</li>
<li><code>allow_full_scan</code> (bool): Optionaler Fallback für kleine Datenmengen/Tests; für große Daten wird Index-basierte Sortierung empfohlen.</li>
</ul>
<p>Weitere Details siehe <code>docs/cursor_pagination.md</code>.</p>
<hr />
<h2 id="aql_syntax-spezial-queries">Spezial-Queries<a class="headerlink" href="#aql_syntax-spezial-queries" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-graph-traversierung">Graph-Traversierung<a class="headerlink" href="#aql_syntax-graph-traversierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR v, e, p IN 1..3 OUTBOUND &quot;users/alice&quot; edges
  FILTER v.active == true
  RETURN {vertex: v, edge: e, path: p}
</code></pre>
<p><strong>Traversal-Richtungen:</strong>
- <code>OUTBOUND</code> - Ausgehende Kanten (Alice → Bob)
- <code>INBOUND</code> - Eingehende Kanten (Alice ← Bob)
- <code>ANY</code> - Beide Richtungen</p>
<p><strong>Depth-Limits:</strong>
- <code>1..1</code> - Nur direkte Nachbarn
- <code>1..3</code> - Bis zu 3 Hops
- <code>2..5</code> - Min 2, Max 5 Hops</p>
<hr />
<h3 id="aql_syntax-vektor-ahnlichkeitssuche">Vektor-Ähnlichkeitssuche<a class="headerlink" href="#aql_syntax-vektor-ahnlichkeitssuche" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR doc IN users
  NEAR(doc.embedding, @query_vector, 10)
  FILTER doc.age &gt; 18
  RETURN {name: doc.name, similarity: SIMILARITY()}
</code></pre>
<p><strong>Funktionen:</strong>
- <code>NEAR(field, vector, k)</code> - k-NN-Suche
- <code>SIMILARITY()</code> - Aktueller Similarity-Score (0.0 - 1.0)</p>
<p><strong>Metriken:</strong></p>
<pre><code class="language-aql">NEAR(doc.embedding, @query_vector, 10, &quot;cosine&quot;)    // Cosine Similarity
NEAR(doc.embedding, @query_vector, 10, &quot;euclidean&quot;) // L2-Distance
</code></pre>
<hr />
<h3 id="aql_syntax-geo-queries">Geo-Queries<a class="headerlink" href="#aql_syntax-geo-queries" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR doc IN locations
  GEO_DISTANCE(doc.lat, doc.lon, 52.52, 13.405) &lt; 5000
  RETURN {name: doc.name, distance: GEO_DISTANCE(doc.lat, doc.lon, 52.52, 13.405)}
</code></pre>
<p><strong>Funktionen:</strong>
- <code>GEO_DISTANCE(lat1, lon1, lat2, lon2)</code> - Haversine-Distanz (Meter)
- <code>GEO_BOX(lat, lon, minLat, maxLat, minLon, maxLon)</code> - Bounding-Box-Check</p>
<hr />
<h3 id="aql_syntax-fulltext-suche">Fulltext-Suche<a class="headerlink" href="#aql_syntax-fulltext-suche" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR doc IN articles
  FULLTEXT(doc.content, &quot;machine learning AI&quot;)
  SORT BM25(doc) DESC
  LIMIT 10
  RETURN {title: doc.title, score: BM25(doc)}
</code></pre>
<p><strong>Funktionen:</strong>
- <code>FULLTEXT(field, query)</code> - Tokenisierte Suche
- <code>BM25(doc)</code> - Relevanz-Score (0.0+)</p>
<hr />
<h2 id="aql_syntax-einfache-joins-mvp">Einfache Joins (MVP)<a class="headerlink" href="#aql_syntax-einfache-joins-mvp" title="Permanent link">&para;</a></h2>
<p>Unterstützt werden Equality-Joins über genau zwei <code>FOR</code>-Klauseln mit einem Gleichheitsprädikat zwischen Variablen.</p>
<pre><code class="language-aql">FOR u IN users
  FOR o IN orders
  FILTER u._key == o.user_id
  RETURN u
</code></pre>
<p>Eigenschaften und Einschränkungen (MVP):
- Genau zwei <code>FOR</code>‑Klauseln; ein Equality‑Prädikat <code>var1.field == var2.field</code> in <code>FILTER</code>.
- Zusätzliche <code>FILTER</code> pro Seite sind erlaubt und werden vor dem Join angewendet.
- <code>RETURN</code> muss aktuell eine der Variablen zurückgeben (typisch <code>u</code> oder <code>o</code>).
- <code>LIMIT</code> wird nach dem Join angewendet. <code>SORT</code> im Join‑Pfad ist derzeit nicht unterstützt.
- <code>explain: true</code> liefert einen Plan, der den Join‑Pfad ausweist; bei LET‑Pre‑Extraction wird <code>plan.let_pre_extracted = true</code> gesetzt.</p>
<p>Projektion mit LET im Join-Kontext:</p>
<pre><code class="language-aql">FOR u IN users
  FOR o IN orders
  FILTER u._key == o.user_id
  LET info = { user: u.name, order: o.id }
  RETURN info
</code></pre>
<p>Hinweis: Komplexe Projektionen können je nach Datenvolumen höhere Kosten verursachen; nutze <code>LIMIT</code> wo sinnvoll.</p>
<hr />
<h2 id="aql_syntax-funktionen-operatoren">Funktionen &amp; Operatoren<a class="headerlink" href="#aql_syntax-funktionen-operatoren" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-string-funktionen">String-Funktionen<a class="headerlink" href="#aql_syntax-string-funktionen" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">CONCAT(str1, str2, ...)       // &quot;Hello&quot; + &quot; &quot; + &quot;World&quot;
LOWER(str)                     // &quot;HELLO&quot; → &quot;hello&quot;
UPPER(str)                     // &quot;hello&quot; → &quot;HELLO&quot;
SUBSTRING(str, offset, length) // &quot;Hello&quot;[1:4] → &quot;ell&quot;
LENGTH(str)                    // &quot;Hello&quot; → 5
TRIM(str)                      // &quot;  Hello  &quot; → &quot;Hello&quot;
</code></pre>
<h3 id="aql_syntax-numeric-funktionen">Numeric-Funktionen<a class="headerlink" href="#aql_syntax-numeric-funktionen" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">ABS(num)                       // |-5| → 5
CEIL(num) / FLOOR(num)         // 3.7 → 4 / 3
ROUND(num, decimals)           // 3.14159, 2 → 3.14
SQRT(num)                      // √16 → 4
POW(base, exp)                 // 2^8 → 256
</code></pre>
<h3 id="aql_syntax-aggregations-in-collect">Aggregations (in COLLECT)<a class="headerlink" href="#aql_syntax-aggregations-in-collect" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">COUNT()                        // Anzahl Zeilen
SUM(expr)                      // Summe
AVG(expr)                      // Durchschnitt
MIN(expr) / MAX(expr)          // Minimum/Maximum
STDDEV(expr)                   // Standardabweichung
VARIANCE(expr)                 // Varianz
</code></pre>
<h3 id="aql_syntax-type-checks">Type-Checks<a class="headerlink" href="#aql_syntax-type-checks" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">IS_NULL(value)
IS_NUMBER(value)
IS_STRING(value)
IS_ARRAY(value)
IS_OBJECT(value)
</code></pre>
<hr />
<h2 id="aql_syntax-beispiel-queries">Beispiel-Queries<a class="headerlink" href="#aql_syntax-beispiel-queries" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-1-einfache-filterung">1. Einfache Filterung<a class="headerlink" href="#aql_syntax-1-einfache-filterung" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR user IN users
  FILTER user.age &gt; 18 AND user.city == &quot;Berlin&quot;
  SORT user.created_at DESC
  LIMIT 10
  RETURN {
    name: user.name,
    email: user.email,
    age: user.age
  }
</code></pre>
<p><strong>Optimizer:</strong>
- Nutzt Composite-Index <code>(city, age)</code> falls vorhanden
- Fallback: Equality-Index <code>city</code> + Full-Scan-Filter <code>age</code></p>
<hr />
<h3 id="aql_syntax-2-geo-proximity-search">2. Geo-Proximity-Search<a class="headerlink" href="#aql_syntax-2-geo-proximity-search" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR loc IN restaurants
  FILTER GEO_DISTANCE(loc.lat, loc.lon, 52.52, 13.405) &lt; 2000
  FILTER loc.rating &gt;= 4.0
  SORT GEO_DISTANCE(loc.lat, loc.lon, 52.52, 13.405) ASC
  LIMIT 5
  RETURN {
    name: loc.name,
    rating: loc.rating,
    distance: GEO_DISTANCE(loc.lat, loc.lon, 52.52, 13.405)
  }
</code></pre>
<p><strong>Optimizer:</strong>
- Nutzt Geo-Index für Bounding-Box-Scan
- Post-Filter für exakte Distanz-Berechnung</p>
<hr />
<h3 id="aql_syntax-3-vektor-suche-mit-filter">3. Vektor-Suche mit Filter<a class="headerlink" href="#aql_syntax-3-vektor-suche-mit-filter" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR product IN products
  NEAR(product.embedding, @query_vector, 20)
  FILTER product.price &lt; 100.0 AND product.in_stock == true
  SORT SIMILARITY() DESC
  LIMIT 10
  RETURN {
    name: product.name,
    price: product.price,
    similarity: SIMILARITY()
  }
</code></pre>
<p><strong>Pre-Filtering vs Post-Filtering:</strong>
- Pre-Filter: Bitset für <code>price &lt; 100 AND in_stock == true</code> → k-NN
- Post-Filter: k-NN (20) → Filter → Top-10</p>
<hr />
<h3 id="aql_syntax-4-aggregationen">4. Aggregationen<a class="headerlink" href="#aql_syntax-4-aggregationen" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR order IN orders
  FILTER order.created_at &gt;= &quot;2025-01-01&quot;
  COLLECT city = order.city
  AGGREGATE 
    total_revenue = SUM(order.amount),
    avg_order = AVG(order.amount),
    order_count = COUNT()
  SORT total_revenue DESC
  LIMIT 10
  RETURN {
    city,
    total_revenue,
    avg_order,
    order_count
  }
</code></pre>
<hr />
<h3 id="aql_syntax-5-graph-traversierung">5. Graph-Traversierung<a class="headerlink" href="#aql_syntax-5-graph-traversierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR vertex, edge, path IN 1..3 OUTBOUND &quot;users/alice&quot; friendships
  FILTER vertex.active == true
  RETURN {
    friend: vertex.name,
    connection_type: edge.type,
    path_length: LENGTH(path.edges)
  }
</code></pre>
<hr />
<h2 id="aql_syntax-query-execution-optimizer">Query-Execution &amp; Optimizer<a class="headerlink" href="#aql_syntax-query-execution-optimizer" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-explain-plan">Explain-Plan<a class="headerlink" href="#aql_syntax-explain-plan" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">POST /query/aql
{
  &quot;query&quot;: &quot;FOR u IN users FILTER u.age &gt; 18 SORT u.created_at DESC LIMIT 10&quot;,
  &quot;explain&quot;: true
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;plan&quot;: {
    &quot;mode&quot;: &quot;range_aware&quot;,
    &quot;order&quot;: [
      { &quot;column&quot;: &quot;created_at&quot;, &quot;value&quot;: &quot;DESC&quot; }
    ],
    &quot;estimates&quot;: [
      { &quot;column&quot;: &quot;age&quot;, &quot;value&quot;: &quot;&gt; 18&quot;, &quot;estimatedCount&quot;: 1200, &quot;capped&quot;: false }
    ],
    &quot;let_pre_extracted&quot;: true
  }
}
</code></pre>
<h3 id="aql_syntax-index-hints-spater">Index-Hints (später)<a class="headerlink" href="#aql_syntax-index-hints-spater" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">FOR doc IN users USE INDEX idx_age_city
  FILTER doc.age &gt; 18
  RETURN doc
</code></pre>
<hr />
<h2 id="aql_syntax-ast-struktur-internal">AST-Struktur (Internal)<a class="headerlink" href="#aql_syntax-ast-struktur-internal" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">// AST-Node-Typen
enum class ASTNodeType {
    ForNode,          // FOR variable IN collection
    FilterNode,       // FILTER condition
    SortNode,         // SORT expr [ASC|DESC]
    LimitNode,        // LIMIT offset, count
    ReturnNode,       // RETURN expression

    // Expressions
    BinaryOp,         // ==, !=, &gt;, &lt;, &gt;=, &lt;=, AND, OR
    UnaryOp,          // NOT, -
    FunctionCall,     // CONCAT, SUM, etc.
    FieldAccess,      // doc.field
    Literal,          // &quot;string&quot;, 123, true, null
    Variable          // doc, user, etc.
};

// Beispiel-AST für: FOR u IN users FILTER u.age &gt; 18 RETURN u.name
ForNode {
    variable: &quot;u&quot;,
    collection: &quot;users&quot;,

    filter: FilterNode {
        condition: BinaryOp {
            op: &quot;&gt;&quot;,
            left: FieldAccess(&quot;u&quot;, &quot;age&quot;),
            right: Literal(18)
        }
    },

    return_expr: ReturnNode {
        expression: FieldAccess(&quot;u&quot;, &quot;name&quot;)
    }
}
</code></pre>
<hr />
<h2 id="aql_syntax-implementierungs-phasen">Implementierungs-Phasen<a class="headerlink" href="#aql_syntax-implementierungs-phasen" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-phase-1-mvp-woche-1-2">Phase 1 (MVP - Woche 1-2):<a class="headerlink" href="#aql_syntax-phase-1-mvp-woche-1-2" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ FOR, FILTER (Equality, Range, IN), SORT, LIMIT, RETURN</li>
<li>✅ Parser (PEGTL)</li>
<li>✅ AST → QueryEngine-Translation</li>
<li>✅ HTTP-Endpoint <code>/query/aql</code></li>
<li>✅ Unit-Tests</li>
</ul>
<h3 id="aql_syntax-phase-2-woche-3-4">Phase 2 (Woche 3-4):<a class="headerlink" href="#aql_syntax-phase-2-woche-3-4" title="Permanent link">&para;</a></h3>
<ul>
<li>LET (Variable Binding)</li>
<li>COLLECT (Aggregationen: COUNT, SUM, AVG)</li>
<li>String-/Numeric-Funktionen</li>
<li>Explain-Plan-Integration</li>
</ul>
<h3 id="aql_syntax-phase-3-woche-5-6">Phase 3 (Woche 5-6):<a class="headerlink" href="#aql_syntax-phase-3-woche-5-6" title="Permanent link">&para;</a></h3>
<ul>
<li>Graph-Traversierung (FOR v, e, p IN ... OUTBOUND)</li>
<li>Vektor-Suche (NEAR, SIMILARITY)</li>
<li>Geo-Queries (GEO_DISTANCE, GEO_BOX)</li>
<li>Fulltext (FULLTEXT, BM25)</li>
</ul>
<h3 id="aql_syntax-phase-4-spater">Phase 4 (später):<a class="headerlink" href="#aql_syntax-phase-4-spater" title="Permanent link">&para;</a></h3>
<ul>
<li>Joins (Multi-Collection)</li>
<li>Subqueries</li>
<li>Transactions (BEGIN, COMMIT, ROLLBACK)</li>
<li>INSERT, UPDATE, DELETE via AQL</li>
</ul>
<hr />
<h2 id="aql_syntax-performance-uberlegungen">Performance-Überlegungen<a class="headerlink" href="#aql_syntax-performance-uberlegungen" title="Permanent link">&para;</a></h2>
<p><strong>Index-Nutzung:</strong>
- FILTER mit <code>==</code> → Equality-Index
- FILTER mit <code>&gt;</code>, <code>&lt;</code> → Range-Index
- FILTER mit <code>IN</code> → Batch-Lookup
- SORT → Range-Index (wenn vorhanden)</p>
<p><strong>Optimizer-Strategien:</strong>
- <strong>Filter-Pushdown:</strong> FILTER vor SORT (reduziert Sortier-Kosten)
- <strong>Index-Auswahl:</strong> Kleinster geschätzter Index zuerst
- <strong>Short-Circuit:</strong> LIMIT früh anwenden (z.B. Top-K)</p>
<p><strong>Vermeiden:</strong>
- Full-Table-Scans ohne LIMIT
- Sortierung ohne Index auf großen Datasets
- Aggregationen ohne COLLECT (ineffizient)</p>
<hr />
<h2 id="aql_syntax-kompatibilitat-erweiterungen">Kompatibilität &amp; Erweiterungen<a class="headerlink" href="#aql_syntax-kompatibilitat-erweiterungen" title="Permanent link">&para;</a></h2>
<p><strong>ArangoDB AQL:</strong>
- Ähnliche Syntax (FOR, FILTER, SORT, LIMIT, RETURN)
- Unterschiede: THEMIS nutzt natives MVCC, kein <code>_key</code> zwingend</p>
<p><strong>SQL-Vergleich:</strong></p>
<pre><code class="language-sql">-- SQL
SELECT name, age FROM users WHERE age &gt; 18 ORDER BY created_at DESC LIMIT 10;

-- AQL
FOR user IN users
  FILTER user.age &gt; 18
  SORT user.created_at DESC
  LIMIT 10
  RETURN {name: user.name, age: user.age}
</code></pre>
<p><strong>Vorteile AQL:</strong>
- Multi-Modell (Graph, Vector, Geo in einer Query)
- Explizite Execution-Reihenfolge (leichter zu optimieren)
- Schemalos (flexible Felder)</p>
<hr />
<h2 id="aql_syntax-fehlerbehandlung">Fehlerbehandlung<a class="headerlink" href="#aql_syntax-fehlerbehandlung" title="Permanent link">&para;</a></h2>
<p><strong>Syntax-Errors:</strong></p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;Syntax error at line 2, column 10: Expected 'IN' after variable name&quot;,
  &quot;query&quot;: &quot;FOR user users FILTER ...&quot;,
  &quot;line&quot;: 2,
  &quot;column&quot;: 10
}
</code></pre>
<p><strong>Semantic-Errors:</strong></p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;Collection 'userz' does not exist (did you mean 'users'?)&quot;,
  &quot;query&quot;: &quot;FOR u IN userz RETURN u&quot;
}
</code></pre>
<p><strong>Runtime-Errors:</strong></p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;Division by zero in expression: amount / quantity&quot;,
  &quot;entity_key&quot;: &quot;orders:12345&quot;
}
</code></pre>
<hr />
<h2 id="aql_syntax-referenz-links">Referenz-Links<a class="headerlink" href="#aql_syntax-referenz-links" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Parser:</strong> PEGTL (https://github.com/taocpp/PEGTL)</li>
<li><strong>Inspiration:</strong> ArangoDB AQL (https://www.arangodb.com/docs/stable/aql/)</li>
<li><strong>Optimizer:</strong> docs/query_optimizer.md</li>
<li><strong>Index-Typen:</strong> docs/indexes.md</li>
</ul>
<hr />
<p><strong>Status:</strong> ✅ Syntax-Definition vollständig<br />
<strong>Nächster Schritt:</strong> Parser-Implementation mit PEGTL</p>
<h2 id="aql_syntax-vollstandige-beispiele-mvp-features">Vollständige Beispiele (MVP Features)<a class="headerlink" href="#aql_syntax-vollstandige-beispiele-mvp-features" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-beispiel-1-user-city-join-mit-aggregation">Beispiel 1: User-City-Join mit Aggregation<a class="headerlink" href="#aql_syntax-beispiel-1-user-city-join-mit-aggregation" title="Permanent link">&para;</a></h3>
<p><strong>Szenario:</strong> Finde alle User in ihren Städten, gruppiert nach Land mit Zählung:</p>
<pre><code class="language-aql">FOR user IN users
  FOR city IN cities
    FILTER user.city_id == city._key
    COLLECT country = city.country
    AGGREGATE user_count = COUNT()
    RETURN {country, user_count}
</code></pre>
<p><strong>Ergebnis:</strong></p>
<pre><code class="language-json">[
  {&quot;country&quot;: &quot;Germany&quot;, &quot;user_count&quot;: 125},
  {&quot;country&quot;: &quot;France&quot;, &quot;user_count&quot;: 87},
  {&quot;country&quot;: &quot;Spain&quot;, &quot;user_count&quot;: 43}
]
</code></pre>
<hr />
<h3 id="aql_syntax-beispiel-2-sales-analyse-mit-let-und-aggregation">Beispiel 2: Sales-Analyse mit LET und Aggregation<a class="headerlink" href="#aql_syntax-beispiel-2-sales-analyse-mit-let-und-aggregation" title="Permanent link">&para;</a></h3>
<p><strong>Szenario:</strong> Berechne Netto/Brutto-Umsätze pro Kategorie:</p>
<pre><code class="language-aql">FOR sale IN sales
  LET net = sale.amount
  LET tax = net * 0.19
  LET gross = net + tax
  COLLECT category = sale.category
  AGGREGATE 
    total_net = SUM(net),
    total_gross = SUM(gross),
    count = COUNT()
  RETURN {
    category,
    total_net,
    total_gross,
    avg_sale: total_net / count,
    count
  }
</code></pre>
<hr />
<h3 id="aql_syntax-beispiel-3-top-10-stadte-nach-user-count">Beispiel 3: Top-10 Städte nach User-Count<a class="headerlink" href="#aql_syntax-beispiel-3-top-10-stadte-nach-user-count" title="Permanent link">&para;</a></h3>
<p><strong>Szenario:</strong> Häufigste Städte finden:</p>
<pre><code class="language-aql">FOR user IN users
  COLLECT city_id = user.city_id WITH COUNT INTO user_count
  SORT user_count DESC
  LIMIT 10
  RETURN {city_id, user_count}
</code></pre>
<hr />
<h2 id="aql_syntax-performance-best-practices-mvp">Performance-Best-Practices (MVP)<a class="headerlink" href="#aql_syntax-performance-best-practices-mvp" title="Permanent link">&para;</a></h2>
<h3 id="aql_syntax-1-join-optimierung">1. JOIN-Optimierung<a class="headerlink" href="#aql_syntax-1-join-optimierung" title="Permanent link">&para;</a></h3>
<p>** Schlecht:<strong> Kartesisches Produkt ohne Filter
** Gut:</strong> Spezifische FILTER-Bedingungen, LIMIT verwenden</p>
<h3 id="aql_syntax-2-let-fur-wiederverwendung">2. LET für Wiederverwendung<a class="headerlink" href="#aql_syntax-2-let-fur-wiederverwendung" title="Permanent link">&para;</a></h3>
<p>Berechnungen einmal durchführen, mehrfach nutzen:</p>
<pre><code class="language-aql">FOR sale IN sales
  LET net = sale.amount
  LET tax = net * 0.19
  RETURN {net, tax, gross: net + tax}
</code></pre>
<h3 id="aql_syntax-3-filter-vor-collect">3. FILTER vor COLLECT<a class="headerlink" href="#aql_syntax-3-filter-vor-collect" title="Permanent link">&para;</a></h3>
<p>Datenvolumen reduzieren bevor gruppiert wird.</p>
<hr />
<h2 id="aql_syntax-implementation-status-31102025">Implementation-Status (31.10.2025)<a class="headerlink" href="#aql_syntax-implementation-status-31102025" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FOR</strong> (Single)</td>
<td>Production</td>
<td>Vollständig optimiert</td>
</tr>
<tr>
<td><strong>FOR</strong> (Multi/Join)</td>
<td>MVP</td>
<td>Nested-Loop, Hash-Join geplant</td>
</tr>
<tr>
<td><strong>FILTER</strong></td>
<td>Production</td>
<td>Equality + Range + AND</td>
</tr>
<tr>
<td><strong>SORT</strong></td>
<td>Production</td>
<td>Index-optimiert</td>
</tr>
<tr>
<td><strong>LIMIT</strong></td>
<td>Production</td>
<td>Offset + Count</td>
</tr>
<tr>
<td><strong>RETURN</strong></td>
<td>Production</td>
<td>Field/Object/Array</td>
</tr>
<tr>
<td><strong>LET</strong></td>
<td>MVP</td>
<td>Basis-Expressions, Arithmetik</td>
</tr>
<tr>
<td><strong>COLLECT</strong></td>
<td>MVP</td>
<td>Hash-Grouping, COUNT/SUM/AVG/MIN/MAX</td>
</tr>
<tr>
<td><strong>OR-Operator</strong></td>
<td>Planned</td>
<td>Index-Merge geplant</td>
</tr>
<tr>
<td><strong>Subqueries</strong></td>
<td>Planned</td>
<td>Phase 1.2</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Dokumentations-Version:</strong> 1.1 (31. Oktober 2025)<br />
<strong>Letzte Aktualisierung:</strong> JOIN/LET/COLLECT MVP-Features dokumentiert</p></section><section class="print-page" id="aql_explain_profile" heading-number="6.3"><h1 id="aql_explain_profile-aql-explain-profile">AQL EXPLAIN &amp; PROFILE<a class="headerlink" href="#aql_explain_profile-aql-explain-profile" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 1.0<br />
<strong>Datum:</strong> 28. Oktober 2025<br />
<strong>Zweck:</strong> Dokumentation der Query-Analyse und Performance-Metriken</p>
<hr />
<h2 id="aql_explain_profile-uberblick">Überblick<a class="headerlink" href="#aql_explain_profile-uberblick" title="Permanent link">&para;</a></h2>
<p>THEMIS bietet <code>explain=true</code> zur Abfrage von Query-Plänen und Performance-Metriken für AQL-Queries. Dies ist nützlich für:</p>
<ul>
<li>Query-Optimierung und Index-Auswahl</li>
<li>Performance-Debugging</li>
<li>BFS-Traversal Pruning-Effektivität</li>
<li>Filter Short-Circuit Analyse</li>
</ul>
<hr />
<h2 id="aql_explain_profile-http-api-usage">HTTP API Usage<a class="headerlink" href="#aql_explain_profile-http-api-usage" title="Permanent link">&para;</a></h2>
<h3 id="aql_explain_profile-request">Request<a class="headerlink" href="#aql_explain_profile-request" title="Permanent link">&para;</a></h3>
<pre><code class="language-http">POST /query/aql
Content-Type: application/json

{
  &quot;query&quot;: &quot;FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social' FILTER v.age &gt; 18 RETURN v&quot;,
  &quot;explain&quot;: true
}
</code></pre>
<h3 id="aql_explain_profile-response-traversal">Response (Traversal)<a class="headerlink" href="#aql_explain_profile-response-traversal" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;table&quot;: &quot;graph&quot;,
  &quot;count&quot;: 42,
  &quot;entities&quot;: [...],
  &quot;metrics&quot;: {
    &quot;constant_filter_precheck&quot;: false,
    &quot;edges_expanded&quot;: 156,
    &quot;pruned_last_level&quot;: 23,
    &quot;filter_evaluations_total&quot;: 89,
    &quot;filter_short_circuits&quot;: 12,
    &quot;frontier_processed_per_depth&quot;: {
      &quot;0&quot;: 1,
      &quot;1&quot;: 5,
      &quot;2&quot;: 18,
      &quot;3&quot;: 65
    },
    &quot;enqueued_per_depth&quot;: {
      &quot;1&quot;: 5,
      &quot;2&quot;: 18,
      &quot;3&quot;: 65
    }
  }
}
</code></pre>
<h3 id="aql_explain_profile-response-relational-query">Response (Relational Query)<a class="headerlink" href="#aql_explain_profile-response-relational-query" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;table&quot;: &quot;users&quot;,
  &quot;count&quot;: 25,
  &quot;entities&quot;: [...],
  &quot;query&quot;: &quot;FOR u IN users FILTER u.age &gt; 18 AND u.city == 'Berlin' RETURN u&quot;,
  &quot;ast&quot;: {...},
  &quot;plan&quot;: {
    &quot;mode&quot;: &quot;index_optimized&quot;,
    &quot;order&quot;: [
      {&quot;column&quot;: &quot;city&quot;, &quot;value&quot;: &quot;Berlin&quot;},
      {&quot;column&quot;: &quot;age&quot;, &quot;value&quot;: &quot;18&quot;}
    ],
    &quot;estimates&quot;: [
      {&quot;column&quot;: &quot;city&quot;, &quot;value&quot;: &quot;Berlin&quot;, &quot;estimatedCount&quot;: 100, &quot;capped&quot;: false},
      {&quot;column&quot;: &quot;age&quot;, &quot;value&quot;: &quot;18&quot;, &quot;estimatedCount&quot;: 500, &quot;capped&quot;: false}
    ]
  }
}
</code></pre>
<hr />
<h2 id="aql_explain_profile-traversal-metrics">Traversal Metrics<a class="headerlink" href="#aql_explain_profile-traversal-metrics" title="Permanent link">&para;</a></h2>
<h3 id="aql_explain_profile-constant_filter_precheck">constant_filter_precheck<a class="headerlink" href="#aql_explain_profile-constant_filter_precheck" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Typ:</strong> <code>boolean</code></li>
<li><strong>Beschreibung:</strong> Wurde ein konstanter FILTER (ohne v/e-Referenzen) vorab evaluiert?</li>
<li><strong>Nutzung:</strong> Zeigt, ob die Query vor BFS abgebrochen wurde (wenn false ergibt)</li>
</ul>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-aql">FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social' 
  FILTER 1 == 2  -- konstant false
  RETURN v
</code></pre>
<p>→ <code>constant_filter_precheck: true</code>, Ergebnis sofort leer ohne BFS</p>
<hr />
<h3 id="aql_explain_profile-edges_expanded">edges_expanded<a class="headerlink" href="#aql_explain_profile-edges_expanded" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Typ:</strong> <code>int</code></li>
<li><strong>Beschreibung:</strong> Anzahl der inspizierten Adjazenz-Kanten (out/in) während BFS</li>
<li><strong>Nutzung:</strong> Indikator für Traversal-Kosten</li>
</ul>
<p><strong>Interpretation:</strong>
- Niedrig: Gut pruned oder kleiner Graph
- Hoch: Großer Frontier oder fehlende Prädikate</p>
<hr />
<h3 id="aql_explain_profile-pruned_last_level">pruned_last_level<a class="headerlink" href="#aql_explain_profile-pruned_last_level" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Typ:</strong> <code>int</code></li>
<li><strong>Beschreibung:</strong> Anzahl der am letzten Level (depth == maxDepth) durch v/e-Prädikate weggeschnittenen Nachbarn</li>
<li><strong>Nutzung:</strong> Wirksamkeit des konservativen Prunings messen</li>
</ul>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-aql">FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social' 
  FILTER v.age &gt; 30
  RETURN v
</code></pre>
<p>→ <code>pruned_last_level: 23</code> – 23 Vertices am letzten Level hatten age &lt;= 30 und wurden nicht eingereiht</p>
<hr />
<h3 id="aql_explain_profile-filter_evaluations_total">filter_evaluations_total<a class="headerlink" href="#aql_explain_profile-filter_evaluations_total" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Typ:</strong> <code>int</code></li>
<li><strong>Beschreibung:</strong> Anzahl der FILTER-Evaluierungen pro BFS-Zeile (Knoten + eingehende Kante)</li>
<li><strong>Nutzung:</strong> Overhead durch komplexe Filter tracken</li>
</ul>
<p><strong>Interpretation:</strong>
- Sollte &lt;= frontier_processed_per_depth (Summe) sein
- Hoch bei komplexen Bool-Ausdrücken</p>
<hr />
<h3 id="aql_explain_profile-filter_short_circuits">filter_short_circuits<a class="headerlink" href="#aql_explain_profile-filter_short_circuits" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Typ:</strong> <code>int</code></li>
<li><strong>Beschreibung:</strong> Anzahl der Short-Circuits bei AND/OR (Early Exit)</li>
<li><strong>Nutzung:</strong> Effizienz der Bool-Logik messen</li>
</ul>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-aql">FILTER v.age &gt; 18 AND v.city == &quot;Berlin&quot;
</code></pre>
<p>→ Wenn <code>v.age &gt; 18</code> false ist, wird <code>v.city == "Berlin"</code> nicht evaluiert → <code>filter_short_circuits++</code></p>
<hr />
<h3 id="aql_explain_profile-frontier_processed_per_depth">frontier_processed_per_depth<a class="headerlink" href="#aql_explain_profile-frontier_processed_per_depth" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Typ:</strong> <code>object</code> (depth → count)</li>
<li><strong>Beschreibung:</strong> Anzahl der verarbeiteten Knoten pro Tiefe</li>
<li><strong>Nutzung:</strong> BFS-Expansion visualisieren</li>
</ul>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-json">{
  &quot;0&quot;: 1,     // Startknoten
  &quot;1&quot;: 5,     // 1. Hop: 5 Nachbarn
  &quot;2&quot;: 18,    // 2. Hop: 18 Nachbarn
  &quot;3&quot;: 65     // 3. Hop: 65 Nachbarn
}
</code></pre>
<p><strong>Interpretation:</strong>
- Exponentielles Wachstum: Dichte Graphen
- Lineares Wachstum: Sparse oder gut gefiltert</p>
<hr />
<h3 id="aql_explain_profile-enqueued_per_depth">enqueued_per_depth<a class="headerlink" href="#aql_explain_profile-enqueued_per_depth" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Typ:</strong> <code>object</code> (depth → count)</li>
<li><strong>Beschreibung:</strong> Anzahl der eingereihten Knoten je (depth+1) während Expansion</li>
<li><strong>Nutzung:</strong> Neue Frontier-Größe tracken (vor visited-Check)</li>
</ul>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-json">{
  &quot;1&quot;: 5,
  &quot;2&quot;: 18,
  &quot;3&quot;: 42    // 23 wurden später durch Pruning gedroppt (siehe pruned_last_level)
}
</code></pre>
<hr />
<h2 id="aql_explain_profile-relational-query-plan">Relational Query Plan<a class="headerlink" href="#aql_explain_profile-relational-query-plan" title="Permanent link">&para;</a></h2>
<h3 id="aql_explain_profile-mode">mode<a class="headerlink" href="#aql_explain_profile-mode" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>index_optimized:</strong> Optimizer-gesteuerter Plan mit Kardinalitätsschätzung</li>
<li><strong>index_parallel:</strong> Parallele Index-Scans mit AND-Merge</li>
<li><strong>full_scan_fallback:</strong> Sequential Scan (wenn allow_full_scan=true und kein Index)</li>
<li><strong>index_rangeaware:</strong> Range-Prädikate/ORDER BY nutzen Range-Index direkt</li>
</ul>
<h3 id="aql_explain_profile-order">order<a class="headerlink" href="#aql_explain_profile-order" title="Permanent link">&para;</a></h3>
<p>Array von Prädikaten in Evaluierungsreihenfolge (sortiert nach Selektivität bei <code>index_optimized</code>)</p>
<h3 id="aql_explain_profile-estimates">estimates<a class="headerlink" href="#aql_explain_profile-estimates" title="Permanent link">&para;</a></h3>
<p>Kardinalitätsschätzung pro Prädikat:
- <strong>estimatedCount:</strong> Geschätzte Anzahl Treffer
- <strong>capped:</strong> Wurde die Schätzung bei MAX_ESTIMATE_LIMIT gecappt?</p>
<hr />
<h2 id="aql_explain_profile-cursor-range-scan-metriken-relational">Cursor &amp; Range-Scan Metriken (Relational)<a class="headerlink" href="#aql_explain_profile-cursor-range-scan-metriken-relational" title="Permanent link">&para;</a></h2>
<p>Zusätzlich zu Traversal-Metriken stellt THEMIS für relationale Abfragen (Sekundärindex-Pfad) optionale Cursor-/Range-Informationen bereit:</p>
<h3 id="aql_explain_profile-explain-plan-felder-bei-explaintrue">Explain-Plan Felder (bei <code>explain=true</code>)<a class="headerlink" href="#aql_explain_profile-explain-plan-felder-bei-explaintrue" title="Permanent link">&para;</a></h3>
<ul>
<li><code>plan.mode</code>: z. B. <code>index_rangeaware</code>, <code>index_optimized</code>, <code>full_scan_fallback</code>.</li>
<li><code>plan.cursor</code> (falls <code>use_cursor=true</code> im Request):</li>
<li><code>used</code>: Ob der Cursorpfad angewendet wurde.</li>
<li><code>cursor_present</code>: Ob ein Cursor-Token im Request vorhanden war.</li>
<li><code>sort_column</code>: Sortierspalte bei ORDER BY.</li>
<li><code>effective_limit</code>: Tatsächlich verwendetes Fetch-Limit (typisch <code>count+1</code> für <code>has_more</code>).</li>
<li><code>anchor_set</code>: Ob ein Cursor-Anker <code>(sort_value, pk)</code> in der Engine gesetzt wurde.</li>
<li><code>requested_count</code>: Angeforderte Seitengröße aus LIMIT.</li>
</ul>
<h3 id="aql_explain_profile-prometheus-metriken-get-metrics">Prometheus-Metriken (<code>GET /metrics</code>)<a class="headerlink" href="#aql_explain_profile-prometheus-metriken-get-metrics" title="Permanent link">&para;</a></h3>
<ul>
<li><code>vccdb_cursor_anchor_hits_total</code> (counter)</li>
<li>Anzahl der Cursor-Anker-Verwendungen im ORDER BY-Paginationpfad.</li>
<li><code>vccdb_range_scan_steps_total</code> (counter)</li>
<li>Summe der besuchten Indexeinträge bei Range-Scans (einschließlich initialem Anker-Scan).</li>
<li><code>vccdb_page_fetch_time_ms_bucket</code>, <code>vccdb_page_fetch_time_ms_sum</code>, <code>vccdb_page_fetch_time_ms_count</code> (histogram)</li>
<li>Dauer der Seitenerzeugung in <code>handleQueryAql</code> für Cursoranfragen (Millisekunden). Buckets: 1, 5, 10, 25, 50, 100, 250, 500, 1000, 5000, +Inf.</li>
</ul>
<p>Hinweise:
- LIMIT/OFFSET ohne Cursor bleiben unverändert (post‑fetch Slicing im HTTP‑Handler).
- Cursor mit ORDER BY: Die Engine holt <code>count+1</code> Elemente für <code>has_more</code>. Bei ungültigem/inkonsistentem Cursor wird eine leere Seite mit <code>has_more=false</code> zurückgegeben.</p>
<hr />
<h2 id="aql_explain_profile-best-practices">Best Practices<a class="headerlink" href="#aql_explain_profile-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="aql_explain_profile-1-pruning-effektivitat-prufen">1. Pruning-Effektivität prüfen<a class="headerlink" href="#aql_explain_profile-1-pruning-effektivitat-prufen" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:8080/query/aql \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;query&quot;: &quot;FOR v IN 1..3 OUTBOUND \&quot;user1\&quot; GRAPH \&quot;social\&quot; FILTER v.age &gt; 30 RETURN v&quot;,
    &quot;explain&quot;: true
  }' | jq '.metrics'
</code></pre>
<p><strong>Erwartetes Ergebnis:</strong>
- <code>pruned_last_level &gt; 0</code> → Pruning greift
- <code>edges_expanded &lt; enqueued_per_depth (Summe)</code> → Effizienz durch visited-Set</p>
<hr />
<h3 id="aql_explain_profile-2-filter-short-circuits-optimieren">2. Filter Short-Circuits optimieren<a class="headerlink" href="#aql_explain_profile-2-filter-short-circuits-optimieren" title="Permanent link">&para;</a></h3>
<p>Stelle selektive Prädikate zuerst:</p>
<pre><code class="language-aql">-- Gut (Stadt zuerst, sehr selektiv)
FILTER v.city == &quot;Smalltown&quot; AND v.age &gt; 18

-- Schlecht (Alter zuerst, wenig selektiv)
FILTER v.age &gt; 18 AND v.city == &quot;Smalltown&quot;
</code></pre>
<p>→ Mehr <code>filter_short_circuits</code> bei optimaler Reihenfolge</p>
<hr />
<h3 id="aql_explain_profile-3-frontier-explosion-vermeiden">3. Frontier-Explosion vermeiden<a class="headerlink" href="#aql_explain_profile-3-frontier-explosion-vermeiden" title="Permanent link">&para;</a></h3>
<p>Bei <code>frontier_processed_per_depth</code> mit exponentiellem Wachstum:
- maxDepth reduzieren
- Stärkere Prädikate (z. B. Edge-Filter) hinzufügen
- Index auf v/e-Felder anlegen</p>
<hr />
<h3 id="aql_explain_profile-4-konstante-filter-vorab-eliminieren">4. Konstante Filter vorab eliminieren<a class="headerlink" href="#aql_explain_profile-4-konstante-filter-vorab-eliminieren" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">-- Ineffizient (BFS läuft, obwohl Ergebnis immer leer)
FOR v IN 1..3 OUTBOUND 'user1' GRAPH 'social' 
  FILTER 1 == 2
  RETURN v
</code></pre>
<p>→ <code>constant_filter_precheck: true</code>, <code>edges_expanded: 0</code></p>
<hr />
<h2 id="aql_explain_profile-metriken-erweitern-roadmap">Metriken erweitern (Roadmap)<a class="headerlink" href="#aql_explain_profile-metriken-erweitern-roadmap" title="Permanent link">&para;</a></h2>
<p>Geplante Erweiterungen:
- [ ] <code>filter_evaluations_per_depth</code> (Granularität pro Level)
- [ ] <code>max_frontier_size</code> (Peak Memory-Indikator)
- [ ] <code>path_reconstructions</code> (bei RETURN p)
- [ ] <code>entity_loads</code> (RocksDB Get-Calls)
- [ ] <code>timing_ms</code> (BFS-Dauer, Filter-Dauer, Serialisierung)</p>
<hr />
<h2 id="aql_explain_profile-zusammenfassung">Zusammenfassung<a class="headerlink" href="#aql_explain_profile-zusammenfassung" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Metrik</th>
<th>Bedeutung</th>
<th>Optimierungsziel</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>edges_expanded</code></td>
<td>BFS-Kosten</td>
<td>Minimieren (durch Filter/Pruning)</td>
</tr>
<tr>
<td><code>pruned_last_level</code></td>
<td>Pruning-Erfolg</td>
<td>Maximieren (zeigt Filtereffizienz)</td>
</tr>
<tr>
<td><code>filter_evaluations_total</code></td>
<td>Filter-Overhead</td>
<td>Minimieren (einfache Prädikate bevorzugen)</td>
</tr>
<tr>
<td><code>filter_short_circuits</code></td>
<td>Bool-Logik-Effizienz</td>
<td>Maximieren (selektive Prädikate zuerst)</td>
</tr>
<tr>
<td><code>frontier_processed_per_depth</code></td>
<td>BFS-Expansion</td>
<td>Kontrolliert wachsen (nicht exponentiell)</td>
</tr>
<tr>
<td><code>enqueued_per_depth</code></td>
<td>Neue Frontier</td>
<td>Niedrig halten (visited-Set wirkt)</td>
</tr>
</tbody>
</table>
<p><strong>Faustregel:</strong><br />
<code>pruned_last_level / edges_expanded</code> sollte &gt; 10% sein für effektives Pruning.</p>
<hr />
<p><strong>Siehe auch:</strong>
- <a href="#aql_syntax">AQL Syntax</a>
- <a href="#indexes">Indexes</a>
- <a href="#architecture-graph-layer">Graph Traversal</a></p></section><section class="print-page" id="recursive_path_queries" heading-number="6.4"><h1 id="recursive_path_queries-recursive-path-queries-multi-hop-reasoning">Recursive Path Queries &amp; Multi-Hop Reasoning<a class="headerlink" href="#recursive_path_queries-recursive-path-queries-multi-hop-reasoning" title="Permanent link">&para;</a></h1>
<p><strong>Status:</strong> MVP Complete (31. Oktober 2025)<br />
<strong>Feature Set:</strong> Rekursive Pfadabfragen, Multi-Hop Traversal, Temporale Graph-Queries</p>
<hr />
<h2 id="recursive_path_queries-uberblick">Überblick<a class="headerlink" href="#recursive_path_queries-uberblick" title="Permanent link">&para;</a></h2>
<p>Das Themis Query-Engine-Modul unterstützt jetzt rekursive Pfadabfragen für Graph-Traversals mit variabler Tiefe und optionaler zeitlicher Filterung.</p>
<h3 id="recursive_path_queries-hauptfunktionen">Hauptfunktionen<a class="headerlink" href="#recursive_path_queries-hauptfunktionen" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Recursive Path Queries:</strong> Variable Tiefe ohne festes Limit (1..max_depth)</li>
<li><strong>Multi-Hop Traversal:</strong> Automatische Pfadfindung über mehrere Knoten</li>
<li><strong>Temporal Graph Support:</strong> Zeitabhängige Kanten mit <code>valid_from</code>/<code>valid_to</code></li>
<li><strong>Shortest Path:</strong> Dijkstra-Algorithmus für kürzeste Pfade</li>
<li><strong>Breadth-First Search:</strong> Alle erreichbaren Knoten bis zu einer bestimmten Tiefe</li>
</ul>
<hr />
<h2 id="recursive_path_queries-api-referenz">API-Referenz<a class="headerlink" href="#recursive_path_queries-api-referenz" title="Permanent link">&para;</a></h2>
<h3 id="recursive_path_queries-recursivepathquery-struktur">RecursivePathQuery Struktur<a class="headerlink" href="#recursive_path_queries-recursivepathquery-struktur" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">struct RecursivePathQuery {
    std::string start_node;              // Start-Knoten (erforderlich)
    std::string end_node;                // Ziel-Knoten (optional, leer = BFS)
    std::string edge_type;               // Kanten-Typ-Filter (reserviert)
    size_t max_depth = 5;                // Maximale Traversal-Tiefe
    std::optional&lt;std::string&gt; valid_from;  // Zeitfenster Start (ms)
    std::optional&lt;std::string&gt; valid_to;    // Zeitfenster Ende (ms)
};
</code></pre>
<h3 id="recursive_path_queries-queryengine-methode">QueryEngine Methode<a class="headerlink" href="#recursive_path_queries-queryengine-methode" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;std::vector&lt;std::string&gt;&gt;&gt; 
executeRecursivePathQuery(const RecursivePathQuery&amp; q) const;
</code></pre>
<p><strong>Rückgabe:</strong>
- <code>Status</code>: OK oder Fehlermeldung
- <code>vector&lt;vector&lt;string&gt;&gt;</code>: Liste von Pfaden (jeder Pfad ist eine Sequenz von Knoten-IDs)</p>
<hr />
<h2 id="recursive_path_queries-verwendungsbeispiele">Verwendungsbeispiele<a class="headerlink" href="#recursive_path_queries-verwendungsbeispiele" title="Permanent link">&para;</a></h2>
<h3 id="recursive_path_queries-beispiel-1-kurzester-pfad-single-target">Beispiel 1: Kürzester Pfad (Single Target)<a class="headerlink" href="#recursive_path_queries-beispiel-1-kurzester-pfad-single-target" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &quot;query/query_engine.h&quot;
#include &quot;index/graph_index.h&quot;

// Setup
RocksDBWrapper db;
db.open(&quot;data/mydb&quot;);
SecondaryIndexManager secIdx(db);
GraphIndexManager graphIdx(db);
QueryEngine engine(db, secIdx, graphIdx);

// Query: Finde kürzesten Pfad von A nach D
RecursivePathQuery q;
q.start_node = &quot;A&quot;;
q.end_node = &quot;D&quot;;
q.max_depth = 10;

auto [st, paths] = engine.executeRecursivePathQuery(q);
if (st.ok &amp;&amp; !paths.empty()) {
    // paths[0] = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]
    for (const auto&amp; node : paths[0]) {
        std::cout &lt;&lt; node &lt;&lt; &quot; -&gt; &quot;;
    }
}
</code></pre>
<h3 id="recursive_path_queries-beispiel-2-bfs-alle-erreichbaren-knoten">Beispiel 2: BFS - Alle erreichbaren Knoten<a class="headerlink" href="#recursive_path_queries-beispiel-2-bfs-alle-erreichbaren-knoten" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Query: Finde alle Knoten erreichbar von A (max Tiefe 3)
RecursivePathQuery q;
q.start_node = &quot;A&quot;;
// Kein end_node = BFS-Modus
q.max_depth = 3;

auto [st, paths] = engine.executeRecursivePathQuery(q);
if (st.ok) {
    std::cout &lt;&lt; &quot;Erreichbare Knoten: &quot; &lt;&lt; paths.size() &lt;&lt; std::endl;
    for (const auto&amp; path : paths) {
        std::cout &lt;&lt; &quot;  &quot; &lt;&lt; path.back() &lt;&lt; std::endl; // Ziel-Knoten
    }
}
</code></pre>
<h3 id="recursive_path_queries-beispiel-3-temporale-pfadabfrage">Beispiel 3: Temporale Pfadabfrage<a class="headerlink" href="#recursive_path_queries-beispiel-3-temporale-pfadabfrage" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Query: Finde Pfad, der zur Zeit 1600ms gültig war
RecursivePathQuery q;
q.start_node = &quot;A&quot;;
q.end_node = &quot;C&quot;;
q.max_depth = 5;
q.valid_from = &quot;1600&quot;;  // Zeitstempel in Millisekunden

auto [st, paths] = engine.executeRecursivePathQuery(q);
// Nur Kanten, die bei valid_from &lt;= 1600 &lt;= valid_to sind, werden traversiert
</code></pre>
<h3 id="recursive_path_queries-beispiel-4-zeitfenster-query">Beispiel 4: Zeitfenster-Query<a class="headerlink" href="#recursive_path_queries-beispiel-4-zeitfenster-query" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Query: Finde Pfad im Zeitfenster [1000, 2000]
RecursivePathQuery q;
q.start_node = &quot;A&quot;;
q.end_node = &quot;D&quot;;
q.max_depth = 10;
q.valid_from = &quot;1000&quot;;
q.valid_to = &quot;2000&quot;;

auto [st, paths] = engine.executeRecursivePathQuery(q);
// Verwendet Mittelpunkt des Zeitfensters (1500ms) als Query-Zeitstempel
</code></pre>
<hr />
<h2 id="recursive_path_queries-graphen-schema">Graphen-Schema<a class="headerlink" href="#recursive_path_queries-graphen-schema" title="Permanent link">&para;</a></h2>
<h3 id="recursive_path_queries-knoten-entity">Knoten-Entity<a class="headerlink" href="#recursive_path_queries-knoten-entity" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">BaseEntity node(&quot;nodes&quot;, &quot;node_id&quot;);
node.set(&quot;name&quot;, &quot;Node Name&quot;);
node.set(&quot;type&quot;, &quot;Person&quot;);
// ... weitere Attribute
db.putEntity(node);
</code></pre>
<h3 id="recursive_path_queries-kanten-entity-standardgraph">Kanten-Entity (Standardgraph)<a class="headerlink" href="#recursive_path_queries-kanten-entity-standardgraph" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">BaseEntity edge(&quot;edges&quot;, &quot;edge_id&quot;);
edge.set(&quot;_from&quot;, &quot;node_a&quot;);  // Erforderlich
edge.set(&quot;_to&quot;, &quot;node_b&quot;);    // Erforderlich
edge.set(&quot;_weight&quot;, 1.5);     // Optional für gewichtete Pfade
db.putEntity(edge);
graphIdx.addEdge(edge);
</code></pre>
<h3 id="recursive_path_queries-kanten-entity-temporaler-graph">Kanten-Entity (Temporaler Graph)<a class="headerlink" href="#recursive_path_queries-kanten-entity-temporaler-graph" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">BaseEntity edge(&quot;edges&quot;, &quot;edge_id&quot;);
edge.set(&quot;_from&quot;, &quot;node_a&quot;);
edge.set(&quot;_to&quot;, &quot;node_b&quot;);
edge.set(&quot;valid_from&quot;, 1000);  // Millisekunden seit Epoch
edge.set(&quot;valid_to&quot;, 2000);    // Millisekunden seit Epoch
db.putEntity(edge);
graphIdx.addEdge(edge);
</code></pre>
<p><strong>Zeitfenster-Semantik:</strong>
- <code>valid_from</code> = null → gültig seit Anbeginn der Zeit
- <code>valid_to</code> = null → gültig bis in alle Ewigkeit
- Query-Zeitstempel <code>t</code> muss in <code>[valid_from, valid_to]</code> liegen</p>
<hr />
<h2 id="recursive_path_queries-interne-algorithmen">Interne Algorithmen<a class="headerlink" href="#recursive_path_queries-interne-algorithmen" title="Permanent link">&para;</a></h2>
<h3 id="recursive_path_queries-shortest-path-end_node-angegeben">Shortest Path (end_node angegeben)<a class="headerlink" href="#recursive_path_queries-shortest-path-end_node-angegeben" title="Permanent link">&para;</a></h3>
<p>Verwendet <strong>Dijkstra-Algorithmus</strong>:
- Zeit-Komplexität: O((V + E) log V)
- Gewichtete Graphen unterstützt (Feld <code>_weight</code>)
- Temporal variant: <code>dijkstraAtTime()</code> filtert Kanten nach Zeitstempel</p>
<h3 id="recursive_path_queries-bfs-kein-end_node">BFS (kein end_node)<a class="headerlink" href="#recursive_path_queries-bfs-kein-end_node" title="Permanent link">&para;</a></h3>
<p>Verwendet <strong>Breadth-First Search</strong>:
- Zeit-Komplexität: O(V + E)
- Findet alle Knoten bis zu <code>max_depth</code>
- Temporal variant: <code>bfsAtTime()</code> filtert Kanten nach Zeitstempel</p>
<h3 id="recursive_path_queries-temporal-filtering">Temporal Filtering<a class="headerlink" href="#recursive_path_queries-temporal-filtering" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TemporalFilter filter = TemporalFilter::at(timestamp_ms);

// Für jede Kante:
bool isValid = filter.isValid(edge.valid_from, edge.valid_to);
</code></pre>
<hr />
<h2 id="recursive_path_queries-performance-charakteristiken">Performance-Charakteristiken<a class="headerlink" href="#recursive_path_queries-performance-charakteristiken" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shortest Path (Dijkstra)</td>
<td>O((V + E) log V)</td>
<td>O(V)</td>
<td>Mit Priority Queue</td>
</tr>
<tr>
<td>BFS Traversal</td>
<td>O(V + E)</td>
<td>O(V)</td>
<td>Breadth-First</td>
</tr>
<tr>
<td>Temporal Filter Check</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Per Edge</td>
</tr>
<tr>
<td>Path Reconstruction</td>
<td>O(depth)</td>
<td>O(depth)</td>
<td>Linear in Tiefe</td>
</tr>
</tbody>
</table>
<p><strong>Skalierung:</strong>
- In-Memory Graph Topology: O(1) Nachbarschaftsabfragen
- RocksDB Fallback: O(log N) bei kalten Kanten
- Empfohlenes Limit: max_depth &lt;= 10 für interaktive Queries</p>
<hr />
<h2 id="recursive_path_queries-tests">Tests<a class="headerlink" href="#recursive_path_queries-tests" title="Permanent link">&para;</a></h2>
<h3 id="recursive_path_queries-unit-tests-test_recursive_path_querycpp">Unit-Tests (test_recursive_path_query.cpp)<a class="headerlink" href="#recursive_path_queries-unit-tests-test_recursive_path_querycpp" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ <code>SimplePathQuery</code>: Kürzester Pfad A → D in linearem Graph</li>
<li>✅ <code>PathNotFound</code>: Kein Pfad in Gegenrichtung (gerichteter Graph)</li>
<li>✅ <code>BFSReachableNodes</code>: BFS findet alle erreichbaren Knoten</li>
<li>✅ <code>TemporalPathQuery_ValidTime</code>: Pfad zur Zeit 1600ms</li>
<li>✅ <code>TemporalPathQuery_InvalidTime</code>: Kein Pfad zur Zeit 500ms</li>
<li>✅ <code>MaxDepthLimit</code>: Respektiert max_depth Grenze</li>
<li>✅ <code>EmptyStartNode</code>: Fehlerbehandlung für leeren Start</li>
<li>✅ <code>NoGraphIndexManager</code>: Fehlerbehandlung ohne Graph-Index</li>
</ul>
<p><strong>Test-Ausführung:</strong></p>
<pre><code class="language-bash">cd build
.\Release\themis_tests.exe --gtest_filter=&quot;RecursivePathQueryTest.*&quot;
</code></pre>
<hr />
<h2 id="recursive_path_queries-einschrankungen-todos">Einschränkungen &amp; TODOs<a class="headerlink" href="#recursive_path_queries-einschrankungen-todos" title="Permanent link">&para;</a></h2>
<h3 id="recursive_path_queries-mvp-scope-aktuell">MVP Scope (Aktuell)<a class="headerlink" href="#recursive_path_queries-mvp-scope-aktuell" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ Single shortest path (Dijkstra)</li>
<li>✅ BFS für erreichbare Knoten</li>
<li>✅ Temporale Filterung (valid_from/valid_to)</li>
<li>✅ Max-Tiefe-Limit</li>
</ul>
<h3 id="recursive_path_queries-zukunftige-erweiterungen">Zukünftige Erweiterungen<a class="headerlink" href="#recursive_path_queries-zukunftige-erweiterungen" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] <strong>All Paths Enumeration:</strong> Nicht nur kürzester, sondern alle Pfade</li>
<li>[ ] <strong>Path Constraints:</strong> Filter auf Kanten-Attributen (z.B. <code>edge_type</code>)</li>
<li>[ ] <strong>Variable-Length Patterns:</strong> Cypher-Style <code>[:KNOWS*1..5]</code></li>
<li>[ ] <strong>Recursive CTEs:</strong> SQL-ähnliche WITH RECURSIVE Syntax</li>
<li>[ ] <strong>Weighted Temporal Paths:</strong> Kombination von Zeitfenster und Gewichtung</li>
<li>[ ] <strong>Bidirectional Search:</strong> Schnellere Pfadsuche für große Graphen</li>
<li>[ ] <strong>Graph Projection:</strong> Virtuelle Subgraphen für spezielle Queries</li>
</ul>
<hr />
<h2 id="recursive_path_queries-aql-integration-geplant">AQL-Integration (Geplant)<a class="headerlink" href="#recursive_path_queries-aql-integration-geplant" title="Permanent link">&para;</a></h2>
<h3 id="recursive_path_queries-zukunftige-aql-syntax">Zukünftige AQL-Syntax<a class="headerlink" href="#recursive_path_queries-zukunftige-aql-syntax" title="Permanent link">&para;</a></h3>
<pre><code class="language-aql">// Kürzester Pfad
FOR v, e, p IN 1..5 OUTBOUND 'nodes/A' GRAPH 'my_graph'
    FILTER p.vertices[*]._key == 'D'
    LIMIT 1
    RETURN p

// Temporale Pfadabfrage
FOR v, e, p IN 1..3 OUTBOUND 'nodes/A' GRAPH 'my_graph'
    FILTER e.valid_from &lt;= @timestamp AND e.valid_to &gt;= @timestamp
    FILTER p.vertices[-1]._key == 'D'
    RETURN p

// Alle erreichbaren Knoten
FOR v IN 1..3 OUTBOUND 'nodes/A' GRAPH 'my_graph'
    RETURN DISTINCT v
</code></pre>
<hr />
<h2 id="recursive_path_queries-siehe-auch">Siehe auch<a class="headerlink" href="#recursive_path_queries-siehe-auch" title="Permanent link">&para;</a></h2>
<ul>
<li><code>docs/architecture.md</code> - System-Architektur-Übersicht</li>
<li><code>include/index/graph_index.h</code> - Graph-Index API</li>
<li><code>include/index/temporal_graph.h</code> - Temporal-Filter Design</li>
<li><code>tests/test_graph_index.cpp</code> - Graph-Index Unit-Tests</li>
<li><code>tests/test_temporal_graph.cpp</code> - Temporal-Graph Tests</li>
</ul>
<hr />
<p><strong>Letzte Aktualisierung:</strong> 31. Oktober 2025<br />
<strong>Version:</strong> 1.0.0 (MVP)<br />
<strong>Status:</strong> ✅ Production Ready</p></section><section class="print-page" id="temporal_graphs" heading-number="6.5"><h1 id="temporal_graphs-temporal-graphs-themis">Temporal Graphs - Themis<a class="headerlink" href="#temporal_graphs-temporal-graphs-themis" title="Permanent link">&para;</a></h1>
<h2 id="temporal_graphs-overview">Overview<a class="headerlink" href="#temporal_graphs-overview" title="Permanent link">&para;</a></h2>
<p>Themis' Temporal Graph implementation adds time-awareness to graph edges, enabling historical queries and point-in-time graph traversals. This is critical for tracking relationship evolution, knowledge graph versioning, and time-series network analysis.</p>
<p><strong>Key Features:</strong>
- <strong>Temporal Edges</strong>: Edges with <code>valid_from</code> and <code>valid_to</code> timestamps
- <strong>Point-in-Time Queries</strong>: Traverse graph as it existed at specific timestamp
- <strong>Historical Analysis</strong>: Track how relationships changed over time
- <strong>Flexible Validity</strong>: Unbounded intervals supported (null = forever/since beginning)
- <strong>Efficient Filtering</strong>: Temporal checks integrated into BFS/Dijkstra algorithms</p>
<hr />
<h2 id="temporal_graphs-architecture">Architecture<a class="headerlink" href="#temporal_graphs-architecture" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-data-model">Data Model<a class="headerlink" href="#temporal_graphs-data-model" title="Permanent link">&para;</a></h3>
<p><strong>Temporal Edge Schema:</strong></p>
<pre><code class="language-cpp">struct Edge {
    std::string id;
    std::string _from;              // Source node
    std::string _to;                // Target node
    double _weight = 1.0;           // Edge weight for pathfinding

    // Temporal fields (optional)
    std::optional&lt;int64_t&gt; valid_from;  // Start of validity (ms since epoch)
    std::optional&lt;int64_t&gt; valid_to;    // End of validity (ms since epoch)
}
</code></pre>
<p><strong>Validity Semantics:</strong>
- <code>valid_from = null</code>: Edge valid since beginning of time
- <code>valid_to = null</code>: Edge valid indefinitely into future
- <code>valid_from = T1, valid_to = T2</code>: Edge valid during interval [T1, T2]
- Both <code>null</code>: Edge always valid (eternal)</p>
<p><strong>Temporal Filter Logic:</strong></p>
<pre><code class="language-cpp">bool isValid(query_timestamp, valid_from, valid_to) {
    if (valid_from.has_value() &amp;&amp; query_timestamp &lt; valid_from) {
        return false;  // Not yet valid
    }
    if (valid_to.has_value() &amp;&amp; query_timestamp &gt; valid_to) {
        return false;  // No longer valid
    }
    return true;  // Valid at query time
}
</code></pre>
<hr />
<h2 id="temporal_graphs-api-reference">API Reference<a class="headerlink" href="#temporal_graphs-api-reference" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-c-api">C++ API<a class="headerlink" href="#temporal_graphs-c-api" title="Permanent link">&para;</a></h3>
<h4 id="temporal_graphs-1-bfs-at-time">1. BFS At Time<a class="headerlink" href="#temporal_graphs-1-bfs-at-time" title="Permanent link">&para;</a></h4>
<p>Breadth-first search with temporal filtering.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;std::string&gt;&gt; bfsAtTime(
    std::string_view startPk,
    int64_t timestamp_ms,
    int maxDepth = 3
) const;
</code></pre>
<p><strong>Parameters:</strong>
- <code>startPk</code>: Starting node primary key
- <code>timestamp_ms</code>: Query timestamp (milliseconds since epoch)
- <code>maxDepth</code>: Maximum traversal depth</p>
<p><strong>Returns:</strong>
- <code>Status</code>: Success/error status
- <code>std::vector&lt;std::string&gt;</code>: Reachable nodes (BFS order)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">// Query: Which nodes could Alice reach in January 2023?
auto [st, nodes] = graph_mgr-&gt;bfsAtTime(&quot;Alice&quot;, 1672531200000, 5);
if (st.ok) {
    for (const auto&amp; node : nodes) {
        std::cout &lt;&lt; &quot;Reachable: &quot; &lt;&lt; node &lt;&lt; &quot;\n&quot;;
    }
}
</code></pre>
<h4 id="temporal_graphs-2-dijkstra-at-time">2. Dijkstra At Time<a class="headerlink" href="#temporal_graphs-2-dijkstra-at-time" title="Permanent link">&para;</a></h4>
<p>Shortest path with temporal filtering.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-cpp">std::pair&lt;Status, PathResult&gt; dijkstraAtTime(
    std::string_view startPk,
    std::string_view targetPk,
    int64_t timestamp_ms
) const;
</code></pre>
<p><strong>Returns:</strong>
- <code>PathResult.path</code>: Nodes from start to target
- <code>PathResult.totalCost</code>: Total path cost (sum of weights)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">// Query: Shortest path from Alice to CompanyX in 2022?
auto [st, path] = graph_mgr-&gt;dijkstraAtTime(&quot;Alice&quot;, &quot;CompanyX&quot;, 1640995200000);
if (st.ok) {
    std::cout &lt;&lt; &quot;Path cost: &quot; &lt;&lt; path.totalCost &lt;&lt; &quot;\n&quot;;
    for (const auto&amp; node : path.path) {
        std::cout &lt;&lt; node &lt;&lt; &quot; -&gt; &quot;;
    }
}
</code></pre>
<h3 id="temporal_graphs-aql-integration-future">AQL Integration (Future)<a class="headerlink" href="#temporal_graphs-aql-integration-future" title="Permanent link">&para;</a></h3>
<p>Planned AQL syntax for temporal queries:</p>
<pre><code class="language-aql">// Find all documents cited by Doc1 in 2022
FOR v IN 1..3 OUTBOUND 'Doc1' citations
    FILTER e.valid_from &lt;= @timestamp AND e.valid_to &gt;= @timestamp
    RETURN v

// Shortest path at specific time
FOR p IN SHORTEST_PATH 'Alice' TO 'CompanyX' GRAPH employment_graph
    FILTER PATH.ALL(e, e.valid_from &lt;= @timestamp AND e.valid_to &gt;= @timestamp)
    RETURN p
</code></pre>
<hr />
<h2 id="temporal_graphs-test-validation-30102025">Test Validation (30.10.2025)<a class="headerlink" href="#temporal_graphs-test-validation-30102025" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-test-suite-18-tests-all-passed">Test Suite: 18 Tests - ALL PASSED ✅<a class="headerlink" href="#temporal_graphs-test-suite-18-tests-all-passed" title="Permanent link">&para;</a></h3>
<h4 id="temporal_graphs-unit-tests-temporalfilter">Unit Tests (TemporalFilter)<a class="headerlink" href="#temporal_graphs-unit-tests-temporalfilter" title="Permanent link">&para;</a></h4>
<p><strong>Test 1: NoFilter_AcceptsAll</strong> ✅
- Filter with <code>timestamp = null</code> accepts all edges
- Validates unbounded interval support</p>
<p><strong>Test 2: WithTimestamp_FiltersCorrectly</strong> ✅
- Edges before <code>valid_from</code> → rejected
- Edges after <code>valid_to</code> → rejected
- Edges during validity period → accepted
- Unbounded intervals handled correctly</p>
<p><strong>Test 3: BoundaryConditions</strong> ✅
- Query at exact <code>valid_from</code> → accepted
- Query at exact <code>valid_to</code> → accepted
- Edge valid only at query time → accepted</p>
<h4 id="temporal_graphs-bfs-temporal-tests">BFS Temporal Tests<a class="headerlink" href="#temporal_graphs-bfs-temporal-tests" title="Permanent link">&para;</a></h4>
<p><strong>Test 4: NoTemporalEdges_ReturnsAllNeighbors</strong> ✅
- Graph without temporal constraints behaves normally
- All nodes reachable regardless of timestamp</p>
<p><strong>Test 5: FiltersByValidFrom</strong> ✅
- Edge A→B valid from 2022 onwards
- Query at 2021: Only A reachable
- Query at 2023: A→B→C reachable</p>
<p><strong>Test 6: FiltersByValidTo</strong> ✅
- Edge A→B valid until 2022
- Query at 2021: Full graph accessible
- Query at 2023: A isolated (edge expired)</p>
<p><strong>Test 7: FiltersByValidRange</strong> ✅
- Edge A→B valid from 2021 to 2023
- Query at 2020: A isolated
- Query at 2022: Full graph
- Query at 2024: A isolated</p>
<p><strong>Test 8: MultiplePathsOverTime</strong> ✅
- Complex scenario: paths change over time
- Period 2020-2021: A→B→D
- Period 2022-2023: A→C→D
- Period 2024+: Both paths active</p>
<p><strong>Test 9: IsolatedNodeAfterExpiration</strong> ✅
- All outgoing edges expire
- Node becomes isolated after expiration time</p>
<h4 id="temporal_graphs-dijkstra-temporal-tests">Dijkstra Temporal Tests<a class="headerlink" href="#temporal_graphs-dijkstra-temporal-tests" title="Permanent link">&para;</a></h4>
<p><strong>Test 10: FindsShortestPathAtTime</strong> ✅
- Two paths: A→B→D (cost 2) and A→C→D (cost 6)
- Before C→D becomes valid: uses A→B→D
- After both paths valid: still uses shorter path</p>
<p><strong>Test 11: PathChangesOverTime</strong> ✅
- Path A→B→D valid 2020-2022 (cost 3)
- Path A→C→D valid 2023+ (cost 2)
- Algorithm correctly switches to cheaper path when available</p>
<p><strong>Test 12: NoPathAtTime</strong> ✅
- All edges to target expired
- Returns error: "Kein Pfad gefunden"</p>
<h4 id="temporal_graphs-edge-cases">Edge Cases<a class="headerlink" href="#temporal_graphs-edge-cases" title="Permanent link">&para;</a></h4>
<p><strong>Test 13-15: Input Validation</strong> ✅
- Empty node names → error
- Negative depth → error
- Proper error messages returned</p>
<p><strong>Test 16: MaxDepthZero_ReturnsOnlyStart</strong> ✅
- Depth limit of 0 returns only starting node</p>
<h4 id="temporal_graphs-real-world-scenarios">Real-World Scenarios<a class="headerlink" href="#temporal_graphs-real-world-scenarios" title="Permanent link">&para;</a></h4>
<p><strong>Test 17: EmploymentHistory</strong> ✅
- Models: Alice worked at CompanyA (2020-2022), CompanyB (2023+)
- Query 2021: Alice→CompanyA
- Query 2023: Alice→CompanyB</p>
<p><strong>Test 18: KnowledgeGraphEvolution</strong> ✅
- Document citation network evolves over time
- Citations added/retracted
- Historical queries return correct citation graph state</p>
<hr />
<h2 id="temporal_graphs-use-cases">Use Cases<a class="headerlink" href="#temporal_graphs-use-cases" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-1-employmentorganizational-networks">1. Employment/Organizational Networks<a class="headerlink" href="#temporal_graphs-1-employmentorganizational-networks" title="Permanent link">&para;</a></h3>
<p>Track employee-company relationships over time:</p>
<pre><code class="language-cpp">// Create temporal employment edge
auto e1 = createTemporalEdge(
    &quot;emp1&quot;,
    &quot;Alice&quot;,
    &quot;CompanyA&quot;,
    toTimestamp(2020, 1, 1),  // started Jan 2020
    toTimestamp(2022, 12, 31) // ended Dec 2022
);
graph_mgr-&gt;addEdge(e1);

// Query: Where did Alice work in 2021?
auto [st, nodes] = graph_mgr-&gt;bfsAtTime(&quot;Alice&quot;, toTimestamp(2021, 6, 1), 1);
// Returns: [&quot;Alice&quot;, &quot;CompanyA&quot;]
</code></pre>
<h3 id="temporal_graphs-2-knowledge-graph-versioning">2. Knowledge Graph Versioning<a class="headerlink" href="#temporal_graphs-2-knowledge-graph-versioning" title="Permanent link">&para;</a></h3>
<p>Track evolving knowledge and citations:</p>
<pre><code class="language-cpp">// Citation retracted in 2023
auto cite = createTemporalEdge(
    &quot;cite1&quot;,
    &quot;Paper1&quot;,
    &quot;Paper2&quot;,
    toTimestamp(2020, 1, 1),
    toTimestamp(2023, 1, 1)  // retracted
);

// Query: What did Paper1 cite in 2021?
auto [st, citations] = graph_mgr-&gt;bfsAtTime(&quot;Paper1&quot;, toTimestamp(2021, 1, 1), 1);
// Returns: [&quot;Paper1&quot;, &quot;Paper2&quot;]

// Query: What does Paper1 cite in 2024?
auto [st2, citations2] = graph_mgr-&gt;bfsAtTime(&quot;Paper1&quot;, toTimestamp(2024, 1, 1), 1);
// Returns: [&quot;Paper1&quot;] (citation retracted)
</code></pre>
<h3 id="temporal_graphs-3-social-network-evolution">3. Social Network Evolution<a class="headerlink" href="#temporal_graphs-3-social-network-evolution" title="Permanent link">&para;</a></h3>
<p>Model friendships, follows, and connections over time:</p>
<pre><code class="language-cpp">// Alice followed Bob from 2020-2022, then unfollowed
auto follow = createTemporalEdge(
    &quot;follow1&quot;,
    &quot;Alice&quot;,
    &quot;Bob&quot;,
    toTimestamp(2020, 1, 1),
    toTimestamp(2022, 12, 31)
);

// Query: Who could Alice reach in 2021?
auto [st, network] = graph_mgr-&gt;bfsAtTime(&quot;Alice&quot;, toTimestamp(2021, 1, 1), 2);
// Returns: Alice's network including Bob

// Query: Who can Alice reach in 2023?
auto [st2, network2] = graph_mgr-&gt;bfsAtTime(&quot;Alice&quot;, toTimestamp(2023, 1, 1), 2);
// Returns: Alice's network excluding Bob
</code></pre>
<h3 id="temporal_graphs-4-infrastructurenetwork-changes">4. Infrastructure/Network Changes<a class="headerlink" href="#temporal_graphs-4-infrastructurenetwork-changes" title="Permanent link">&para;</a></h3>
<p>Track network topology changes:</p>
<pre><code class="language-cpp">// Router1 -&gt; Router2 link active 2020-2022
// Router1 -&gt; Router3 link active 2023+
// Query shortest path at different times
auto [st1, path1] = graph_mgr-&gt;dijkstraAtTime(&quot;Router1&quot;, &quot;Server1&quot;, toTimestamp(2021, 1, 1));
auto [st2, path2] = graph_mgr-&gt;dijkstraAtTime(&quot;Router1&quot;, &quot;Server1&quot;, toTimestamp(2024, 1, 1));
// Paths differ based on network topology at query time
</code></pre>
<hr />
<h2 id="temporal_graphs-performance-considerations">Performance Considerations<a class="headerlink" href="#temporal_graphs-performance-considerations" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-current-implementation">Current Implementation<a class="headerlink" href="#temporal_graphs-current-implementation" title="Permanent link">&para;</a></h3>
<p><strong>Time Complexity:</strong>
- BFS at time: O(V + E * T) where T = edge load time
- Dijkstra at time: O((V + E) * log V * T)</p>
<p><strong>Edge Load Overhead:</strong>
Each edge requires:
1. RocksDB Get (~1-2ms for SSD)
2. Deserialization (~0.1ms)
3. Temporal filter check (~0.001ms)</p>
<p><strong>Optimization Strategies:</strong></p>
<ol>
<li>
<p><strong>Batch Edge Loading:</strong>
   <code>cpp
   // Instead of individual Gets, use MultiGet
   std::vector&lt;std::string&gt; edge_keys;
   for (auto&amp; adj : adjacency) {
       edge_keys.push_back(makeGraphEdgeKey(adj.edgeId));
   }
   auto edges = db_.multiGet(edge_keys);  // Single batch call</code></p>
</li>
<li>
<p><strong>Temporal Index:</strong>
   <code>cpp
   // Secondary index: valid_at_timestamp -&gt; [edge_ids]
   // Enables fast "give me all edges valid at time T"
   Key: "temporal_index:2023-01-01:edge1" -&gt; ""</code></p>
</li>
<li>
<p><strong>Caching:</strong>
   <code>cpp
   // Cache edge validity info (avoid deserialization)
   struct EdgeValidityCache {
       std::string edge_id;
       std::optional&lt;int64_t&gt; valid_from;
       std::optional&lt;int64_t&gt; valid_to;
   };</code></p>
</li>
</ol>
<hr />
<h2 id="temporal_graphs-limitations-future-enhancements">Limitations &amp; Future Enhancements<a class="headerlink" href="#temporal_graphs-limitations-future-enhancements" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-current-limitations">Current Limitations<a class="headerlink" href="#temporal_graphs-current-limitations" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>No Temporal Aggregation:</strong> Cannot query "How many times did this edge exist?"</li>
<li><strong>No Event Streams:</strong> Cannot subscribe to temporal changes</li>
<li><strong>Single Timestamp Queries:</strong> No interval queries (e.g., "valid anytime during 2020-2022")</li>
<li><strong>No Temporal Joins:</strong> Cannot correlate temporal patterns across graphs</li>
</ol>
<h3 id="temporal_graphs-planned-enhancements-sprint-c">Planned Enhancements (Sprint C+)<a class="headerlink" href="#temporal_graphs-planned-enhancements-sprint-c" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>Temporal Range Queries:</strong>
   <code>cpp
   // Find all edges that were ever valid during interval
   auto edges = graph_mgr-&gt;getEdgesValidDuring(t_start, t_end);</code></p>
</li>
<li>
<p><strong>Temporal Aggregations:</strong>
   <code>cpp
   // How long was this edge valid?
   auto duration = graph_mgr-&gt;getTotalValidDuration(edge_id);</code></p>
</li>
<li>
<p><strong>AQL Integration:</strong>
   <code>aql
   FOR v IN 1..3 OUTBOUND 'Doc1' citations
       OPTIONS {timestamp: @query_time}
       RETURN v</code></p>
</li>
<li>
<p><strong>Temporal Predicates:</strong>
   <code>aql
   // Find nodes reachable at ANY point during 2022
   FOR v IN 1..3 OUTBOUND 'Alice' friends
       FILTER e.valid_from &lt;= '2022-12-31' AND e.valid_to &gt;= '2022-01-01'
       RETURN DISTINCT v</code></p>
</li>
<li>
<p><strong>Change Stream:</strong>
   <code>cpp
   // Subscribe to temporal edge changes
   graph_mgr-&gt;watchTemporalChanges(callback);</code></p>
</li>
</ol>
<hr />
<h2 id="temporal_graphs-implementation-notes">Implementation Notes<a class="headerlink" href="#temporal_graphs-implementation-notes" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-temporal-filter">Temporal Filter<a class="headerlink" href="#temporal_graphs-temporal-filter" title="Permanent link">&para;</a></h3>
<p>Located in <code>include/index/temporal_graph.h</code>:</p>
<pre><code class="language-cpp">struct TemporalFilter {
    std::optional&lt;int64_t&gt; timestamp_ms;

    bool isValid(std::optional&lt;int64_t&gt; valid_from, 
                 std::optional&lt;int64_t&gt; valid_to) const {
        if (!timestamp_ms.has_value()) return true;  // No filter

        int64_t t = *timestamp_ms;
        if (valid_from.has_value() &amp;&amp; t &lt; *valid_from) return false;
        if (valid_to.has_value() &amp;&amp; t &gt; *valid_to) return false;
        return true;
    }

    static TemporalFilter now();
    static TemporalFilter at(int64_t timestamp_ms);
    static TemporalFilter all();  // No temporal filtering
};
</code></pre>
<h3 id="temporal_graphs-bfs-implementation">BFS Implementation<a class="headerlink" href="#temporal_graphs-bfs-implementation" title="Permanent link">&para;</a></h3>
<p>Located in <code>src/index/graph_index.cpp</code>:</p>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;std::string&gt;&gt; 
GraphIndexManager::bfsAtTime(std::string_view startPk, 
                             int64_t timestamp_ms, 
                             int maxDepth) const {
    TemporalFilter filter = TemporalFilter::at(timestamp_ms);

    // Standard BFS with temporal edge filtering
    for (const auto&amp; info : adjacency) {
        // Load edge to check validity
        BaseEntity edge = BaseEntity::deserialize(edgeKey, *blob);

        std::optional&lt;int64_t&gt; valid_from = edge.getFieldAsInt(&quot;valid_from&quot;);
        std::optional&lt;int64_t&gt; valid_to = edge.getFieldAsInt(&quot;valid_to&quot;);

        if (!filter.isValid(valid_from, valid_to)) {
            continue;  // Skip invalid edge
        }

        // Process valid neighbor
        // ...
    }
}
</code></pre>
<hr />
<h2 id="temporal_graphs-testing">Testing<a class="headerlink" href="#temporal_graphs-testing" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-run-temporal-graph-tests">Run Temporal Graph Tests<a class="headerlink" href="#temporal_graphs-run-temporal-graph-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Run all temporal graph tests
cd build
.\Release\themis_tests.exe --gtest_filter=&quot;TemporalGraphTest.*&quot;

# Expected output:
# [==========] Running 18 tests from 1 test suite.
# [  PASSED  ] 18 tests.
</code></pre>
<h3 id="temporal_graphs-test-coverage">Test Coverage<a class="headerlink" href="#temporal_graphs-test-coverage" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ TemporalFilter logic (3 tests)</li>
<li>✅ BFS temporal traversal (6 tests)</li>
<li>✅ Dijkstra shortest path (3 tests)</li>
<li>✅ Edge cases &amp; validation (3 tests)</li>
<li>✅ Real-world scenarios (3 tests)</li>
</ul>
<p><strong>Total: 18 tests, 100% passing</strong></p>
<hr />
<h2 id="temporal_graphs-configuration">Configuration<a class="headerlink" href="#temporal_graphs-configuration" title="Permanent link">&para;</a></h2>
<h3 id="temporal_graphs-enable-temporal-graph-default-enabled">Enable Temporal Graph (Default: Enabled)<a class="headerlink" href="#temporal_graphs-enable-temporal-graph-default-enabled" title="Permanent link">&para;</a></h3>
<p>No special configuration required - temporal edges work alongside regular edges.</p>
<p><strong>Optional: Temporal Index (Future):</strong></p>
<pre><code class="language-json">{
  &quot;graph&quot;: {
    &quot;temporal_index&quot;: true,
    &quot;temporal_cache_size_mb&quot;: 256
  }
}
</code></pre>
<hr />
<h2 id="temporal_graphs-summary">Summary<a class="headerlink" href="#temporal_graphs-summary" title="Permanent link">&para;</a></h2>
<p><strong>Sprint B - Temporal Graphs: ✅ PRODUCTION READY</strong></p>
<ul>
<li>✅ Temporal edge support with <code>valid_from</code>/<code>valid_to</code></li>
<li>✅ BFS at time implementation</li>
<li>✅ Dijkstra at time implementation</li>
<li>✅ 18 comprehensive Google Tests (all passing)</li>
<li>✅ Real-world scenario validation</li>
<li>✅ Documentation complete</li>
</ul>
<p><strong>Use Cases Validated:</strong>
- Employment history tracking
- Knowledge graph versioning
- Social network evolution
- Infrastructure change management</p>
<p><strong>Next Steps:</strong>
- Temporal range queries
- AQL integration
- Temporal aggregations
- Change streams</p></section><section class="print-page" id="temporal_time_range_queries" heading-number="6.6"><h1 id="temporal_time_range_queries-temporal-time-range-queries">Temporal Time-Range Queries<a class="headerlink" href="#temporal_time_range_queries-temporal-time-range-queries" title="Permanent link">&para;</a></h1>
<p><strong>Status:</strong> ✅ Implemented &amp; Tested (8/8 tests passing)<br />
<strong>Feature:</strong> Extended temporal graph queries with time-window filtering<br />
<strong>Date:</strong> 2025-01-15</p>
<hr />
<h2 id="temporal_time_range_queries-overview">Overview<a class="headerlink" href="#temporal_time_range_queries-overview" title="Permanent link">&para;</a></h2>
<p>This feature extends Themis's temporal graph capabilities from single-timestamp queries to <strong>time-range queries</strong>. You can now find all edges that overlap with or are fully contained within a specified time window.</p>
<h3 id="temporal_time_range_queries-use-cases">Use Cases<a class="headerlink" href="#temporal_time_range_queries-use-cases" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Audit Queries:</strong> "Show all relationships valid during Q4 2024"</li>
<li><strong>Compliance:</strong> "Find edges fully contained within investigation period"</li>
<li><strong>Historical Analysis:</strong> "What connections existed between 2020-2022?"</li>
<li><strong>Temporal Analytics:</strong> "Relationships overlapping with event timeframe"</li>
</ul>
<hr />
<h2 id="temporal_time_range_queries-api-reference">API Reference<a class="headerlink" href="#temporal_time_range_queries-api-reference" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-timerangefilter-structure">TimeRangeFilter Structure<a class="headerlink" href="#temporal_time_range_queries-timerangefilter-structure" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">struct TimeRangeFilter {
    int64_t start_ms;  // Range start (milliseconds since epoch)
    int64_t end_ms;    // Range end (milliseconds since epoch)

    // Factory methods
    static TimeRangeFilter between(int64_t start, int64_t end);
    static TimeRangeFilter since(int64_t start);
    static TimeRangeFilter until(int64_t end);
    static TimeRangeFilter all();

    // Filtering methods
    bool hasOverlap(std::optional&lt;int64_t&gt; edge_valid_from, 
                    std::optional&lt;int64_t&gt; edge_valid_to) const;
    bool fullyContains(std::optional&lt;int64_t&gt; edge_valid_from,
                       std::optional&lt;int64_t&gt; edge_valid_to) const;
};
</code></pre>
<h3 id="temporal_time_range_queries-edgeinfo-structure">EdgeInfo Structure<a class="headerlink" href="#temporal_time_range_queries-edgeinfo-structure" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">struct EdgeInfo {
    std::string edgeId;                     // Edge identifier
    std::string fromPk;                     // Source node primary key
    std::string toPk;                       // Target node primary key
    std::optional&lt;int64_t&gt; valid_from;      // Edge valid from (ms)
    std::optional&lt;int64_t&gt; valid_to;        // Edge valid to (ms)
};
</code></pre>
<h3 id="temporal_time_range_queries-query-methods">Query Methods<a class="headerlink" href="#temporal_time_range_queries-query-methods" title="Permanent link">&para;</a></h3>
<h4 id="temporal_time_range_queries-global-time-range-query">Global Time-Range Query<a class="headerlink" href="#temporal_time_range_queries-global-time-range-query" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;EdgeInfo&gt;&gt; 
getEdgesInTimeRange(int64_t range_start_ms, 
                    int64_t range_end_ms,
                    bool require_full_containment = false) const;
</code></pre>
<p><strong>Parameters:</strong>
- <code>range_start_ms</code>: Query time window start (milliseconds since epoch)
- <code>range_end_ms</code>: Query time window end (milliseconds since epoch)
- <code>require_full_containment</code>: 
  - <code>false</code> (default): Returns edges with <strong>any overlap</strong> with query window
  - <code>true</code>: Returns edges <strong>fully contained</strong> within query window</p>
<p><strong>Returns:</strong> 
- <code>Status</code>: Operation success/failure
- <code>vector&lt;EdgeInfo&gt;</code>: All matching edges with temporal metadata</p>
<p><strong>Time Complexity:</strong> O(E) where E = total edges in database</p>
<hr />
<h4 id="temporal_time_range_queries-node-specific-time-range-query">Node-Specific Time-Range Query<a class="headerlink" href="#temporal_time_range_queries-node-specific-time-range-query" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;EdgeInfo&gt;&gt;
getOutEdgesInTimeRange(std::string_view fromPk,
                       int64_t range_start_ms,
                       int64_t range_end_ms, 
                       bool require_full_containment = false) const;
</code></pre>
<p><strong>Parameters:</strong>
- <code>fromPk</code>: Source node primary key
- <code>range_start_ms</code>: Query time window start (milliseconds since epoch)
- <code>range_end_ms</code>: Query time window end (milliseconds since epoch)
- <code>require_full_containment</code>: Same as global query</p>
<p><strong>Returns:</strong> 
- <code>Status</code>: Operation success/failure
- <code>vector&lt;EdgeInfo&gt;</code>: All matching outgoing edges from <code>fromPk</code></p>
<p><strong>Time Complexity:</strong> O(d) where d = out-degree of node</p>
<hr />
<h2 id="temporal_time_range_queries-usage-examples">Usage Examples<a class="headerlink" href="#temporal_time_range_queries-usage-examples" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-example-1-overlap-query-default">Example 1: Overlap Query (Default)<a class="headerlink" href="#temporal_time_range_queries-example-1-overlap-query-default" title="Permanent link">&para;</a></h3>
<p>Find all edges with <strong>any overlap</strong> with time window [1000, 2000]:</p>
<pre><code class="language-cpp">GraphIndexManager graph(db);

// Add edges with different temporal periods
BaseEntity e1(&quot;edge1&quot;);
e1.setField(&quot;_from&quot;, &quot;A&quot;);
e1.setField(&quot;_to&quot;, &quot;B&quot;);
e1.setField(&quot;valid_from&quot;, 500);   // Partially overlaps
e1.setField(&quot;valid_to&quot;, 1500);
graph.addEdge(e1);

BaseEntity e2(&quot;edge2&quot;);
e2.setField(&quot;_from&quot;, &quot;A&quot;);
e2.setField(&quot;_to&quot;, &quot;C&quot;);
e2.setField(&quot;valid_from&quot;, 1200);  // Fully inside
e2.setField(&quot;valid_to&quot;, 1800);
graph.addEdge(e2);

BaseEntity e3(&quot;edge3&quot;);
e3.setField(&quot;_from&quot;, &quot;B&quot;);
e3.setField(&quot;_to&quot;, &quot;C&quot;);
e3.setField(&quot;valid_from&quot;, 2500);  // No overlap
e3.setField(&quot;valid_to&quot;, 3000);
graph.addEdge(e3);

// Query: Find edges overlapping [1000, 2000]
auto [status, edges] = graph.getEdgesInTimeRange(1000, 2000);

// Result: edges = [edge1, edge2]
// edge1: overlaps (500-1500 overlaps with 1000-2000)
// edge2: fully inside (1200-1800 inside 1000-2000)
// edge3: no overlap (2500-3000 is after 2000)
</code></pre>
<hr />
<h3 id="temporal_time_range_queries-example-2-full-containment-query">Example 2: Full Containment Query<a class="headerlink" href="#temporal_time_range_queries-example-2-full-containment-query" title="Permanent link">&para;</a></h3>
<p>Find edges <strong>fully contained</strong> within time window [1000, 3000]:</p>
<pre><code class="language-cpp">// Same edges as Example 1

// Query: Find edges FULLY INSIDE [1000, 3000]
auto [status, edges] = graph.getEdgesInTimeRange(1000, 3000, true);

// Result: edges = [edge2, edge3]
// edge1: NOT included (500-1500 starts before 1000)
// edge2: included (1200-1800 fully inside 1000-3000)
// edge3: included (2500-3000 fully inside 1000-3000)
</code></pre>
<hr />
<h3 id="temporal_time_range_queries-example-3-node-specific-time-range-query">Example 3: Node-Specific Time-Range Query<a class="headerlink" href="#temporal_time_range_queries-example-3-node-specific-time-range-query" title="Permanent link">&para;</a></h3>
<p>Find outgoing edges from specific node in time window:</p>
<pre><code class="language-cpp">// Add edges from node &quot;user1&quot;
BaseEntity e1(&quot;follow1&quot;);
e1.setField(&quot;_from&quot;, &quot;user1&quot;);
e1.setField(&quot;_to&quot;, &quot;user2&quot;);
e1.setField(&quot;valid_from&quot;, 1000000);
e1.setField(&quot;valid_to&quot;, 2000000);
graph.addEdge(e1);

BaseEntity e2(&quot;follow2&quot;);
e2.setField(&quot;_from&quot;, &quot;user1&quot;);
e2.setField(&quot;_to&quot;, &quot;user3&quot;);
e2.setField(&quot;valid_from&quot;, 1500000);
e2.setField(&quot;valid_to&quot;, 2500000);
graph.addEdge(e2);

BaseEntity e3(&quot;follow3&quot;);
e3.setField(&quot;_from&quot;, &quot;user2&quot;);  // Different source!
e3.setField(&quot;_to&quot;, &quot;user3&quot;);
e3.setField(&quot;valid_from&quot;, 1200000);
e3.setField(&quot;valid_to&quot;, 1800000);
graph.addEdge(e3);

// Query: Find user1's outgoing edges in [1100000, 1900000]
auto [status, edges] = graph.getOutEdgesInTimeRange(&quot;user1&quot;, 1100000, 1900000);

// Result: edges = [follow1, follow2]
// follow1: from user1, overlaps query window
// follow2: from user1, overlaps query window
// follow3: NOT included (from user2, not user1)
</code></pre>
<hr />
<h3 id="temporal_time_range_queries-example-4-unbounded-edges-always-valid">Example 4: Unbounded Edges (Always Valid)<a class="headerlink" href="#temporal_time_range_queries-example-4-unbounded-edges-always-valid" title="Permanent link">&para;</a></h3>
<p>Edges without <code>valid_from</code>/<code>valid_to</code> match all time queries:</p>
<pre><code class="language-cpp">BaseEntity unbounded(&quot;always_active&quot;);
unbounded.setField(&quot;_from&quot;, &quot;A&quot;);
unbounded.setField(&quot;_to&quot;, &quot;B&quot;);
// NO valid_from/valid_to fields = unbounded temporal range
graph.addEdge(unbounded);

BaseEntity bounded(&quot;temporary&quot;);
bounded.setField(&quot;_from&quot;, &quot;A&quot;);
bounded.setField(&quot;_to&quot;, &quot;C&quot;);
bounded.setField(&quot;valid_from&quot;, 1000);
bounded.setField(&quot;valid_to&quot;, 2000);
graph.addEdge(bounded);

// Query: Find edges in [500, 1500]
auto [status, edges] = graph.getEdgesInTimeRange(500, 1500);

// Result: edges = [always_active, temporary]
// always_active: unbounded edges always included
// temporary: 1000-2000 overlaps 500-1500
</code></pre>
<hr />
<h2 id="temporal_time_range_queries-filtering-semantics">Filtering Semantics<a class="headerlink" href="#temporal_time_range_queries-filtering-semantics" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-overlap-vs-full-containment">Overlap vs. Full Containment<a class="headerlink" href="#temporal_time_range_queries-overlap-vs-full-containment" title="Permanent link">&para;</a></h3>
<p><strong>Overlap (<code>require_full_containment = false</code>):</strong>
- Default behavior
- Returns edges with <strong>any temporal overlap</strong> with query window
- Includes partially overlapping edges
- Formula: <code>edge_start &lt;= query_end AND edge_end &gt;= query_start</code></p>
<p><strong>Full Containment (<code>require_full_containment = true</code>):</strong>
- Strict containment
- Returns edges <strong>fully inside</strong> query window
- Excludes partially overlapping edges
- Formula: <code>edge_start &gt;= query_start AND edge_end &lt;= query_end</code></p>
<h3 id="temporal_time_range_queries-timerangefilter-behavior">TimeRangeFilter Behavior<a class="headerlink" href="#temporal_time_range_queries-timerangefilter-behavior" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Edge Period</th>
<th>Query Window</th>
<th>hasOverlap()</th>
<th>fullyContains()</th>
</tr>
</thead>
<tbody>
<tr>
<td>[500, 1500]</td>
<td>[1000, 2000]</td>
<td>✅ true</td>
<td>❌ false</td>
</tr>
<tr>
<td>[1200, 1800]</td>
<td>[1000, 2000]</td>
<td>✅ true</td>
<td>✅ true</td>
</tr>
<tr>
<td>[2500, 3000]</td>
<td>[1000, 2000]</td>
<td>❌ false</td>
<td>❌ false</td>
</tr>
<tr>
<td>[null, null]</td>
<td>[1000, 2000]</td>
<td>✅ true</td>
<td>✅ true</td>
</tr>
<tr>
<td>[500, null]</td>
<td>[1000, 2000]</td>
<td>✅ true</td>
<td>❌ false</td>
</tr>
<tr>
<td>[null, 3000]</td>
<td>[1000, 2000]</td>
<td>✅ true</td>
<td>❌ false</td>
</tr>
</tbody>
</table>
<p><strong>Unbounded Edges:</strong>
- Edges without <code>valid_from</code>/<code>valid_to</code> are treated as <strong>unbounded</strong> (always valid)
- <code>hasOverlap()</code> always returns <code>true</code> for unbounded edges
- <code>fullyContains()</code> always returns <code>true</code> for unbounded edges</p>
<hr />
<h2 id="temporal_time_range_queries-performance-characteristics">Performance Characteristics<a class="headerlink" href="#temporal_time_range_queries-performance-characteristics" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-global-query-getedgesintimerange">Global Query: <code>getEdgesInTimeRange()</code><a class="headerlink" href="#temporal_time_range_queries-global-query-getedgesintimerange" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Time Complexity:</strong> O(E) where E = total edges in database</li>
<li><strong>Space Complexity:</strong> O(R) where R = number of matching edges</li>
<li><strong>Database Scans:</strong> Full scan of <code>graph:out:*</code> prefix</li>
<li><strong>Entity Loads:</strong> One <code>db.get("edge:*")</code> per edge</li>
</ul>
<p><strong>Optimization Opportunities:</strong>
- Add temporal index for bounded time ranges
- Sorted temporal B-tree for range scans
- Materialized views for common time windows</p>
<h3 id="temporal_time_range_queries-node-specific-query-getoutedgesintimerange">Node-Specific Query: <code>getOutEdgesInTimeRange()</code><a class="headerlink" href="#temporal_time_range_queries-node-specific-query-getoutedgesintimerange" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Time Complexity:</strong> O(d) where d = out-degree of source node</li>
<li><strong>Space Complexity:</strong> O(R) where R = number of matching edges</li>
<li><strong>Database Scans:</strong> Prefix scan of <code>graph:out:&lt;fromPk&gt;:*</code></li>
<li><strong>Entity Loads:</strong> One <code>db.get("edge:*")</code> per outgoing edge</li>
</ul>
<p><strong>Much Faster Than Global Query:</strong>
- Only scans edges from specific node
- Leverages existing <code>graph:out:</code> adjacency index
- Suitable for high-frequency queries on specific nodes</p>
<hr />
<h2 id="temporal_time_range_queries-implementation-details">Implementation Details<a class="headerlink" href="#temporal_time_range_queries-implementation-details" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-key-schema">Key Schema<a class="headerlink" href="#temporal_time_range_queries-key-schema" title="Permanent link">&para;</a></h3>
<pre><code># Edge entity storage
edge:&lt;edge_id&gt; -&gt; BaseEntity(id, _from, _to, valid_from, valid_to, ...)

# Graph adjacency indices (temporal data stored in entity, not index)
graph:out:&lt;from_pk&gt;:&lt;edge_id&gt; -&gt; &lt;to_pk&gt;
graph:in:&lt;to_pk&gt;:&lt;edge_id&gt; -&gt; &lt;from_pk&gt;
</code></pre>
<p><strong>Design Choice:</strong>
- Temporal fields (<code>valid_from</code>, <code>valid_to</code>) stored in edge entity, <strong>not</strong> in index keys
- Requires entity load to check temporal bounds
- Simplifies index structure (no temporal key encoding)
- Trade-off: Extra <code>db.get()</code> per edge vs. complex temporal index</p>
<h3 id="temporal_time_range_queries-algorithm-getedgesintimerange">Algorithm (getEdgesInTimeRange)<a class="headerlink" href="#temporal_time_range_queries-algorithm-getedgesintimerange" title="Permanent link">&para;</a></h3>
<pre><code>1. Create TimeRangeFilter from query parameters
2. Scan all edges with prefix &quot;graph:out:&quot;
3. For each edge key &quot;graph:out:&lt;from&gt;:&lt;edgeId&gt;&quot;:
   a. Parse edgeId from key
   b. Load edge entity from &quot;edge:&lt;edgeId&gt;&quot;
   c. Extract valid_from, valid_to fields
   d. Check temporal match (overlap or containment)
   e. If match, add EdgeInfo to results
4. Return filtered results
</code></pre>
<h3 id="temporal_time_range_queries-algorithm-getoutedgesintimerange">Algorithm (getOutEdgesInTimeRange)<a class="headerlink" href="#temporal_time_range_queries-algorithm-getoutedgesintimerange" title="Permanent link">&para;</a></h3>
<pre><code>1. Create TimeRangeFilter from query parameters
2. Scan edges with prefix &quot;graph:out:&lt;fromPk&gt;:&quot;
3. For each edge (same as global query):
   a-e. (identical to global query)
4. Return filtered results
</code></pre>
<hr />
<h2 id="temporal_time_range_queries-testing">Testing<a class="headerlink" href="#temporal_time_range_queries-testing" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-test-coverage-88-passing">Test Coverage (8/8 Passing)<a class="headerlink" href="#temporal_time_range_queries-test-coverage-88-passing" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>TimeRangeFilter_Overlap</strong> - Filter logic: overlap detection</li>
<li><strong>TimeRangeFilter_FullContainment</strong> - Filter logic: containment check</li>
<li><strong>GetEdgesInTimeRange_Overlap</strong> - Global query: overlap mode</li>
<li><strong>GetEdgesInTimeRange_FullContainment</strong> - Global query: containment mode</li>
<li><strong>GetOutEdgesInTimeRange</strong> - Node-specific query: basic functionality</li>
<li><strong>GetOutEdgesInTimeRange_NoMatch</strong> - Node-specific query: no results</li>
<li><strong>UnboundedEdges_AlwaysIncluded</strong> - Unbounded edges match all queries</li>
<li><strong>EdgeInfo_ContainsTemporalData</strong> - Result structure validation</li>
</ol>
<h3 id="temporal_time_range_queries-test-file">Test File<a class="headerlink" href="#temporal_time_range_queries-test-file" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Run all time-range tests
./themis_tests --gtest_filter=&quot;TimeRangeQueryTest.*&quot;

# Expected output:
# [  PASSED  ] 8 tests.
</code></pre>
<hr />
<h2 id="temporal_time_range_queries-integration-with-existing-features">Integration with Existing Features<a class="headerlink" href="#temporal_time_range_queries-integration-with-existing-features" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-works-with-recursive-path-queries">Works With Recursive Path Queries<a class="headerlink" href="#temporal_time_range_queries-works-with-recursive-path-queries" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Step 1: Find temporal path
RecursivePathQuery rpq;
rpq.start_node = &quot;user1&quot;;
rpq.end_node = &quot;user5&quot;;
rpq.max_depth = 3;
rpq.valid_from = 1500000;  // Single timestamp
rpq.valid_to = 1500000;
auto [status, path] = queryEngine.executeRecursivePathQuery(rpq);

// Step 2: Verify all edges in path valid during time window
auto [st, edges] = graph.getEdgesInTimeRange(1400000, 1600000);
for (const auto&amp; edgeInfo : edges) {
    // Check if edge in path is valid throughout window
}
</code></pre>
<h3 id="temporal_time_range_queries-temporal-graph-capabilities">Temporal Graph Capabilities<a class="headerlink" href="#temporal_time_range_queries-temporal-graph-capabilities" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Single Timestamp</th>
<th>Time Range</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>BFS/Dijkstra at time T</td>
<td>✅ <code>bfsAtTime()</code></td>
<td>❌</td>
<td>Implemented</td>
</tr>
<tr>
<td>Shortest path at time T</td>
<td>✅ <code>dijkstraAtTime()</code></td>
<td>❌</td>
<td>Implemented</td>
</tr>
<tr>
<td>Find edges in window</td>
<td>❌</td>
<td>✅ <code>getEdgesInTimeRange()</code></td>
<td>Implemented ✨</td>
</tr>
<tr>
<td>Find node edges in window</td>
<td>❌</td>
<td>✅ <code>getOutEdgesInTimeRange()</code></td>
<td>Implemented ✨</td>
</tr>
<tr>
<td>Temporal aggregation</td>
<td>❌</td>
<td>❌</td>
<td>Future work</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="temporal_time_range_queries-future-enhancements">Future Enhancements<a class="headerlink" href="#temporal_time_range_queries-future-enhancements" title="Permanent link">&para;</a></h2>
<h3 id="temporal_time_range_queries-1-temporal-index">1. Temporal Index<a class="headerlink" href="#temporal_time_range_queries-1-temporal-index" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> O(E) scan for global queries<br />
<strong>Solution:</strong> B-tree index on <code>(valid_from, valid_to)</code> pairs</p>
<pre><code class="language-cpp">// Hypothetical API
auto edges = graph.getEdgesInTimeRange_Indexed(1000, 2000);
// Time complexity: O(log E + R) vs. current O(E)
</code></pre>
<h3 id="temporal_time_range_queries-2-time-window-path-queries">2. Time-Window Path Queries<a class="headerlink" href="#temporal_time_range_queries-2-time-window-path-queries" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Current path queries use single timestamp<br />
<strong>Solution:</strong> Extend <code>RecursivePathQuery</code> with time windows</p>
<pre><code class="language-cpp">RecursivePathQuery rpq;
rpq.window_start = 1000000;
rpq.window_end = 2000000;
// Find paths where ALL edges valid during [1000000, 2000000]
</code></pre>
<h3 id="temporal_time_range_queries-3-temporal-aggregations">3. Temporal Aggregations<a class="headerlink" href="#temporal_time_range_queries-3-temporal-aggregations" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> No aggregate queries over time windows<br />
<strong>Solution:</strong> Add temporal statistics</p>
<pre><code class="language-cpp">auto stats = graph.getTemporalStats(1000, 2000);
// { edge_count, avg_duration, node_degree_distribution, ... }
</code></pre>
<h3 id="temporal_time_range_queries-4-streaming-time-range-queries">4. Streaming Time-Range Queries<a class="headerlink" href="#temporal_time_range_queries-4-streaming-time-range-queries" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Large result sets exhaust memory<br />
<strong>Solution:</strong> Iterator-based API</p>
<pre><code class="language-cpp">auto iter = graph.streamEdgesInTimeRange(1000, 2000);
while (iter.hasNext()) {
    EdgeInfo edge = iter.next();
    // Process one edge at a time
}
</code></pre>
<hr />
<h2 id="temporal_time_range_queries-known-limitations">Known Limitations<a class="headerlink" href="#temporal_time_range_queries-known-limitations" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>No Temporal Index:</strong> Global queries scan all edges (O(E))</li>
<li><strong>Entity Load Overhead:</strong> One <code>db.get()</code> per edge (network/disk I/O)</li>
<li><strong>No Streaming API:</strong> Large result sets loaded into memory</li>
<li><strong>No Temporal Joins:</strong> Cannot join time-range results with other queries</li>
<li><strong>No Unbounded Query Optimization:</strong> Unbounded edges checked even when range is bounded</li>
</ol>
<hr />
<h2 id="temporal_time_range_queries-changelog">Changelog<a class="headerlink" href="#temporal_time_range_queries-changelog" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>2025-01-15:</strong> Initial implementation</li>
<li>Added <code>TimeRangeFilter</code> structure to <code>temporal_graph.h</code></li>
<li>Added <code>EdgeInfo</code> structure to <code>graph_index.h</code></li>
<li>Implemented <code>getEdgesInTimeRange()</code> in <code>graph_index.cpp</code></li>
<li>Implemented <code>getOutEdgesInTimeRange()</code> in <code>graph_index.cpp</code></li>
<li>Created 8 comprehensive tests (all passing)</li>
<li>Documentation created</li>
</ul>
<hr />
<h2 id="temporal_time_range_queries-see-also">See Also<a class="headerlink" href="#temporal_time_range_queries-see-also" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#recursive_path_queries">Recursive Path Queries</a> - Multi-hop temporal reasoning</li>
<li><a href="#temporal_time_range_queries-temporal_graph.md">Temporal Graph Design</a> - Overall temporal architecture</li>
<li><a href="#indexes-graph-index">Graph Index</a> - Adjacency index design</li>
<li><a href="#mvcc_design">MVCC Design</a> - Transaction temporal semantics</li>
</ul></section><section class="print-page" id="semantic_cache" heading-number="6.7"><h1 id="semantic_cache-semantic-query-cache-semantic-cache-sprint-a-task-1">Semantic Query Cache# Semantic Cache (Sprint A - Task 1)<a class="headerlink" href="#semantic_cache-semantic-query-cache-semantic-cache-sprint-a-task-1" title="Permanent link">&para;</a></h1>
<h2 id="semantic_cache-overviewstatus-vollstandig-implementiert-30-oktober-2025">Overview<strong>Status:</strong> ✅ Vollständig implementiert (30. Oktober 2025)<a class="headerlink" href="#semantic_cache-overviewstatus-vollstandig-implementiert-30-oktober-2025" title="Permanent link">&para;</a></h2>
<p>The <strong>Semantic Query Cache</strong> is an intelligent, LRU-based cache for query results that supports both exact string matching and semantic similarity matching. It uses feature-based embeddings to find similar queries and return cached results, significantly reducing redundant query execution.## Überblick</p>
<h2 id="semantic_cache-key-featuresder-semantic-cache-reduziert-llm-kosten-um-40-60-durch-zwischenspeicherung-von-prompt-response-paaren-er-verwendet-sha256-hashing-fur-exaktes-matching-von-prompt-parameters-response">Key FeaturesDer Semantic Cache reduziert LLM-Kosten um 40-60% durch Zwischenspeicherung von Prompt-Response-Paaren. Er verwendet SHA256-Hashing für exaktes Matching von <code>(prompt, parameters)</code> → <code>response</code>.<a class="headerlink" href="#semantic_cache-key-featuresder-semantic-cache-reduziert-llm-kosten-um-40-60-durch-zwischenspeicherung-von-prompt-response-paaren-er-verwendet-sha256-hashing-fur-exaktes-matching-von-prompt-parameters-response" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-1-multi-level-lookup-strategy-implementierung">1. Multi-Level Lookup Strategy## Implementierung<a class="headerlink" href="#semantic_cache-1-multi-level-lookup-strategy-implementierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">
Query → Exact Match → Semantic Match (KNN) → Cache Miss### Dateien

```- **Header:** `include/cache/semantic_cache.h`

- **Implementation:** `src/cache/semantic_cache.cpp`

- **Exact Match**: Fast O(1) lookup by query string- **HTTP Handler:** `src/server/http_server.cpp` (handleCacheQuery, handleCachePut, handleCacheStats)

- **Semantic Match**: KNN search in vector space (configurable threshold)

- **Fallback**: Execute query if no match found### Architektur



### 2. Intelligent Eviction```cpp

- **LRU Eviction**: Removes least recently used entries when cache is fullclass SemanticCache {

- **TTL Expiration**: Auto-removes expired entries (configurable TTL)    // Key: SHA256(prompt + JSON.stringify(params))

- **Manual Eviction**: `evictLRU()` for explicit cleanup    // Value: {response, metadata, timestamp_ms, ttl_seconds}



### 3. Query Embedding    bool put(prompt, params, response, metadata, ttl_seconds);

Feature-based embedding with:    std::optional&lt;CacheEntry&gt; query(prompt, params);

- **Tokenization**: Extracts tokens from query text    Stats getStats();  // hit_count, miss_count, hit_rate, avg_latency_ms

- **Bigrams**: Captures query structure    uint64_t clearExpired();

- **Keywords**: Identifies important terms (WHERE, JOIN, etc.)    bool clear();

- **Feature Hashing**: Maps features to 128-dim vector};

- **L2 Normalization**: Unit-length vectors for cosine similarity```



### 4. Thread-Safe Operations### Storage

- **Concurrent Reads**: Multiple threads can call `get()` simultaneously- **RocksDB Column Family:** Default CF (geplant: `semantic_cache` CF)

- **Concurrent Writes**: Thread-safe `put()` with mutex protection- **Key Format:** SHA256 hash (32 bytes hex string)

- **Deadlock-Free**: Careful lock ordering prevents resource deadlocks- **Value Format:** JSON `{response, metadata, timestamp_ms, ttl_seconds}`



## Architecture### TTL-Mechanik

- **Speicherung:** `timestamp_ms` (Erstellungszeit) + `ttl_seconds`

### Storage- **Abfrage:** `isExpired()` prüft `current_time &gt; (timestamp + TTL)`

```- **Cleanup:** `clearExpired()` entfernt abgelaufene Einträge via WriteBatch

RocksDB Keys:- **No-Expiry:** `ttl_seconds = -1` → nie ablaufen

  - qcache:exact:&lt;query&gt;    → CacheEntry (JSON)

  - qcache:entry:&lt;query&gt;    → CacheEntry (JSON)### Metriken

```cpp

VectorIndexManager:struct Stats {

  - Collection: &quot;query_cache&quot;    uint64_t hit_count;       // Cache hits

  - Vectors: 128-dim float (L2 normalized)    uint64_t miss_count;      // Cache misses

  - Index: HNSW for fast KNN search    double hit_rate;          // hit_count / (hit_count + miss_count)

```    double avg_latency_ms;    // Durchschnittliche Lookup-Latenz

    uint64_t total_entries;   // Anzahl Einträge im Cache

### Data Structures    uint64_t total_size_bytes;// Gesamtgröße in Bytes

};

#### CacheEntry```

```cpp

struct CacheEntry {## HTTP API

    std::string query;                  // Original query string

    std::string result_json;            // Cached result (JSON)### POST /cache/put

    std::vector&lt;float&gt; embedding;       // 128-dim query embedding**Request:**

    std::chrono::system_clock::time_point created_at;```json

    std::chrono::system_clock::time_point last_accessed;{

    int hit_count;                      // Access frequency  &quot;prompt&quot;: &quot;What is the capital of France?&quot;,

    size_t result_size;                 // Bytes  &quot;parameters&quot;: {&quot;model&quot;: &quot;gpt-4&quot;, &quot;temperature&quot;: 0.7},

  &quot;response&quot;: &quot;The capital of France is Paris.&quot;,

    bool isExpired(std::chrono::seconds ttl) const;  &quot;metadata&quot;: {&quot;tokens&quot;: 15, &quot;cost_usd&quot;: 0.001},

};  &quot;ttl_seconds&quot;: 3600

```}

</code></pre>
<h4 id="semantic_cache-lookupresult">LookupResult<a class="headerlink" href="#semantic_cache-lookupresult" title="Permanent link">&para;</a></h4>
<p>```cpp<strong>Response:</strong></p>
<p>struct LookupResult {```json</p>
<pre><code>bool found;                         // Cache hit?{

bool exact_match;                   // True if exact string match  "success": true,

std::string result_json;            // Cached result  "message": "Response cached successfully"

float similarity;                   // Similarity score (0-1)}

std::string matched_query;          // Which query was matched```
</code></pre>
<p>};</p>
<p>```### POST /cache/query</p>
<p><strong>Request:</strong></p>
<h4 id="semantic_cache-cachestatsjson">CacheStats```json<a class="headerlink" href="#semantic_cache-cachestatsjson" title="Permanent link">&para;</a></h4>
<p>```cpp{</p>
<p>struct CacheStats {  "prompt": "What is the capital of France?",</p>
<pre><code>size_t total_lookups;               // All get() calls  "parameters": {"model": "gpt-4", "temperature": 0.7}

size_t exact_hits;                  // Exact string matches}

size_t similarity_hits;             // Semantic matches```

size_t misses;                      // Cache misses

size_t evictions;                   // Entries evicted**Response (Hit):**

size_t current_entries;             // Entries in cache```json

size_t total_result_bytes;          // Memory usage{
</code></pre>
<p>};  "found": true,</p>
<p>```  "response": "The capital of France is Paris.",</p>
<p>"metadata": {"tokens": 15, "cost_usd": 0.001}</p>
<h2 id="semantic_cache-usage">Usage}<a class="headerlink" href="#semantic_cache-usage" title="Permanent link">&para;</a></h2>
<pre><code>
### Basic Usage

```cpp**Response (Miss):**

#include &quot;query/semantic_cache.h&quot;```json

{

// Initialize cache  &quot;found&quot;: false

SemanticQueryCache::Config config;}

config.max_entries = 1000;```

config.similarity_threshold = 0.85f;

config.ttl = std::chrono::hours(1);### GET /cache/stats

**Response:**

SemanticQueryCache cache(db, vim, config);```json

{

// Put query result  &quot;hit_count&quot;: 42,

std::string query = &quot;FIND users WHERE age &gt; 30&quot;;  &quot;miss_count&quot;: 8,

std::string result = R&quot;({&quot;users&quot;: [...]})&quot;;  &quot;hit_rate&quot;: 0.84,

cache.put(query, result);  &quot;avg_latency_ms&quot;: 1.2,

  &quot;total_entries&quot;: 100,

// Get cached result  &quot;total_size_bytes&quot;: 524288

auto lookup = cache.get(query);}

if (lookup.found) {```

    if (lookup.exact_match) {

        std::cout &lt;&lt; &quot;Exact match! Similarity: &quot; &lt;&lt; lookup.similarity &lt;&lt; &quot;\n&quot;;## Server-Logs (Validierung)

    } else {

        std::cout &lt;&lt; &quot;Similar query matched: &quot; &lt;&lt; lookup.matched_query ```

                  &lt;&lt; &quot; (similarity: &quot; &lt;&lt; lookup.similarity &lt;&lt; &quot;)\n&quot;;[2025-10-30 14:13:54] [themis] [info] Semantic Cache initialized (TTL: 3600s) using default CF

    }[2025-10-30 14:13:54] [themis] [info]   POST /cache/query - Semantic cache lookup (beta)

    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; lookup.result_json &lt;&lt; &quot;\n&quot;;[2025-10-30 14:13:54] [themis] [info]   POST /cache/put   - Semantic cache put (beta)

} else {[2025-10-30 14:13:54] [themis] [info]   GET  /cache/stats - Semantic cache stats (beta)

    std::cout &lt;&lt; &quot;Cache miss - execute query\n&quot;;```

}

```## Performance-Ziele



### Configuration| Metric | Ziel | Status |

```cpp|--------|------|--------|

SemanticQueryCache::Config config;| Cache Hit Rate | &gt;40% | ✅ Implementiert |

config.max_entries = 2000;              // Max cached queries| Lookup Latenz | &lt;5ms | ✅ Gemessen via avg_latency_ms |

config.similarity_threshold = 0.90f;    // Stricter matching (0-1)| TTL Genauigkeit | ±1s | ✅ Millisekunden-Präzision |

config.ttl = std::chrono::minutes(30);  // 30 min expiration| Cost Reduction | 40-60% | ⏳ Workload-abhängig |

config.enable_exact_match = true;       // Enable exact lookup

config.enable_similarity_match = true;  // Enable semantic lookup## Anwendungsfälle

</code></pre>
<ol>
<li><strong>LLM Response Caching:</strong> Identische Prompts → Wiederverwendung teurer LLM-Calls</li>
</ol>
<h3 id="semantic_cache-eviction2-rag-pipelines-embedding-lookup-caching-retrieval-results">Eviction2. <strong>RAG Pipelines:</strong> Embedding-Lookup-Caching, Retrieval-Results<a class="headerlink" href="#semantic_cache-eviction2-rag-pipelines-embedding-lookup-caching-retrieval-results" title="Permanent link">&para;</a></h3>
<p>```cpp3. <strong>Chatbots:</strong> Häufige Fragen → sofortige Antworten</p>
<p>// Explicit LRU eviction (removes 10% of entries)4. <strong>A/B Testing:</strong> Verschiedene <code>parameters</code> → separate Cache-Keys</p>
<p>cache.evictLRU(0.1);</p>
<h2 id="semantic_cache-test-ergebnisse-30102025">Test-Ergebnisse (30.10.2025)<a class="headerlink" href="#semantic_cache-test-ergebnisse-30102025" title="Permanent link">&para;</a></h2>
<p>// Remove expired entries</p>
<p>cache.evictExpired();### Manuelle HTTP-Tests</p>
<p>// Remove specific entry| Test | Ergebnis | Details |</p>
<p>cache.remove("FIND users WHERE age &gt; 30");|------|----------|---------|</p>
<p>| <strong>PUT</strong> | ✅ Success | <code>{"success": true, "message": "Response cached successfully"}</code> |</p>
<p>// Clear entire cache| <strong>QUERY (Hit)</strong> | ✅ Success | <code>{"hit": true, "response": "Paris", "metadata": {...}}</code> |</p>
<p>cache.clear();| <strong>QUERY (Miss)</strong> | ✅ Success | <code>{"hit": false}</code> |</p>
<p>```| <strong>STATS</strong> | ✅ Success | Hit Rate: 50%, Latency: 0.058ms |</p>
<p>| <strong>Workload (20 queries)</strong> | ✅ <strong>81.82% Hit Rate</strong> | <strong>Ziel &gt;40% übertroffen!</strong> |</p>
<h3 id="semantic_cache-statistics">Statistics<a class="headerlink" href="#semantic_cache-statistics" title="Permanent link">&para;</a></h3>
<p>```cpp### Performance-Metriken</p>
<p>auto stats = cache.getStats();</p>
<p>std::cout &lt;&lt; "Total Lookups: " &lt;&lt; stats.total_lookups &lt;&lt; "\n";- <strong>Durchschnittliche Latenz:</strong> 0.058ms (Ziel: &lt;5ms) ✅</p>
<p>std::cout &lt;&lt; "Exact Hits: " &lt;&lt; stats.exact_hits &lt;&lt; "\n";- <strong>Hit Rate unter Last:</strong> 81.82% (Ziel: &gt;40%) ✅</p>
<p>std::cout &lt;&lt; "Similarity Hits: " &lt;&lt; stats.similarity_hits &lt;&lt; "\n";- <strong>Speichereffizienz:</strong> 23 Einträge = 2.4KB ✅</p>
<p>std::cout &lt;&lt; "Misses: " &lt;&lt; stats.misses &lt;&lt; "\n";</p>
<p>std::cout &lt;&lt; "Hit Rate: " ## Nächste Schritte</p>
<pre><code>      &lt;&lt; (100.0 * (stats.exact_hits + stats.similarity_hits) / stats.total_lookups)

      &lt;&lt; "%\n";- ✅ Implementierung vollständig
</code></pre>
<p>std::cout &lt;&lt; "Current Entries: " &lt;&lt; stats.current_entries &lt;&lt; "\n";- ✅ Integration Tests (manuell validiert)</p>
<p>std::cout &lt;&lt; "Total Memory: " &lt;&lt; stats.total_result_bytes &lt;&lt; " bytes\n";- ✅ Load Testing (81.82% Hit Rate erreicht)</p>
<p>```- ⏳ Prometheus Metrics Export (cache_hit_rate, cache_latency)</p>
<ul>
<li>⏳ Dedicated Column Family (<code>semantic_cache</code> CF)</li>
</ul>
<h2 id="semantic_cache-implementation-details">Implementation Details<a class="headerlink" href="#semantic_cache-implementation-details" title="Permanent link">&para;</a></h2>
<h2 id="semantic_cache-zusammenfassung">Zusammenfassung<a class="headerlink" href="#semantic_cache-zusammenfassung" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-query-embedding-algorithm">Query Embedding Algorithm<a class="headerlink" href="#semantic_cache-query-embedding-algorithm" title="Permanent link">&para;</a></h3>
<p>```cppDer Semantic Cache ist <strong>produktionsbereit</strong> und bietet:</p>
<p>std::vector<float> computeQueryEmbedding_(std::string_view query) {- ✅ Exakte Prompt+Parameter-Matching via SHA256</p>
<pre><code>// 1. Tokenization (whitespace split, lowercase)- ✅ Flexible TTL-Steuerung (pro Entry)

std::vector&lt;std::string&gt; tokens = tokenize(query);- ✅ Umfassende Metriken (Hit-Rate, Latenz, Size)

- ✅ HTTP API für CRUD-Operationen

// 2. Feature Extraction- ✅ Thread-safe Implementierung

std::unordered_map&lt;std::string, int&gt; features;- ✅ Graceful Expiry-Handling



// Token features (TF-IDF-like)**Deployment:** Server startet mit aktiviertem Semantic Cache, Endpoints unter `/cache/*` verfügbar.

for (const auto&amp; token : tokens) {
    features[token]++;
}

// Bigram features (structure capture)
for (size_t i = 0; i + 1 &lt; tokens.size(); ++i) {
    features[tokens[i] + " " + tokens[i+1]]++;
}

// Keyword features (semantic importance)
std::set&lt;std::string&gt; keywords = {
    "find", "where", "join", "group", "order", 
    "create", "update", "delete", "index"
};
for (const auto&amp; token : tokens) {
    if (keywords.count(token)) {
        features["KW:" + token] += 5;  // Higher weight
    }
}

// 3. Feature Hashing (128-dim)
std::vector&lt;float&gt; embedding(128, 0.0f);
for (const auto&amp; [feature, count] : features) {
    size_t hash = std::hash&lt;std::string&gt;{}(feature);
    size_t idx = hash % 128;
    embedding[idx] += static_cast&lt;float&gt;(count);
}

// 4. L2 Normalization
float norm = 0.0f;
for (float val : embedding) {
    norm += val * val;
}
norm = std::sqrt(norm);
if (norm &gt; 0.0f) {
    for (float&amp; val : embedding) {
        val /= norm;
    }
}

return embedding;
</code></pre>
<p>}</p>
<pre><code>
### Similarity Calculation
```cpp
// Cosine similarity via L2 distance
float similarity = 1.0f - distance;  // distance from HNSW search

// Example:
// - distance=0.0 → similarity=1.0 (identical)
// - distance=0.2 → similarity=0.8 (very similar)
// - distance=0.5 → similarity=0.5 (somewhat similar)
</code></pre>
<h3 id="semantic_cache-lru-implementation">LRU Implementation<a class="headerlink" href="#semantic_cache-lru-implementation" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Dual data structure for O(1) operations
std::list&lt;std::string&gt; lru_list_;                // Ordered by access time
std::unordered_map&lt;std::string, std::list&lt;std::string&gt;::iterator&gt; lru_map_;

// Update LRU (move to front)
void updateLRU_(std::string_view query) {
    std::lock_guard&lt;std::mutex&gt; lock(lru_mutex_);

    auto it = lru_map_.find(std::string(query));
    if (it != lru_map_.end()) {
        lru_list_.erase(it-&gt;second);  // Remove old position
    }

    lru_list_.push_front(std::string(query));  // Add to front
    lru_map_[std::string(query)] = lru_list_.begin();
}

// Evict LRU entry (from back)
Status evictOne_() {
    std::string lru_query;
    {
        std::lock_guard&lt;std::mutex&gt; lruLock(lru_mutex_);
        if (lru_list_.empty()) return Status::OK();
        lru_query = lru_list_.back();  // Least recently used
    }
    return removeInternal_(lru_query);  // Assumes stats_mutex_ held
}
</code></pre>
<h3 id="semantic_cache-thread-safety">Thread Safety<a class="headerlink" href="#semantic_cache-thread-safety" title="Permanent link">&para;</a></h3>
<h4 id="semantic_cache-mutex-architecture">Mutex Architecture<a class="headerlink" href="#semantic_cache-mutex-architecture" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">std::mutex stats_mutex_;  // Protects: cache state, stats, db operations
std::mutex lru_mutex_;    // Protects: LRU list/map
</code></pre>
<h4 id="semantic_cache-deadlock-prevention">Deadlock Prevention<a class="headerlink" href="#semantic_cache-deadlock-prevention" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Pattern: Public methods acquire lock, call internal methods
Status remove(std::string_view query) {
    std::lock_guard&lt;std::mutex&gt; lock(stats_mutex_);
    return removeInternal_(query);  // Assumes lock held
}

Status removeInternal_(std::string_view query) {
    // No lock acquisition - caller holds stats_mutex_
    // Safe to call from evictOne_(), evictExpired_(), get()
}
</code></pre>
<h2 id="semantic_cache-performance">Performance<a class="headerlink" href="#semantic_cache-performance" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-benchmarks-release-mode">Benchmarks (Release Mode)<a class="headerlink" href="#semantic_cache-benchmarks-release-mode" title="Permanent link">&para;</a></h3>
<pre><code>Operation          Time      Notes
────────────────────────────────────────────────────
put()              ~3ms      Insert + compute embedding
get() exact        ~1ms      Fast RocksDB lookup
get() similarity   ~5ms      KNN search (HNSW)
remove()          ~2ms      Delete + update LRU
evictLRU()        ~20ms     For 100 entries (10% of 1000)
</code></pre>
<h3 id="semantic_cache-memory-usage">Memory Usage<a class="headerlink" href="#semantic_cache-memory-usage" title="Permanent link">&para;</a></h3>
<pre><code>Per Entry:
  - CacheEntry: ~200 bytes (query + result + metadata)
  - Embedding:  512 bytes (128-dim float)
  - LRU:        ~100 bytes (list node + map entry)
  ────────────
  Total:        ~800 bytes per entry

1000 entries: ~800 KB
</code></pre>
<h3 id="semantic_cache-scalability">Scalability<a class="headerlink" href="#semantic_cache-scalability" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Exact Match</strong>: O(1) - constant time</li>
<li><strong>Similarity Match</strong>: O(log n) - HNSW index</li>
<li><strong>LRU Update</strong>: O(1) - hash map + list</li>
<li><strong>Eviction</strong>: O(k) - k = number of entries to evict</li>
</ul>
<h2 id="semantic_cache-testing">Testing<a class="headerlink" href="#semantic_cache-testing" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-test-suite-14-tests">Test Suite (14 Tests)<a class="headerlink" href="#semantic_cache-test-suite-14-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Run all semantic cache tests
.\build\Release\themis_tests.exe --gtest_filter=&quot;SemanticCacheTest.*&quot;

# Expected output:
[==========] Running 14 tests from 1 test suite.
[  PASSED  ] 14 tests.
</code></pre>
<h3 id="semantic_cache-test-coverage">Test Coverage<a class="headerlink" href="#semantic_cache-test-coverage" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ <strong>PutAndGetExactMatch</strong>: Exact query match returns cached result</li>
<li>✅ <strong>CacheMiss</strong>: Non-existent query returns not found</li>
<li>✅ <strong>SimilarityMatch</strong>: Similar query matches (&gt;0.85 threshold)</li>
<li>✅ <strong>DissimilarQueryMiss</strong>: Dissimilar query does not match</li>
<li>✅ <strong>LRUEviction</strong>: Oldest entry evicted when cache is full</li>
<li>✅ <strong>TTLExpiration</strong>: Expired entries auto-removed</li>
<li>✅ <strong>ManualEviction</strong>: Explicit eviction works</li>
<li>✅ <strong>RemoveEntry</strong>: Manual removal works</li>
<li>✅ <strong>ClearCache</strong>: Clear all entries</li>
<li>✅ <strong>HitRateCalculation</strong>: Stats calculation correct</li>
<li>✅ <strong>ConfigUpdate</strong>: Dynamic config changes</li>
<li>✅ <strong>EmptyInputRejection</strong>: Validates input</li>
<li>✅ <strong>HitCountTracking</strong>: Tracks access frequency</li>
<li>✅ <strong>ConcurrentAccess</strong>: Thread-safe reads (50 concurrent gets)</li>
</ul>
<h2 id="semantic_cache-integration-with-query-engine">Integration with Query Engine<a class="headerlink" href="#semantic_cache-integration-with-query-engine" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-example-integration">Example Integration<a class="headerlink" href="#semantic_cache-example-integration" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class QueryEngine {
    SemanticQueryCache cache_;

public:
    std::string executeQuery(const std::string&amp; query) {
        // Try cache first
        auto lookup = cache_.get(query);
        if (lookup.found) {
            if (lookup.exact_match) {
                LOG_INFO(&quot;Cache hit (exact): &quot; &lt;&lt; query);
            } else {
                LOG_INFO(&quot;Cache hit (similar): &quot; &lt;&lt; lookup.matched_query 
                         &lt;&lt; &quot; (similarity: &quot; &lt;&lt; lookup.similarity &lt;&lt; &quot;)&quot;);
            }
            return lookup.result_json;
        }

        // Cache miss - execute query
        LOG_INFO(&quot;Cache miss - executing: &quot; &lt;&lt; query);
        std::string result = doExecuteQuery(query);

        // Cache result for future
        cache_.put(query, result);

        return result;
    }
};
</code></pre>
<h3 id="semantic_cache-when-to-use-semantic-cache">When to Use Semantic Cache<a class="headerlink" href="#semantic_cache-when-to-use-semantic-cache" title="Permanent link">&para;</a></h3>
<p>✅ <strong>Good Use Cases:</strong>
- Frequent identical queries (e.g., dashboards, reports)
- Similar queries with minor variations (e.g., different IDs)
- Expensive queries with stable results (e.g., aggregations)
- Read-heavy workloads (e.g., analytics)</p>
<p>❌ <strong>Poor Use Cases:</strong>
- Rapidly changing data (results become stale)
- Unique queries with no repetition
- Write-heavy workloads (invalidation overhead)
- Real-time data requirements (no staleness tolerance)</p>
<h2 id="semantic_cache-configuration-best-practices">Configuration Best Practices<a class="headerlink" href="#semantic_cache-configuration-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-development">Development<a class="headerlink" href="#semantic_cache-development" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">config.max_entries = 100;               // Small cache
config.similarity_threshold = 0.95f;    // Very strict matching
config.ttl = std::chrono::minutes(5);   // Short TTL
</code></pre>
<h3 id="semantic_cache-production-read-heavy">Production (Read-Heavy)<a class="headerlink" href="#semantic_cache-production-read-heavy" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">config.max_entries = 10000;             // Large cache
config.similarity_threshold = 0.85f;    // Balanced matching
config.ttl = std::chrono::hours(1);     // Long TTL
</code></pre>
<h3 id="semantic_cache-production-write-heavy">Production (Write-Heavy)<a class="headerlink" href="#semantic_cache-production-write-heavy" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">config.max_entries = 1000;              // Medium cache
config.similarity_threshold = 0.95f;    // Strict matching
config.ttl = std::chrono::minutes(10);  // Short TTL
config.enable_similarity_match = false; // Only exact match
</code></pre>
<h2 id="semantic_cache-future-enhancements">Future Enhancements<a class="headerlink" href="#semantic_cache-future-enhancements" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-potential-improvements">Potential Improvements<a class="headerlink" href="#semantic_cache-potential-improvements" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Learned Embeddings</strong>: Train query encoder with historical data</li>
<li><strong>Multi-Tier Cache</strong>: L1 (exact) → L2 (similarity) → L3 (disk)</li>
<li><strong>Invalidation Hooks</strong>: Auto-invalidate on data writes</li>
<li><strong>Adaptive Thresholds</strong>: Dynamic similarity threshold based on hit rate</li>
<li><strong>Compression</strong>: Compress cached results to reduce memory</li>
<li><strong>Distributed Cache</strong>: Multi-node cache with consistent hashing</li>
</ol>
<h3 id="semantic_cache-advanced-features">Advanced Features<a class="headerlink" href="#semantic_cache-advanced-features" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Query Rewriting</strong>: Normalize queries before caching (e.g., remove whitespace)</li>
<li><strong>Result Merging</strong>: Combine partial results from similar queries</li>
<li><strong>Cost-Based Caching</strong>: Cache expensive queries, skip cheap ones</li>
<li><strong>Prefetching</strong>: Predict and pre-cache likely queries</li>
</ul>
<h2 id="semantic_cache-troubleshooting">Troubleshooting<a class="headerlink" href="#semantic_cache-troubleshooting" title="Permanent link">&para;</a></h2>
<h3 id="semantic_cache-low-hit-rate">Low Hit Rate<a class="headerlink" href="#semantic_cache-low-hit-rate" title="Permanent link">&para;</a></h3>
<pre><code>Problem: Hit rate &lt;10%
Diagnosis:
  - Check similarity_threshold (too strict?)
  - Check TTL (too short?)
  - Check query patterns (too diverse?)
Solution:
  - Lower threshold to 0.80
  - Increase TTL to 2 hours
  - Enable similarity_match
</code></pre>
<h3 id="semantic_cache-high-memory-usage">High Memory Usage<a class="headerlink" href="#semantic_cache-high-memory-usage" title="Permanent link">&para;</a></h3>
<pre><code>Problem: Cache uses &gt;1GB RAM
Diagnosis:
  - Check max_entries (too high?)
  - Check result sizes (large results?)
Solution:
  - Lower max_entries to 5000
  - Compress results before caching
  - Implement result size limit
</code></pre>
<h3 id="semantic_cache-deadlocks">Deadlocks<a class="headerlink" href="#semantic_cache-deadlocks" title="Permanent link">&para;</a></h3>
<pre><code>Problem: Resource deadlock errors
Diagnosis:
  - Nested mutex acquisition
  - Incorrect use of remove() vs removeInternal_()
Solution:
  - Use removeInternal_() when stats_mutex_ is held
  - Use scope-based locking for temporary locks
  - Never call public methods from internal methods
</code></pre>
<h2 id="semantic_cache-summary">Summary<a class="headerlink" href="#semantic_cache-summary" title="Permanent link">&para;</a></h2>
<p>The Semantic Query Cache provides:
- ✅ <strong>Fast Lookups</strong>: ~1ms exact, ~5ms similarity
- ✅ <strong>Intelligent Matching</strong>: Feature-based embeddings
- ✅ <strong>Automatic Eviction</strong>: LRU + TTL
- ✅ <strong>Thread-Safe</strong>: Concurrent reads/writes
- ✅ <strong>Production-Ready</strong>: 14/14 tests passing</p>
<p><strong>Status</strong>: ✅ COMPLETE (Task 5/9)
<strong>Tests</strong>: 14/14 PASSED
<strong>Code</strong>: 700+ lines (header + impl + tests)
<strong>Performance</strong>: Production-ready</p></section></section>
                    <section class='print-page md-section' id='section-7' heading-number='7'>
                        <h1>Content Pipeline<a class='headerlink' href='#section-7' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="content_pipeline" heading-number="7.1"><h1 id="content_pipeline-content-pipeline">Content Pipeline<a class="headerlink" href="#content_pipeline-content-pipeline" title="Permanent link">&para;</a></h1>
<h2 id="content_pipeline-uberblick">Überblick<a class="headerlink" href="#content_pipeline-uberblick" title="Permanent link">&para;</a></h2>
<p>Die <strong>Content Pipeline</strong> ist das zentrale System für die Verarbeitung heterogener Datentypen in THEMIS. Sie ermöglicht es, beliebige Inhalte (Text, Bilder, Geodaten, CAD, Audio, strukturierte Daten) zu importieren, zu transformieren und für Vektor-, Graph- und Attributsuche bereitzustellen.</p>
<p><strong>Kernkonzepte:</strong></p>
<ul>
<li><strong>Modulare Architektur:</strong> Typ-spezifische Prozessoren (<code>IContentProcessor</code>) für jede Datenkategorie</li>
<li><strong>Einheitliche API:</strong> Ein Import-Endpoint (<code>POST /content/import</code>) für alle Datentypen</li>
<li><strong>Wiederverwendbare Komponenten:</strong> Deduplication, Chunking, Graph-Erstellung, Embedding-Generierung</li>
<li><strong>Kanonisches Schema:</strong> Strukturiertes JSON-Format (Content/Chunks/Edges) für alle Modalitäten</li>
<li><strong>RAG-Ready:</strong> Automatische Graph-Konstruktion mit <code>parent</code>, <code>next</code>, <code>prev</code>, <code>contains</code>, <code>sibling</code> Edges für kontextuelle Suche</li>
</ul>
<p><strong>Architektur-Diagramm:</strong></p>
<pre><code>Client → POST /content/import
           ↓
    ContentManager (Orchestrator)
           ↓
    ┌──────────────────────────┐
    │  ContentTypeRegistry     │  MIME → Category Mapping
    └──────────────────────────┘
           ↓
    ┌──────────────────────────┐
    │  Processor Routing       │  Category → IContentProcessor
    └──────────────────────────┘
           ↓
    ┌───────────────────────────────────────────────┐
    │  Prozessoren (TextProcessor, ImageProcessor,  │
    │  GeoProcessor, CADProcessor, AudioProcessor,  │
    │  StructuredProcessor, BinaryProcessor)        │
    └───────────────────────────────────────────────┘
           ↓
    ┌──────────────────────────┐
    │  Storage Layer           │
    │  • RocksDB (Metadata)    │
    │  • VectorIndex (HNSW)    │
    │  • GraphIndex (Edges)    │
    │  • SecondaryIndex (Tags) │
    └──────────────────────────┘
</code></pre>
<h2 id="content_pipeline-1-content-type-system">1. Content-Type-System<a class="headerlink" href="#content_pipeline-1-content-type-system" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-11-contentcategory">1.1 ContentCategory<a class="headerlink" href="#content_pipeline-11-contentcategory" title="Permanent link">&para;</a></h3>
<p>THEMIS unterstützt 9 Content-Kategorien:</p>
<table>
<thead>
<tr>
<th>Kategorie</th>
<th>Beschreibung</th>
<th>Beispiel-MIME-Types</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TEXT</code></td>
<td>Textdokumente, Code, Markdown</td>
<td><code>text/plain</code>, <code>application/json</code>, <code>text/xml</code></td>
</tr>
<tr>
<td><code>IMAGE</code></td>
<td>Fotos, Diagramme, Screenshots</td>
<td><code>image/jpeg</code>, <code>image/png</code>, <code>image/webp</code></td>
</tr>
<tr>
<td><code>AUDIO</code></td>
<td>Musik, Podcasts, Sprachchips</td>
<td><code>audio/mpeg</code>, <code>audio/wav</code>, <code>audio/flac</code></td>
</tr>
<tr>
<td><code>VIDEO</code></td>
<td>Videos</td>
<td><code>video/mp4</code>, <code>video/webm</code></td>
</tr>
<tr>
<td><code>GEO</code></td>
<td>Geodaten, GIS</td>
<td><code>application/geo+json</code>, <code>application/gpx</code></td>
</tr>
<tr>
<td><code>CAD</code></td>
<td>3D-Modelle, CAD-Zeichnungen</td>
<td><code>model/step</code>, <code>model/iges</code>, <code>model/stl</code></td>
</tr>
<tr>
<td><code>STRUCTURED</code></td>
<td>Tabellarische Daten</td>
<td><code>text/csv</code>, <code>application/parquet</code></td>
</tr>
<tr>
<td><code>ARCHIVE</code></td>
<td>Archive, Container</td>
<td><code>application/zip</code>, <code>application/tar+gzip</code></td>
</tr>
<tr>
<td><code>BINARY</code></td>
<td>Unbekannte Binärdaten (Fallback)</td>
<td><code>application/octet-stream</code></td>
</tr>
</tbody>
</table>
<h3 id="content_pipeline-12-contenttyperegistry">1.2 ContentTypeRegistry<a class="headerlink" href="#content_pipeline-12-contenttyperegistry" title="Permanent link">&para;</a></h3>
<p>Die <code>ContentTypeRegistry</code> mappt MIME-Types auf Kategorien und speichert Metadaten über Fähigkeiten:</p>
<pre><code class="language-cpp">struct ContentType {
    std::string mime_type;
    ContentCategory category;
    std::vector&lt;std::string&gt; extensions;  // z.B. {&quot;.txt&quot;, &quot;.md&quot;}
    bool supports_text_extraction;        // Kann Text extrahiert werden?
    bool supports_chunking;               // Kann in Chunks zerlegt werden?
    bool supports_embedding;              // Kann Embedding generiert werden?

    struct Features {
        bool hierarchical;   // Hat Hierarchie (CAD Assembly, Archive)
        bool spatial;        // Hat räumliche Koordinaten (Geo, GeoTIFF)
        bool temporal;       // Hat zeitliche Dimension (Audio, Video)
        bool multimodal;     // Mehrere Modalitäten (Video = Audio + Frames)
    };
    Features features;
};
</code></pre>
<p><strong>Beispiel-Registrierung:</strong></p>
<pre><code class="language-cpp">ContentType text_plain;
text_plain.mime_type = &quot;text/plain&quot;;
text_plain.category = ContentCategory::TEXT;
text_plain.extensions = {&quot;.txt&quot;, &quot;.log&quot;, &quot;.md&quot;};
text_plain.supports_text_extraction = true;
text_plain.supports_chunking = true;
text_plain.supports_embedding = true;
text_plain.features.hierarchical = false;

ContentTypeRegistry::instance().registerType(text_plain);
</code></pre>
<h2 id="content_pipeline-2-content-prozessoren">2. Content-Prozessoren<a class="headerlink" href="#content_pipeline-2-content-prozessoren" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-21-icontentprocessor-interface">2.1 IContentProcessor Interface<a class="headerlink" href="#content_pipeline-21-icontentprocessor-interface" title="Permanent link">&para;</a></h3>
<p>Jeder Prozessor implementiert 3 Kernmethoden:</p>
<pre><code class="language-cpp">class IContentProcessor {
public:
    // 1. Extraktion: Blob → Strukturierte Daten
    virtual ExtractionResult extract(
        const std::string&amp; blob,
        const ContentType&amp; content_type
    ) = 0;

    // 2. Chunking: Extraktion → Viele kleine Chunks
    virtual std::vector&lt;json&gt; chunk(
        const ExtractionResult&amp; extraction_result,
        int chunk_size,
        int overlap
    ) = 0;

    // 3. Embedding: Chunk → Vektorrepräsentation
    virtual std::vector&lt;float&gt; generateEmbedding(
        const std::string&amp; chunk_data
    ) = 0;
};
</code></pre>
<p><strong>ExtractionResult-Struktur:</strong></p>
<pre><code class="language-cpp">struct ExtractionResult {
    bool ok;
    std::string text;              // Extrahierter Plain-Text
    json metadata;                 // EXIF, ID3, CAD-Properties, etc.
    std::vector&lt;float&gt; embedding;  // Optional: Pre-computed Embedding
    std::string error_message;

    // Typ-spezifische Daten
    std::optional&lt;GeoData&gt; geo_data;      // Koordinaten, Projektion, Properties
    std::optional&lt;MediaData&gt; media_data;  // Duration, Width, Height, Codec
    std::optional&lt;CADData&gt; cad_data;      // Parts, BOM, Dimensionen
};
</code></pre>
<h3 id="content_pipeline-22-textprocessor">2.2 TextProcessor<a class="headerlink" href="#content_pipeline-22-textprocessor" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeiten:</strong></p>
<ul>
<li>Text-Normalisierung (Whitespace, Newlines)</li>
<li>Sentenz-basiertes Chunking mit Overlap</li>
<li>Embedding via Sentence-Transformers (768D)</li>
</ul>
<p><strong>Chunking-Strategie:</strong></p>
<pre><code class="language-cpp">std::vector&lt;json&gt; TextProcessor::chunk(
    const ExtractionResult&amp; extraction,
    int chunk_size,      // z.B. 512 Tokens
    int overlap          // z.B. 50 Tokens
) {
    std::string text = normalizeText(extraction.text);
    std::vector&lt;std::string&gt; sentences = splitIntoSentences(text);

    std::vector&lt;json&gt; chunks;
    std::string current_chunk;
    int current_tokens = 0;

    for (const auto&amp; sentence : sentences) {
        int tokens = countTokens(sentence);

        if (current_tokens + tokens &gt; chunk_size &amp;&amp; !current_chunk.empty()) {
            // Save chunk
            chunks.push_back({
                {&quot;type&quot;, &quot;text&quot;},
                {&quot;text&quot;, current_chunk},
                {&quot;tokens&quot;, current_tokens}
            });

            // Overlap: Behalte letzte N Tokens
            current_chunk = getLastNTokens(current_chunk, overlap) + &quot; &quot; + sentence;
            current_tokens = overlap + tokens;
        } else {
            current_chunk += &quot; &quot; + sentence;
            current_tokens += tokens;
        }
    }

    return chunks;
}
</code></pre>
<p><strong>Embedding:</strong></p>
<pre><code class="language-cpp">std::vector&lt;float&gt; TextProcessor::generateEmbedding(const std::string&amp; chunk_data) {
    json chunk = json::parse(chunk_data);
    std::string text = chunk[&quot;text&quot;];

    // Aufruf an externes Embedding-Service (z.B. FastAPI mit Sentence-Transformers)
    json request = {{&quot;text&quot;, text}};
    auto response = http_client_-&gt;post(&quot;http://localhost:5000/embed&quot;, request);
    return response[&quot;embedding&quot;].get&lt;std::vector&lt;float&gt;&gt;(); // 768D
}
</code></pre>
<h3 id="content_pipeline-23-imageprocessor">2.3 ImageProcessor<a class="headerlink" href="#content_pipeline-23-imageprocessor" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeiten:</strong></p>
<ul>
<li>EXIF-Metadaten extrahieren (GPS, DateTime, Camera Model)</li>
<li>Bild-Dimensionen, Format, Kompression erkennen</li>
<li>Embedding via CLIP (512D)</li>
</ul>
<p><strong>Extraktion:</strong></p>
<pre><code class="language-cpp">ExtractionResult ImageProcessor::extract(const std::string&amp; blob, const ContentType&amp; type) {
    ExtractionResult result;

    // EXIF-Tags parsen
    result.metadata = extractEXIF(blob);

    // Dimensionen
    auto [width, height] = getImageDimensions(blob);
    result.media_data = MediaData{
        .duration_seconds = 0,
        .width = width,
        .height = height,
        .codec = type.mime_type
    };

    // OCR (optional, falls Text im Bild)
    if (config.enable_ocr) {
        result.text = performOCR(blob);
    }

    result.ok = true;
    return result;
}
</code></pre>
<p><strong>Chunking:</strong> Bilder werden i.d.R. als ein Chunk gespeichert. Bei großen Bildern könnte Tiling erfolgen:</p>
<pre><code class="language-cpp">std::vector&lt;json&gt; ImageProcessor::chunk(const ExtractionResult&amp; extraction, int chunk_size, int overlap) {
    // Für MVP: Ein Chunk pro Bild
    json chunk = {
        {&quot;type&quot;, &quot;image&quot;},
        {&quot;width&quot;, extraction.media_data-&gt;width},
        {&quot;height&quot;, extraction.media_data-&gt;height},
        {&quot;exif&quot;, extraction.metadata}
    };

    // Falls OCR-Text vorhanden, separater Text-Chunk
    std::vector&lt;json&gt; chunks = {chunk};
    if (!extraction.text.empty()) {
        chunks.push_back({
            {&quot;type&quot;, &quot;ocr_text&quot;},
            {&quot;text&quot;, extraction.text}
        });
    }

    return chunks;
}
</code></pre>
<p><strong>Embedding:</strong></p>
<pre><code class="language-cpp">std::vector&lt;float&gt; ImageProcessor::generateEmbedding(const std::string&amp; chunk_data) {
    // CLIP: Bild → 512D Vektor
    // blob muss als Base64 oder Dateipfad übermittelt werden
    json request = {{&quot;image_base64&quot;, base64Encode(blob)}};
    auto response = http_client_-&gt;post(&quot;http://localhost:5000/embed/image&quot;, request);
    return response[&quot;embedding&quot;].get&lt;std::vector&lt;float&gt;&gt;(); // 512D
}
</code></pre>
<h3 id="content_pipeline-24-geoprocessor">2.4 GeoProcessor<a class="headerlink" href="#content_pipeline-24-geoprocessor" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeiten:</strong></p>
<ul>
<li>GeoJSON, GPX, GeoTIFF parsen</li>
<li>Koordinaten-Extraktion, Projektion (EPSG/SRID), Bounding Box</li>
<li>Spatial Embeddings via Geo2Vec oder TileDB</li>
</ul>
<p><strong>Extraktion:</strong></p>
<pre><code class="language-cpp">ExtractionResult GeoProcessor::extract(const std::string&amp; blob, const ContentType&amp; type) {
    ExtractionResult result;

    if (type.mime_type == &quot;application/geo+json&quot;) {
        result.geo_data = parseGeoJSON(blob);
    } else if (type.mime_type.find(&quot;gpx&quot;) != std::string::npos) {
        result.geo_data = parseGPX(blob);
    }

    // Metadata: SRID, Feature-Count, BBox
    result.metadata = {
        {&quot;srid&quot;, result.geo_data-&gt;projection},
        {&quot;feature_count&quot;, result.geo_data-&gt;coordinates.size()},
        {&quot;bbox&quot;, computeBBox(result.geo_data-&gt;coordinates)}
    };

    result.ok = true;
    return result;
}
</code></pre>
<p><strong>Chunking:</strong> Ein Chunk pro Feature (bei FeatureCollection):</p>
<pre><code class="language-cpp">std::vector&lt;json&gt; GeoProcessor::chunk(const ExtractionResult&amp; extraction, int chunk_size, int overlap) {
    std::vector&lt;json&gt; chunks;

    for (size_t i = 0; i &lt; extraction.geo_data-&gt;coordinates.size(); ++i) {
        auto [lat, lon] = extraction.geo_data-&gt;coordinates[i];
        json properties = extraction.geo_data-&gt;properties[i]; // Annahme: properties pro Feature

        chunks.push_back({
            {&quot;type&quot;, &quot;geo_feature&quot;},
            {&quot;geometry&quot;, {{&quot;type&quot;, &quot;Point&quot;}, {&quot;coordinates&quot;, {lon, lat}}}},
            {&quot;srid&quot;, extraction.geo_data-&gt;projection},
            {&quot;properties&quot;, properties}
        });
    }

    return chunks;
}
</code></pre>
<p><strong>Embedding:</strong></p>
<pre><code class="language-cpp">std::vector&lt;float&gt; GeoProcessor::generateEmbedding(const std::string&amp; chunk_data) {
    json chunk = json::parse(chunk_data);
    auto coords = chunk[&quot;geometry&quot;][&quot;coordinates&quot;];
    double lon = coords[0], lat = coords[1];

    // Geo2Vec: [lon, lat] → 128D Vektor
    json request = {{&quot;lon&quot;, lon}, {&quot;lat&quot;, lat}};
    auto response = http_client_-&gt;post(&quot;http://localhost:5000/embed/geo&quot;, request);
    return response[&quot;embedding&quot;].get&lt;std::vector&lt;float&gt;&gt;();
}
</code></pre>
<h3 id="content_pipeline-25-cadprocessor">2.5 CADProcessor<a class="headerlink" href="#content_pipeline-25-cadprocessor" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeiten:</strong></p>
<ul>
<li>STEP, IGES, STL, DXF parsen</li>
<li>Assembly-Hierarchie extrahieren (Parent-Child-Beziehungen)</li>
<li>Bill of Materials (BOM), Dimensionen, Constraints</li>
</ul>
<p><strong>Extraktion:</strong></p>
<pre><code class="language-cpp">ExtractionResult CADProcessor::extract(const std::string&amp; blob, const ContentType&amp; type) {
    ExtractionResult result;

    if (type.mime_type == &quot;model/step&quot;) {
        json step_data = parseSTEP(blob);
        result.cad_data = CADData{
            .part_ids = extractPartIDs(step_data),
            .bom = extractBOM(step_data),
            .dimensions = extractDimensions(step_data)
        };
    }

    result.metadata = {
        {&quot;format&quot;, &quot;STEP&quot;},
        {&quot;part_count&quot;, result.cad_data-&gt;part_ids.size()}
    };

    result.ok = true;
    return result;
}
</code></pre>
<p><strong>Chunking:</strong> Ein Chunk pro Part (Hierarchie via Edges):</p>
<pre><code class="language-cpp">std::vector&lt;json&gt; CADProcessor::chunk(const ExtractionResult&amp; extraction, int chunk_size, int overlap) {
    std::vector&lt;json&gt; chunks;

    for (const auto&amp; part_id : extraction.cad_data-&gt;part_ids) {
        json part_info = extraction.cad_data-&gt;bom[part_id];

        chunks.push_back({
            {&quot;type&quot;, &quot;cad_part&quot;},
            {&quot;part_id&quot;, part_id},
            {&quot;name&quot;, part_info[&quot;name&quot;]},
            {&quot;material&quot;, part_info[&quot;material&quot;]},
            {&quot;dimensions&quot;, part_info[&quot;dimensions&quot;]}
        });
    }

    return chunks;
}
</code></pre>
<p><strong>Graph-Edges:</strong> <code>contains</code> (Assembly → Part), <code>sibling</code> (Parts im gleichen Assembly)</p>
<h3 id="content_pipeline-26-audioprocessor">2.6 AudioProcessor<a class="headerlink" href="#content_pipeline-26-audioprocessor" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeiten:</strong></p>
<ul>
<li>ID3-Tags extrahieren (Titel, Artist, Album)</li>
<li>Duration, Bitrate, Codec erkennen</li>
<li>Speech-to-Text (optional)</li>
<li>Embedding via Wav2Vec2 (768D)</li>
</ul>
<p><strong>Chunking:</strong> Zeit-basiert (z.B. 10-Sekunden-Segmente):</p>
<pre><code class="language-cpp">std::vector&lt;json&gt; AudioProcessor::chunk(const ExtractionResult&amp; extraction, int chunk_size, int overlap) {
    int duration = extraction.media_data-&gt;duration_seconds;
    std::vector&lt;json&gt; chunks;

    for (int i = 0; i &lt; duration; i += chunk_size) {
        int end_time = std::min(i + chunk_size, duration);

        chunks.push_back({
            {&quot;type&quot;, &quot;audio_segment&quot;},
            {&quot;start_time&quot;, i},
            {&quot;end_time&quot;, end_time},
            {&quot;transcript&quot;, extractTranscript(i, end_time)} // Optional: Whisper ASR
        });
    }

    return chunks;
}
</code></pre>
<h3 id="content_pipeline-27-structuredprocessor">2.7 StructuredProcessor<a class="headerlink" href="#content_pipeline-27-structuredprocessor" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeiten:</strong></p>
<ul>
<li>CSV, Parquet, Arrow parsen</li>
<li>Schema-Inferenz (Spaltentypen)</li>
<li>Row-Level Chunking</li>
<li>Spalten-Embeddings (für Table-QA)</li>
</ul>
<p><strong>Chunking:</strong></p>
<pre><code class="language-cpp">std::vector&lt;json&gt; StructuredProcessor::chunk(const ExtractionResult&amp; extraction, int chunk_size, int overlap) {
    auto rows = parseCSV(extraction.text);
    json schema = extractSchema(rows);

    std::vector&lt;json&gt; chunks;

    // Header als separater Chunk
    chunks.push_back({
        {&quot;type&quot;, &quot;table_schema&quot;},
        {&quot;schema&quot;, schema}
    });

    // Rows in Batches
    for (size_t i = 1; i &lt; rows.size(); i += chunk_size) {
        json row_batch = json::array();
        for (size_t j = i; j &lt; std::min(i + chunk_size, rows.size()); ++j) {
            row_batch.push_back(rows[j]);
        }

        chunks.push_back({
            {&quot;type&quot;, &quot;table_rows&quot;},
            {&quot;rows&quot;, row_batch},
            {&quot;row_range&quot;, {i, std::min(i + chunk_size, rows.size())}}
        });
    }

    return chunks;
}
</code></pre>
<h3 id="content_pipeline-28-binaryprocessor-fallback">2.8 BinaryProcessor (Fallback)<a class="headerlink" href="#content_pipeline-28-binaryprocessor-fallback" title="Permanent link">&para;</a></h3>
<p>Falls kein spezialisierter Prozessor vorhanden, nutzt <code>BinaryProcessor</code> nur Hash + Größe:</p>
<pre><code class="language-cpp">ExtractionResult BinaryProcessor::extract(const std::string&amp; blob, const ContentType&amp; type) {
    ExtractionResult result;
    result.metadata = {
        {&quot;size_bytes&quot;, blob.size()},
        {&quot;hash_sha256&quot;, computeSHA256(blob)}
    };
    result.ok = true;
    return result;
}
</code></pre>
<h2 id="content_pipeline-3-import-pipeline-post-contentimport">3. Import-Pipeline (POST /content/import)<a class="headerlink" href="#content_pipeline-3-import-pipeline-post-contentimport" title="Permanent link">&para;</a></h2>
<p>Ab <strong>MVP 2.0</strong> wird die Ingestion <strong>client-seitig</strong> durchgeführt. Der Server erwartet vorverarbeitete JSON-Objekte mit einem kanonischen Schema.</p>
<h3 id="content_pipeline-31-import-schema">3.1 Import-Schema<a class="headerlink" href="#content_pipeline-31-import-schema" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;content&quot;: {
    &quot;id&quot;: &quot;content-uuid&quot;,
    &quot;mime_type&quot;: &quot;text/plain&quot;,
    &quot;category&quot;: &quot;TEXT&quot;,
    &quot;original_filename&quot;: &quot;doc.txt&quot;,
    &quot;size_bytes&quot;: 1024,
    &quot;hash_sha256&quot;: &quot;abc123...&quot;,
    &quot;created_at&quot;: 1672531200,
    &quot;user_metadata&quot;: {&quot;author&quot;: &quot;John Doe&quot;},
    &quot;tags&quot;: [&quot;documentation&quot;, &quot;v1.0&quot;]
  },
  &quot;chunks&quot;: [
    {
      &quot;id&quot;: &quot;chunk-uuid-1&quot;,
      &quot;content_id&quot;: &quot;content-uuid&quot;,
      &quot;seq_num&quot;: 0,
      &quot;chunk_type&quot;: &quot;text&quot;,
      &quot;text&quot;: &quot;This is the first chunk...&quot;,
      &quot;start_offset&quot;: 0,
      &quot;end_offset&quot;: 512,
      &quot;embedding&quot;: [0.12, -0.45, ...]  // 768D
    },
    {
      &quot;id&quot;: &quot;chunk-uuid-2&quot;,
      &quot;content_id&quot;: &quot;content-uuid&quot;,
      &quot;seq_num&quot;: 1,
      &quot;chunk_type&quot;: &quot;text&quot;,
      &quot;text&quot;: &quot;This is the second chunk...&quot;,
      &quot;start_offset&quot;: 462,
      &quot;end_offset&quot;: 974,
      &quot;embedding&quot;: [0.34, 0.67, ...]
    }
  ],
  &quot;edges&quot;: [
    {
      &quot;from&quot;: &quot;chunk-uuid-1&quot;,
      &quot;to&quot;: &quot;chunk-uuid-2&quot;,
      &quot;type&quot;: &quot;next&quot;,
      &quot;weight&quot;: 1.0
    },
    {
      &quot;from&quot;: &quot;chunk-uuid-2&quot;,
      &quot;to&quot;: &quot;chunk-uuid-1&quot;,
      &quot;type&quot;: &quot;prev&quot;,
      &quot;weight&quot;: 1.0
    }
  ],
  &quot;blob&quot;: &quot;&lt;base64-encoded-binary&gt;&quot;  // Optional: Original-Blob
}
</code></pre>
<h3 id="content_pipeline-32-server-seitige-import-verarbeitung">3.2 Server-seitige Import-Verarbeitung<a class="headerlink" href="#content_pipeline-32-server-seitige-import-verarbeitung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">Status ContentManager::importContent(const json&amp; spec, const std::optional&lt;std::string&gt;&amp; blob) {
    // 1. Validierung
    if (!spec.contains(&quot;content&quot;) || !spec.contains(&quot;chunks&quot;)) {
        return Status::Error(&quot;Invalid schema: missing 'content' or 'chunks'&quot;);
    }

    // 2. Content-Metadata speichern
    ContentMeta meta = ContentMeta::fromJson(spec[&quot;content&quot;]);
    BaseEntity content_entity(meta.id, &quot;content&quot;);
    content_entity.set(&quot;mime_type&quot;, meta.mime_type);
    content_entity.set(&quot;category&quot;, static_cast&lt;int&gt;(meta.category));
    content_entity.set(&quot;original_filename&quot;, meta.original_filename);
    // ... (weitere Felder)
    storage_-&gt;put(content_entity);

    // 3. Blob speichern (falls vorhanden)
    if (blob.has_value()) {
        BaseEntity blob_entity(meta.id, &quot;content_blob&quot;);
        blob_entity.setBlob(*blob);
        storage_-&gt;put(blob_entity);
    }

    // 4. Chunks speichern + VectorIndex aktualisieren
    for (const auto&amp; chunk_json : spec[&quot;chunks&quot;]) {
        ChunkMeta chunk = ChunkMeta::fromJson(chunk_json);

        BaseEntity chunk_entity(chunk.id, &quot;chunk&quot;);
        chunk_entity.set(&quot;content_id&quot;, chunk.content_id);
        chunk_entity.set(&quot;seq_num&quot;, chunk.seq_num);
        chunk_entity.set(&quot;chunk_type&quot;, chunk.chunk_type);
        chunk_entity.set(&quot;text&quot;, chunk.text);
        storage_-&gt;put(chunk_entity);

        // VectorIndex: Embedding einfügen
        if (!chunk.embedding.empty()) {
            vector_index_-&gt;addVector(chunk.id, chunk.embedding);
        }
    }

    // 5. Graph-Edges speichern
    if (spec.contains(&quot;edges&quot;)) {
        for (const auto&amp; edge : spec[&quot;edges&quot;]) {
            graph_index_-&gt;addEdge(
                edge[&quot;from&quot;],
                edge[&quot;to&quot;],
                edge[&quot;type&quot;],
                edge.value(&quot;weight&quot;, 1.0)
            );
        }
    }

    return Status::OK();
}
</code></pre>
<h3 id="content_pipeline-33-http-endpoint">3.3 HTTP-Endpoint<a class="headerlink" href="#content_pipeline-33-http-endpoint" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// In main_server.cpp
app.post(&quot;/content/import&quot;, [&amp;](const Request&amp; req, Response&amp; res) {
    json spec = json::parse(req.body);

    std::optional&lt;std::string&gt; blob;
    if (spec.contains(&quot;blob&quot;)) {
        blob = base64Decode(spec[&quot;blob&quot;].get&lt;std::string&gt;());
    }

    auto status = content_manager-&gt;importContent(spec, blob);

    if (status.ok) {
        res.status = 200;
        res.set_content(json{{&quot;ok&quot;, true}, {&quot;content_id&quot;, spec[&quot;content&quot;][&quot;id&quot;]}}.dump(), &quot;application/json&quot;);
    } else {
        res.status = 400;
        res.set_content(json{{&quot;error&quot;, status.message}}.dump(), &quot;application/json&quot;);
    }
});
</code></pre>
<h2 id="content_pipeline-4-batching-bulk-import">4. Batching &amp; Bulk-Import<a class="headerlink" href="#content_pipeline-4-batching-bulk-import" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-41-motivation">4.1 Motivation<a class="headerlink" href="#content_pipeline-41-motivation" title="Permanent link">&para;</a></h3>
<p>Beim Import vieler Dokumente (z.B. 10.000 PDFs) ist sequentielles Einfügen ineffizient. <strong>Batching</strong> gruppiert mehrere Operationen:</p>
<ul>
<li><strong>Embedding-Batch-API:</strong> Generierung von 100 Embeddings in einem Request</li>
<li><strong>RocksDB WriteBatch:</strong> Atomare Transaktionen für mehrere Entities</li>
<li><strong>VectorIndex Bulk-Insert:</strong> HNSW-Build via Batch-Add</li>
</ul>
<h3 id="content_pipeline-42-batch-import-schema">4.2 Batch-Import-Schema<a class="headerlink" href="#content_pipeline-42-batch-import-schema" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;batch&quot;: [
    {
      &quot;content&quot;: {...},
      &quot;chunks&quot;: [...],
      &quot;edges&quot;: [...],
      &quot;blob&quot;: &quot;...&quot;
    },
    {
      &quot;content&quot;: {...},
      &quot;chunks&quot;: [...],
      &quot;edges&quot;: [...],
      &quot;blob&quot;: &quot;...&quot;
    }
  ]
}
</code></pre>
<h3 id="content_pipeline-43-server-implementierung">4.3 Server-Implementierung<a class="headerlink" href="#content_pipeline-43-server-implementierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">Status ContentManager::importBatch(const json&amp; batch_spec) {
    rocksdb::WriteBatch batch;
    std::vector&lt;std::pair&lt;std::string, std::vector&lt;float&gt;&gt;&gt; embeddings_to_add;

    for (const auto&amp; item : batch_spec[&quot;batch&quot;]) {
        // Content + Chunks in WriteBatch speichern
        ContentMeta meta = ContentMeta::fromJson(item[&quot;content&quot;]);
        batch.Put(&quot;content:&quot; + meta.id, meta.toJson().dump());

        for (const auto&amp; chunk_json : item[&quot;chunks&quot;]) {
            ChunkMeta chunk = ChunkMeta::fromJson(chunk_json);
            batch.Put(&quot;chunk:&quot; + chunk.id, chunk.toJson().dump());

            if (!chunk.embedding.empty()) {
                embeddings_to_add.push_back({chunk.id, chunk.embedding});
            }
        }
    }

    // Atomare DB-Write
    auto db_status = storage_-&gt;getRaw()-&gt;Write(rocksdb::WriteOptions(), &amp;batch);
    if (!db_status.ok()) {
        return Status::Error(&quot;Batch write failed: &quot; + db_status.ToString());
    }

    // VectorIndex: Bulk-Add
    vector_index_-&gt;addVectorsBatch(embeddings_to_add);

    return Status::OK();
}
</code></pre>
<h2 id="content_pipeline-5-error-handling">5. Error Handling<a class="headerlink" href="#content_pipeline-5-error-handling" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-51-fehler-kategorien">5.1 Fehler-Kategorien<a class="headerlink" href="#content_pipeline-51-fehler-kategorien" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Fehler</th>
<th>HTTP-Code</th>
<th>Ursache</th>
<th>Recovery</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Invalid Schema</code></td>
<td>400</td>
<td>Fehlende Pflichtfelder (<code>content</code>, <code>chunks</code>)</td>
<td>Client: Schema validieren</td>
</tr>
<tr>
<td><code>Duplicate Content</code></td>
<td>409</td>
<td><code>hash_sha256</code> bereits vorhanden</td>
<td>Client: Dedup-Check vor Upload</td>
</tr>
<tr>
<td><code>Embedding Dimension Mismatch</code></td>
<td>400</td>
<td>Embedding hat falsche Dimension</td>
<td>Client: Modell-Version prüfen</td>
</tr>
<tr>
<td><code>Storage Error</code></td>
<td>500</td>
<td>RocksDB Write fehlgeschlagen</td>
<td>Server: Retry mit Backoff</td>
</tr>
<tr>
<td><code>VectorIndex Error</code></td>
<td>500</td>
<td>HNSW-Build fehlgeschlagen</td>
<td>Server: Rebuild Index</td>
</tr>
</tbody>
</table>
<h3 id="content_pipeline-52-status-objekt">5.2 Status-Objekt<a class="headerlink" href="#content_pipeline-52-status-objekt" title="Permanent link">&para;</a></h3>
<p>Alle ContentManager-Methoden geben <code>Status</code> zurück:</p>
<pre><code class="language-cpp">struct Status {
    bool ok = true;
    std::string message;

    static Status OK() { return {}; }
    static Status Error(std::string msg) { return Status{false, std::move(msg)}; }
};
</code></pre>
<p><strong>Beispiel-Nutzung:</strong></p>
<pre><code class="language-cpp">auto status = content_manager-&gt;importContent(spec, blob);
if (!status.ok) {
    THEMIS_ERROR(&quot;Import failed: {}&quot;, status.message);
    // Logging, Retry-Logik, Client-Notification
}
</code></pre>
<h3 id="content_pipeline-53-deduplication">5.3 Deduplication<a class="headerlink" href="#content_pipeline-53-deduplication" title="Permanent link">&para;</a></h3>
<p>Hash-basierte Dedup verhindert doppelte Speicherung:</p>
<pre><code class="language-cpp">Status ContentManager::importContent(const json&amp; spec, const std::optional&lt;std::string&gt;&amp; blob) {
    ContentMeta meta = ContentMeta::fromJson(spec[&quot;content&quot;]);

    // Dedup-Check via SecondaryIndex (hash_sha256)
    auto existing = secondary_index_-&gt;get(&quot;hash_sha256&quot;, meta.hash_sha256);
    if (existing.has_value()) {
        return Status{
            .ok = true,
            .message = &quot;Duplicate content (hash: &quot; + meta.hash_sha256 + &quot;), skipping import&quot;
        };
    }

    // ... normal import
}
</code></pre>
<h2 id="content_pipeline-6-graph-konstruktion">6. Graph-Konstruktion<a class="headerlink" href="#content_pipeline-6-graph-konstruktion" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-61-edge-typen">6.1 Edge-Typen<a class="headerlink" href="#content_pipeline-61-edge-typen" title="Permanent link">&para;</a></h3>
<p>THEMIS konstruiert automatisch Edges für verschiedene Beziehungen:</p>
<table>
<thead>
<tr>
<th>Edge-Typ</th>
<th>Bedeutung</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>parent</code></td>
<td>Chunk gehört zu Content</td>
<td><code>chunk:uuid</code> → <code>content:uuid</code></td>
</tr>
<tr>
<td><code>next</code></td>
<td>Sequentieller Nachfolger</td>
<td><code>chunk:1</code> → <code>chunk:2</code></td>
</tr>
<tr>
<td><code>prev</code></td>
<td>Sequentieller Vorgänger</td>
<td><code>chunk:2</code> → <code>chunk:1</code></td>
</tr>
<tr>
<td><code>contains</code></td>
<td>Hierarchie (Assembly → Part)</td>
<td><code>content:assembly</code> → <code>content:part</code></td>
</tr>
<tr>
<td><code>sibling</code></td>
<td>Gleiche Hierarchie-Ebene</td>
<td><code>chunk:part1</code> → <code>chunk:part2</code></td>
</tr>
<tr>
<td><code>member_of</code></td>
<td>Geodaten: Feature gehört zu Region</td>
<td><code>chunk:poi</code> → <code>chunk:region</code></td>
</tr>
<tr>
<td><code>spatially_near</code></td>
<td>Geodaten: Räumliche Nachbarschaft</td>
<td><code>chunk:poi1</code> → <code>chunk:poi2</code> (z.B. &lt; 1 km)</td>
</tr>
</tbody>
</table>
<h3 id="content_pipeline-62-automatische-edge-generierung">6.2 Automatische Edge-Generierung<a class="headerlink" href="#content_pipeline-62-automatische-edge-generierung" title="Permanent link">&para;</a></h3>
<p><strong>Text-Chunks:</strong></p>
<pre><code class="language-cpp">// parent + next/prev Edges
for (size_t i = 0; i &lt; chunks.size(); ++i) {
    graph_index_-&gt;addEdge(chunks[i].id, content_id, &quot;parent&quot;, 1.0);

    if (i &gt; 0) {
        graph_index_-&gt;addEdge(chunks[i].id, chunks[i-1].id, &quot;prev&quot;, 1.0);
    }
    if (i &lt; chunks.size() - 1) {
        graph_index_-&gt;addEdge(chunks[i].id, chunks[i+1].id, &quot;next&quot;, 1.0);
    }
}
</code></pre>
<p><strong>CAD-Assembly:</strong></p>
<pre><code class="language-cpp">// contains + sibling Edges
for (const auto&amp; part_id : assembly_parts) {
    graph_index_-&gt;addEdge(assembly_id, part_id, &quot;contains&quot;, 1.0);

    for (const auto&amp; sibling_id : assembly_parts) {
        if (part_id != sibling_id) {
            graph_index_-&gt;addEdge(part_id, sibling_id, &quot;sibling&quot;, 0.5);
        }
    }
}
</code></pre>
<p><strong>Geodaten:</strong></p>
<pre><code class="language-cpp">// member_of + spatially_near Edges
for (const auto&amp; poi : pois) {
    std::string region = findRegion(poi.lat, poi.lon); // Spatial Join
    graph_index_-&gt;addEdge(poi.id, region, &quot;member_of&quot;, 1.0);

    auto nearby = findNearbyPOIs(poi.lat, poi.lon, 1000.0); // 1 km Radius
    for (const auto&amp; neighbor : nearby) {
        double distance = haversineDistance(poi, neighbor);
        double weight = 1.0 / (1.0 + distance); // Näher = höheres Gewicht
        graph_index_-&gt;addEdge(poi.id, neighbor.id, &quot;spatially_near&quot;, weight);
    }
}
</code></pre>
<h3 id="content_pipeline-63-graph-expansion-rag">6.3 Graph-Expansion (RAG)<a class="headerlink" href="#content_pipeline-63-graph-expansion-rag" title="Permanent link">&para;</a></h3>
<p>Suche mit Kontext-Expansion:</p>
<pre><code class="language-cpp">std::vector&lt;std::pair&lt;std::string, float&gt;&gt; ContentManager::searchWithExpansion(
    const std::string&amp; query_text,
    int k,
    int expansion_hops
) {
    // 1. Vektor-Suche: Top-K Chunks
    auto embedding = generateQueryEmbedding(query_text);
    auto top_k_chunks = vector_index_-&gt;search(embedding, k);

    // 2. Graph-Expansion: Nachbarn via BFS
    std::set&lt;std::string&gt; expanded_chunks;
    for (const auto&amp; [chunk_id, score] : top_k_chunks) {
        expanded_chunks.insert(chunk_id);

        // BFS: expansion_hops Schritte
        auto neighbors = graph_index_-&gt;bfs(chunk_id, expansion_hops, {&quot;next&quot;, &quot;prev&quot;, &quot;parent&quot;, &quot;sibling&quot;});
        for (const auto&amp; neighbor : neighbors) {
            expanded_chunks.insert(neighbor);
        }
    }

    // 3. Ergebnisse ranken (Original-Score beibehalten)
    std::vector&lt;std::pair&lt;std::string, float&gt;&gt; results;
    for (const auto&amp; chunk_id : expanded_chunks) {
        auto it = std::find_if(top_k_chunks.begin(), top_k_chunks.end(),
            [&amp;](const auto&amp; p) { return p.first == chunk_id; });

        float score = (it != top_k_chunks.end()) ? it-&gt;second : 0.5; // Nachbarn mit reduziertem Score
        results.push_back({chunk_id, score});
    }

    // 4. Nach Score sortieren
    std::sort(results.begin(), results.end(),
        [](const auto&amp; a, const auto&amp; b) { return a.second &gt; b.second; });

    return results;
}
</code></pre>
<h2 id="content_pipeline-7-embedding-strategien">7. Embedding-Strategien<a class="headerlink" href="#content_pipeline-7-embedding-strategien" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-71-embedding-modelle-pro-modalitat">7.1 Embedding-Modelle pro Modalität<a class="headerlink" href="#content_pipeline-71-embedding-modelle-pro-modalitat" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Modalität</th>
<th>Modell</th>
<th>Dimension</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Text</td>
<td>Sentence-Transformers (<code>all-MiniLM-L6-v2</code>)</td>
<td>768D</td>
<td>Semantische Textsuche</td>
</tr>
<tr>
<td>Bilder</td>
<td>CLIP (<code>openai/clip-vit-base-patch32</code>)</td>
<td>512D</td>
<td>Multi-modale (Bild + Text) Embeddings</td>
</tr>
<tr>
<td>Geodaten</td>
<td>Geo2Vec (Custom)</td>
<td>128D</td>
<td>[lon, lat] → Vektor</td>
</tr>
<tr>
<td>CAD</td>
<td>PartNet / GraphSAINT (Custom)</td>
<td>256D</td>
<td>Geometry + BOM → Vektor</td>
</tr>
<tr>
<td>Audio</td>
<td>Wav2Vec2 (<code>facebook/wav2vec2-base</code>)</td>
<td>768D</td>
<td>Akustische Features</td>
</tr>
<tr>
<td>Tabellen</td>
<td>TaBERT / TAPAS (Custom)</td>
<td>768D</td>
<td>Schema + Rows → Vektor</td>
</tr>
</tbody>
</table>
<h3 id="content_pipeline-72-externe-embedding-services">7.2 Externe Embedding-Services<a class="headerlink" href="#content_pipeline-72-externe-embedding-services" title="Permanent link">&para;</a></h3>
<p>Embeddings werden via HTTP-APIs generiert:</p>
<p><strong>Text-Embedding:</strong></p>
<pre><code class="language-http">POST http://localhost:5000/embed
Content-Type: application/json

{
  &quot;text&quot;: &quot;This is a sample document.&quot;
}

Response:
{
  &quot;embedding&quot;: [0.123, -0.456, ..., 0.789],  // 768D
  &quot;model&quot;: &quot;all-MiniLM-L6-v2&quot;
}
</code></pre>
<p><strong>Batch-Embedding:</strong></p>
<pre><code class="language-http">POST http://localhost:5000/embed/batch
Content-Type: application/json

{
  &quot;texts&quot;: [&quot;Doc 1&quot;, &quot;Doc 2&quot;, ..., &quot;Doc 100&quot;]
}

Response:
{
  &quot;embeddings&quot;: [
    [0.1, 0.2, ...],
    [0.3, 0.4, ...],
    ...
  ]
}
</code></pre>
<h3 id="content_pipeline-73-hybrid-search">7.3 Hybrid-Search<a class="headerlink" href="#content_pipeline-73-hybrid-search" title="Permanent link">&para;</a></h3>
<p>Kombination von Vektor- und Attributsuche:</p>
<pre><code class="language-cpp">std::vector&lt;std::pair&lt;std::string, float&gt;&gt; ContentManager::hybridSearch(
    const std::string&amp; query_text,
    const json&amp; filters,
    int k
) {
    // 1. Vektor-Suche
    auto embedding = generateQueryEmbedding(query_text);
    auto vector_results = vector_index_-&gt;search(embedding, k * 2); // Oversampling

    // 2. Filter auf Metadaten (SecondaryIndex)
    std::vector&lt;std::pair&lt;std::string, float&gt;&gt; filtered_results;
    for (const auto&amp; [chunk_id, score] : vector_results) {
        auto chunk = getChunk(chunk_id);
        if (!chunk.has_value()) continue;

        // Filter anwenden
        bool matches = true;
        if (filters.contains(&quot;category&quot;)) {
            auto content = getContentMeta(chunk-&gt;content_id);
            if (content-&gt;category != filters[&quot;category&quot;].get&lt;ContentCategory&gt;()) {
                matches = false;
            }
        }
        if (filters.contains(&quot;tags&quot;)) {
            auto content = getContentMeta(chunk-&gt;content_id);
            auto required_tags = filters[&quot;tags&quot;].get&lt;std::vector&lt;std::string&gt;&gt;();
            for (const auto&amp; tag : required_tags) {
                if (std::find(content-&gt;tags.begin(), content-&gt;tags.end(), tag) == content-&gt;tags.end()) {
                    matches = false;
                    break;
                }
            }
        }

        if (matches) {
            filtered_results.push_back({chunk_id, score});
        }
    }

    // 3. Top-K zurückgeben
    filtered_results.resize(std::min(k, static_cast&lt;int&gt;(filtered_results.size())));
    return filtered_results;
}
</code></pre>
<h2 id="content_pipeline-8-http-api">8. HTTP API<a class="headerlink" href="#content_pipeline-8-http-api" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-81-endpoints">8.1 Endpoints<a class="headerlink" href="#content_pipeline-81-endpoints" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Endpoint</th>
<th>Methode</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/content/import</code></td>
<td>POST</td>
<td>Import vorverarbeiteter Inhalte (Schema oben)</td>
</tr>
<tr>
<td><code>/content/:id</code></td>
<td>GET</td>
<td>Content-Metadaten abrufen</td>
</tr>
<tr>
<td><code>/content/:id/blob</code></td>
<td>GET</td>
<td>Original-Blob herunterladen</td>
</tr>
<tr>
<td><code>/content/:id/chunks</code></td>
<td>GET</td>
<td>Alle Chunks eines Contents (sortiert)</td>
</tr>
<tr>
<td><code>/content/search</code></td>
<td>POST</td>
<td>Semantische Suche (Query-Text + Filters)</td>
</tr>
<tr>
<td><code>/content/:id</code></td>
<td>DELETE</td>
<td>Content + Chunks + Edges löschen</td>
</tr>
</tbody>
</table>
<h3 id="content_pipeline-82-beispiele">8.2 Beispiele<a class="headerlink" href="#content_pipeline-82-beispiele" title="Permanent link">&para;</a></h3>
<p><strong>Import:</strong></p>
<pre><code class="language-http">POST /content/import
Content-Type: application/json

{
  &quot;content&quot;: {
    &quot;id&quot;: &quot;doc-123&quot;,
    &quot;mime_type&quot;: &quot;text/plain&quot;,
    &quot;category&quot;: &quot;TEXT&quot;,
    &quot;original_filename&quot;: &quot;readme.txt&quot;,
    &quot;size_bytes&quot;: 512,
    &quot;hash_sha256&quot;: &quot;abc...&quot;,
    &quot;created_at&quot;: 1672531200,
    &quot;tags&quot;: [&quot;docs&quot;]
  },
  &quot;chunks&quot;: [
    {
      &quot;id&quot;: &quot;chunk-1&quot;,
      &quot;content_id&quot;: &quot;doc-123&quot;,
      &quot;seq_num&quot;: 0,
      &quot;chunk_type&quot;: &quot;text&quot;,
      &quot;text&quot;: &quot;Introduction...&quot;,
      &quot;embedding&quot;: [0.1, 0.2, ...]
    }
  ],
  &quot;edges&quot;: [
    {
      &quot;from&quot;: &quot;chunk-1&quot;,
      &quot;to&quot;: &quot;doc-123&quot;,
      &quot;type&quot;: &quot;parent&quot;
    }
  ]
}

Response:
{
  &quot;ok&quot;: true,
  &quot;content_id&quot;: &quot;doc-123&quot;,
  &quot;chunks_created&quot;: 1,
  &quot;edges_created&quot;: 1
}
</code></pre>
<p><strong>Suche:</strong></p>
<pre><code class="language-http">POST /content/search
Content-Type: application/json

{
  &quot;query&quot;: &quot;machine learning tutorial&quot;,
  &quot;k&quot;: 10,
  &quot;filters&quot;: {
    &quot;category&quot;: &quot;TEXT&quot;,
    &quot;tags&quot;: [&quot;ai&quot;]
  },
  &quot;expansion_hops&quot;: 1
}

Response:
{
  &quot;results&quot;: [
    {
      &quot;chunk_id&quot;: &quot;chunk-42&quot;,
      &quot;content_id&quot;: &quot;doc-ml-intro&quot;,
      &quot;score&quot;: 0.87,
      &quot;text&quot;: &quot;Introduction to machine learning...&quot;,
      &quot;metadata&quot;: {&quot;filename&quot;: &quot;ml_intro.md&quot;}
    },
    ...
  ]
}
</code></pre>
<h2 id="content_pipeline-9-best-practices">9. Best Practices<a class="headerlink" href="#content_pipeline-9-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-91-chunking-richtlinien">9.1 Chunking-Richtlinien<a class="headerlink" href="#content_pipeline-91-chunking-richtlinien" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Text:</strong> 200–400 Tokens (besserer Retrieval/Ranking-Tradeoff), 50 Tokens Overlap</li>
<li><strong>Audio/Video:</strong> 2–10 Sekunden pro Segment (annehmbare Granularität)</li>
<li><strong>Tabellen:</strong> 100–500 Rows pro Batch (Balance zwischen Kontext und Performance)</li>
<li><strong>Geodaten:</strong> Ein Chunk pro Feature (GeoJSON), Spatial Aggregation bei Millionen Features</li>
</ul>
<h3 id="content_pipeline-92-embedding-optimierung">9.2 Embedding-Optimierung<a class="headerlink" href="#content_pipeline-92-embedding-optimierung" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Batch-Processing:</strong> 100–500 Embeddings pro Request (10x schneller als einzeln)</li>
<li><strong>GPU-Beschleunigung:</strong> Sentence-Transformers mit CUDA (5–10x Speedup)</li>
<li><strong>Embedding-Cache:</strong> Hash → Embedding speichern (Dedup vermeidet Re-Computation)</li>
</ul>
<h3 id="content_pipeline-93-storage-optimierung">9.3 Storage-Optimierung<a class="headerlink" href="#content_pipeline-93-storage-optimierung" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Inline vs. External Blobs:</strong></li>
<li>&lt; 1 MB: RocksDB (schneller Zugriff)</li>
<li>&gt; 1 MB: Filesystem oder S3 (Blob-Ref in RocksDB)</li>
<li><strong>Kompression:</strong> Zstd für große Blobs (3:1 Ratio bei Text, 1.5:1 bei Binär)</li>
<li><strong>TTL:</strong> Alte Inhalte automatisch löschen (siehe <code>docs/base_entity.md</code>)</li>
</ul>
<h3 id="content_pipeline-94-modalitats-spezifische-guidelines">9.4 Modalitäts-spezifische Guidelines<a class="headerlink" href="#content_pipeline-94-modalitats-spezifische-guidelines" title="Permanent link">&para;</a></h3>
<p><strong>Bilder:</strong></p>
<ul>
<li>EXIF-Daten extrahieren (GPS, DateTime, Camera Model)</li>
<li>OCR nur bei Bedarf (teuer!)</li>
<li>Object Detection optional (YOLO, Detectron2)</li>
<li>Captioning mit BLIP/GIT für Textsuche</li>
</ul>
<p><strong>Geodaten:</strong></p>
<ul>
<li>Normalisierung auf WGS84 (EPSG:4326) vor Import</li>
<li>Bounding Box pre-compute für schnelle Spatial Queries</li>
<li>Spatial Joins für <code>member_of</code> Edges (Punkt-in-Polygon-Tests)</li>
</ul>
<p><strong>CAD:</strong></p>
<ul>
<li>BOM-Extraktion via Open CASCADE oder STEP-Parser</li>
<li>Geometrie-Hashing für Duplikaterkennung (Topology-Hash)</li>
<li>Assembly-Hierarchie als <code>contains</code> Edges abbilden</li>
</ul>
<p><strong>Tabellen:</strong></p>
<ul>
<li>Schema-Inferenz (Datentypen, Primärschlüssel)</li>
<li>Foreign-Key-Erkennung → <code>references</code> Edges</li>
<li>Spalten-Normalisierung (z.B. Dates → ISO8601)</li>
</ul>
<h2 id="content_pipeline-10-performance-benchmarks">10. Performance &amp; Benchmarks<a class="headerlink" href="#content_pipeline-10-performance-benchmarks" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-101-ingestion-throughput">10.1 Ingestion-Throughput<a class="headerlink" href="#content_pipeline-101-ingestion-throughput" title="Permanent link">&para;</a></h3>
<p><strong>Baseline (Sequentiell):</strong></p>
<ul>
<li>Text (1 MB): ~2 s (Tokenization + Embedding)</li>
<li>Image (5 MB): ~5 s (EXIF + CLIP-Embedding)</li>
<li>Geodaten (10k Features): ~10 s (Parsing + Spatial Embeddings)</li>
</ul>
<p><strong>Mit Batching:</strong></p>
<ul>
<li>Text Batch (100 Docs): ~10 s (10x Speedup via Batch-Embedding)</li>
<li>Image Batch (50 Images): ~15 s (3x Speedup via GPU-Batch)</li>
</ul>
<h3 id="content_pipeline-102-search-latenz">10.2 Search-Latenz<a class="headerlink" href="#content_pipeline-102-search-latenz" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Vektor-Suche (HNSW):</strong> 10–50 ms (1M Vektoren, k=10)</li>
<li><strong>Hybrid-Search (Vektor + Filter):</strong> 50–100 ms (Filter auf 100k Entities)</li>
<li><strong>Graph-Expansion (1 Hop):</strong> +20 ms (BFS auf 100k Edges)</li>
</ul>
<h3 id="content_pipeline-103-storage-groe">10.3 Storage-Größe<a class="headerlink" href="#content_pipeline-103-storage-groe" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>RocksDB Overhead:</strong> ~30% (Metadata, Indexes)</li>
<li><strong>VectorIndex (HNSW):</strong> ~1.5x der Embedding-Größe (Links + Metadata)</li>
<li><strong>GraphIndex:</strong> ~40 Bytes pro Edge (From + To + Type + Weight)</li>
</ul>
<p><strong>Beispiel:</strong> 1 Million Text-Chunks (768D Embeddings)</p>
<ul>
<li>RocksDB (Metadata): ~500 MB</li>
<li>VectorIndex (Embeddings): 1M * 768 * 4 Bytes * 1.5 = ~4.5 GB</li>
<li>GraphIndex (2 Edges/Chunk): 2M * 40 Bytes = ~80 MB</li>
<li><strong>Total:</strong> ~5 GB</li>
</ul>
<h2 id="content_pipeline-11-testing">11. Testing<a class="headerlink" href="#content_pipeline-11-testing" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-111-unit-tests-pro-processor">11.1 Unit-Tests (pro Processor)<a class="headerlink" href="#content_pipeline-111-unit-tests-pro-processor" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST(TextProcessorTest, ExtractsTextFromPlainText) {
    TextProcessor processor;
    std::string blob = &quot;Hello, world!&quot;;
    ContentType type = {.mime_type=&quot;text/plain&quot;, .category=ContentCategory::TEXT};

    auto result = processor.extract(blob, type);

    ASSERT_TRUE(result.ok);
    EXPECT_EQ(result.text, &quot;Hello, world!&quot;);
}

TEST(ImageProcessorTest, ExtractsEXIF) {
    ImageProcessor processor;
    std::string blob = loadTestImage(&quot;test_photo.jpg&quot;);
    ContentType type = {.mime_type=&quot;image/jpeg&quot;, .category=ContentCategory::IMAGE};

    auto result = processor.extract(blob, type);

    ASSERT_TRUE(result.ok);
    EXPECT_TRUE(result.metadata.contains(&quot;exif&quot;));
    EXPECT_EQ(result.metadata[&quot;exif&quot;][&quot;Make&quot;], &quot;Canon&quot;);
}
</code></pre>
<h3 id="content_pipeline-112-integration-tests">11.2 Integration-Tests<a class="headerlink" href="#content_pipeline-112-integration-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST(ContentManagerTest, ImportTextDocumentEndToEnd) {
    auto storage = std::make_shared&lt;RocksDBWrapper&gt;(&quot;./test_db&quot;);
    auto vector_index = std::make_shared&lt;VectorIndexManager&gt;(storage, 768);
    auto graph_index = std::make_shared&lt;GraphIndexManager&gt;(storage);
    auto secondary_index = std::make_shared&lt;SecondaryIndexManager&gt;(storage);

    ContentManager manager(storage, vector_index, graph_index, secondary_index);

    json spec = {
        {&quot;content&quot;, {
            {&quot;id&quot;, &quot;test-doc&quot;},
            {&quot;mime_type&quot;, &quot;text/plain&quot;},
            {&quot;category&quot;, &quot;TEXT&quot;},
            {&quot;original_filename&quot;, &quot;test.txt&quot;},
            {&quot;size_bytes&quot;, 100},
            {&quot;hash_sha256&quot;, &quot;hash123&quot;},
            {&quot;created_at&quot;, 1672531200}
        }},
        {&quot;chunks&quot;, json::array({
            {{&quot;id&quot;, &quot;chunk-1&quot;}, {&quot;content_id&quot;, &quot;test-doc&quot;}, {&quot;seq_num&quot;, 0}, {&quot;chunk_type&quot;, &quot;text&quot;}, {&quot;text&quot;, &quot;Hello&quot;}, {&quot;embedding&quot;, std::vector&lt;float&gt;(768, 0.1)}}
        })},
        {&quot;edges&quot;, json::array({
            {{&quot;from&quot;, &quot;chunk-1&quot;}, {&quot;to&quot;, &quot;test-doc&quot;}, {&quot;type&quot;, &quot;parent&quot;}}
        })}
    };

    auto status = manager.importContent(spec, std::nullopt);

    ASSERT_TRUE(status.ok);

    // Verify metadata stored
    auto meta = manager.getContentMeta(&quot;test-doc&quot;);
    ASSERT_TRUE(meta.has_value());
    EXPECT_EQ(meta-&gt;mime_type, &quot;text/plain&quot;);

    // Verify chunks stored
    auto chunks = manager.getContentChunks(&quot;test-doc&quot;);
    EXPECT_EQ(chunks.size(), 1);

    // Verify graph edges
    auto neighbors = graph_index-&gt;getOutNeighbors(&quot;chunk-1&quot;);
    EXPECT_EQ(neighbors.size(), 1); // Has 'parent' edge
}
</code></pre>
<h3 id="content_pipeline-113-performance-benchmarks">11.3 Performance-Benchmarks<a class="headerlink" href="#content_pipeline-113-performance-benchmarks" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">static void BM_ImportLargeDocument(benchmark::State&amp; state) {
    ContentManager manager(/* ... */);

    std::string large_text(10 * 1024 * 1024, 'A'); // 10 MB
    json spec = createTestSpec(large_text, 512, 50); // 512 Tokens/Chunk, 50 Overlap

    for (auto _ : state) {
        manager.importContent(spec, std::nullopt);
    }
}
BENCHMARK(BM_ImportLargeDocument);

static void BM_HybridSearch(benchmark::State&amp; state) {
    ContentManager manager(/* ... */);
    // ... populate with 100k documents

    for (auto _ : state) {
        manager.hybridSearch(&quot;machine learning&quot;, {{&quot;category&quot;, &quot;TEXT&quot;}}, 10);
    }
}
BENCHMARK(BM_HybridSearch);
</code></pre>
<h2 id="content_pipeline-12-roadmap">12. Roadmap<a class="headerlink" href="#content_pipeline-12-roadmap" title="Permanent link">&para;</a></h2>
<h3 id="content_pipeline-mvp-10-aktuell">MVP 1.0 (Aktuell)<a class="headerlink" href="#content_pipeline-mvp-10-aktuell" title="Permanent link">&para;</a></h3>
<ul>
<li>[x] ContentTypeRegistry + ContentCategory</li>
<li>[x] TextProcessor (Extraction, Chunking, Embedding via Mock)</li>
<li>[x] ContentManager::importContent() (kanonisches Schema)</li>
<li>[x] HTTP Endpoint: POST /content/import</li>
<li>[x] BasicTests (Unit + Integration)</li>
</ul>
<h3 id="content_pipeline-mvp-20-geplant">MVP 2.0 (Geplant)<a class="headerlink" href="#content_pipeline-mvp-20-geplant" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] ImageProcessor (EXIF + CLIP-Embedding via external service)</li>
<li>[ ] GeoProcessor (GeoJSON + Geo2Vec)</li>
<li>[ ] CADProcessor (STEP + PartNet-Embedding)</li>
<li>[ ] Batch-Import (POST /content/import/batch)</li>
<li>[ ] Hybrid-Search (Vektor + Filter)</li>
<li>[ ] Graph-Expansion (BFS mit <code>next</code>, <code>prev</code>, <code>contains</code>)</li>
</ul>
<h3 id="content_pipeline-future-post-mvp">Future (Post-MVP)<a class="headerlink" href="#content_pipeline-future-post-mvp" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] AudioProcessor (ID3 + Wav2Vec2 + Whisper ASR)</li>
<li>[ ] StructuredProcessor (CSV/Parquet + TaBERT)</li>
<li>[ ] Async-Ingestion (Job-Queue mit Status-Tracking)</li>
<li>[ ] External Blob-Storage (S3-Anbindung)</li>
<li>[ ] Multi-Hop Graph-Reasoning (z.B. "Show CAD parts from same supplier")</li>
<li>[ ] Federated Search (Multi-Tenant mit Access Control)</li>
</ul>
<h2 id="content_pipeline-13-fazit">13. Fazit<a class="headerlink" href="#content_pipeline-13-fazit" title="Permanent link">&para;</a></h2>
<p>Die <strong>Content Pipeline</strong> bietet eine <strong>skalierbare, erweiterbare Architektur</strong> für heterogene Datentypen. Durch die Trennung von generischen Operationen (Hashing, Graph-Erstellung) und typ-spezifischer Verarbeitung (via Processors) bleibt das System wartbar und einfach erweiterbar.</p>
<p><strong>Key Benefits:</strong></p>
<ul>
<li><strong>Einheitliche API:</strong> Ein Import-Endpoint für alle Datentypen</li>
<li><strong>Wiederverwendbare Komponenten:</strong> Chunking, Graph-Erstellung, Deduplication</li>
<li><strong>Typ-Sicherheit:</strong> ContentTypeRegistry verhindert falsche Verarbeitung</li>
<li><strong>Produktivität:</strong> Neue Datentypen in &lt; 1 Tag integrierbar (nur Processor implementieren)</li>
<li><strong>RAG-Ready:</strong> Graph-Expansion für kontextuelle Suche out-of-the-box</li>
<li><strong>Performance:</strong> Batching, GPU-Embeddings, HNSW-Index für Millionen Vektoren</li>
</ul>
<p><strong>Weiterführende Dokumentation:</strong></p>
<ul>
<li><a href="#content_architecture">Content Architecture</a> - Design-Details der Prozessor-Architektur</li>
<li><a href="#content-ingestion">Ingestion Guidelines</a> - Modalitäts-spezifische Vorverarbeitungs-Empfehlungen</li>
<li><a href="#indexes-vector-index">Vector Index</a> - HNSW-Algorithmus und Tuning-Parameter</li>
<li><a href="#indexes-graph-index">Graph Index</a> - BFS/DFS-Traversierung und Edge-Typen</li>
<li><a href="#aql_syntax">AQL Syntax</a> - Hybrid-Queries mit <code>VECTOR_KNN()</code> und <code>GRAPH_EXPAND()</code></li>
</ul></section><section class="print-page" id="content_architecture" heading-number="7.2"><h1 id="content_architecture-content-manager-architektur">Content Manager Architektur<a class="headerlink" href="#content_architecture-content-manager-architektur" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 1.0<br />
<strong>Datum:</strong> 28. Oktober 2025<br />
<strong>Status:</strong> Design Phase</p>
<h2 id="content_architecture-1-uberblick">1. Überblick<a class="headerlink" href="#content_architecture-1-uberblick" title="Permanent link">&para;</a></h2>
<p>Das Content Manager System ist eine <strong>universelle Schicht</strong> für die Verwaltung heterogener Datentypen in THEMIS. Es abstrahiert die Komplexität der Verarbeitung verschiedener Content-Typen (Text, Bilder, Audio, Geo-Daten, CAD-Modelle, etc.) hinter einer einheitlichen API.</p>
<h3 id="content_architecture-11-ziele">1.1 Ziele<a class="headerlink" href="#content_architecture-11-ziele" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Erweiterbarkeit:</strong> Neue Datentypen können über Plugins hinzugefügt werden</li>
<li><strong>Wiederverwendbarkeit:</strong> Gemeinsame Operationen (Hashing, Chunking, Graph-Erstellung) nur einmal implementiert</li>
<li><strong>Typsicherheit:</strong> Klare Trennung zwischen generischen und typspezifischen Operationen</li>
<li><strong>Produktivität:</strong> Entwickler müssen nicht für jeden Datentyp eine vollständige Pipeline implementieren</li>
</ul>
<h3 id="content_architecture-12-architektur-prinzipien">1.2 Architektur-Prinzipien<a class="headerlink" href="#content_architecture-12-architektur-prinzipien" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                    HTTP API Layer                               │
│  POST /content/upload, GET /content/:id, POST /content/search   │
└────────────────────────────┬────────────────────────────────────┘
                             │
┌────────────────────────────▼────────────────────────────────────┐
│                    ContentManager                               │
│  • Unified ingestion pipeline                                   │
│  • Processor routing by category                                │
│  • Graph construction (parent, next/prev, hierarchical)         │
│  • Deduplication (SHA-256 hash)                                 │
└──────┬────────────┬────────────┬────────────┬────────────┬──────┘
       │            │            │            │            │
┌──────▼────┐  ┌───▼──────┐ ┌──▼──────┐ ┌───▼──────┐ ┌──▼──────┐
│   Text    │  │  Image   │ │   Geo   │ │   CAD    │ │  Audio  │
│ Processor │  │Processor │ │Processor│ │Processor │ │Processor│
└──────┬────┘  └───┬──────┘ └──┬──────┘ └───┬──────┘ └──┬──────┘
       │            │            │            │            │
       │  • extract()  • chunk()  • generateEmbedding()   │
       │                                                   │
┌──────▼───────────────────────────────────────────────────▼──────┐
│                    Storage Layer                                │
│  • RocksDB (metadata + blobs)                                   │
│  • VectorIndex (embeddings)                                     │
│  • GraphIndex (parent, next/prev, assembly hierarchy)           │
│  • SecondaryIndex (tags, mime_type, hash for dedup)             │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="content_architecture-2-core-components">2. Core Components<a class="headerlink" href="#content_architecture-2-core-components" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-21-contenttyperegistry">2.1 ContentTypeRegistry<a class="headerlink" href="#content_architecture-21-contenttyperegistry" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeit:</strong> MIME-Type → Category Mapping</p>
<p><strong>Funktionen:</strong>
- MIME-Type-Erkennung (manuelle Angabe, Magic Bytes, Dateiendung)
- Kategorisierung (TEXT, IMAGE, AUDIO, VIDEO, GEO, CAD, STRUCTURED, BINARY)
- Feature Flags (supports_text_extraction, supports_embedding, geospatial, hierarchical)</p>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-cpp">ContentType pdf_type;
pdf_type.mime_type = &quot;application/pdf&quot;;
pdf_type.category = ContentCategory::TEXT;
pdf_type.extensions = {&quot;.pdf&quot;};
pdf_type.supports_text_extraction = true;
pdf_type.supports_chunking = true;
pdf_type.binary_storage_required = true;

ContentTypeRegistry::instance().registerType(pdf_type);
</code></pre>
<p><strong>Default Types (Pre-Registered):</strong></p>
<table>
<thead>
<tr>
<th>Category</th>
<th>MIME Types</th>
<th>Features</th>
</tr>
</thead>
<tbody>
<tr>
<td>TEXT</td>
<td><code>text/plain</code>, <code>text/markdown</code>, <code>text/html</code>, <code>application/json</code>, <code>text/x-python</code></td>
<td>text_extraction, chunking, embedding</td>
</tr>
<tr>
<td>IMAGE</td>
<td><code>image/jpeg</code>, <code>image/png</code>, <code>image/svg+xml</code>, <code>image/tiff</code></td>
<td>metadata_extraction (EXIF), embedding (CLIP)</td>
</tr>
<tr>
<td>AUDIO</td>
<td><code>audio/mpeg</code>, <code>audio/wav</code>, <code>audio/flac</code></td>
<td>metadata_extraction (ID3), temporal</td>
</tr>
<tr>
<td>VIDEO</td>
<td><code>video/mp4</code>, <code>video/webm</code></td>
<td>metadata_extraction, temporal, multimodal</td>
</tr>
<tr>
<td>GEO</td>
<td><code>application/geo+json</code>, <code>application/gpx+xml</code>, <code>image/tiff</code> (GeoTIFF)</td>
<td>geospatial, metadata_extraction</td>
</tr>
<tr>
<td>CAD</td>
<td><code>model/step</code>, <code>model/iges</code>, <code>model/stl</code>, <code>application/dxf</code></td>
<td>hierarchical, metadata_extraction</td>
</tr>
<tr>
<td>STRUCTURED</td>
<td><code>text/csv</code>, <code>application/vnd.apache.parquet</code>, <code>application/vnd.apache.arrow</code></td>
<td>text_extraction, chunking (row-level)</td>
</tr>
<tr>
<td>ARCHIVE</td>
<td><code>application/zip</code>, <code>application/x-tar</code></td>
<td>hierarchical (extract members recursively)</td>
</tr>
<tr>
<td>BINARY</td>
<td>Fallback für unbekannte Typen</td>
<td>binary_storage_required</td>
</tr>
</tbody>
</table>
<h3 id="content_architecture-22-icontentprocessor-plugin-interface">2.2 IContentProcessor (Plugin Interface)<a class="headerlink" href="#content_architecture-22-icontentprocessor-plugin-interface" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeit:</strong> Typ-spezifische Verarbeitung</p>
<p><strong>Kernmethoden:</strong></p>
<pre><code class="language-cpp">class IContentProcessor {
public:
    // Extrahiere strukturierte Daten aus Blob
    virtual ExtractionResult extract(
        const std::string&amp; blob,
        const ContentType&amp; content_type
    ) = 0;

    // Chunking (z.B. Text → Paragraphen, CAD → Parts, CSV → Rows)
    virtual std::vector&lt;json&gt; chunk(
        const ExtractionResult&amp; extraction_result,
        int chunk_size,
        int overlap
    ) = 0;

    // Embedding-Generierung (z.B. Text → Sentence-BERT, Image → CLIP)
    virtual std::vector&lt;float&gt; generateEmbedding(
        const std::string&amp; chunk_data
    ) = 0;

    virtual std::vector&lt;ContentCategory&gt; getSupportedCategories() const = 0;
};
</code></pre>
<p><strong>Implementierte Processors:</strong></p>
<h4 id="content_architecture-textprocessor">TextProcessor<a class="headerlink" href="#content_architecture-textprocessor" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Extraction:</strong> UTF-8 Normalisierung, Markdown → Plain Text, Code Syntax-Highlighting</li>
<li><strong>Chunking:</strong> Fixed-size (512 Tokens) mit Overlap (50 Tokens), Sentence-Boundary-Preserving</li>
<li><strong>Embedding:</strong> Sentence-Transformers (z.B. <code>all-mpnet-base-v2</code>, 768D)</li>
</ul>
<h4 id="content_architecture-imageprocessor">ImageProcessor<a class="headerlink" href="#content_architecture-imageprocessor" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Extraction:</strong> EXIF Metadata (Camera, GPS, Timestamp), Dimensions, Color Profile</li>
<li><strong>Chunking:</strong> Keine (Bild als ganzes) oder Region-Proposals (für Object Detection)</li>
<li><strong>Embedding:</strong> CLIP (<code>openai/clip-vit-base-patch32</code>, 512D)</li>
</ul>
<h4 id="content_architecture-geoprocessor">GeoProcessor<a class="headerlink" href="#content_architecture-geoprocessor" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Extraction:</strong> GeoJSON → Coordinates, Properties; GPX → Tracks/Waypoints; GeoTIFF → Raster + Projection</li>
<li><strong>Chunking:</strong> Feature-Level (jedes GeoJSON Feature = 1 Chunk)</li>
<li><strong>Embedding:</strong> Geo2Vec (Lat/Lon → Embedding) oder Text-Embedding der Properties</li>
</ul>
<h4 id="content_architecture-cadprocessor">CADProcessor<a class="headerlink" href="#content_architecture-cadprocessor" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Extraction:</strong> STEP → Assembly Hierarchy, Parts, BOM; STL → Mesh Geometry</li>
<li><strong>Chunking:</strong> Part-Level (jedes Part = 1 Chunk)</li>
<li><strong>Embedding:</strong> PartNet (3D Shape → Embedding) oder Property-Text-Embedding</li>
</ul>
<h4 id="content_architecture-audioprocessor">AudioProcessor<a class="headerlink" href="#content_architecture-audioprocessor" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Extraction:</strong> ID3 Tags (Title, Artist, Album), Duration, Bitrate, Codec</li>
<li><strong>Chunking:</strong> Time-based (z.B. 30s Segmente) oder Speech-Transcript-based</li>
<li><strong>Embedding:</strong> Wav2Vec2 (Audio → Embedding) oder Text-Embedding des Transcripts</li>
</ul>
<h4 id="content_architecture-structuredprocessor">StructuredProcessor<a class="headerlink" href="#content_architecture-structuredprocessor" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Extraction:</strong> CSV → Schema + Rows, Parquet → Arrow Table</li>
<li><strong>Chunking:</strong> Row-Level (jede Zeile = 1 Chunk) oder Batch (z.B. 100 Zeilen)</li>
<li><strong>Embedding:</strong> Column-Embeddings (für Schema) + Row-Embeddings (für Data)</li>
</ul>
<h4 id="content_architecture-binaryprocessor-fallback">BinaryProcessor (Fallback)<a class="headerlink" href="#content_architecture-binaryprocessor-fallback" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Extraction:</strong> Nur Metadata (Size, Hash, Magic Bytes)</li>
<li><strong>Chunking:</strong> Keine (gesamter Blob)</li>
<li><strong>Embedding:</strong> Keine (Binary-Daten nicht semantisch suchbar)</li>
</ul>
<h3 id="content_architecture-23-contentmanager-orchestrator">2.3 ContentManager (Orchestrator)<a class="headerlink" href="#content_architecture-23-contentmanager-orchestrator" title="Permanent link">&para;</a></h3>
<p><strong>Verantwortlichkeit:</strong> Unified Ingestion Pipeline</p>
<p><strong>Ingestion Flow:</strong></p>
<pre><code class="language-cpp">IngestionResult ContentManager::ingestContent(
    const std::string&amp; blob,
    const std::optional&lt;std::string&gt;&amp; mime_type,
    const std::string&amp; filename,
    const json&amp; user_metadata,
    const IngestionConfig&amp; config
) {
    // 1. Content-Type Detection
    const ContentType* type = detectContentType(blob, mime_type, filename);

    // 2. Deduplication Check (SHA-256 Hash)
    std::string hash = computeSHA256(blob);
    if (auto existing = checkDuplicateByHash(hash)) {
        return {.ok=true, .content_id=*existing, .message=&quot;Duplicate&quot;};
    }

    // 3. Processor Routing
    auto* processor = getProcessor(type-&gt;category);
    if (!processor) {
        // Fallback to BinaryProcessor
        processor = getProcessor(ContentCategory::BINARY);
    }

    // 4. Extraction
    auto extraction = processor-&gt;extract(blob, *type);
    if (!extraction.ok) {
        return {.ok=false, .message=extraction.error_message};
    }

    // 5. Store Blob (Optional)
    std::string content_id = generateUuid();
    if (config.store_blob) {
        BaseEntity content_entity(&quot;content:&quot; + content_id);
        content_entity.setBlob(blob);
        storage_-&gt;put(&quot;content:&quot; + content_id, content_entity.serialize());
    }

    // 6. Chunking
    std::vector&lt;json&gt; chunks;
    if (config.generate_chunks &amp;&amp; type-&gt;supports_chunking) {
        chunks = processor-&gt;chunk(extraction, config.chunk_size, config.chunk_overlap);
    }

    // 7. Embedding Generation + VectorIndex Insertion
    std::vector&lt;std::string&gt; chunk_ids;
    if (config.generate_embeddings) {
        for (int i = 0; i &lt; chunks.size(); i++) {
            std::string chunk_id = generateUuid();
            chunk_ids.push_back(chunk_id);

            auto embedding = processor-&gt;generateEmbedding(chunks[i][&quot;text&quot;]);

            // Insert into VectorIndex
            BaseEntity chunk_entity(&quot;chunk:&quot; + chunk_id);
            chunk_entity.set(&quot;content_id&quot;, content_id);
            chunk_entity.set(&quot;seq_num&quot;, i);
            chunk_entity.set(&quot;text&quot;, chunks[i][&quot;text&quot;]);
            chunk_entity.set(&quot;embedding&quot;, embedding);

            storage_-&gt;put(&quot;chunk:&quot; + chunk_id, chunk_entity.serialize());
            vector_index_-&gt;addEntity(chunk_entity, embedding);
        }
    }

    // 8. Graph Construction
    if (config.build_graph) {
        createChunkGraph(chunk_ids, content_id, &quot;text_chunk&quot;);
    }

    // 9. Store Metadata
    ContentMeta meta;
    meta.id = content_id;
    meta.mime_type = type-&gt;mime_type;
    meta.category = type-&gt;category;
    meta.original_filename = filename;
    meta.size_bytes = blob.size();
    meta.hash_sha256 = hash;
    meta.chunk_count = chunks.size();
    meta.extracted_metadata = extraction.metadata;
    meta.user_metadata = user_metadata;

    storage_-&gt;put(&quot;meta:&quot; + content_id, meta.toJson().dump());

    return {.ok=true, .content_id=content_id, .chunks_created=(int)chunks.size()};
}
</code></pre>
<h2 id="content_architecture-3-graph-strukturen">3. Graph-Strukturen<a class="headerlink" href="#content_architecture-3-graph-strukturen" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-31-chunk-graph-fur-rag">3.1 Chunk-Graph (für RAG)<a class="headerlink" href="#content_architecture-31-chunk-graph-fur-rag" title="Permanent link">&para;</a></h3>
<p><strong>Vertex-Typen:</strong>
- <code>content:&lt;uuid&gt;</code>: Content-Item (Document, Image, etc.)
- <code>chunk:&lt;uuid&gt;</code>: Chunk</p>
<p><strong>Edge-Typen:</strong>
- <code>parent</code>: <code>chunk -&gt; content</code> (N:1, jeder Chunk gehört zu genau einem Content-Item)
- <code>next</code>: <code>chunk -&gt; chunk</code> (sequentielle Reihenfolge, z.B. Paragraph 1 → Paragraph 2)
- <code>prev</code>: <code>chunk -&gt; chunk</code> (Rückwärts-Navigation)</p>
<p><strong>Beispiel: Text-Dokument mit 3 Chunks</strong></p>
<pre><code>content:doc123 (Document)
   ├─ chunk:c1 (Paragraph 1) ──next──&gt; chunk:c2 (Paragraph 2) ──next──&gt; chunk:c3 (Paragraph 3)
   │                             ↑                             ↑                             ↑
   └──────────parent──────────────┴──────────parent─────────────┴──────────parent────────────┘
</code></pre>
<p><strong>Query: Vector-Search + Graph-Expansion</strong></p>
<pre><code class="language-aql">-- 1. Vector-Suche: Top-K Chunks
LET top_chunks = VECTOR_KNN('chunks', @query_vec, 10)

-- 2. Graph-Expansion: Lade Kontext (prev/next)
FOR chunk IN top_chunks
  FOR neighbor IN 1..1 ANY chunk GRAPH 'content_graph'
    FILTER neighbor._type == 'chunk'
    RETURN DISTINCT neighbor
</code></pre>
<h3 id="content_architecture-32-hierarchical-graph-fur-cadarchive">3.2 Hierarchical Graph (für CAD/Archive)<a class="headerlink" href="#content_architecture-32-hierarchical-graph-fur-cadarchive" title="Permanent link">&para;</a></h3>
<p><strong>Vertex-Typen:</strong>
- <code>content:assembly</code> (CAD Assembly)
- <code>content:part1</code>, <code>content:part2</code>, ... (CAD Parts)</p>
<p><strong>Edge-Typen:</strong>
- <code>contains</code>: <code>assembly -&gt; part</code> (1:N, Assembly enthält Parts)
- <code>sibling</code>: <code>part -&gt; part</code> (Parts auf gleicher Hierarchie-Ebene)</p>
<p><strong>Beispiel: CAD Assembly</strong></p>
<pre><code>content:assembly (Getriebe)
   ├─── contains ──&gt; content:part1 (Zahnrad A)
   ├─── contains ──&gt; content:part2 (Zahnrad B)
   └─── contains ──&gt; content:part3 (Welle)
</code></pre>
<p><strong>Query: Finde alle Parts eines Assemblies</strong></p>
<pre><code class="language-aql">FOR part IN 1..1 OUTBOUND 'content:assembly' GRAPH 'cad_graph'
  FILTER part._type == 'part'
  RETURN part
</code></pre>
<h3 id="content_architecture-33-geo-graph-fur-gis-daten">3.3 Geo-Graph (für GIS-Daten)<a class="headerlink" href="#content_architecture-33-geo-graph-fur-gis-daten" title="Permanent link">&para;</a></h3>
<p><strong>Vertex-Typen:</strong>
- <code>content:layer</code> (GeoJSON Layer)
- <code>content:feature1</code>, <code>content:feature2</code>, ... (GeoJSON Features)</p>
<p><strong>Edge-Typen:</strong>
- <code>member_of</code>: <code>feature -&gt; layer</code>
- <code>spatially_near</code>: <code>feature -&gt; feature</code> (basierend auf Geohash-Proximity)</p>
<p><strong>Beispiel: GeoJSON Layer mit Features</strong></p>
<pre><code>content:layer (Städte Deutschland)
   ├─── member_of ──&gt; content:feature1 (Berlin)
   ├─── member_of ──&gt; content:feature2 (Hamburg)
   └─── member_of ──&gt; content:feature3 (München)

content:feature1 (Berlin) ──spatially_near──&gt; content:feature4 (Potsdam)
</code></pre>
<h2 id="content_architecture-4-embedding-strategien">4. Embedding-Strategien<a class="headerlink" href="#content_architecture-4-embedding-strategien" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-41-text-embeddings-sentence-transformers">4.1 Text-Embeddings (Sentence-Transformers)<a class="headerlink" href="#content_architecture-41-text-embeddings-sentence-transformers" title="Permanent link">&para;</a></h3>
<p><strong>Modell:</strong> <code>all-mpnet-base-v2</code> (768D, hohe Qualität)<br />
<strong>Alternative:</strong> <code>all-MiniLM-L6-v2</code> (384D, schneller)</p>
<p><strong>Integration:</strong></p>
<pre><code class="language-cpp">// Externe API (z.B. Python Microservice mit Flask)
std::vector&lt;float&gt; TextProcessor::generateEmbedding(const std::string&amp; text) {
    // HTTP POST to embedding service
    json request = {{&quot;text&quot;, text}};
    auto response = http_client_-&gt;post(&quot;http://localhost:5000/embed&quot;, request);
    return response[&quot;embedding&quot;];
}
</code></pre>
<p><strong>Mock für Tests:</strong></p>
<pre><code class="language-cpp">std::vector&lt;float&gt; TextProcessor::generateEmbedding(const std::string&amp; text) {
    // Simple hash-based mock embedding
    std::vector&lt;float&gt; embedding(768, 0.0f);
    std::hash&lt;std::string&gt; hasher;
    size_t hash = hasher(text);
    for (int i = 0; i &lt; 768; i++) {
        embedding[i] = ((hash &gt;&gt; i) &amp; 1) ? 1.0f : -1.0f;
    }
    return embedding;
}
</code></pre>
<h3 id="content_architecture-42-image-embeddings-clip">4.2 Image-Embeddings (CLIP)<a class="headerlink" href="#content_architecture-42-image-embeddings-clip" title="Permanent link">&para;</a></h3>
<p><strong>Modell:</strong> <code>openai/clip-vit-base-patch32</code> (512D)</p>
<p><strong>Integration:</strong></p>
<pre><code class="language-python"># Embedding Service (Python Flask)
from transformers import CLIPProcessor, CLIPModel
import torch

model = CLIPModel.from_pretrained(&quot;openai/clip-vit-base-patch32&quot;)
processor = CLIPProcessor.from_pretrained(&quot;openai/clip-vit-base-patch32&quot;)

@app.route('/embed/image', methods=['POST'])
def embed_image():
    image_bytes = request.files['image'].read()
    image = Image.open(io.BytesIO(image_bytes))
    inputs = processor(images=image, return_tensors=&quot;pt&quot;)
    with torch.no_grad():
        embedding = model.get_image_features(**inputs)
    return jsonify({'embedding': embedding[0].tolist()})
</code></pre>
<h3 id="content_architecture-43-cad-embeddings-partnet-custom">4.3 CAD-Embeddings (PartNet / Custom)<a class="headerlink" href="#content_architecture-43-cad-embeddings-partnet-custom" title="Permanent link">&para;</a></h3>
<p><strong>Ansatz:</strong> 
- <strong>Option 1:</strong> Render CAD-Part als Bild (Multiple Views), dann CLIP-Embedding
- <strong>Option 2:</strong> Extract Properties (Volume, Surface Area, Material) → Text-Embedding
- <strong>Option 3:</strong> PartNet (3D Shape Encoder, research-basiert)</p>
<p><strong>MVP:</strong> Text-Embedding der BOM/Properties</p>
<pre><code class="language-cpp">std::vector&lt;float&gt; CADProcessor::generateEmbedding(const std::string&amp; chunk_data) {
    // chunk_data = JSON with CAD properties
    json props = json::parse(chunk_data);
    std::string text = &quot;Part: &quot; + props[&quot;name&quot;].get&lt;std::string&gt;() +
                       &quot;, Material: &quot; + props[&quot;material&quot;].get&lt;std::string&gt;() +
                       &quot;, Volume: &quot; + std::to_string(props[&quot;volume&quot;].get&lt;double&gt;());

    // Delegate to TextProcessor
    TextProcessor text_proc;
    return text_proc.generateEmbedding(text);
}
</code></pre>
<h2 id="content_architecture-5-api-design">5. API Design<a class="headerlink" href="#content_architecture-5-api-design" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-51-http-endpoints">5.1 HTTP Endpoints<a class="headerlink" href="#content_architecture-51-http-endpoints" title="Permanent link">&para;</a></h3>
<p><strong>Upload Content</strong></p>
<pre><code class="language-http">POST /content/upload
Content-Type: multipart/form-data

Form fields:
- file: binary file
- mime_type: (optional) override MIME detection
- metadata: (optional) JSON with user metadata
- tags: (optional) comma-separated tags
- config: (optional) JSON with IngestionConfig

Response:
{
  &quot;ok&quot;: true,
  &quot;content_id&quot;: &quot;uuid-1234&quot;,
  &quot;chunks_created&quot;: 15,
  &quot;message&quot;: &quot;Content ingested successfully&quot;
}
</code></pre>
<p><strong>Get Content Metadata</strong></p>
<pre><code class="language-http">GET /content/:id

Response:
{
  &quot;id&quot;: &quot;uuid-1234&quot;,
  &quot;mime_type&quot;: &quot;application/pdf&quot;,
  &quot;category&quot;: &quot;TEXT&quot;,
  &quot;original_filename&quot;: &quot;report.pdf&quot;,
  &quot;size_bytes&quot;: 1048576,
  &quot;created_at&quot;: 1730120400,
  &quot;chunk_count&quot;: 15,
  &quot;extracted_metadata&quot;: {
    &quot;pages&quot;: 10,
    &quot;author&quot;: &quot;John Doe&quot;
  },
  &quot;user_metadata&quot;: {
    &quot;project&quot;: &quot;Alpha&quot;
  },
  &quot;tags&quot;: [&quot;report&quot;, &quot;2025&quot;]
}
</code></pre>
<p><strong>Download Content Blob</strong></p>
<pre><code class="language-http">GET /content/:id/blob

Response:
Content-Type: application/pdf
Content-Disposition: attachment; filename=&quot;report.pdf&quot;
Content-Length: 1048576

&lt;binary data&gt;
</code></pre>
<p><strong>Search Content</strong></p>
<pre><code class="language-http">POST /content/search
Content-Type: application/json

{
  &quot;query&quot;: &quot;machine learning techniques&quot;,
  &quot;k&quot;: 10,
  &quot;filters&quot;: {
    &quot;category&quot;: &quot;TEXT&quot;,
    &quot;tags&quot;: [&quot;research&quot;]
  },
  &quot;expansion&quot;: {
    &quot;enabled&quot;: true,
    &quot;hops&quot;: 1
  }
}

Response:
{
  &quot;results&quot;: [
    {
      &quot;chunk_id&quot;: &quot;chunk-uuid-1&quot;,
      &quot;content_id&quot;: &quot;uuid-1234&quot;,
      &quot;score&quot;: 0.95,
      &quot;text&quot;: &quot;Machine learning techniques have revolutionized...&quot;,
      &quot;seq_num&quot;: 5,
      &quot;metadata&quot;: {
        &quot;filename&quot;: &quot;ml_paper.pdf&quot;,
        &quot;page&quot;: 3
      }
    },
    ...
  ],
  &quot;total&quot;: 10,
  &quot;query_time_ms&quot;: 45
}
</code></pre>
<p><strong>Get Content Chunks</strong></p>
<pre><code class="language-http">GET /content/:id/chunks

Response:
{
  &quot;chunks&quot;: [
    {
      &quot;id&quot;: &quot;chunk-uuid-1&quot;,
      &quot;seq_num&quot;: 0,
      &quot;text&quot;: &quot;Introduction...&quot;,
      &quot;start_offset&quot;: 0,
      &quot;end_offset&quot;: 512,
      &quot;embedding_indexed&quot;: true
    },
    ...
  ]
}
</code></pre>
<p><strong>Delete Content</strong></p>
<pre><code class="language-http">DELETE /content/:id

Response:
{
  &quot;ok&quot;: true,
  &quot;message&quot;: &quot;Content and 15 chunks deleted&quot;
}
</code></pre>
<h2 id="content_architecture-6-erweiterung-neue-datentypen-hinzufugen">6. Erweiterung: Neue Datentypen hinzufügen<a class="headerlink" href="#content_architecture-6-erweiterung-neue-datentypen-hinzufugen" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-beispiel-video-processor">Beispiel: Video-Processor<a class="headerlink" href="#content_architecture-beispiel-video-processor" title="Permanent link">&para;</a></h3>
<p><strong>1. Content-Type registrieren</strong></p>
<pre><code class="language-cpp">ContentType video_mp4;
video_mp4.mime_type = &quot;video/mp4&quot;;
video_mp4.category = ContentCategory::VIDEO;
video_mp4.extensions = {&quot;.mp4&quot;, &quot;.m4v&quot;};
video_mp4.supports_text_extraction = false; // (außer mit Speech-to-Text)
video_mp4.supports_chunking = true;         // Time-based chunks
video_mp4.supports_embedding = true;        // Video embeddings (VideoMAE, etc.)
video_mp4.features.temporal = true;
video_mp4.features.multimodal = true;       // Audio + Frames

ContentTypeRegistry::instance().registerType(video_mp4);
</code></pre>
<p><strong>2. VideoProcessor implementieren</strong></p>
<pre><code class="language-cpp">class VideoProcessor : public IContentProcessor {
public:
    ExtractionResult extract(const std::string&amp; blob, const ContentType&amp; type) override {
        ExtractionResult result;

        // Extract metadata with FFmpeg
        result.metadata = extractVideoMetadata(blob);
        result.media_data = MediaData{
            .duration_seconds = result.metadata[&quot;duration&quot;],
            .width = result.metadata[&quot;width&quot;],
            .height = result.metadata[&quot;height&quot;],
            .codec = result.metadata[&quot;codec&quot;]
        };

        result.ok = true;
        return result;
    }

    std::vector&lt;json&gt; chunk(const ExtractionResult&amp; extraction, int chunk_size, int overlap) override {
        // Chunk by time (e.g., 10-second segments)
        int duration = extraction.media_data-&gt;duration_seconds;
        std::vector&lt;json&gt; chunks;

        for (int i = 0; i &lt; duration; i += chunk_size) {
            json chunk = {
                {&quot;type&quot;, &quot;video_segment&quot;},
                {&quot;start_time&quot;, i},
                {&quot;end_time&quot;, std::min(i + chunk_size, duration)},
                {&quot;frame_ref&quot;, &quot;video_frames_&quot; + std::to_string(i)}
            };
            chunks.push_back(chunk);
        }

        return chunks;
    }

    std::vector&lt;float&gt; generateEmbedding(const std::string&amp; chunk_data) override {
        // Extract representative frame, encode with CLIP or VideoMAE
        json chunk = json::parse(chunk_data);
        int start_time = chunk[&quot;start_time&quot;];

        // External call to video embedding service
        return callVideoEmbeddingService(start_time);
    }

    std::vector&lt;ContentCategory&gt; getSupportedCategories() const override {
        return {ContentCategory::VIDEO};
    }
};
</code></pre>
<p><strong>3. Processor registrieren</strong></p>
<pre><code class="language-cpp">content_manager-&gt;registerProcessor(std::make_unique&lt;VideoProcessor&gt;());
</code></pre>
<p><strong>4. Verwenden</strong></p>
<pre><code class="language-cpp">auto result = content_manager-&gt;ingestContent(
    video_blob,
    &quot;video/mp4&quot;,
    &quot;tutorial.mp4&quot;,
    json::object(),
    IngestionConfig{
        .chunk_size = 10,  // 10 seconds per chunk
        .chunk_overlap = 2  // 2 seconds overlap
    }
);
</code></pre>
<h2 id="content_architecture-7-performance-uberlegungen">7. Performance-Überlegungen<a class="headerlink" href="#content_architecture-7-performance-uberlegungen" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-71-blob-storage">7.1 Blob-Storage<a class="headerlink" href="#content_architecture-71-blob-storage" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Große Dateien (GB-Range) sollten nicht komplett in RocksDB gespeichert werden.</p>
<p><strong>Lösung:</strong> Hybrid-Storage</p>
<pre><code class="language-cpp">struct BlobStorageConfig {
    int64_t inline_threshold_bytes = 1024 * 1024; // 1 MB
    std::string external_storage_path = &quot;./data/blobs/&quot;;
};

// In ContentManager::ingestContent()
if (blob.size() &lt; config.inline_threshold_bytes) {
    // Store inline in RocksDB
    entity.setBlob(blob);
} else {
    // Store externally (filesystem or S3)
    std::string blob_path = external_storage_path + content_id + &quot;.blob&quot;;
    writeToFile(blob_path, blob);
    entity.set(&quot;blob_ref&quot;, blob_path);
}
</code></pre>
<h3 id="content_architecture-72-embedding-batch-processing">7.2 Embedding-Batch-Processing<a class="headerlink" href="#content_architecture-72-embedding-batch-processing" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Sequentielle Embedding-Generierung ist langsam.</p>
<p><strong>Lösung:</strong> Batch-API</p>
<pre><code class="language-cpp">std::vector&lt;std::vector&lt;float&gt;&gt; generateEmbeddingsBatch(const std::vector&lt;std::string&gt;&amp; texts) {
    json request = {{&quot;texts&quot;, texts}};
    auto response = http_client_-&gt;post(&quot;http://localhost:5000/embed/batch&quot;, request);
    return response[&quot;embeddings&quot;];
}
</code></pre>
<h3 id="content_architecture-73-async-ingestion">7.3 Async-Ingestion<a class="headerlink" href="#content_architecture-73-async-ingestion" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Große Dateien blockieren HTTP-Response.</p>
<p><strong>Lösung:</strong> Job-Queue</p>
<pre><code class="language-cpp">IngestionResult ContentManager::ingestContentAsync(/*...*/) {
    std::string job_id = generateUuid();

    // Queue job
    job_queue_-&gt;enqueue({
        .job_id = job_id,
        .blob = blob,
        .mime_type = mime_type,
        // ...
    });

    return {.ok=true, .content_id=job_id, .message=&quot;Queued for processing&quot;};
}

// Background worker
void processJobs() {
    while (true) {
        auto job = job_queue_-&gt;dequeue();
        auto result = ingestContent(job.blob, job.mime_type, /*...*/);
        updateJobStatus(job.job_id, result);
    }
}
</code></pre>
<h2 id="content_architecture-8-testing-strategie">8. Testing-Strategie<a class="headerlink" href="#content_architecture-8-testing-strategie" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-81-unit-tests-pro-processor">8.1 Unit Tests (pro Processor)<a class="headerlink" href="#content_architecture-81-unit-tests-pro-processor" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST(TextProcessorTest, ExtractsTextFromPlainText) {
    TextProcessor processor;
    std::string blob = &quot;Hello, world!&quot;;
    ContentType type = {.mime_type=&quot;text/plain&quot;, .category=ContentCategory::TEXT};

    auto result = processor.extract(blob, type);

    ASSERT_TRUE(result.ok);
    EXPECT_EQ(result.text, &quot;Hello, world!&quot;);
}

TEST(TextProcessorTest, ChunksTextWithOverlap) {
    TextProcessor processor;
    ExtractionResult extraction;
    extraction.text = &quot;Lorem ipsum dolor sit amet...&quot;; // 1000 chars

    auto chunks = processor.chunk(extraction, 512, 50);

    ASSERT_GE(chunks.size(), 2);
    // Verify overlap
    std::string end_of_chunk1 = chunks[0][&quot;text&quot;].get&lt;std::string&gt;().substr(462, 50);
    std::string start_of_chunk2 = chunks[1][&quot;text&quot;].get&lt;std::string&gt;().substr(0, 50);
    EXPECT_EQ(end_of_chunk1, start_of_chunk2);
}
</code></pre>
<h3 id="content_architecture-82-integration-tests">8.2 Integration Tests<a class="headerlink" href="#content_architecture-82-integration-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST(ContentManagerTest, IngestTextDocumentEndToEnd) {
    auto storage = std::make_shared&lt;RocksDBWrapper&gt;(&quot;./test_db&quot;);
    auto vector_index = std::make_shared&lt;VectorIndexManager&gt;(/*...*/);
    auto graph_index = std::make_shared&lt;GraphIndexManager&gt;(/*...*/);
    auto secondary_index = std::make_shared&lt;SecondaryIndexManager&gt;(/*...*/);

    ContentManager manager(storage, vector_index, graph_index, secondary_index);
    manager.registerProcessor(std::make_unique&lt;TextProcessor&gt;());

    std::string blob = &quot;This is a test document. It has multiple sentences.&quot;;
    auto result = manager.ingestContent(blob, &quot;text/plain&quot;, &quot;test.txt&quot;);

    ASSERT_TRUE(result.ok);
    EXPECT_GT(result.chunks_created, 0);

    // Verify metadata stored
    auto meta = manager.getContentMeta(result.content_id);
    ASSERT_TRUE(meta.has_value());
    EXPECT_EQ(meta-&gt;mime_type, &quot;text/plain&quot;);

    // Verify chunks stored
    auto chunks = manager.getContentChunks(result.content_id);
    EXPECT_EQ(chunks.size(), result.chunks_created);

    // Verify graph edges
    auto neighbors = graph_index-&gt;getOutNeighbors(&quot;chunk:&quot; + chunks[0].id);
    EXPECT_GT(neighbors.size(), 0); // Has 'next' edge
}
</code></pre>
<h3 id="content_architecture-83-performance-benchmarks">8.3 Performance Benchmarks<a class="headerlink" href="#content_architecture-83-performance-benchmarks" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">BENCHMARK(BM_IngestLargeDocument) {
    std::string large_doc(10 * 1024 * 1024, 'A'); // 10 MB
    for (auto _ : state) {
        content_manager-&gt;ingestContent(large_doc, &quot;text/plain&quot;, &quot;large.txt&quot;);
    }
}

BENCHMARK(BM_SearchWithExpansion) {
    for (auto _ : state) {
        content_manager-&gt;searchWithExpansion(&quot;machine learning&quot;, 10, 1);
    }
}
</code></pre>
<h2 id="content_architecture-9-migration-plan">9. Migration-Plan<a class="headerlink" href="#content_architecture-9-migration-plan" title="Permanent link">&para;</a></h2>
<h3 id="content_architecture-phase-1-foundation-woche-1-2">Phase 1: Foundation (Woche 1-2)<a class="headerlink" href="#content_architecture-phase-1-foundation-woche-1-2" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] ContentType + ContentTypeRegistry implementieren</li>
<li>[ ] IContentProcessor Interface + BinaryProcessor (Fallback)</li>
<li>[ ] ContentManager Grundstruktur (ohne Processors)</li>
<li>[ ] Unit Tests für ContentTypeRegistry</li>
</ul>
<h3 id="content_architecture-phase-2-text-processor-woche-3">Phase 2: Text-Processor (Woche 3)<a class="headerlink" href="#content_architecture-phase-2-text-processor-woche-3" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] TextProcessor implementieren (extract, chunk, embedding mit Mock)</li>
<li>[ ] Integration in ContentManager</li>
<li>[ ] HTTP Endpoint: POST /content/upload (nur TEXT)</li>
<li>[ ] Integration Tests</li>
</ul>
<h3 id="content_architecture-phase-3-imagegeocad-processors-woche-4-5">Phase 3: Image/Geo/CAD-Processors (Woche 4-5)<a class="headerlink" href="#content_architecture-phase-3-imagegeocad-processors-woche-4-5" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] ImageProcessor (EXIF extraction, CLIP embedding via external service)</li>
<li>[ ] GeoProcessor (GeoJSON parsing)</li>
<li>[ ] CADProcessor (STEP parsing mit Open CASCADE)</li>
<li>[ ] HTTP Endpoints erweitern</li>
</ul>
<h3 id="content_architecture-phase-4-hybrid-queries-woche-6">Phase 4: Hybrid-Queries (Woche 6)<a class="headerlink" href="#content_architecture-phase-4-hybrid-queries-woche-6" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] AQL VECTOR_KNN() Function</li>
<li>[ ] Graph-Expansion in ContentManager::searchWithExpansion()</li>
<li>[ ] Benchmarks</li>
</ul>
<h3 id="content_architecture-phase-5-production-hardening-woche-7">Phase 5: Production-Hardening (Woche 7+)<a class="headerlink" href="#content_architecture-phase-5-production-hardening-woche-7" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] Async-Ingestion (Job-Queue)</li>
<li>[ ] External Blob-Storage (Filesystem/S3)</li>
<li>[ ] Monitoring/Metrics</li>
<li>[ ] Documentation</li>
</ul>
<h2 id="content_architecture-10-fazit">10. Fazit<a class="headerlink" href="#content_architecture-10-fazit" title="Permanent link">&para;</a></h2>
<p>Das Content Manager System bietet eine <strong>skalierbare, erweiterbare Architektur</strong> für heterogene Datentypen. Durch die Trennung von generischen Operationen (Hashing, Graph-Erstellung) und typ-spezifischer Verarbeitung (via Processors) bleibt das System wartbar und einfach erweiterbar.</p>
<p><strong>Key Benefits:</strong>
- <strong>Einheitliche API:</strong> Ein Upload-Endpoint für alle Datentypen
- <strong>Wiederverwendbare Komponenten:</strong> Chunking-Logik, Graph-Erstellung, Deduplication
- <strong>Typ-Sicherheit:</strong> ContentTypeRegistry verhindert falsche Verarbeitung
- <strong>Produktivität:</strong> Neue Datentypen in &lt; 1 Tag integrierbar (nur Processor implementieren)
- <strong>RAG-Ready:</strong> Graph-Expansion für kontextuelle Suche out-of-the-box</p></section><section class="print-page" id="content-ingestion" heading-number="7.3"><h1 id="content-ingestion-content-v0-bulk-ingestion">Content v0: Bulk Ingestion<a class="headerlink" href="#content-ingestion-content-v0-bulk-ingestion" title="Permanent link">&para;</a></h1>
<p>Dieses Dokument beschreibt das v0-Schema für den Bulk-Import von bereits vorverarbeiteten Inhalten über die HTTP-API. Ziel: Einfache, robuste Übernahme von Content-Metadaten, optionalem Original-Blob, Chunks (inkl. Embeddings) und optionalen Graph-Kanten.</p>
<p>Stand: MVP, stabil genug für erste Integrationen. Erweiterungen (z. B. SSE-CDC, fortgeschrittene Filter) folgen später.</p>
<h2 id="content-ingestion-endpunkte">Endpunkte<a class="headerlink" href="#content-ingestion-endpunkte" title="Permanent link">&para;</a></h2>
<ul>
<li>POST /content/import</li>
<li>Nimmt einen strukturierten JSON-Spec entgegen und speichert Content-Meta, Chunk-Metas, optional den Original-Blob sowie optional Graph-Kanten.</li>
<li>GET /content/{id}</li>
<li>Liefert die Content-Metadaten zurück.</li>
<li>GET /content/{id}/blob</li>
<li>Liefert den gespeicherten Binärblob (Content-Type aus <code>mime_type</code>).</li>
<li>GET /content/{id}/chunks</li>
<li>Liefert alle Chunks (Metadaten). Aus Platzgründen wird die <code>embedding</code>-Liste in der Antwort auf leere Arrays normalisiert.</li>
</ul>
<p>Hinweis: Alle IDs können mit oder ohne Prefix übergeben werden. Intern werden folgende Keys verwendet:
- content:{id}, content_blob:{id}, content_chunks:{id}
- chunk:{id}</p>
<h2 id="content-ingestion-import-schema-request">Import-Schema (Request)<a class="headerlink" href="#content-ingestion-import-schema-request" title="Permanent link">&para;</a></h2>
<p>Request-Body für POST /content/import:</p>
<p>{
  "content": {
    "id": "optional-string-uuid",
    "mime_type": "text/plain",
    "category": 0,
    "original_filename": "optional.txt",
    "size_bytes": 0,
    "created_at": 0,
    "modified_at": 0,
    "hash_sha256": "",
    "text_extracted": false,
    "chunked": false,
    "indexed": false,
    "chunk_count": 0,
    "embedding_dim": 0,
    "extracted_metadata": {},
    "user_metadata": {},
    "tags": ["optional", "tags"],
    "parent_id": "",
    "child_ids": []
  },
  "chunks": [
    {
      "id": "optional-chunk-id",
      "content_id": "optional-content-id",
      "seq_num": 0,
      "chunk_type": "text",
      "text": "optional chunk text",
      "data": {},
      "blob_ref": "",
      "start_offset": 0,
      "end_offset": 0,
      "embedding": [/<em> optional float[] </em>/],
      "embedding_indexed": false,
      "created_at": 0
    }
  ],
  "edges": [
    { "from": "nodeA", "to": "nodeB", "type": "next", "weight": 1.0 }
  ],
  "blob": "optional raw blob als String" 
  // alternativ: "blob_base64": "..." (derzeit ohne Dekodierung im Server-MVP)
}</p>
<p>Erläuterungen:
- content.id: Wenn nicht gesetzt, wird serverseitig eine UUID generiert.
- blob: Wird unter key "content_blob:{id}" gespeichert. Größe wird in <code>content.size_bytes</code> übernommen.
- chunks[<em>].id: Wird generiert, falls nicht angegeben. <code>content_id</code> wird auf die Content-ID normiert.
- chunks[</em>].embedding: Falls gesetzt und Dimension zum initialisierten Vektorindex passt, wird ein Vektorobjekt mit PK "chunks:{chunk_id}" im VectorIndex angelegt. Ist noch kein Index initialisiert, wird er implizit mit Objektname "chunks" und COSINE-Metrik anhand der ersten Embedding-Dimension initialisiert.
- edges: Optionale Kanten, die als Graph-Edges gespeichert werden (frei gestaltbares Feldschema; häufig: from, to, type, weight).</p>
<h2 id="content-ingestion-antworten">Antworten<a class="headerlink" href="#content-ingestion-antworten" title="Permanent link">&para;</a></h2>
<ul>
<li>200 OK: { "status": "success", "content_id": "..." }</li>
<li>4xx/5xx mit Schema { error: true, message: string, status_code: number }</li>
</ul>
<h2 id="content-ingestion-beispiele">Beispiele<a class="headerlink" href="#content-ingestion-beispiele" title="Permanent link">&para;</a></h2>
<p>Minimaler Text-Import ohne Embeddings:</p>
<p>POST /content/import
Content-Type: application/json</p>
<p>{
  "content": {
    "id": "doc-001",
    "mime_type": "text/plain",
    "user_metadata": {"dataset": "alpha"},
    "tags": ["demo"]
  },
  "blob": "Hello world",
  "chunks": [
    {"seq_num": 0, "chunk_type": "text", "text": "Hello"},
    {"seq_num": 1, "chunk_type": "text", "text": "world"}
  ]
}</p>
<p>Antwort:</p>
<p>{
  "status": "success",
  "content_id": "doc-001"
}</p>
<p>Abfrage der Metadaten:
- GET /content/doc-001 → ContentMeta inkl. chunk_count
- GET /content/doc-001/chunks → { count, chunks: [...] } (embedding-Felder leere Arrays)
- GET /content/doc-001/blob → liefert den Blob (Content-Type: text/plain)</p>
<h2 id="content-ingestion-filter-und-graph-funktionen-ausblick">Filter- und Graph-Funktionen (Ausblick)<a class="headerlink" href="#content-ingestion-filter-und-graph-funktionen-ausblick" title="Permanent link">&para;</a></h2>
<ul>
<li>Hybrid-/Vektorsuche: POST /search/hybrid (siehe allgemeine Doku); nutzt VectorIndex plus optionale Graph-Expansion.</li>
<li>Filterkonfiguration: GET/PUT /config/content-filters</li>
<li>Schema: { field_map: { alias: "json.pfad.im.contentmeta" } }</li>
<li>Dient der Deklaration, welche Felder in Content-Metadaten für Filter verwendet werden können.</li>
<li>Kanten-Gewichte: GET/PUT /config/edge-weights</li>
</ul>
<h2 id="content-ingestion-kompatibilitat-und-grenzen">Kompatibilität und Grenzen<a class="headerlink" href="#content-ingestion-kompatibilitat-und-grenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><code>blob_base64</code> wird aktuell nicht automatisch dekodiert; bitte <code>blob</code> verwenden oder selbst dekodieren, bevor es gesendet wird.</li>
<li><code>category</code> ist derzeit als numerischer Enumwert erwartbar (0=TEXT, 1=IMAGE, ...); ist optional, da <code>mime_type</code> für viele Workflows ausreichend ist.</li>
<li>Embeddings erfordern einen initialisierten VectorIndex (wird bei erstem Einfügen implizit für Objektname "chunks" angelegt).</li>
</ul>
<h2 id="content-ingestion-troubleshooting">Troubleshooting<a class="headerlink" href="#content-ingestion-troubleshooting" title="Permanent link">&para;</a></h2>
<ul>
<li>400 Invalid JSON: Request-Body ist kein valides JSON.</li>
<li>500 failed to store ...: Persistenzfehler (RocksDB). Logs prüfen.</li>
<li>Chunks erscheinen ohne Embeddings: Prüfen, ob Dimension konsistent ist bzw. ob überhaupt Embeddings übergeben wurden.</li>
</ul>
<hr />
<h1 id="content-ingestion-ingestion-leitfaden-vorverarbeitung-vor-dem-import-maximale-verknupfbarkeit">Ingestion-Leitfaden: Vorverarbeitung vor dem Import (Maximale Verknüpfbarkeit)<a class="headerlink" href="#content-ingestion-ingestion-leitfaden-vorverarbeitung-vor-dem-import-maximale-verknupfbarkeit" title="Permanent link">&para;</a></h1>
<p>Ziel dieses Leitfadens ist es, externe Ingestion-Pipelines so zu beschreiben, dass Inhalte vor dem Schreiben in THEMIS maximal verknüpfbar sind. Die DB selbst führt keine Extraktion durch – sie erwartet bereits strukturierte JSON-Daten gemäß <code>POST /content/import</code> und baut darauf Indexe (Dokument-, Graph- und Vektorindex) auf.</p>
<p>Die folgenden Empfehlungen liefern pro Datentyp konkrete Schritte, Felder und Kanten-Modelle, um Breite (viele Verbindungsmöglichkeiten) und Tiefe (hohe semantische Dichte) zu maximieren.</p>
<h2 id="content-ingestion-grundprinzipien">Grundprinzipien<a class="headerlink" href="#content-ingestion-grundprinzipien" title="Permanent link">&para;</a></h2>
<ul>
<li>Eindeutige, stabile IDs: Bestimmen Sie <code>content.id</code> deterministisch (z. B. Hash aus Normal-Form des Quellobjekts). Chunk-IDs können aus <code>content.id</code> + Positionsmerkmalen abgeleitet werden.</li>
<li>Chunking vor Embedding: Zerlegen Sie Inhalte semantisch (Absätze, Szenen, Segmente, Zeilen, Komponenten), erzeugen Sie dann pro Chunk Embeddings. So bleiben Kanten und Kontext fein granular.</li>
<li>Kanonisches Schema nutzen: Mappen Sie alles auf <code>content</code> (Metadaten), <code>chunks</code> (Kleinstrukturen), <code>edges</code> (Relationen). Halten Sie sich an wiederkehrende Schlüssel:</li>
<li><code>source_uri</code>, <code>hash_sha256</code>, <code>created_at</code>, <code>modified_at</code>, <code>language</code>, <code>authors</code>, <code>topics</code>, <code>tags</code></li>
<li>Zeitliche Felder: <code>start_ms</code>, <code>end_ms</code> (Audio/Video-Segmente)</li>
<li>Räumliche Felder: <code>lat</code>, <code>lon</code>, <code>bbox</code>, <code>srid</code>, <code>geometry</code></li>
<li>Strukturfelder in <code>chunks[*].data</code>: typ-spezifisch (siehe unten)</li>
<li>Ontologien &amp; kontrollierte Vokabulare: Verwenden Sie normierte Werte (ISO-Sprachcodes, EPSG für Geo, Standard-Einheiten, taxonomische Kategorien), um Abgleich/Join zu erleichtern.</li>
<li>Kanten explizit modellieren: Nutzen Sie <code>edges</code> mit <code>type</code> und optional <code>weight</code>. Empfohlene Typen: <code>derived_from</code>, <code>contains</code>, <code>references</code>, <code>mentions</code>, <code>same_as</code>, <code>next</code>, <code>similar</code>, <code>depicts</code>, <code>located_in</code>, <code>belongs_to</code>, <code>mate</code> (CAD).</li>
<li>Datenschutz: Entfernen/Maskieren Sie PII frühzeitig. Speichern Sie nur notwendige Felder, nutzen Sie Pseudonyme/Hashes bei Bedarf.</li>
</ul>
<h2 id="content-ingestion-modalitatsspezifische-leitfaden">Modalitätsspezifische Leitfäden<a class="headerlink" href="#content-ingestion-modalitatsspezifische-leitfaden" title="Permanent link">&para;</a></h2>
<h3 id="content-ingestion-1-bilder-rastergrafiken">1) Bilder (Rastergrafiken)<a class="headerlink" href="#content-ingestion-1-bilder-rastergrafiken" title="Permanent link">&para;</a></h3>
<p>Pipeline-Schritte:
- EXIF/Metadaten extrahieren (Kamera, Zeit, GPS)
- Objekterkennung/Tags (z. B. Personen, Orte, Dinge) – <code>chunks[*].data.objects</code>
- OCR für eingebetteten Text – Ergebnisse als eigener Text-Chunk
- Bildunterschrift/Captioning – kurze Beschreibung als Text-Chunk
- Perceptual Hash (pHash/aHash) – Deduplikation/Ähnlichkeit
- Multimodales Embedding (z. B. CLIP) für Retrieval</p>
<p>Mapping:
- <code>content.mime_type = image/jpeg|png</code> | <code>category = IMAGE</code>
- Chunks:
  - <code>chunk_type = image_meta</code> mit <code>{ exif: {...}, p_hash: "...", colors: [...] }</code>
  - <code>chunk_type = text</code> für OCR/Caption (<code>text</code> gesetzt)
  - <code>embedding</code> am passenden Chunk (z. B. Caption-Chunk oder <code>image_meta</code>)
- Kanten:
  - <code>derived_from</code> (zwischen Transformaten/Thumbnails und Original)
  - <code>similar</code> (zu anderen Bildern per pHash/Embedding)
  - <code>depicts</code> (zu Entitäten: Personen, Orte, Objekte)</p>
<p>Beispiel (auszugsweise):</p>
<pre><code>{
  &quot;content&quot;: {&quot;id&quot;:&quot;img:beach-001&quot;,&quot;mime_type&quot;:&quot;image/jpeg&quot;,&quot;tags&quot;:[&quot;beach&quot;,&quot;sunset&quot;],&quot;extracted_metadata&quot;:{&quot;exif&quot;:{&quot;gps&quot;:{&quot;lat&quot;:36.6,&quot;lon&quot;:-121.9}}}},
  &quot;chunks&quot;: [
    {&quot;seq_num&quot;:0,&quot;chunk_type&quot;:&quot;image_meta&quot;,&quot;data&quot;:{&quot;p_hash&quot;:&quot;cafe1234&quot;,&quot;objects&quot;:[&quot;person&quot;,&quot;sea&quot;],&quot;colors&quot;:[&quot;#ffaa77&quot;,&quot;#003355&quot;]},&quot;embedding&quot;:[...]},
    {&quot;seq_num&quot;:1,&quot;chunk_type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;A person walking along the beach at sunset.&quot;,&quot;embedding&quot;:[...]}
  ],
  &quot;edges&quot;:[{&quot;from&quot;:&quot;img:beach-001&quot;,&quot;to&quot;:&quot;place:carmel&quot;,&quot;type&quot;:&quot;located_in&quot;,&quot;weight&quot;:0.9}]
}
</code></pre>
<h3 id="content-ingestion-2-video">2) Video<a class="headerlink" href="#content-ingestion-2-video" title="Permanent link">&para;</a></h3>
<p>Pipeline-Schritte:
- Szenen-/Shot-Erkennung → Szenen-Segmente mit <code>start_ms</code>/<code>end_ms</code>
- Keyframes extrahieren (als separate Bild-Contents, mit <code>derived_from</code>-Kanten)
- ASR-Transkript (Sprache erkennen, ggf. Übersetzung) + Sprecherdiarisierung
- Objekterkennung/Tracking über Zeit (Tracks als Arrays)
- Segment-Embeddings (z. B. pro Szene, pro 2–5 Sekunden)</p>
<p>Mapping:
- <code>content.mime_type = video/mp4</code> | <code>category = VIDEO</code>
- Chunks:
  - <code>chunk_type = scene</code> mit <code>{ start_ms, end_ms, transcript, speakers:[...], objects:[...], tracks:[...] }</code>
  - <code>chunk_type = text</code> für reine Transkript-Segmente
  - Embeddings am jeweiligen Segment-Chunk
- Kanten:
  - <code>contains</code> (Video → Keyframe-Bilder), <code>derived_from</code> (Keyframe → Video)
  - <code>mentions</code>/<code>depicts</code> zu erkannten Entitäten
  - <code>next</code> zwischen Szenen in zeitlicher Reihenfolge</p>
<p>Beispiel (auszugsweise):</p>
<pre><code>{
  &quot;content&quot;:{&quot;id&quot;:&quot;vid:promo-2025&quot;,&quot;mime_type&quot;:&quot;video/mp4&quot;,&quot;duration_ms&quot;:90000},
  &quot;chunks&quot;:[
    {&quot;seq_num&quot;:0,&quot;chunk_type&quot;:&quot;scene&quot;,&quot;data&quot;:{&quot;start_ms&quot;:0,&quot;end_ms&quot;:6000,&quot;transcript&quot;:&quot;Welcome to...&quot;,&quot;speakers&quot;:[&quot;spk1&quot;]},&quot;embedding&quot;:[...]},
    {&quot;seq_num&quot;:1,&quot;chunk_type&quot;:&quot;scene&quot;,&quot;data&quot;:{&quot;start_ms&quot;:6000,&quot;end_ms&quot;:12000,&quot;transcript&quot;:&quot;Our product...&quot;},&quot;embedding&quot;:[...]}
  ],
  &quot;edges&quot;:[{&quot;from&quot;:&quot;vid:promo-2025&quot;,&quot;to&quot;:&quot;img:keyframe-abc&quot;,&quot;type&quot;:&quot;contains&quot;}]
}
</code></pre>
<h3 id="content-ingestion-3-audio">3) Audio<a class="headerlink" href="#content-ingestion-3-audio" title="Permanent link">&para;</a></h3>
<p>Pipeline-Schritte:
- ASR-Transkript + Sprecher-Erkennung
- Segmentierung (z. B. Voice Activity Detection) mit <code>start_ms</code>/<code>end_ms</code>
- Audio-Embeddings pro Segment</p>
<p>Mapping:
- <code>content.mime_type = audio/mpeg|wav</code> | <code>category = AUDIO</code>
- <code>chunk_type = segment|text</code> mit zeitlichen Feldern und <code>text</code>
- Kanten: <code>next</code> (Sequenz), <code>mentions</code> (Erwähnte Entitäten)</p>
<h3 id="content-ingestion-4-schriftdokumente-pdfdocx">4) Schriftdokumente (PDF/DOCX)<a class="headerlink" href="#content-ingestion-4-schriftdokumente-pdfdocx" title="Permanent link">&para;</a></h3>
<p>Pipeline-Schritte:
- Layout-aware Parsing (Abschnitt, Überschrift, Absatz, Liste, Tabelle, Fußnote)
- Semantische Chunking-Regeln (Absatzblöcke 200–400 Tokens; Tabellen als eigene Chunks)
- Referenzen/Zitationen extrahieren (DOIs, URLs) → <code>edges: references</code>
- Embeddings pro Text-Chunk</p>
<p>Mapping:
- <code>mime_type = application/pdf|vnd.openxmlformats-officedocument.wordprocessingml.document</code>
- Chunks:
  - <code>chunk_type = text</code> mit <code>{ section:"2.3", page: 5, heading: "Method" }</code>
  - <code>chunk_type = table</code> mit <code>{ schema: {...}, cells: [...], page: n }</code> (kompakt halten)
- Kanten:
  - <code>references</code> (Zitationen), <code>mentions</code> (Begriffe), <code>same_as</code> (Duplikat-Funde)</p>
<h3 id="content-ingestion-5-tabellendokumente-csvxlsx">5) Tabellendokumente (CSV/XLSX)<a class="headerlink" href="#content-ingestion-5-tabellendokumente-csvxlsx" title="Permanent link">&para;</a></h3>
<p>Pipeline-Schritte:
- Schema- und Typinferenz (Datums-/Zahl-/Einheiten-Normalisierung)
- Fremdschlüssel-/Referenzen ableiten (Spalten, die IDs/Schlüssel enthalten)
- Zeilen-Embeddings (aus konkatenierten textuellen Spalten) optional</p>
<p>Mapping:
- <code>mime_type = text/csv|application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code>
- Chunks:
  - <code>chunk_type = row</code> mit <code>{ row_index, values: {col: val, ...}, normalized: {...} }</code>
  - <code>chunk_type = schema</code> für Kopf-/Spaltenmetadaten
- Kanten:
  - <code>references</code>/<code>foreign_key</code> (Zeile → referenzierte Entität/Content)</p>
<p>Beispiel (auszugsweise):</p>
<pre><code>{
  &quot;content&quot;:{&quot;id&quot;:&quot;csv:customers-2025&quot;,&quot;mime_type&quot;:&quot;text/csv&quot;,&quot;user_metadata&quot;:{&quot;dataset&quot;:&quot;crm&quot;}},
  &quot;chunks&quot;:[
    {&quot;seq_num&quot;:0,&quot;chunk_type&quot;:&quot;schema&quot;,&quot;data&quot;:{&quot;columns&quot;:[{&quot;name&quot;:&quot;customer_id&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;name&quot;:&quot;city&quot;,&quot;type&quot;:&quot;string&quot;}]}},
    {&quot;seq_num&quot;:1,&quot;chunk_type&quot;:&quot;row&quot;,&quot;data&quot;:{&quot;row_index&quot;:1,&quot;values&quot;:{&quot;customer_id&quot;:&quot;C-001&quot;,&quot;city&quot;:&quot;Berlin&quot;}}}
  ],
  &quot;edges&quot;:[{&quot;from&quot;:&quot;chunk:csv:customers-2025:row:1&quot;,&quot;to&quot;:&quot;city:berlin&quot;,&quot;type&quot;:&quot;references&quot;,&quot;weight&quot;:0.8}]
}
</code></pre>
<h3 id="content-ingestion-6-cad-daten-bomassemblies">6) CAD-Daten (BOM/Assemblies)<a class="headerlink" href="#content-ingestion-6-cad-daten-bomassemblies" title="Permanent link">&para;</a></h3>
<p>Pipeline-Schritte:
- Ableitung der Stückliste (BOM), Komponenten, Unterbaugruppen
- Geometrische Metadaten (Abmessungen, Material, Toleranzen), optional vereinfachte Meshes/Thumbnails
- Ähnlichkeitssuche (Feature-Hash/Embedding) für „ähnliche Teile“
- Constraints/Mates zwischen Komponenten</p>
<p>Mapping:
- <code>mime_type = application/vnd.cad+zip|step|iges</code> (je nach Quelle)
- Chunks:
  - <code>chunk_type = cad_part</code> mit <code>{ part_no, name, material, dims:{...}, mass, attributes:{...} }</code>
  - <code>chunk_type = cad_assembly</code> mit <code>{ components:[{ref:"...", qty:n}], constraints:[...]}</code>
- Kanten:
  - <code>contains</code> (Assembly → Part), <code>mate</code> (Part ↔ Part), <code>similar</code> (Part ↔ Part)
  - <code>derived_from</code> (Darstellungen wie Thumbnails ↔ Original)</p>
<h3 id="content-ingestion-7-geodaten">7) Geodaten<a class="headerlink" href="#content-ingestion-7-geodaten" title="Permanent link">&para;</a></h3>
<p>Pipeline-Schritte:
- Geometrien normieren (GeoJSON), Ziel-SRID EPSG:4326 (WGS84)
- Bounding Box berechnen (<code>bbox</code>), ggf. Vereinfachung für Übersicht
- Verknüpfungen zu administrativen Einheiten (Gemeinde, Landkreis, Bundesland) – vorberechnen
- Zeitliche Gültigkeit (falls vorhanden) als Felder abbilden</p>
<p>Mapping:
- <code>mime_type = application/geo+json|application/json</code>
- Chunks:
  - <code>chunk_type = feature</code> mit <code>{ geometry: {...}, srid: 4326, bbox: [...], properties: {...} }</code>
- Kanten:
  - <code>located_in</code> (Feature → admin Einheit), <code>adjacent_to</code>, <code>part_of</code></p>
<p>Beispiel (auszugsweise):</p>
<pre><code>{
  &quot;content&quot;:{&quot;id&quot;:&quot;geo:park-berlin&quot;,&quot;mime_type&quot;:&quot;application/geo+json&quot;},
  &quot;chunks&quot;:[{&quot;seq_num&quot;:0,&quot;chunk_type&quot;:&quot;feature&quot;,&quot;data&quot;:{&quot;srid&quot;:4326,&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[... ]},&quot;bbox&quot;:[...],&quot;properties&quot;:{&quot;name&quot;:&quot;Tiergarten&quot;}}}]
}
</code></pre>
<h2 id="content-ingestion-kanten-design-und-gewichte">Kanten-Design und Gewichte<a class="headerlink" href="#content-ingestion-kanten-design-und-gewichte" title="Permanent link">&para;</a></h2>
<ul>
<li>Verwenden Sie sprechende <code>type</code>-Werte (siehe oben). Gewichte <code>weight</code> optional verwenden, um Relevanz (0–1) zu codieren.</li>
<li>Systemweite Gewichtung kann via <code>/config/edge-weights</code> kalibriert werden.</li>
<li>Reihenfolge-Kanten (<code>next</code>) erleichtern zeitliche/strukturelle Pfade (z. B. Video-Szenen, Dokument-Absätze).</li>
</ul>
<h2 id="content-ingestion-ids-deduplikation-provenienz">IDs, Deduplikation, Provenienz<a class="headerlink" href="#content-ingestion-ids-deduplikation-provenienz" title="Permanent link">&para;</a></h2>
<ul>
<li>IDs deterministisch: <code>id = prefix:base64(sha256(normalized_source))</code></li>
<li><code>hash_sha256</code> am <code>content</code> für schnelle Duplikatprüfung</li>
<li><code>source_uri</code> und <code>provenance</code> (z. B. Tool-Versionen) in <code>extracted_metadata</code></li>
</ul>
<h2 id="content-ingestion-qualitatssicherung-empfehlungen">Qualitätssicherung (Empfehlungen)<a class="headerlink" href="#content-ingestion-qualitatssicherung-empfehlungen" title="Permanent link">&para;</a></h2>
<ul>
<li>Mindestabdeckung: ≥95% der Chunks mit Spracheintrag <code>language</code> (falls Text vorhanden)</li>
<li>Embedding-Dimension konsistent halten; Fehlwürfe (NaNs) filtern</li>
<li>Tabellen: Typinferenzquote und Normalisierung dokumentieren</li>
<li>ASR: Wort-Fehlerrate (WER) erfassen; Sprecherlabels plausibilisieren</li>
</ul>
<h2 id="content-ingestion-performance-groe">Performance &amp; Größe<a class="headerlink" href="#content-ingestion-performance-groe" title="Permanent link">&para;</a></h2>
<ul>
<li>Text-Chunks 200–400 Tokens für gute Retrieval/Ranking-Qualität</li>
<li>Video/Audio-Segmente 2–10 Sekunden für annehmbare Granularität</li>
<li>Bilder: OCR-Text als eigener Chunk, Bild-Captioning kurz halten (≤ 200 Zeichen)</li>
<li>Große Payloads ggf. in Batches aufteilen; <code>chunk_count</code> am <code>content</code> liefern</li>
</ul>
<h2 id="content-ingestion-sicherheit-datenschutz">Sicherheit &amp; Datenschutz<a class="headerlink" href="#content-ingestion-sicherheit-datenschutz" title="Permanent link">&para;</a></h2>
<ul>
<li>PII vor Import anonymisieren; nur erforderliche Teile speichern</li>
<li>Hashen/Pseudonymisieren, wo möglich</li>
<li>Vollständige Ereignis-/Zugriffsketten außerhalb von THEMIS auditieren</li>
</ul>
<hr />
<p>Mit diesem Leitfaden werden Inhalte so vorbereitet, dass THEMIS sie optimal über Dokument-, Graph- und Vektorindex verknüpfen kann. Die Beispiele zeigen, wie Modalitäten in das kanonische <code>content/chunks/edges</code>-Schema abgebildet werden, um reichhaltige Abfragen (Hybrid-Suche, Pfad-Expansion, Analysen) zu ermöglichen.</p></section><section class="print-page" id="ingestion-json_ingestion_spec" heading-number="7.4"><h1 id="ingestion-json_ingestion_spec-json-ingestion-spezifikation-post-go-live">JSON Ingestion Spezifikation (Post-Go-Live)<a class="headerlink" href="#ingestion-json_ingestion_spec-json-ingestion-spezifikation-post-go-live" title="Permanent link">&para;</a></h1>
<p>Ziel dieses Dokuments ist, den standardisierten JSON-gestützten Ingestion-Prozess (ETL) zu definieren, damit strukturierte, Geo- und Textdaten aus heterogenen Quellen konsistent, abfragefreundlich und revisionssicher in die Kerndatenbank übernommen werden.</p>
<h2 id="ingestion-json_ingestion_spec-zweck-scope">Zweck &amp; Scope<a class="headerlink" href="#ingestion-json_ingestion_spec-zweck-scope" title="Permanent link">&para;</a></h2>
<ul>
<li>Einheitlicher Contract für alle Quellen (GeoJSON, GPX, CSV, proprietär, Text/Binary mit Metadaten)</li>
<li>Abfragefähigkeit entlang dreier Achsen: Relational (Attribute/Begriffe), Räumlich (Punkt/Linie/Polygon), Semantisch (Vektor)</li>
<li>Qualität, Idempotenz, Deduplikation, Lineage/Audit als First-Class-Bestandteile</li>
</ul>
<h2 id="ingestion-json_ingestion_spec-mini-contract-inputsoutputs">Mini-Contract (Inputs/Outputs)<a class="headerlink" href="#ingestion-json_ingestion_spec-mini-contract-inputsoutputs" title="Permanent link">&para;</a></h2>
<ul>
<li>Input: JSON-Dokument (Payload) + optionaler Binärblob (z. B. Originaldatei)</li>
<li>Output:</li>
<li>Relationale Records (Tables: features/points/lines/polygons/terms/synonyms)</li>
<li>Optional Blob-Speicher (Original) + Hash</li>
<li>Indizes: räumlich (BBox/GiST), textuell (B-Tree/FTS/Trigram), vektoriell</li>
<li>Fehler/Qualität: Validierungsfehler in DLQ; Metriken/Logs; Retry mit Idempotenz-Schlüssel</li>
</ul>
<h2 id="ingestion-json_ingestion_spec-json-struktur-generisch">JSON-Struktur (generisch)<a class="headerlink" href="#ingestion-json_ingestion_spec-json-struktur-generisch" title="Permanent link">&para;</a></h2>
<pre><code class="language-json">{
  &quot;source_id&quot;: &quot;behörde-bayern-lsg-2025&quot;,
  &quot;source_pk&quot;: &quot;ext-12345&quot;,
  &quot;content_type&quot;: &quot;geo&quot;,
  &quot;geo&quot;: {
    &quot;type&quot;: &quot;Polygon&quot;,
    &quot;crs&quot;: &quot;EPSG:4326&quot;,
    &quot;coordsPath&quot;: &quot;features[0].geometry.coordinates&quot;,
    &quot;bbox&quot;: [minLon, minLat, maxLon, maxLat]
  },
  &quot;text&quot;: {
    &quot;language&quot;: &quot;de&quot;,
    &quot;fields&quot;: [&quot;properties.name&quot;, &quot;properties.category&quot;],
    &quot;tokenization&quot;: &quot;default&quot;
  },
  &quot;mappings&quot;: {
    &quot;name&quot;: &quot;properties.name&quot;,
    &quot;class&quot;: &quot;properties.category&quot;,
    &quot;tags&quot;: &quot;properties.tags&quot;
  },
  &quot;transforms&quot;: [
    {&quot;op&quot;: &quot;trim&quot;, &quot;field&quot;: &quot;name&quot;},
    {&quot;op&quot;: &quot;upper&quot;, &quot;field&quot;: &quot;class&quot;},
    {&quot;op&quot;: &quot;synonym_map&quot;, &quot;field&quot;: &quot;class&quot;, &quot;dict&quot;: &quot;geo_classes_v1&quot;}
  ],
  &quot;provenance&quot;: {
    &quot;ingested_at&quot;: &quot;2025-10-28T12:00:00Z&quot;,
    &quot;ingested_by&quot;: &quot;etl@system&quot;,
    &quot;license&quot;: &quot;CC-BY&quot;
  },
  &quot;metadata&quot;: {&quot;version&quot;: 1, &quot;note&quot;: &quot;LSG Import 2025&quot;}
}
</code></pre>
<p>Hinweis: Für reine Textquellen entfällt der Block <code>geo</code>. Für GPX/LineStrings: <code>type: "LineString"</code>. Für Punktdaten: <code>type: "Point"</code> und <code>coordsPath</code> verweist auf <code>[lon,lat]</code>.</p>
<h2 id="ingestion-json_ingestion_spec-pipeline-schritte">Pipeline-Schritte<a class="headerlink" href="#ingestion-json_ingestion_spec-pipeline-schritte" title="Permanent link">&para;</a></h2>
<ol>
<li>detect: MIME/Category, ggf. Magic Bytes</li>
<li>extract: Quelle lesen (GeoJSON/GPX/CSV/Text)</li>
<li>normalize:</li>
<li>Geo: nach EPSG:4326 (lon/lat), BBox berechnen, MultiGeometrien auflösen</li>
<li>Text: Unicode-Normalisierung, Language-Detection (falls nicht vorgegeben)</li>
<li>map: Felder gemäß <code>mappings</code> extrahieren, <code>transforms</code> anwenden</li>
<li>validate(schema): Pflichtfelder, Datentypen, Geometrie-Validität (self-intersections)</li>
<li>write:</li>
<li>Relationale Tabellen (features + points/lines/polygons)</li>
<li>Optional: blobs + content_hash</li>
<li>index: räumliche Indizes, textuelle Indizes, Vektor-Embeddings (optional)</li>
<li>lineage/audit: Provenienz und Hash-Manifest erfassen</li>
</ol>
<h2 id="ingestion-json_ingestion_spec-idempotenz-deduplikation">Idempotenz &amp; Deduplikation<a class="headerlink" href="#ingestion-json_ingestion_spec-idempotenz-deduplikation" title="Permanent link">&para;</a></h2>
<ul>
<li>Idempotenz-Schlüssel: <code>(source_id, source_pk)</code></li>
<li>Deduplizierung: <code>content_hash</code> (SHA-256 des Normalform-JSONs bzw. Blobs)</li>
<li>Wiederholungen: Upsert-Strategie mit Versionszähler (optimistische MVCC)</li>
</ul>
<h2 id="ingestion-json_ingestion_spec-qualitatsregeln-fehlerbehandlung">Qualitätsregeln &amp; Fehlerbehandlung<a class="headerlink" href="#ingestion-json_ingestion_spec-qualitatsregeln-fehlerbehandlung" title="Permanent link">&para;</a></h2>
<ul>
<li>Validation Errors → DLQ (JSON + Fehlerliste)</li>
<li>Retry-Politik mit Backoff; Max-Retries konfigurierbar</li>
<li>Metriken: <code>ingested_total</code>, <code>failed_total</code>, <code>duplicates_total</code>, Latenzen je Schritt</li>
</ul>
<h2 id="ingestion-json_ingestion_spec-beispiel-1-lsg-polygon-geojson">Beispiel 1: LSG (Polygon, GeoJSON)<a class="headerlink" href="#ingestion-json_ingestion_spec-beispiel-1-lsg-polygon-geojson" title="Permanent link">&para;</a></h2>
<pre><code class="language-json">{
  &quot;source_id&quot;: &quot;behörde-bayern-lsg-2025&quot;,
  &quot;source_pk&quot;: &quot;lsg-987&quot;,
  &quot;content_type&quot;: &quot;geo&quot;,
  &quot;geo&quot;: {&quot;type&quot;: &quot;Polygon&quot;, &quot;crs&quot;: &quot;EPSG:4326&quot;, &quot;coordsPath&quot;: &quot;geometry.coordinates&quot;},
  &quot;mappings&quot;: {&quot;name&quot;: &quot;properties.name&quot;, &quot;class&quot;: &quot;properties.category&quot;},
  &quot;transforms&quot;: [{&quot;op&quot;:&quot;synonym_map&quot;,&quot;field&quot;:&quot;class&quot;,&quot;dict&quot;:&quot;geo_classes_v1&quot;}],
  &quot;metadata&quot;: {&quot;dataset&quot;: &quot;LSG&quot;, &quot;year&quot;: 2025}
}
</code></pre>
<h2 id="ingestion-json_ingestion_spec-beispiel-2-fliegewasser-linie-gpx-linestring">Beispiel 2: Fließgewässer (Linie, GPX → LineString)<a class="headerlink" href="#ingestion-json_ingestion_spec-beispiel-2-fliegewasser-linie-gpx-linestring" title="Permanent link">&para;</a></h2>
<pre><code class="language-json">{
  &quot;source_id&quot;: &quot;wasserverband-gpx-2025&quot;,
  &quot;source_pk&quot;: &quot;track-42&quot;,
  &quot;content_type&quot;: &quot;geo&quot;,
  &quot;geo&quot;: {&quot;type&quot;: &quot;LineString&quot;, &quot;crs&quot;: &quot;EPSG:4326&quot;, &quot;coordsPath&quot;: &quot;tracks[0].segments[0]&quot;},
  &quot;mappings&quot;: {&quot;name&quot;: &quot;metadata.track_name&quot;, &quot;class&quot;: &quot;metadata.feature_class&quot;},
  &quot;metadata&quot;: {&quot;dataset&quot;: &quot;Fließgewässer&quot;}
}
</code></pre>
<h2 id="ingestion-json_ingestion_spec-beispiel-3-textdokument">Beispiel 3: Textdokument<a class="headerlink" href="#ingestion-json_ingestion_spec-beispiel-3-textdokument" title="Permanent link">&para;</a></h2>
<pre><code class="language-json">{
  &quot;source_id&quot;: &quot;dms-ordner-a&quot;,
  &quot;source_pk&quot;: &quot;doc-1001&quot;,
  &quot;content_type&quot;: &quot;text&quot;,
  &quot;text&quot;: {&quot;language&quot;: &quot;de&quot;, &quot;fields&quot;: [&quot;title&quot;, &quot;body&quot;], &quot;tokenization&quot;: &quot;default&quot;},
  &quot;mappings&quot;: {&quot;name&quot;: &quot;title&quot;, &quot;tags&quot;: &quot;keywords&quot;},
  &quot;metadata&quot;: {&quot;doctype&quot;: &quot;bericht&quot;}
}
</code></pre>
<h2 id="ingestion-json_ingestion_spec-indexierung-hinweise">Indexierung (Hinweise)<a class="headerlink" href="#ingestion-json_ingestion_spec-indexierung-hinweise" title="Permanent link">&para;</a></h2>
<ul>
<li>Räumlich: R-Tree/GiST (BBox bzw. Geometriespalte)</li>
<li>Text: B-Tree auf <code>class/name</code>, optional FTS/Trigram für unscharfe Suche</li>
<li>Vektor: Embeddings für Name/Tags (optional) + ANN-Index</li>
</ul>
<h2 id="ingestion-json_ingestion_spec-versionierung-governance">Versionierung &amp; Governance<a class="headerlink" href="#ingestion-json_ingestion_spec-versionierung-governance" title="Permanent link">&para;</a></h2>
<ul>
<li>Schema-Version je Quelle (<code>metadata.version</code>)</li>
<li>Änderungen via Migrationsnotiz; kompatible Evolution bevorzugt</li>
<li>Audit: <code>provenance</code> speichern; Hash-Manifest für Unveränderlichkeit</li>
</ul>
<h2 id="ingestion-json_ingestion_spec-offene-punkte">Offene Punkte<a class="headerlink" href="#ingestion-json_ingestion_spec-offene-punkte" title="Permanent link">&para;</a></h2>
<ul>
<li>Einheitliche Synonymlisten-Verwaltung (z. B. <code>geo_classes_v1</code>)</li>
<li>Vereinheitlichung der DLQ-Formate und Monitoring-Alarmierung</li>
</ul></section><section class="print-page" id="content-geo_processor_design" heading-number="7.5"><h1 id="content-geo_processor_design-geoprocessor-design-phase-4">GeoProcessor – Design (Phase 4)<a class="headerlink" href="#content-geo_processor_design-geoprocessor-design-phase-4" title="Permanent link">&para;</a></h1>
<p>Dieses Dokument beschreibt die Verarbeitung von Geo-Daten (GeoJSON/GPX) im Content/Filesystem-Layer.</p>
<h2 id="content-geo_processor_design-ziele">Ziele<a class="headerlink" href="#content-geo_processor_design-ziele" title="Permanent link">&para;</a></h2>
<ul>
<li>Extraktion und Normalisierung von Geometrien (Point/LineString/Polygon) nach EPSG:4326</li>
<li>Berechnung der Bounding Box und optionale Vereinfachung</li>
<li>Chunking in räumliche Tiles (z. B. quadtree-ähnlich oder fixes Grid)</li>
<li>Embedding aus lat/lon (grid-based) für grobe semantische Nähe</li>
</ul>
<h2 id="content-geo_processor_design-contract">Contract<a class="headerlink" href="#content-geo_processor_design-contract" title="Permanent link">&para;</a></h2>
<ul>
<li>extract(blob/json, content_type: application/geo+json | application/gpx+xml) → ExtractionResult</li>
<li>fields:<ul>
<li>geometry_type: Point | LineString | Polygon | Multi*</li>
<li>coordinates (normalisiert, lon/lat)</li>
<li>bbox: [minLon, minLat, maxLon, maxLat]</li>
<li>properties: Map<string,any></li>
</ul>
</li>
<li>chunk(extraction, cfg: { tile_size_deg: 0.1, max_tiles?: 64 }) → [Chunk]</li>
<li>Schneidet Geometrie gegen ein reguläres Lon/Lat-Grid (Kachelung)</li>
<li>payload je Chunk: { tile_bbox, geom_fraction, length_or_area }</li>
<li>generateEmbedding(chunk_payload) → float[128]</li>
<li>128D Vektor aus (tile center lon/lat) + scale; normalisiert</li>
</ul>
<h2 id="content-geo_processor_design-datenablage-verweis">Datenablage (Verweis)<a class="headerlink" href="#content-geo_processor_design-datenablage-verweis" title="Permanent link">&para;</a></h2>
<ul>
<li>siehe <code>docs/storage/geo_relational_schema.md</code> (features/points/lines/polygons)</li>
<li>Content-Layer speichert zusätzlich <code>content:&lt;id&gt;</code> Meta (bbox, type, props)</li>
</ul>
<h2 id="content-geo_processor_design-normalisierung">Normalisierung<a class="headerlink" href="#content-geo_processor_design-normalisierung" title="Permanent link">&para;</a></h2>
<ul>
<li>CRS nach EPSG:4326 (lon/lat)</li>
<li>BBox aus Geometrie berechnen</li>
<li>MultiGeometrien in Einzelgeometrien aufteilen (optional)</li>
</ul>
<h2 id="content-geo_processor_design-chunking">Chunking<a class="headerlink" href="#content-geo_processor_design-chunking" title="Permanent link">&para;</a></h2>
<ul>
<li>Reguläres Grid über BBox; für jede Kachel, die Geometrie schneidet → Chunk</li>
<li><code>geom_fraction</code>: Anteil der Geometrie in der Kachel (Heuristik)</li>
<li><code>length_or_area</code>: Metrik (Linienlänge/Polygonfläche) innerhalb der Kachel</li>
</ul>
<h2 id="content-geo_processor_design-embedding-grid-based">Embedding (grid-based)<a class="headerlink" href="#content-geo_processor_design-embedding-grid-based" title="Permanent link">&para;</a></h2>
<ul>
<li>Positionsembedding über sinus/cosinus Kodierung der lon/lat des Kachelzentrums</li>
<li>Skalierung über Zoom/Frequenzen; Ausgabe 128D, L2-normalisiert</li>
</ul>
<h2 id="content-geo_processor_design-tests-20-unit-tests">Tests (20 Unit Tests)<a class="headerlink" href="#content-geo_processor_design-tests-20-unit-tests" title="Permanent link">&para;</a></h2>
<p>1) extract: Point korrekt normalisiert + bbox
2-3) extract: LineString/Polygon bbox korrekt
4) extract: MultiPolygon → mehrere Einheiten (optional)
5-8) chunk: Kachelzählung abhängig von bbox/tile_size
9-12) chunk: geom_fraction plausibel (0..1)
13-14) chunk: length/area konsistent
15-17) embedding: 128D, L2≈1.0, deterministisch
18-20) integration: insert + index + query stub</p>
<h2 id="content-geo_processor_design-open-points">Open Points<a class="headerlink" href="#content-geo_processor_design-open-points" title="Permanent link">&para;</a></h2>
<ul>
<li>GPX Höhenprofil/Elevation, Zeitstempel</li>
<li>Genauere Flächen-/Längenberechnung (Geodäsie)</li>
<li>Integration mit räumlichen Indizes (RocksDB sekundär vs. externer Store)</li>
</ul></section><section class="print-page" id="content-image_processor_design" heading-number="7.6"><h1 id="content-image_processor_design-imageprocessor-design-phase-4">ImageProcessor – Design (Phase 4)<a class="headerlink" href="#content-image_processor_design-imageprocessor-design-phase-4" title="Permanent link">&para;</a></h1>
<p>Dieses Dokument beschreibt die Architektur und Testspezifikation für den Bildverarbeitungsprozessor innerhalb des Content/Filesystem-Layers.</p>
<h2 id="content-image_processor_design-ziele">Ziele<a class="headerlink" href="#content-image_processor_design-ziele" title="Permanent link">&para;</a></h2>
<ul>
<li>Einheitliche Verarbeitung von Image-Content (JPEG/PNG) über das Processor-Plugin-Modell</li>
<li>Extraktion von EXIF/Meta (Dimensionen, GPS, Kamera), Thumbnail-Erzeugung</li>
<li>Chunking als 3x3 Tile-Grid für lokale Features</li>
<li>Mock-Embedding (768D) kompatibel zum bestehenden Vector-Index (Cosine)</li>
</ul>
<h2 id="content-image_processor_design-contract">Contract<a class="headerlink" href="#content-image_processor_design-contract" title="Permanent link">&para;</a></h2>
<ul>
<li>extract(blob, content_type: image/*) → ExtractionResult</li>
<li>fields:<ul>
<li>width, height (px)</li>
<li>exif: { camera_make, camera_model, focal_length, iso, datetime_original?, gps_lat?, gps_lon? }</li>
<li>mime_type</li>
<li>thumbnail (optional, z. B. 256px Kante, JPEG/PNG)</li>
</ul>
</li>
<li>chunk(extraction, cfg: { grid: 3x3, overlap_px?: 0 }) → [Chunk]</li>
<li>Jeder Chunk repräsentiert ein Tile (row, col, bbox_px)</li>
<li>payload: { tile_bbox: {x,y,w,h}, stats: { mean_rgb, std_rgb } }</li>
<li>generateEmbedding(chunk_payload) → float[768]</li>
<li>Mock-CLIP: deterministische Hash-Verteilung über Pixel-Statistiken + Position</li>
<li>L2-normalisiert</li>
</ul>
<h2 id="content-image_processor_design-datenablage-schlusseljson">Datenablage (Schlüssel/JSON)<a class="headerlink" href="#content-image_processor_design-datenablage-schlusseljson" title="Permanent link">&para;</a></h2>
<ul>
<li>content:<id> → Meta (mime_type,image meta, exif, dims)</li>
<li>content_blob:<id> → Originalbild (binary)</li>
<li>content_thumbnail:<id> → Thumbnail (binary)</li>
<li>content_chunks:<id> → [chunk_ids]</li>
<li>chunk:<chunk_id> → { parent_id, row, col, bbox_px, stats, embedding_ref }</li>
<li>Hinweis: Vector-Index unter Namespace "chunks" (dim=768, COSINE)</li>
</ul>
<h2 id="content-image_processor_design-tile-spezifikation">Tile-Spezifikation<a class="headerlink" href="#content-image_processor_design-tile-spezifikation" title="Permanent link">&para;</a></h2>
<ul>
<li>Grid 3x3 über (width,height)</li>
<li>bbox_px Berechnung: floor/ceil so verteilen, dass alle Pixel abgedeckt sind</li>
<li>stats: mean/std RGB (grob, optional proxy aus Thumbnail/Downscale)</li>
</ul>
<h2 id="content-image_processor_design-embedding-mock">Embedding (Mock)<a class="headerlink" href="#content-image_processor_design-embedding-mock" title="Permanent link">&para;</a></h2>
<ul>
<li>Input: { mean_rgb, std_rgb, row, col, width, height }</li>
<li>Hash-basierte Projektion mit 3 Seeds → 768D; leichte Positionskodierung</li>
<li>L2-Normalisierung (Cosine-kompatibel)</li>
</ul>
<h2 id="content-image_processor_design-exifmeta">EXIF/Meta<a class="headerlink" href="#content-image_processor_design-exifmeta" title="Permanent link">&para;</a></h2>
<ul>
<li>Felder:</li>
<li>Dimensionen: width/height</li>
<li>Kamera: make/model</li>
<li>Aufnahme: datetime_original, iso, focal_length</li>
<li>GPS: gps_lat, gps_lon (falls vorhanden)</li>
<li>Fehlertoleranz: fehlende EXIF zulässig; gps optional</li>
</ul>
<h2 id="content-image_processor_design-tests-20-unit-tests">Tests (20 Unit Tests)<a class="headerlink" href="#content-image_processor_design-tests-20-unit-tests" title="Permanent link">&para;</a></h2>
<p>1-3) extract: liest width/height korrekt (JPEG/PNG Samples)
4) extract: fehlende EXIF → Felder optional
5) extract: GPS parsing korrekt
6-10) chunk: 3x3 Tiles count/bbox korrekt, Gesamtfläche abgedeckt
11-13) chunk: stats plausibel (mean in [0,1], std ≥ 0)
14-17) embedding: dimension=768, L2≈1.0, deterministisch bei idempotentem Input
18) embedding: unterschiedliche Tiles → unterschiedliche Vektoren (cosine&lt;0.99)
19) integration: ingest → vector index init (dim 768)
20) integration: retrieval of chunks ohne Embeddings (Datenschutz/Antwortgröße)</p>
<h2 id="content-image_processor_design-open-points">Open Points<a class="headerlink" href="#content-image_processor_design-open-points" title="Permanent link">&para;</a></h2>
<ul>
<li>Farbmanagement/EXIF-Orientierung berücksichtigen (Rotation)</li>
<li>Downscale-Strategie (schneller Pfad via Thumbnail)</li>
<li>Erweiterung: Face/Logo-Detektion (später, extern)</li>
</ul></section></section>
                    <section class='print-page md-section' id='section-8' heading-number='8'>
                        <h1>Suche<a class='headerlink' href='#section-8' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="search-hybrid_search_design" heading-number="8.1"><h1 id="search-hybrid_search_design-hybrid-search-design-phase-4">Hybrid Search – Design (Phase 4)<a class="headerlink" href="#search-hybrid_search_design-hybrid-search-design-phase-4" title="Permanent link">&para;</a></h1>
<p>Kombiniert Vektorähnlichkeit (Chunks) mit Graph-Expansion und optionalen Filtern, um robuste Ergebnisse über Content-Chunks zu liefern.</p>
<h2 id="search-hybrid_search_design-ziele">Ziele<a class="headerlink" href="#search-hybrid_search_design-ziele" title="Permanent link">&para;</a></h2>
<ul>
<li>Semantische Suche (Vector Top-K) + Kontext-Expansion (Graph n-hop)</li>
<li>Score-Fusion aus Embedding-Similarity und Graph-Distanz/Topologie</li>
<li>Filterbarkeit (category, mime_type, metadata-*), Pagination</li>
</ul>
<h2 id="search-hybrid_search_design-ablauf">Ablauf<a class="headerlink" href="#search-hybrid_search_design-ablauf" title="Permanent link">&para;</a></h2>
<p>1) Query-Embedding (dim wie Index; z. B. 768D)
2) Vector Top-K über Namespace "chunks" (Whitelist optional)
3) Graph-Expansion: für gefundene Chunks → n-Hop Nachbarn (prev/next/parent/geo)
4) Re-Scoring:
   - final = alpha * sim - beta * graph_distance - gamma * hop
   - Deduplikation pro Content (Top-Chunk + Bonus für konsistente Mehrfachtreffer)
5) Filter anwenden (serverseitig vor/nach Fusion, je nach Kosten)
6) Sortierung + Pagination (limit/offset oder Cursor)</p>
<h2 id="search-hybrid_search_design-api-skizze">API (Skizze)<a class="headerlink" href="#search-hybrid_search_design-api-skizze" title="Permanent link">&para;</a></h2>
<ul>
<li>POST /search/hybrid</li>
</ul>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;text or vector&quot;,
  &quot;embedding&quot;: [..optional..],
  &quot;k&quot;: 20,
  &quot;expand&quot;: {&quot;hops&quot;: 1, &quot;edges&quot;: [&quot;parent&quot;,&quot;next&quot;,&quot;prev&quot;,&quot;geo&quot;]},
  &quot;filters&quot;: {&quot;category&quot;: [&quot;TEXT&quot;,&quot;IMAGE&quot;,&quot;GEO&quot;], &quot;mime_type&quot;: [&quot;image/jpeg&quot;], &quot;metadata&quot;: {&quot;dataset&quot;: &quot;LSG&quot;}},
  &quot;scoring&quot;: {&quot;alpha&quot;: 1.0, &quot;beta&quot;: 0.2, &quot;gamma&quot;: 0.1}
}
</code></pre>
<ul>
<li>Response: Liste von Chunks (mit parent content meta), Score, ggf. Pfad/Expansion-Evidence</li>
</ul>
<h2 id="search-hybrid_search_design-storageindex-annahmen">Storage/Index-Annahmen<a class="headerlink" href="#search-hybrid_search_design-storageindex-annahmen" title="Permanent link">&para;</a></h2>
<ul>
<li>Vector-Index: "chunks" (dim=768 für Text/Image; Geo 128D → ggf. getrennte Namespaces)</li>
<li>Graph: Kanten parent/child, next/prev (Dokument-Order), geo (räumliche Nähe)</li>
<li>Sekundärindizes: category, mime_type, metadata.dataset</li>
</ul>
<h2 id="search-hybrid_search_design-edge-cases">Edge Cases<a class="headerlink" href="#search-hybrid_search_design-edge-cases" title="Permanent link">&para;</a></h2>
<ul>
<li>Leeres/kurzes Query → Fallback auf Filter/Graph-only</li>
<li>Heterogene Dimensionen (Text 768D, Geo 128D) → getrennte Indizes + späte Fusion</li>
<li>Große Hops → harte Limits, Zeitouts, Soft-Cutoff</li>
</ul>
<h2 id="search-hybrid_search_design-tests-skizze">Tests (Skizze)<a class="headerlink" href="#search-hybrid_search_design-tests-skizze" title="Permanent link">&para;</a></h2>
<ul>
<li>Top-K stabil, Fusion deterministisch bei fixierten Parametern</li>
<li>Filter wirksam (before/after Fusion), Paginierung korrekt</li>
<li>Graph-Expansion erhöht Recall (nachweisbar an Testdaten)</li>
</ul></section><section class="print-page" id="search-pagination_benchmarks" heading-number="8.2"><h1 id="search-pagination_benchmarks-pagination-benchmarks-offset-vs-cursor">Pagination Benchmarks: Offset vs Cursor<a class="headerlink" href="#search-pagination_benchmarks-pagination-benchmarks-offset-vs-cursor" title="Permanent link">&para;</a></h1>
<p>Dieser Leitfaden beschreibt zwei Microbenchmarks zur Pagination-Performance:</p>
<ul>
<li>Offset-basierte Pagination (ORDER BY + LIMIT offset,count mit Post-Slicing)</li>
<li>Cursor-basierte Pagination (Anchor-based Start-after mit LIMIT count+1)</li>
</ul>
<p>Quelle: <code>benchmarks/bench_query.cpp</code></p>
<h2 id="search-pagination_benchmarks-setup">Setup<a class="headerlink" href="#search-pagination_benchmarks-setup" title="Permanent link">&para;</a></h2>
<p>Beim ersten Lauf wird eine Testdatenbank unter <code>data/themis_bench_query</code> erzeugt. Es werden <code>bench_users</code>-Entities mit Range-Index auf <code>age</code> angelegt.</p>
<h2 id="search-pagination_benchmarks-benchmarks">Benchmarks<a class="headerlink" href="#search-pagination_benchmarks-benchmarks" title="Permanent link">&para;</a></h2>
<ul>
<li><code>BM_Pagination_Offset(page_size=50, pages=50)</code></li>
<li><code>BM_Pagination_Cursor(page_size=50, pages=50)</code></li>
</ul>
<p>Offset-Variante setzt <code>orderBy.limit = offset + count</code> und schneidet die Seite nachträglich (wie der HTTP-Pfad). Cursor-Variante nutzt <code>(cursor_value, cursor_pk)</code> als Anchor und <code>LIMIT count+1</code> zur <code>has_more</code>-Erkennung.</p>
<h2 id="search-pagination_benchmarks-ausfuhren-optional">Ausführen (optional)<a class="headerlink" href="#search-pagination_benchmarks-ausfuhren-optional" title="Permanent link">&para;</a></h2>
<pre><code class="language-powershell"># Reconfigure to ensure benchmarks are built (once)
cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release -DTHEMIS_BUILD_BENCHMARKS=ON
cmake --build . --config Release --parallel

# Run only pagination benchmarks
.\Release\themis_benchmarks.exe --benchmark_filter=BM_Pagination_.*
</code></pre>
<p>Hinweis: Zeiten können durch I/O-Cache und Hardware variieren. Für reproduzierbare Messungen ggf. mehrfach ausführen und Mittelwerte bilden.</p>
<h2 id="search-pagination_benchmarks-interpretation">Interpretation<a class="headerlink" href="#search-pagination_benchmarks-interpretation" title="Permanent link">&para;</a></h2>
<ul>
<li>Offset-Pagination: Aufwand wächst mit <code>offset</code> (Index muss die Einträge bis zur Seite traversieren).</li>
<li>Cursor-Pagination: Konstante Arbeit pro Seite (Start-after) – stabil bei großen Datenmengen.</li>
</ul>
<p>In Einzelfällen kann die Cursor-Variante durch zusätzliche Entity-Loads (Anchor-Ermittlung) leicht höhere CPU-Zeit zeigen; mit warmem Cache und realistischen Daten ist sie bei großen Offsets typischerweise überlegen.</p></section></section>
                    <section class='print-page md-section' id='section-9' heading-number='9'>
                        <h1>Performance & Benchmarks<a class='headerlink' href='#section-9' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="performance_benchmarks" heading-number="9.1"><h1 id="performance_benchmarks-performance-benchmarks">Performance &amp; Benchmarks<a class="headerlink" href="#performance_benchmarks-performance-benchmarks" title="Permanent link">&para;</a></h1>
<p>Dieser Leitfaden konsolidiert die wichtigsten Performance-Themen und Microbenchmarks in ThemisDB: Kompression, Pagination, MVCC vs. WriteBatch, Index-Rebuilds und Vector-Suche. Er beschreibt Messmethodik, Interpretation und konkrete Tuning-Empfehlungen.</p>
<h2 id="performance_benchmarks-ziele-und-erfolgsmetriken">Ziele und Erfolgsmetriken<a class="headerlink" href="#performance_benchmarks-ziele-und-erfolgsmetriken" title="Permanent link">&para;</a></h2>
<ul>
<li>Schreibrate und -latenz unter realistischen Index-Setups</li>
<li>Leselatenzen für typische Abfragepfade (Equal/Range/Cursor)</li>
<li>Speicherbedarf und Write Amplification unter verschiedenen Kompressionsmodi</li>
<li>Rebuild-/Reindex-Durchsatz und Fortschrittsmetriken</li>
<li>Vector-Suche: Latenz vs. Genauigkeit (HNSW efSearch)</li>
</ul>
<h2 id="performance_benchmarks-methodik">Methodik<a class="headerlink" href="#performance_benchmarks-methodik" title="Permanent link">&para;</a></h2>
<ul>
<li>Alle Microbenchmarks basieren auf Google Benchmark und laufen isoliert mit reproduzierbaren Seeds.</li>
<li>Ergebnisse hängen stark von Hardware, OS, Compiler und Cache-Zustand ab; mehrere Läufe und Mittelwerte bilden.</li>
<li>Metriken über Prometheus (/metrics) und RocksDB Properties ergänzen (z. B. SST-Größen, Compactions).</li>
</ul>
<h2 id="performance_benchmarks-benchmarks-ausfuhren-optional">Benchmarks ausführen (optional)<a class="headerlink" href="#performance_benchmarks-benchmarks-ausfuhren-optional" title="Permanent link">&para;</a></h2>
<p>Hinweis: Beispiel für Windows PowerShell, Release-Build und aktivierte Benchmarks.</p>
<pre><code class="language-powershell"># Im Build-Ordner (falls nicht vorhanden, erzeugen)
cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release -DTHEMIS_BUILD_BENCHMARKS=ON
cmake --build . --config Release --parallel

# Alle Benchmarks
.\Release\themis_benchmarks.exe --benchmark_repetitions=3

# Nur Pagination
.\Release\themis_benchmarks.exe --benchmark_filter=BM_Pagination_.*

# Nur CRUD/MVCC
.\Release\themis_benchmarks.exe --benchmark_filter=CRUDFixture|MVCCFixture
</code></pre>
<p>Siehe auch: spezifische Seiten unten für Filter und Setups.</p>
<h2 id="performance_benchmarks-kompression-none-vs-lz4-vs-zstd">Kompression: none vs lz4 vs zstd<a class="headerlink" href="#performance_benchmarks-kompression-none-vs-lz4-vs-zstd" title="Permanent link">&para;</a></h2>
<p>Quelle: <code>benchmarks/bench_compression.cpp</code>, Dokumentation: <a href="#compression_benchmarks">Kompressionsvalidierung &amp; Benchmarks</a></p>
<p>Kernaussagen (aus Messungen):
- Kleine Entities (≤ 1 KB): lz4/zstd oft schneller als none (I/O-Reduktion &gt; CPU-Overhead)
- Mittlere Größen (~4 KB): ähnlich; zstd minimal besser bei hoher Kompressibilität
- Große Blobs (≥ 16 KB): none schneller (CPU-Kosten der Kompression dominieren)
- Reads (warm cache): none am schnellsten; in I/O-limitierten Szenarien kann Kompression dennoch helfen</p>
<p>Empfohlene Hybrid-Konfiguration:</p>
<pre><code class="language-json">&quot;compression&quot;: {
  &quot;default&quot;: &quot;lz4&quot;,
  &quot;bottommost&quot;: &quot;zstd&quot;
}
</code></pre>
<p>Write Amplification einschätzen und messen:
- SST-Größe reduziert Kompaktionsarbeit → geringere Write Amplification bei kompressiblen JSON
- Exakt messen über RocksDB <code>GetProperty("rocksdb.total-sst-files-size")</code> vor/nach Workloads</p>
<p>Weitere Details und Tabellen: siehe <a href="#compression_benchmarks">compression_benchmarks.md</a></p>
<h2 id="performance_benchmarks-pagination-offset-vs-cursor-anchor">Pagination: Offset vs Cursor (Anchor)<a class="headerlink" href="#performance_benchmarks-pagination-offset-vs-cursor-anchor" title="Permanent link">&para;</a></h2>
<p>Quelle: <code>benchmarks/bench_query.cpp</code>, Dokumentation: <a href="#search-pagination_benchmarks">Pagination Benchmarks</a></p>
<ul>
<li>Offset: Aufwand wächst linear mit dem Offset (Index traversiert alle Einträge bis zur Seite)</li>
<li>Cursor/Anchor: konstante Arbeit pro Seite via start-after <code>(cursor_value, cursor_pk)</code> und <code>LIMIT count+1</code></li>
<li>Praxisempfehlung: Cursor-Pagination für große Datenmengen; siehe <a href="#cursor_pagination">Cursor/Pagination</a> für API/Beispiele</li>
</ul>
<p>Optional reproduzieren:</p>
<pre><code class="language-powershell">.\Release\themis_benchmarks.exe --benchmark_filter=BM_Pagination_.*
</code></pre>
<h2 id="performance_benchmarks-mvcc-vs-writebatch-und-crud-durchsatz">MVCC vs WriteBatch und CRUD-Durchsatz<a class="headerlink" href="#performance_benchmarks-mvcc-vs-writebatch-und-crud-durchsatz" title="Permanent link">&para;</a></h2>
<p>Quelle: <code>benchmarks/bench_mvcc.cpp</code>, <code>benchmarks/bench_crud.cpp</code></p>
<ul>
<li>MVCC (Transaction) bietet Snapshot-Isolation und komfortable Rollbacks; leichter Overhead vs. WriteBatch</li>
<li>WriteBatch ist minimal schneller bei Bulk-Inserts, aber ohne Isolation/Locks</li>
<li>Indexschwere Workloads (mehrere Sekundärindizes) skalieren besser mit Batching (100+ pro Commit)</li>
</ul>
<p>Empfehlungen:
- Einzel- und kleine Writes: MVCC für Korrektheit, besonders bei parallelen Reads
- Bulk-Import: WriteBatch nutzen, WAL optional deaktivieren, danach <code>flush()</code>
- Allgemein: Batches von 100–1000 Entities für Throughput optimieren</p>
<h2 id="performance_benchmarks-index-rebuilds-und-reindex">Index-Rebuilds und Reindex<a class="headerlink" href="#performance_benchmarks-index-rebuilds-und-reindex" title="Permanent link">&para;</a></h2>
<p>Quelle: <code>benchmarks/bench_index_rebuild.cpp</code>, Dokumentation: <a href="#index_stats_maintenance">Index-Statistiken &amp; Wartung</a></p>
<ul>
<li>Rebuild pro Index-Typ (Regular/Composite/Range/Sparse/Geo/TTL/Fulltext) separat messbar</li>
<li>Gesamt-Reindex pro Tabelle berücksichtigt alle Indizes; IO- und CPU-limitierte Phasen möglich</li>
<li>Fortschritt über Prometheus-Metriken und interne Counters beobachten</li>
</ul>
<p>Wichtige Metriken (Auswahl):
- <code>themis_index_rebuild_count</code>, <code>themis_index_rebuild_duration_ms_total</code>
- <code>themis_index_rebuild_entities_processed_total</code>
- <code>themis_index_cursor_anchor_hits_total</code>, <code>themis_index_range_scan_steps_total</code></p>
<h2 id="performance_benchmarks-vector-suche-hnsw-tuning">Vector-Suche (HNSW) Tuning<a class="headerlink" href="#performance_benchmarks-vector-suche-hnsw-tuning" title="Permanent link">&para;</a></h2>
<p>Voraussetzung: Build mit HNSW (<code>THEMIS_HNSW_ENABLED</code>). Konfiguration siehe Deployment:
- <code>engine</code>: "hnsw"
- <code>hnsw_m</code>: Nachbarschaftsgrad (Speicher/Genauigkeit)
- <code>hnsw_ef_construction</code>: Aufbau-Qualität (Indexierzeit/Genauigkeit)
- Laufzeit-Tuning: <code>setEfSearch(ef)</code> steigert Recall mit mehr Sucharbeit (höhere Latenz)</p>
<p>Empfehlungen:
- Startwerte: <code>m=16</code>, <code>ef_construction=200</code>, <code>efSearch=32–128</code> je nach k und Datenbankgröße
- Persistenz nutzen (<code>saveIndex</code>/<code>loadIndex</code>) für schnellere Warmstarts
- Bei reiner CPU-Suche: Vektoren normalisieren, kleineren Dimensionalitätsraum bevorzugen</p>
<p>Benchmarks (implementiert in <code>benchmarks/bench_vector_search.cpp</code>):
- BM_VectorSearch_efSearch(ef,k): Sweep über <code>efSearch</code> für k-NN (Latenz vs. Suchaufwand)
- BM_VectorInsert_Batch100(dim): Insert-Durchsatz in 100er Batches</p>
<p>Optional ausführen (PowerShell):</p>
<pre><code class="language-powershell">.\Release\themis_benchmarks.exe --benchmark_filter=BM_Vector(Search|Insert)_.*
</code></pre>
<h2 id="performance_benchmarks-best-practices-und-tuning-checkliste">Best Practices und Tuning-Checkliste<a class="headerlink" href="#performance_benchmarks-best-practices-und-tuning-checkliste" title="Permanent link">&para;</a></h2>
<ul>
<li>Batching: Schreib- und Indexoperationen in Batches (100–1000) bündeln</li>
<li>Cursor-Pagination statt Offset für große Offsets einsetzen</li>
<li>Kompression hybrid (lz4 + zstd bottommost); große Binärblobs ggf. ohne Kompression</li>
<li>RocksDB-Tuning: Memtable/Block-Cache passend zur Workload, Hintergrundjobs ausreichend hoch</li>
<li>Kalte vs. warme Messungen getrennt betrachten; OS-Cache explizit berücksichtigen</li>
<li>Rebuilds in Wartungsfenstern; Fortschritt/Metriken überwachen</li>
<li>Vector-Suche: <code>efSearch</code> dynamisch an SLOs anpassen (Latenz/Recall)</li>
</ul>
<h2 id="performance_benchmarks-referenzen">Referenzen<a class="headerlink" href="#performance_benchmarks-referenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#compression_benchmarks">compression_benchmarks.md</a></li>
<li><a href="#search-pagination_benchmarks">search/pagination_benchmarks.md</a></li>
<li><a href="#indexes">indexes.md</a></li>
<li><a href="#index_stats_maintenance">index_stats_maintenance.md</a></li>
<li><a href="#memory_tuning">memory_tuning.md</a></li>
</ul></section><section class="print-page" id="compression_benchmarks" heading-number="9.2"><h1 id="compression_benchmarks-kompressionsvalidierung-und-benchmarks">Kompressionsvalidierung und Benchmarks<a class="headerlink" href="#compression_benchmarks-kompressionsvalidierung-und-benchmarks" title="Permanent link">&para;</a></h1>
<p><strong>Datum:</strong> 27. Oktober 2025<br />
<strong>System:</strong> Windows 11, MSVC 19.44, 20 CPU cores @ 3.7 GHz</p>
<h2 id="compression_benchmarks-validierung">Validierung<a class="headerlink" href="#compression_benchmarks-validierung" title="Permanent link">&para;</a></h2>
<p>Die Kompression wurde zur Laufzeit verifiziert:
- <strong>none:</strong> <code>default=none, bottommost=none</code>
- <strong>lz4:</strong> <code>default=lz4, bottommost=lz4</code>
- <strong>zstd:</strong> <code>default=zstd, bottommost=zstd</code></p>
<p>RocksDB nutzt die in vcpkg.json aktivierten Features (<code>lz4</code>, <code>zstd</code>) korrekt.</p>
<h2 id="compression_benchmarks-benchmark-ergebnisse">Benchmark-Ergebnisse<a class="headerlink" href="#compression_benchmarks-benchmark-ergebnisse" title="Permanent link">&para;</a></h2>
<h3 id="compression_benchmarks-sequential-write-1000-keys-per-iteration">Sequential Write (1000 keys per iteration)<a class="headerlink" href="#compression_benchmarks-sequential-write-1000-keys-per-iteration" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Compression</th>
<th>Blob Size</th>
<th>Time/Iter</th>
<th>Throughput (MB/s)</th>
<th>Items/s</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>512B</td>
<td>23.6 ms</td>
<td>22.7 MB/s</td>
<td>46.4k</td>
</tr>
<tr>
<td><strong>lz4</strong></td>
<td>512B</td>
<td>22.0 ms</td>
<td>24.1 MB/s</td>
<td>49.3k</td>
</tr>
<tr>
<td><strong>zstd</strong></td>
<td>512B</td>
<td>21.9 ms</td>
<td>25.6 MB/s</td>
<td>52.5k</td>
</tr>
<tr>
<td>none</td>
<td>4KB</td>
<td>29.7 ms</td>
<td>147.7 MB/s</td>
<td>37.8k</td>
</tr>
<tr>
<td><strong>lz4</strong></td>
<td>4KB</td>
<td>31.2 ms</td>
<td>141.0 MB/s</td>
<td>36.1k</td>
</tr>
<tr>
<td><strong>zstd</strong></td>
<td>4KB</td>
<td>31.6 ms</td>
<td>148.6 MB/s</td>
<td>38.1k</td>
</tr>
<tr>
<td>none</td>
<td>16KB</td>
<td>49.8 ms</td>
<td>348.8 MB/s</td>
<td>22.3k</td>
</tr>
<tr>
<td><strong>lz4</strong></td>
<td>16KB</td>
<td>54.1 ms</td>
<td>289.5 MB/s</td>
<td>18.5k</td>
</tr>
<tr>
<td><strong>zstd</strong></td>
<td>16KB</td>
<td>53.4 ms</td>
<td>294.1 MB/s</td>
<td>18.8k</td>
</tr>
</tbody>
</table>
<h3 id="compression_benchmarks-random-read-warm-cache-1000-pre-populated-keys">Random Read (warm cache, 1000 pre-populated keys)<a class="headerlink" href="#compression_benchmarks-random-read-warm-cache-1000-pre-populated-keys" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Compression</th>
<th>Blob Size</th>
<th>Latency (µs)</th>
<th>Items/s</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>4KB</td>
<td>2.32</td>
<td>434k</td>
</tr>
<tr>
<td><strong>lz4</strong></td>
<td>4KB</td>
<td>2.63</td>
<td>383k</td>
</tr>
<tr>
<td><strong>zstd</strong></td>
<td>4KB</td>
<td>2.61</td>
<td>412k</td>
</tr>
</tbody>
</table>
<h2 id="compression_benchmarks-interpretation">Interpretation<a class="headerlink" href="#compression_benchmarks-interpretation" title="Permanent link">&para;</a></h2>
<h3 id="compression_benchmarks-write-performance">Write Performance<a class="headerlink" href="#compression_benchmarks-write-performance" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Kleine Blobs (512B):</strong><br />
  ZSTD und LZ4 <strong>schneller</strong> als <code>none</code> (~7-13% Verbesserung). Die Kompression reduziert I/O und Write Amplification stärker als die CPU-Kosten wiegen.</p>
</li>
<li>
<p><strong>Mittlere Blobs (4KB):</strong><br />
  Alle drei Varianten ähnlich (~147 MB/s). ZSTD minimal schneller bei hoher Kompressibilität.</p>
</li>
<li>
<p><strong>Große Blobs (16KB):</strong><br />
<code>none</code> <strong>deutlich schneller</strong> (+20% gegenüber LZ4/ZSTD). CPU-Kosten für Kompression überwiegen I/O-Einsparungen bei großen Payloads.</p>
</li>
</ul>
<h3 id="compression_benchmarks-read-performance">Read Performance<a class="headerlink" href="#compression_benchmarks-read-performance" title="Permanent link">&para;</a></h3>
<ul>
<li>LZ4 und ZSTD fügen ~14% Latenz hinzu (Dekompressions-Overhead).</li>
<li>Bei Cache-Hits (reiner memcpy) ist <code>none</code> am schnellsten.</li>
<li>Im realen Betrieb mit Disk-I/O kann Kompression durch geringere Datenmengen schneller sein.</li>
</ul>
<h2 id="compression_benchmarks-empfehlungen">Empfehlungen<a class="headerlink" href="#compression_benchmarks-empfehlungen" title="Permanent link">&para;</a></h2>
<ol>
<li>
<p><strong>Für hohen Write-Throughput mit kleineren Entities (&lt; 1KB):</strong><br />
   → <strong>ZSTD</strong> (default) oder <strong>LZ4</strong> (bottommost) nutzen</p>
</li>
<li>
<p><strong>Für große BLOBs (&gt; 8KB) oder read-heavy Workloads:</strong><br />
   → <strong>LZ4</strong> für Reads mit weniger Latenz; oder <strong>none</strong> für maximalen Read-Durchsatz</p>
</li>
<li>
<p><strong>Hybrid-Konfiguration (empfohlen):</strong>
   <code>json
   "compression": {
     "default": "lz4",
     "bottommost": "zstd"
   }</code>
   Frische Daten (L0) mit LZ4 schnell komprimiert; ältere Levels (bottommost) mit ZSTD platzsparend.</p>
</li>
</ol>
<h2 id="compression_benchmarks-write-amplification">Write Amplification<a class="headerlink" href="#compression_benchmarks-write-amplification" title="Permanent link">&para;</a></h2>
<p>Ohne direkte Messung lässt sich aus den Benchmarks ableiten:
- Kompression reduziert SSTable-Größe → weniger Compaction-Aufwand
- Bei kompressiblen JSON-Daten (Faktor ~3-5x) führt Kompression zu <strong>niedrigerer Write Amplification</strong></p>
<p>Für genaue Werte: RocksDB-Property <code>rocksdb.total-sst-files-size</code> vor/nach Schreibvorgängen prüfen.</p>
<h2 id="compression_benchmarks-nachste-schritte">Nächste Schritte<a class="headerlink" href="#compression_benchmarks-nachste-schritte" title="Permanent link">&para;</a></h2>
<ul>
<li>[ ] Write Amplification mit RocksDB <code>GetProperty("rocksdb.total-sst-files-size")</code> messen</li>
<li>[ ] Disk-I/O Benchmarks (cold cache) mit verschiedenen Kompressionen</li>
<li>[ ] Speicherplatzvergleich nach 10k/100k Entities</li>
</ul></section><section class="print-page" id="search-pagination_benchmarks" heading-number="9.3"><h1 id="search-pagination_benchmarks-pagination-benchmarks-offset-vs-cursor">Pagination Benchmarks: Offset vs Cursor<a class="headerlink" href="#search-pagination_benchmarks-pagination-benchmarks-offset-vs-cursor" title="Permanent link">&para;</a></h1>
<p>Dieser Leitfaden beschreibt zwei Microbenchmarks zur Pagination-Performance:</p>
<ul>
<li>Offset-basierte Pagination (ORDER BY + LIMIT offset,count mit Post-Slicing)</li>
<li>Cursor-basierte Pagination (Anchor-based Start-after mit LIMIT count+1)</li>
</ul>
<p>Quelle: <code>benchmarks/bench_query.cpp</code></p>
<h2 id="search-pagination_benchmarks-setup">Setup<a class="headerlink" href="#search-pagination_benchmarks-setup" title="Permanent link">&para;</a></h2>
<p>Beim ersten Lauf wird eine Testdatenbank unter <code>data/themis_bench_query</code> erzeugt. Es werden <code>bench_users</code>-Entities mit Range-Index auf <code>age</code> angelegt.</p>
<h2 id="search-pagination_benchmarks-benchmarks">Benchmarks<a class="headerlink" href="#search-pagination_benchmarks-benchmarks" title="Permanent link">&para;</a></h2>
<ul>
<li><code>BM_Pagination_Offset(page_size=50, pages=50)</code></li>
<li><code>BM_Pagination_Cursor(page_size=50, pages=50)</code></li>
</ul>
<p>Offset-Variante setzt <code>orderBy.limit = offset + count</code> und schneidet die Seite nachträglich (wie der HTTP-Pfad). Cursor-Variante nutzt <code>(cursor_value, cursor_pk)</code> als Anchor und <code>LIMIT count+1</code> zur <code>has_more</code>-Erkennung.</p>
<h2 id="search-pagination_benchmarks-ausfuhren-optional">Ausführen (optional)<a class="headerlink" href="#search-pagination_benchmarks-ausfuhren-optional" title="Permanent link">&para;</a></h2>
<pre><code class="language-powershell"># Reconfigure to ensure benchmarks are built (once)
cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release -DTHEMIS_BUILD_BENCHMARKS=ON
cmake --build . --config Release --parallel

# Run only pagination benchmarks
.\Release\themis_benchmarks.exe --benchmark_filter=BM_Pagination_.*
</code></pre>
<p>Hinweis: Zeiten können durch I/O-Cache und Hardware variieren. Für reproduzierbare Messungen ggf. mehrfach ausführen und Mittelwerte bilden.</p>
<h2 id="search-pagination_benchmarks-interpretation">Interpretation<a class="headerlink" href="#search-pagination_benchmarks-interpretation" title="Permanent link">&para;</a></h2>
<ul>
<li>Offset-Pagination: Aufwand wächst mit <code>offset</code> (Index muss die Einträge bis zur Seite traversieren).</li>
<li>Cursor-Pagination: Konstante Arbeit pro Seite (Start-after) – stabil bei großen Datenmengen.</li>
</ul>
<p>In Einzelfällen kann die Cursor-Variante durch zusätzliche Entity-Loads (Anchor-Ermittlung) leicht höhere CPU-Zeit zeigen; mit warmem Cache und realistischen Daten ist sie bei großen Offsets typischerweise überlegen.</p></section></section><section class="print-page" id="quality_assurance" heading-number="10"><h1 id="quality_assurance-qualitatssicherung-qa">Qualitätssicherung (QA)<a class="headerlink" href="#quality_assurance-qualitatssicherung-qa" title="Permanent link">&para;</a></h1>
<p>Diese Seite beschreibt die Teststrategie, Werkzeuge und Best Practices zur Sicherstellung der Softwarequalität in ThemisDB: Unit/Integration/E2E-Tests, CI/CD, Code Coverage, statische Analysen und Performance-Regressionstests.</p>
<h2 id="quality_assurance-testpyramide-und-abdeckung">Testpyramide und Abdeckung<a class="headerlink" href="#quality_assurance-testpyramide-und-abdeckung" title="Permanent link">&para;</a></h2>
<ul>
<li>Unit-Tests: Logiknah, schnell, unabhängig von I/O (z. B. Parser, Serializer, Hilfsfunktionen)</li>
<li>Integrationstests: Zusammenspiel von Storage/Indexes/Query (z. B. <code>tests/test_*</code>)</li>
<li>E2E-/API-Tests: HTTP-/OpenAPI-Endpunkte, CDC/SSE, Fehlerpfade, Berechtigungen</li>
<li>Performance-Benchmarks: Google Benchmark (stabil, reproduzierbar), keine CI-Gates, aber Trends überwachen</li>
</ul>
<p>Zielabdeckung: 70–80% auf kritischen Kernpfaden (Parser, Index, Query Engine, Storage-Wrapper).</p>
<h2 id="quality_assurance-tests-ausfuhren">Tests ausführen<a class="headerlink" href="#quality_assurance-tests-ausfuhren" title="Permanent link">&para;</a></h2>
<ul>
<li>CTest/Executable (Windows PowerShell Beispiel):</li>
</ul>
<pre><code class="language-powershell"># Build (Release empfohlen für realistischere Ausführungszeiten)
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --config Release --parallel

# Tests
ctest --test-dir build --output-on-failure --parallel

# Alternativ: direktes Binary (falls vorhanden)
.\build\Release\themis_tests.exe
</code></pre>
<h2 id="quality_assurance-struktur-und-namenskonventionen">Struktur und Namenskonventionen<a class="headerlink" href="#quality_assurance-struktur-und-namenskonventionen" title="Permanent link">&para;</a></h2>
<ul>
<li>Testdateien in <code>tests/</code> mit Präfix <code>test_*.cpp</code></li>
<li>Eine Testdatei pro Komponente/Subsystem</li>
<li>Klarer Arrange-Act-Assert-Stil, aussagekräftige Namen, keine versteckten Sleeps/Timing-Hacks</li>
</ul>
<h2 id="quality_assurance-testdaten-strategie">Testdaten-Strategie<a class="headerlink" href="#quality_assurance-testdaten-strategie" title="Permanent link">&para;</a></h2>
<ul>
<li>Deterministische Seeds für Zufallsdaten in Tests und Benchmarks</li>
<li>Kleine, repräsentative Fixtures; große Datensätze nur in Benchmarks/Loadtests</li>
<li>Cleanup von temporären DB-Pfaden pro Test (z. B. unter <code>data/test_*</code>)</li>
</ul>
<h2 id="quality_assurance-cicd-empfehlungen-github-actions">CI/CD-Empfehlungen (GitHub Actions)<a class="headerlink" href="#quality_assurance-cicd-empfehlungen-github-actions" title="Permanent link">&para;</a></h2>
<ul>
<li>Pipelines (Beispiele):</li>
<li>build-and-test: MSVC (Windows) und Clang/GCC (Linux), Release + Debug</li>
<li>static-analysis: clang-tidy, cppcheck (Nur-Warnungen, optional blockend für neue Issues)</li>
<li>coverage: lcov/gcovr (Linux), Artefakte/Badges veröffentlichen</li>
<li>package: Docker-Image bauen, SBOM generieren (Syft), Signatur (cosign) optional</li>
<li>Caching: vcpkg/ccache (Linux) und MSVC Build Cache</li>
<li>Artefakte: Testreports (JUnit), Coverage HTML, Binaries (Nightly)</li>
</ul>
<h2 id="quality_assurance-code-coverage">Code Coverage<a class="headerlink" href="#quality_assurance-code-coverage" title="Permanent link">&para;</a></h2>
<ul>
<li>Linux: <code>-fprofile-arcs -ftest-coverage</code> bzw. <code>-fprofile-instr-generate -fcoverage-mapping</code></li>
<li>Werkzeuge: gcovr/lcov; Ausschlüsse für generierten Code/3rd-Party</li>
<li>Schwellenwerte: z. B. Zeilen ≥ 70%, Funktionen ≥ 75% (nicht hart blockend, aber Trend-basiert)</li>
</ul>
<h2 id="quality_assurance-statische-analysen-linters">Statische Analysen &amp; Linters<a class="headerlink" href="#quality_assurance-statische-analysen-linters" title="Permanent link">&para;</a></h2>
<ul>
<li>clang-tidy: Modernize-, Performance-, Readability-Checks aktivieren</li>
<li>cppcheck: Fehleranfällige Muster, MISRA-ähnliche Regeln wo sinnvoll</li>
<li>Formatierung: clang-format mit projektspezifischem Style; Pre-commit Hook empfohlen</li>
</ul>
<h2 id="quality_assurance-performance-regressionen">Performance-Regressionen<a class="headerlink" href="#quality_assurance-performance-regressionen" title="Permanent link">&para;</a></h2>
<ul>
<li>Google Benchmark-Suite regelmäßig auf dedizierter Maschine ausführen</li>
<li>Relevante Filter: CRUD, MVCC, Pagination, Kompression, Vector-Suche</li>
<li>Veränderungen dokumentieren (Changelog) und auffällige Deltas untersuchen</li>
</ul>
<h2 id="quality_assurance-testbarkeit-architektur">Testbarkeit &amp; Architektur<a class="headerlink" href="#quality_assurance-testbarkeit-architektur" title="Permanent link">&para;</a></h2>
<ul>
<li>Abhängigkeiten injizieren (Interfaces), um I/O zu mocken</li>
<li>Pure Functions bevorzugen, deterministische Uhrzeit/Zufall abstrahieren</li>
<li>Kleine, fokussierte Klassen/Methoden, klare Verantwortlichkeiten</li>
</ul>
<h2 id="quality_assurance-review-checkliste-auszug">Review-Checkliste (Auszug)<a class="headerlink" href="#quality_assurance-review-checkliste-auszug" title="Permanent link">&para;</a></h2>
<ul>
<li>Korrektheit: Tests vorhanden (Happy Path + 1–2 Edge Cases)</li>
<li>Robustheit: Fehlerpfade, Timeouts, Null/Empty-Handling</li>
<li>Performance: Hot Paths, Allokationen, unnötige Kopien, Paging/Batching</li>
<li>Sicherheit: Input-Validierung, Logging von Secrets vermeiden</li>
<li>Docs: Öffentliche APIs und Verhalten dokumentiert, Changelog aktualisiert</li>
</ul>
<h2 id="quality_assurance-nachste-schritte">Nächste Schritte<a class="headerlink" href="#quality_assurance-nachste-schritte" title="Permanent link">&para;</a></h2>
<ul>
<li>CI-Workflows hinzufügen (GitHub Actions) mit Build+Test, static-analysis, Coverage</li>
<li>Abdeckungslücken identifizieren (Reports) und kritische Bereiche priorisieren</li>
<li>Optional: Nightly Performance-Benchmarks mit Trend-Dashboards</li>
</ul></section>
                    <section class='print-page md-section' id='section-11' heading-number='11'>
                        <h1>Vektor & GNN<a class='headerlink' href='#section-11' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="vector_ops" heading-number="11.1"><h1 id="vector_ops-vector-operations">Vector Operations<a class="headerlink" href="#vector_ops-vector-operations" title="Permanent link">&para;</a></h1>
<p>Dieses Dokument beschreibt die Vektor-Indexierungs- und Suchoperationen in Themis.</p>
<h2 id="vector_ops-ubersicht">Übersicht<a class="headerlink" href="#vector_ops-ubersicht" title="Permanent link">&para;</a></h2>
<p>Der <code>VectorIndexManager</code> unterstützt:</p>
<ul>
<li><strong>Batch-Einfügung</strong> (<code>POST /vector/batch_insert</code>) für performante Massenimporte</li>
<li><strong>Gezielte Löschung</strong> (<code>DELETE /vector/by-filter</code>) via PK-Liste oder Key-Präfix</li>
<li><strong>KNN-Suche</strong> (<code>POST /vector/search</code>) mit optionaler Cursor-Pagination</li>
<li><strong>Persistenz</strong> (<code>POST /vector/index/save</code>, <code>POST /vector/index/load</code>) für HNSW-Index</li>
<li><strong>Konfiguration</strong> (<code>GET/PUT /vector/index/config</code>) zur Laufzeit (z. B. <code>efSearch</code>)</li>
<li><strong>Statistiken</strong> (<code>GET /vector/index/stats</code>) für Index-Kennzahlen</li>
</ul>
<h2 id="vector_ops-batch-insert">Batch Insert<a class="headerlink" href="#vector_ops-batch-insert" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-endpoint">Endpoint<a class="headerlink" href="#vector_ops-endpoint" title="Permanent link">&para;</a></h3>
<pre><code>POST /vector/batch_insert
</code></pre>
<h3 id="vector_ops-anfrage">Anfrage<a class="headerlink" href="#vector_ops-anfrage" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;vector_field&quot;: &quot;embedding&quot;,  // Standard: &quot;embedding&quot;
  &quot;items&quot;: [
    {
      &quot;pk&quot;: &quot;doc1&quot;,
      &quot;vector&quot;: [0.1, 0.2, 0.3],
      &quot;fields&quot;: {
        &quot;title&quot;: &quot;Beispiel&quot;,
        &quot;category&quot;: &quot;test&quot;
      }
    },
    {
      &quot;pk&quot;: &quot;doc2&quot;,
      &quot;vector&quot;: [0.4, 0.5, 0.6],
      &quot;fields&quot;: {
        &quot;title&quot;: &quot;Another&quot;,
        &quot;category&quot;: &quot;demo&quot;
      }
    }
  ]
}
</code></pre>
<h3 id="vector_ops-antwort">Antwort<a class="headerlink" href="#vector_ops-antwort" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;inserted&quot;: 2,
  &quot;errors&quot;: 0,
  &quot;objectName&quot;: &quot;vectors&quot;,
  &quot;dimension&quot;: 3
}
</code></pre>
<h3 id="vector_ops-best-practices">Best Practices<a class="headerlink" href="#vector_ops-best-practices" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Batch-Größe</strong>: 100–1000 Einträge pro Request für optimales Latenz/Durchsatz-Verhältnis</li>
<li><strong>Auto-Init</strong>: Wenn <code>dimension</code> = 0, wird der Index automatisch mit der Dimension des ersten Vektors initialisiert</li>
<li><strong>Fehlerbehandlung</strong>: Einzelne fehlerhafte Items werden übersprungen; <code>errors</code>-Feld zählt Ausnahmen</li>
<li><strong>Transaktionssicherheit</strong>: Jedes Item wird atomar geschrieben (RocksDB WriteBatch)</li>
</ul>
<h2 id="vector_ops-delete-by-filter">Delete by Filter<a class="headerlink" href="#vector_ops-delete-by-filter" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-endpoint_1">Endpoint<a class="headerlink" href="#vector_ops-endpoint_1" title="Permanent link">&para;</a></h3>
<pre><code>DELETE /vector/by-filter
</code></pre>
<h3 id="vector_ops-anfrage-pk-liste">Anfrage (PK-Liste)<a class="headerlink" href="#vector_ops-anfrage-pk-liste" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;pks&quot;: [&quot;doc1&quot;, &quot;doc2&quot;, &quot;doc3&quot;]
}
</code></pre>
<h3 id="vector_ops-anfrage-prafix-filter">Anfrage (Präfix-Filter)<a class="headerlink" href="#vector_ops-anfrage-prafix-filter" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;prefix&quot;: &quot;temp-&quot;
}
</code></pre>
<h3 id="vector_ops-antwort_1">Antwort<a class="headerlink" href="#vector_ops-antwort_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;deleted&quot;: 3,
  &quot;method&quot;: &quot;pks&quot;  // oder &quot;prefix&quot;
}
</code></pre>
<h3 id="vector_ops-anwendungsfalle">Anwendungsfälle<a class="headerlink" href="#vector_ops-anwendungsfalle" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Cleanup</strong>: Löschen temporärer oder veralteter Vektoren via Präfix (z. B. <code>tmp-</code>, <code>staging-</code>)</li>
<li><strong>Bulk-Removal</strong>: Liste spezifischer Dokument-IDs nach Qualitätskontrolle</li>
<li><strong>Namensraum-Bereinigung</strong>: Entfernen aller Einträge eines bestimmten Namensraums</li>
</ul>
<h2 id="vector_ops-knn-suche-mit-cursor-pagination">KNN-Suche mit Cursor-Pagination<a class="headerlink" href="#vector_ops-knn-suche-mit-cursor-pagination" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-endpoint_2">Endpoint<a class="headerlink" href="#vector_ops-endpoint_2" title="Permanent link">&para;</a></h3>
<pre><code>POST /vector/search
</code></pre>
<h3 id="vector_ops-anfrage-legacy-modus">Anfrage (Legacy-Modus)<a class="headerlink" href="#vector_ops-anfrage-legacy-modus" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;vector&quot;: [0.1, 0.2, 0.3],
  &quot;k&quot;: 10
}
</code></pre>
<h3 id="vector_ops-antwort-legacy">Antwort (Legacy)<a class="headerlink" href="#vector_ops-antwort-legacy" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;results&quot;: [
    {&quot;pk&quot;: &quot;doc1&quot;, &quot;distance&quot;: 0.05},
    {&quot;pk&quot;: &quot;doc2&quot;, &quot;distance&quot;: 0.12}
  ],
  &quot;k&quot;: 10,
  &quot;count&quot;: 2
}
</code></pre>
<h3 id="vector_ops-anfrage-cursor-pagination">Anfrage (Cursor-Pagination)<a class="headerlink" href="#vector_ops-anfrage-cursor-pagination" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;vector&quot;: [0.1, 0.2, 0.3],
  &quot;k&quot;: 10,
  &quot;use_cursor&quot;: true,
  &quot;cursor&quot;: &quot;20&quot;  // optional; Offset der vorherigen Seite
}
</code></pre>
<h3 id="vector_ops-antwort-cursor-pagination">Antwort (Cursor-Pagination)<a class="headerlink" href="#vector_ops-antwort-cursor-pagination" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;items&quot;: [
    {&quot;pk&quot;: &quot;doc21&quot;, &quot;distance&quot;: 0.08},
    {&quot;pk&quot;: &quot;doc22&quot;, &quot;distance&quot;: 0.09}
  ],
  &quot;batch_size&quot;: 2,
  &quot;has_more&quot;: true,
  &quot;next_cursor&quot;: &quot;30&quot;
}
</code></pre>
<h3 id="vector_ops-best-practices_1">Best Practices<a class="headerlink" href="#vector_ops-best-practices_1" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Page-Size</strong>: k = 10–100 für typische UI-Pagination; k = 100–1000 für Batch-Verarbeitung</li>
<li><strong>HNSW efSearch</strong>: Setze <code>efSearch</code> ≥ k für gute Recall; 64–128 ist ein guter Start</li>
<li><strong>Distanz-Metrik</strong>: COSINE (Standard) für normalisierte Embeddings, L2 für räumliche Daten</li>
<li><strong>Cursor-Verwendung</strong>: Für große Result-Sets (&gt; k) aktiviere <code>use_cursor</code> um Memory-Druck zu reduzieren</li>
</ul>
<h2 id="vector_ops-persistenz">Persistenz<a class="headerlink" href="#vector_ops-persistenz" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-speichern">Speichern<a class="headerlink" href="#vector_ops-speichern" title="Permanent link">&para;</a></h3>
<pre><code>POST /vector/index/save
{ &quot;directory&quot;: &quot;./data/vector_index&quot; }
</code></pre>
<p>Speichert:
- <code>meta.txt</code>: objectName, dimension, metric, efSearch, M, efConstruction
- <code>labels.txt</code>: PK-Mapping (id → PK)
- <code>index.bin</code>: HNSW-Struktur (wenn HNSW aktiviert)</p>
<h3 id="vector_ops-laden">Laden<a class="headerlink" href="#vector_ops-laden" title="Permanent link">&para;</a></h3>
<pre><code>POST /vector/index/load
{ &quot;directory&quot;: &quot;./data/vector_index&quot; }
</code></pre>
<p>Lädt den Index aus persistierten Dateien; überschreibt aktuelle In-Memory-Struktur.</p>
<h3 id="vector_ops-auto-save">Auto-Save<a class="headerlink" href="#vector_ops-auto-save" title="Permanent link">&para;</a></h3>
<p>Setze <code>auto_save=true</code> und <code>savePath</code> via <code>VectorIndexManager::setAutoSavePath()</code> für automatisches Speichern beim Server-Shutdown.</p>
<h2 id="vector_ops-konfiguration-zur-laufzeit">Konfiguration zur Laufzeit<a class="headerlink" href="#vector_ops-konfiguration-zur-laufzeit" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-get-vectorindexconfig">GET /vector/index/config<a class="headerlink" href="#vector_ops-get-vectorindexconfig" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;objectName&quot;: &quot;vectors&quot;,
  &quot;dimension&quot;: 768,
  &quot;metric&quot;: &quot;COSINE&quot;,
  &quot;efSearch&quot;: 64,
  &quot;M&quot;: 16,
  &quot;efConstruction&quot;: 200,
  &quot;hnswEnabled&quot;: true
}
</code></pre>
<h3 id="vector_ops-put-vectorindexconfig">PUT /vector/index/config<a class="headerlink" href="#vector_ops-put-vectorindexconfig" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;efSearch&quot;: 128
}
</code></pre>
<p><strong>Hinweis</strong>: <code>M</code> und <code>efConstruction</code> erfordern Index-Rebuild und können zur Laufzeit nicht geändert werden.</p>
<h2 id="vector_ops-statistiken">Statistiken<a class="headerlink" href="#vector_ops-statistiken" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-get-vectorindexstats">GET /vector/index/stats<a class="headerlink" href="#vector_ops-get-vectorindexstats" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;objectName&quot;: &quot;vectors&quot;,
  &quot;dimension&quot;: 768,
  &quot;metric&quot;: &quot;COSINE&quot;,
  &quot;vectorCount&quot;: 123456,
  &quot;efSearch&quot;: 64,
  &quot;M&quot;: 16,
  &quot;efConstruction&quot;: 200,
  &quot;hnswEnabled&quot;: true
}
</code></pre>
<h2 id="vector_ops-performance-ziele">Performance-Ziele<a class="headerlink" href="#vector_ops-performance-ziele" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Ziel</th>
<th>Bemerkungen</th>
</tr>
</thead>
<tbody>
<tr>
<td>Batch Insert</td>
<td>&lt; 500 ms / 1000 Items</td>
<td>Mit HNSW M=16, efConstruction=200</td>
</tr>
<tr>
<td>KNN Search (k=10)</td>
<td>&lt; 10 ms</td>
<td>efSearch=64, ~100k Vektoren</td>
</tr>
<tr>
<td>Delete by PKs (100)</td>
<td>&lt; 50 ms</td>
<td>Markiert als gelöscht in HNSW</td>
</tr>
<tr>
<td>Delete by Prefix</td>
<td>&lt; 200 ms / 1000 Items</td>
<td>Scan + Batch-Delete</td>
</tr>
<tr>
<td>Index Save</td>
<td>&lt; 2 s / 100k Vectors</td>
<td>Abhängig von IO-Geschwindigkeit</td>
</tr>
<tr>
<td>Index Load</td>
<td>&lt; 1 s / 100k Vectors</td>
<td>Memory-Mapping wenn möglich</td>
</tr>
</tbody>
</table>
<h2 id="vector_ops-metriken-prometheus">Metriken (Prometheus)<a class="headerlink" href="#vector_ops-metriken-prometheus" title="Permanent link">&para;</a></h2>
<p>Die folgenden Metriken sind unter <code>GET /metrics</code> verfügbar:</p>
<ul>
<li><code>vccdb_vector_index_size_bytes</code>: Geschätzte Größe des In-Memory-Index</li>
<li><code>vccdb_vector_search_duration_ms</code>: Histogram der Suchlatenz in Millisekunden</li>
<li><code>vccdb_vector_batch_insert_duration_ms</code>: Histogram der Batch-Insert-Latenz</li>
<li><code>vccdb_vector_batch_insert_total</code>: Counter der gesamten Batch-Insert-Operationen</li>
<li><code>vccdb_vector_batch_insert_items_total</code>: Counter aller eingefügten Items</li>
<li><code>vccdb_vector_delete_by_filter_total</code>: Counter der Delete-by-Filter-Operationen</li>
<li><code>vccdb_vector_delete_by_filter_items_total</code>: Counter aller gelöschten Items</li>
</ul>
<h2 id="vector_ops-haufige-fragen-faq">Häufige Fragen (FAQ)<a class="headerlink" href="#vector_ops-haufige-fragen-faq" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-q-wie-gehe-ich-mit-groen-datenmengen-um-1-mio-vektoren">Q: Wie gehe ich mit großen Datenmengen um (&gt; 1 Mio. Vektoren)?<a class="headerlink" href="#vector_ops-q-wie-gehe-ich-mit-groen-datenmengen-um-1-mio-vektoren" title="Permanent link">&para;</a></h3>
<p>A: 
1. Batch-Insert in Blöcken von 500–1000 Items
2. Setze <code>M=32</code> und <code>efConstruction=400</code> für bessere Qualität (höhere Build-Zeit)
3. Nutze <code>efSearch=128–200</code> zur Suche für höhere Recall
4. Aktiviere Auto-Save + regelmäßige Checkpoints
5. Erwäge Sharding (mehrere Indizes) für Skalierung über 10 Mio. Vektoren</p>
<h3 id="vector_ops-q-wie-optimiere-ich-die-suche-fur-niedrige-latenz">Q: Wie optimiere ich die Suche für niedrige Latenz?<a class="headerlink" href="#vector_ops-q-wie-optimiere-ich-die-suche-fur-niedrige-latenz" title="Permanent link">&para;</a></h3>
<p>A:
1. Reduziere <code>efSearch</code> auf 32–64 (Kompromiss: niedrigere Recall)
2. Setze <code>k</code> so niedrig wie möglich (z. B. k=10 statt k=100)
3. Nutze Cursor-Pagination für große Result-Sets
4. Cache häufige Queries (siehe <code>docs/cdc.md</code> für Semantic Cache)</p>
<h3 id="vector_ops-q-kann-ich-mehrere-vektorindizes-parallel-betreiben">Q: Kann ich mehrere Vektorindizes parallel betreiben?<a class="headerlink" href="#vector_ops-q-kann-ich-mehrere-vektorindizes-parallel-betreiben" title="Permanent link">&para;</a></h3>
<p>A: Im aktuellen MVP unterstützt <code>VectorIndexManager</code> einen Index pro Instanz. Für mehrere Namensräume:
- Option 1: Separater <code>VectorIndexManager</code> pro Namespace (mehrere Server-Instanzen)
- Option 2: Präfix-Trennung im objectName (z. B. <code>docs_en</code>, <code>docs_de</code>)</p>
<h3 id="vector_ops-q-was-passiert-bei-dimensionskonflikten">Q: Was passiert bei Dimensionskonflikten?<a class="headerlink" href="#vector_ops-q-was-passiert-bei-dimensionskonflikten" title="Permanent link">&para;</a></h3>
<p>A: Wenn ein Vektor mit falscher Dimension eingefügt wird:
- Batch-Insert: Item wird übersprungen, <code>errors</code>-Counter erhöht
- Single-Insert: Fehler wird sofort zurückgegeben
- Search: Anfrage wird abgelehnt mit HTTP 400</p>
<h3 id="vector_ops-q-wie-werden-geloschte-vektoren-behandelt">Q: Wie werden gelöschte Vektoren behandelt?<a class="headerlink" href="#vector_ops-q-wie-werden-geloschte-vektoren-behandelt" title="Permanent link">&para;</a></h3>
<p>A:
- HNSW: <code>markDelete()</code> markiert Vektoren als gelöscht; physisches Entfernen erfordert Rebuild
- Cache: Sofortige Entfernung aus PK-Mapping und Cache
- RocksDB: Löschung via WriteBatch (kompaktiert in nächster Compaction)</p>
<h2 id="vector_ops-beispiele">Beispiele<a class="headerlink" href="#vector_ops-beispiele" title="Permanent link">&para;</a></h2>
<h3 id="vector_ops-1-massenimport-aus-csv">1. Massenimport aus CSV<a class="headerlink" href="#vector_ops-1-massenimport-aus-csv" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">import csv
import requests
import numpy as np

url = &quot;http://localhost:8765/vector/batch_insert&quot;
batch_size = 500

with open(&quot;embeddings.csv&quot;) as f:
    reader = csv.DictReader(f)
    batch = []
    for row in reader:
        vec = np.fromstring(row[&quot;embedding&quot;], sep=&quot;,&quot;).tolist()
        batch.append({
            &quot;pk&quot;: row[&quot;id&quot;],
            &quot;vector&quot;: vec,
            &quot;fields&quot;: {&quot;title&quot;: row[&quot;title&quot;]}
        })
        if len(batch) &gt;= batch_size:
            resp = requests.post(url, json={&quot;items&quot;: batch})
            print(f&quot;Inserted {resp.json()['inserted']}, errors: {resp.json()['errors']}&quot;)
            batch = []
    if batch:
        resp = requests.post(url, json={&quot;items&quot;: batch})
        print(f&quot;Final batch: {resp.json()['inserted']} inserted&quot;)
</code></pre>
<h3 id="vector_ops-2-prafix-basierte-bereinigung">2. Präfix-basierte Bereinigung<a class="headerlink" href="#vector_ops-2-prafix-basierte-bereinigung" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Alle temporären Vektoren löschen
curl -X DELETE http://localhost:8765/vector/by-filter \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;prefix&quot;: &quot;temp-&quot;}'

# Ausgabe: {&quot;deleted&quot;: 42, &quot;method&quot;: &quot;prefix&quot;}
</code></pre>
<h3 id="vector_ops-3-paginierte-suche">3. Paginierte Suche<a class="headerlink" href="#vector_ops-3-paginierte-suche" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">import requests

url = &quot;http://localhost:8765/vector/search&quot;
query_vec = [0.1, 0.2, 0.3]  # Beispiel-Embedding
cursor = None
all_results = []

while True:
    payload = {&quot;vector&quot;: query_vec, &quot;k&quot;: 20, &quot;use_cursor&quot;: True}
    if cursor:
        payload[&quot;cursor&quot;] = cursor

    resp = requests.post(url, json=payload).json()
    all_results.extend(resp[&quot;items&quot;])

    if not resp[&quot;has_more&quot;]:
        break
    cursor = resp[&quot;next_cursor&quot;]

print(f&quot;Total results: {len(all_results)}&quot;)
</code></pre>
<h2 id="vector_ops-siehe-auch">Siehe auch<a class="headerlink" href="#vector_ops-siehe-auch" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#aql_syntax">AQL Syntax</a> – Hybrid-Queries mit Vektorsuche</li>
<li><a href="#indexes">Indexes</a> – Sekundär- und Range-Indizes</li>
<li><a href="#deployment">Deployment</a> – Production-Setup und Tuning</li>
<li><a href="#tracing">Tracing</a> – Performance-Debugging mit OpenTelemetry</li>
</ul></section><section class="print-page" id="gnn_embeddings" heading-number="11.2"><h1 id="gnn_embeddings-gnn-embeddings">GNN Embeddings<a class="headerlink" href="#gnn_embeddings-gnn-embeddings" title="Permanent link">&para;</a></h1>
<p><strong>Status:</strong> ✅ COMPLETE<br />
<strong>Version:</strong> 1.0<br />
<strong>Date:</strong> 31. Oktober 2025<br />
<strong>Tests:</strong> 13/13 Passing  </p>
<h2 id="gnn_embeddings-overview">Overview<a class="headerlink" href="#gnn_embeddings-overview" title="Permanent link">&para;</a></h2>
<p>The GNN (Graph Neural Network) Embeddings module provides graph embedding generation for nodes, edges, and entire graphs. It enables machine learning workflows like node classification, link prediction, and graph similarity search by converting graph structures into dense vector representations.</p>
<h2 id="gnn_embeddings-architecture">Architecture<a class="headerlink" href="#gnn_embeddings-architecture" title="Permanent link">&para;</a></h2>
<pre><code>GNNEmbeddingManager
├─ Feature Extraction (from BaseEntity fields)
├─ Embedding Computation (feature-based MVP, extensible to GNN models)
├─ Storage Layer (RocksDB + VectorIndexManager)
├─ Similarity Search (HNSW-based KNN)
└─ Model Registry (multiple embedding models per graph)
</code></pre>
<p><strong>Components:</strong>
- <strong>PropertyGraphManager:</strong> Provides graph structure (nodes, edges, labels, types)
- <strong>VectorIndexManager:</strong> Stores embeddings for similarity search (HNSW index)
- <strong>RocksDBWrapper:</strong> Persists embeddings for retrieval
- <strong>BaseEntity:</strong> Flexible entity storage with type-safe field access</p>
<h2 id="gnn_embeddings-features">Features<a class="headerlink" href="#gnn_embeddings-features" title="Permanent link">&para;</a></h2>
<h3 id="gnn_embeddings-1-node-embeddings">1. Node Embeddings<a class="headerlink" href="#gnn_embeddings-1-node-embeddings" title="Permanent link">&para;</a></h3>
<p>Generate embeddings for all nodes with a specific label:</p>
<pre><code class="language-cpp">GNNEmbeddingManager gem(db, pgm, vim);

// Register model
gem.registerModel(&quot;my_model&quot;, &quot;GraphSAGE&quot;, 128);

// Generate embeddings for all &quot;Person&quot; nodes
auto st = gem.generateNodeEmbeddings(&quot;graph1&quot;, &quot;Person&quot;, &quot;my_model&quot;);

// Update single node embedding
auto st2 = gem.updateNodeEmbedding(&quot;person123&quot;, &quot;graph1&quot;, &quot;my_model&quot;);

// Retrieve embedding
auto [st3, embInfo] = gem.getNodeEmbedding(&quot;person123&quot;, &quot;graph1&quot;, &quot;my_model&quot;);
std::vector&lt;float&gt; embedding = embInfo.embedding;  // 128-dim vector
</code></pre>
<p><strong>Use Cases:</strong>
- Node classification (predict node labels)
- Clustering (group similar nodes)
- Anomaly detection (find outliers)</p>
<h3 id="gnn_embeddings-2-edge-embeddings">2. Edge Embeddings<a class="headerlink" href="#gnn_embeddings-2-edge-embeddings" title="Permanent link">&para;</a></h3>
<p>Generate embeddings for relationships:</p>
<pre><code class="language-cpp">// Generate embeddings for all &quot;KNOWS&quot; edges
auto st = gem.generateEdgeEmbeddings(&quot;graph1&quot;, &quot;KNOWS&quot;, &quot;my_model&quot;);

// Update single edge
auto st2 = gem.updateEdgeEmbedding(&quot;edge456&quot;, &quot;graph1&quot;, &quot;my_model&quot;);

// Retrieve
auto [st3, embInfo] = gem.getEdgeEmbedding(&quot;edge456&quot;, &quot;graph1&quot;, &quot;my_model&quot;);
</code></pre>
<p><strong>Use Cases:</strong>
- Link prediction (predict missing edges)
- Relationship classification
- Edge importance scoring</p>
<h3 id="gnn_embeddings-3-graph-level-embeddings">3. Graph-Level Embeddings<a class="headerlink" href="#gnn_embeddings-3-graph-level-embeddings" title="Permanent link">&para;</a></h3>
<p>Aggregate node embeddings to represent entire graphs:</p>
<pre><code class="language-cpp">// Mean pooling
auto [st, graphEmb] = gem.generateGraphEmbedding(&quot;graph1&quot;, &quot;my_model&quot;, &quot;mean&quot;);

// Sum pooling
auto [st2, graphEmbSum] = gem.generateGraphEmbedding(&quot;graph1&quot;, &quot;my_model&quot;, &quot;sum&quot;);

// Max pooling
auto [st3, graphEmbMax] = gem.generateGraphEmbedding(&quot;graph1&quot;, &quot;my_model&quot;, &quot;max&quot;);
</code></pre>
<p><strong>Aggregation Methods:</strong>
- <code>mean</code>: Average of all node embeddings (good for balanced graphs)
- <code>sum</code>: Sum of embeddings (sensitive to graph size)
- <code>max</code>: Element-wise maximum (captures extreme features)</p>
<p><strong>Use Cases:</strong>
- Graph classification (classify entire graphs)
- Graph similarity (compare graphs)
- Graph clustering</p>
<h3 id="gnn_embeddings-4-similarity-search">4. Similarity Search<a class="headerlink" href="#gnn_embeddings-4-similarity-search" title="Permanent link">&para;</a></h3>
<p>Find similar nodes or edges using vector similarity:</p>
<pre><code class="language-cpp">// Find 10 similar nodes to person123
auto [st, similar] = gem.findSimilarNodes(&quot;person123&quot;, &quot;graph1&quot;, 10, &quot;my_model&quot;);

for (const auto&amp; res : similar) {
    std::cout &lt;&lt; &quot;Node: &quot; &lt;&lt; res.entity_id 
              &lt;&lt; &quot; Similarity: &quot; &lt;&lt; res.similarity &lt;&lt; &quot;\n&quot;;
}

// Find similar edges
auto [st2, simEdges] = gem.findSimilarEdges(&quot;edge456&quot;, &quot;graph1&quot;, 5, &quot;my_model&quot;);
</code></pre>
<p><strong>Similarity Metric:</strong> Cosine similarity (1 - L2 distance from HNSW)</p>
<p><strong>Use Cases:</strong>
- Recommendation (find similar users/items)
- Duplicate detection
- Entity resolution</p>
<h3 id="gnn_embeddings-5-model-management">5. Model Management<a class="headerlink" href="#gnn_embeddings-5-model-management" title="Permanent link">&para;</a></h3>
<p>Support multiple embedding models per graph:</p>
<pre><code class="language-cpp">// Register models with different dimensions
gem.registerModel(&quot;small_model&quot;, &quot;GraphSAGE&quot;, 64);
gem.registerModel(&quot;large_model&quot;, &quot;GraphSAGE&quot;, 256);

// List all models
auto [st, models] = gem.listModels();
// models = [&quot;small_model&quot;, &quot;large_model&quot;]

// Get model info
auto [st2, info] = gem.getModelInfo(&quot;large_model&quot;);
// info.embedding_dim = 256
// info.type = &quot;GraphSAGE&quot;
</code></pre>
<p><strong>Model Types:</strong>
- <code>feature_based</code>: Simple feature aggregation (current MVP)
- <code>GraphSAGE</code>: Inductive graph learning (future)
- <code>GAT</code>: Graph Attention Networks (future)
- <code>GCN</code>: Graph Convolutional Networks (future)</p>
<h3 id="gnn_embeddings-6-batch-operations">6. Batch Operations<a class="headerlink" href="#gnn_embeddings-6-batch-operations" title="Permanent link">&para;</a></h3>
<p>Efficient processing of multiple entities:</p>
<pre><code class="language-cpp">std::vector&lt;std::string&gt; node_pks = {&quot;person1&quot;, &quot;person2&quot;, &quot;person3&quot;};

// Process in batches of 32
auto st = gem.generateNodeEmbeddingsBatch(node_pks, &quot;graph1&quot;, &quot;my_model&quot;, 32);

// Edge batching
std::vector&lt;std::string&gt; edge_ids = {...};
auto st2 = gem.generateEdgeEmbeddingsBatch(edge_ids, &quot;graph1&quot;, &quot;my_model&quot;, 32);
</code></pre>
<p><strong>Benefits:</strong>
- Reduced database roundtrips
- Better memory locality
- Progress monitoring</p>
<h3 id="gnn_embeddings-7-statistics-monitoring">7. Statistics &amp; Monitoring<a class="headerlink" href="#gnn_embeddings-7-statistics-monitoring" title="Permanent link">&para;</a></h3>
<p>Track embedding generation:</p>
<pre><code class="language-cpp">auto [st, stats] = gem.getStats();

std::cout &lt;&lt; &quot;Total node embeddings: &quot; &lt;&lt; stats.total_node_embeddings &lt;&lt; &quot;\n&quot;;
std::cout &lt;&lt; &quot;Total edge embeddings: &quot; &lt;&lt; stats.total_edge_embeddings &lt;&lt; &quot;\n&quot;;

for (const auto&amp; [model, count] : stats.embeddings_per_model) {
    std::cout &lt;&lt; &quot;Model &quot; &lt;&lt; model &lt;&lt; &quot;: &quot; &lt;&lt; count &lt;&lt; &quot; embeddings\n&quot;;
}
</code></pre>
<h2 id="gnn_embeddings-implementation-details">Implementation Details<a class="headerlink" href="#gnn_embeddings-implementation-details" title="Permanent link">&para;</a></h2>
<h3 id="gnn_embeddings-feature-extraction">Feature Extraction<a class="headerlink" href="#gnn_embeddings-feature-extraction" title="Permanent link">&para;</a></h3>
<p>Current MVP extracts numeric features from BaseEntity fields:</p>
<pre><code class="language-cpp">std::vector&lt;float&gt; extractFeatures_(
    const BaseEntity&amp; entity,
    const std::vector&lt;std::string&gt;&amp; feature_fields
) {
    std::vector&lt;float&gt; features;

    for (const auto&amp; field : feature_fields) {
        auto intVal = entity.getFieldAsInt(field);
        if (intVal.has_value()) {
            features.push_back(static_cast&lt;float&gt;(*intVal));
            continue;
        }

        auto doubleVal = entity.getFieldAsDouble(field);
        if (doubleVal.has_value()) {
            features.push_back(static_cast&lt;float&gt;(*doubleVal));
        }
    }

    return features;
}
</code></pre>
<p><strong>Default Fields (if none specified):</strong>
- <code>age</code>, <code>score</code>, <code>rating</code>, <code>count</code>, <code>value</code></p>
<p><strong>Future:</strong> Support categorical encoding, text embeddings (Sentence-BERT), image features</p>
<h3 id="gnn_embeddings-embedding-computation-mvp">Embedding Computation (MVP)<a class="headerlink" href="#gnn_embeddings-embedding-computation-mvp" title="Permanent link">&para;</a></h3>
<p>Simple normalized feature aggregation:</p>
<pre><code class="language-cpp">std::vector&lt;float&gt; computeEmbedding_(
    const std::vector&lt;float&gt;&amp; features,
    int target_dim
) {
    // 1. Copy/pad features to target dimension
    std::vector&lt;float&gt; embedding(target_dim, 0.0f);
    std::copy(features.begin(), 
              features.begin() + std::min(features.size(), target_dim),
              embedding.begin());

    // 2. L2 normalization
    float norm = std::sqrt(std::inner_product(
        embedding.begin(), embedding.end(), 
        embedding.begin(), 0.0f));

    if (norm &gt; 0.0f) {
        for (float&amp; val : embedding) {
            val /= norm;
        }
    }

    return embedding;
}
</code></pre>
<p><strong>Future GNN Integration:</strong>
- Load pretrained GNN models (PyTorch C++ API)
- Online GNN training (incremental updates)
- Neighbor aggregation (GraphSAGE, GAT)</p>
<h3 id="gnn_embeddings-storage-architecture">Storage Architecture<a class="headerlink" href="#gnn_embeddings-storage-architecture" title="Permanent link">&para;</a></h3>
<p>Dual storage for efficiency:</p>
<pre><code class="language-cpp">// 1. Store in RocksDB (for retrieval)
std::string embKey = &quot;gnn_emb:node:graph1:model:person123&quot;;
db_.put(embKey, embEntity.serialize());

// 2. Add to vector index (for similarity search)
vim_.addEntity(embEntity, &quot;embedding&quot;);
</code></pre>
<p><strong>Key Schema:</strong>
- Node: <code>gnn_emb:node:&lt;graph_id&gt;:&lt;model_name&gt;:&lt;node_pk&gt;</code>
- Edge: <code>gnn_emb:edge:&lt;graph_id&gt;:&lt;model_name&gt;:&lt;edge_id&gt;</code></p>
<p><strong>Metadata:</strong>
- <code>entity_id</code>: Original node/edge ID
- <code>entity_type</code>: "node" or "edge"
- <code>graph_id</code>: Multi-graph isolation
- <code>model_name</code>: Model used for generation
- <code>timestamp</code>: Creation/update time
- <code>embedding</code>: Dense vector (std::vector<float>)</p>
<h3 id="gnn_embeddings-multi-graph-isolation">Multi-Graph Isolation<a class="headerlink" href="#gnn_embeddings-multi-graph-isolation" title="Permanent link">&para;</a></h3>
<p>Embeddings are isolated per graph:</p>
<pre><code class="language-cpp">// Graph 1: person123 embedding
gem.updateNodeEmbedding(&quot;person123&quot;, &quot;graph1&quot;, &quot;model&quot;);

// Graph 2: person123 embedding (different entity!)
gem.updateNodeEmbedding(&quot;person123&quot;, &quot;graph2&quot;, &quot;model&quot;);

// Similarity search only within same graph
auto [st, similar] = gem.findSimilarNodes(&quot;person123&quot;, &quot;graph1&quot;, 10, &quot;model&quot;);
// Result: Only nodes from graph1, never from graph2
</code></pre>
<p><strong>Implementation:</strong> Graph ID is part of embedding key + similarity search filters</p>
<h2 id="gnn_embeddings-api-reference">API Reference<a class="headerlink" href="#gnn_embeddings-api-reference" title="Permanent link">&para;</a></h2>
<h3 id="gnn_embeddings-constructor">Constructor<a class="headerlink" href="#gnn_embeddings-constructor" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">GNNEmbeddingManager(
    RocksDBWrapper&amp; db,
    PropertyGraphManager&amp; pgm,
    VectorIndexManager&amp; vim
);
</code></pre>
<h3 id="gnn_embeddings-node-embedding-methods">Node Embedding Methods<a class="headerlink" href="#gnn_embeddings-node-embedding-methods" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Generate embeddings for all nodes with label
Status generateNodeEmbeddings(
    std::string_view graph_id,
    std::string_view label,
    std::string_view model_name,
    const std::vector&lt;std::string&gt;&amp; feature_fields = {}
);

// Update/create single node embedding
Status updateNodeEmbedding(
    std::string_view node_pk,
    std::string_view graph_id,
    std::string_view model_name,
    const std::vector&lt;std::string&gt;&amp; feature_fields = {}
);

// Retrieve node embedding
std::pair&lt;Status, EmbeddingInfo&gt; getNodeEmbedding(
    std::string_view node_pk,
    std::string_view graph_id,
    std::string_view model_name
) const;

// Find similar nodes
std::pair&lt;Status, std::vector&lt;SimilarityResult&gt;&gt; findSimilarNodes(
    std::string_view node_pk,
    std::string_view graph_id,
    int k,
    std::string_view model_name
) const;
</code></pre>
<h3 id="gnn_embeddings-edge-embedding-methods">Edge Embedding Methods<a class="headerlink" href="#gnn_embeddings-edge-embedding-methods" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">Status generateEdgeEmbeddings(...);
Status updateEdgeEmbedding(...);
std::pair&lt;Status, EmbeddingInfo&gt; getEdgeEmbedding(...) const;
std::pair&lt;Status, std::vector&lt;SimilarityResult&gt;&gt; findSimilarEdges(...) const;
</code></pre>
<h3 id="gnn_embeddings-graph-level-methods">Graph-Level Methods<a class="headerlink" href="#gnn_embeddings-graph-level-methods" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">std::pair&lt;Status, std::vector&lt;float&gt;&gt; generateGraphEmbedding(
    std::string_view graph_id,
    std::string_view model_name,
    std::string_view aggregation_method  // &quot;mean&quot;, &quot;sum&quot;, &quot;max&quot;
);
</code></pre>
<h3 id="gnn_embeddings-model-management">Model Management<a class="headerlink" href="#gnn_embeddings-model-management" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">Status registerModel(
    std::string_view model_name,
    std::string_view model_type,
    int embedding_dim,
    std::string_view config = &quot;&quot;
);

std::pair&lt;Status, std::vector&lt;std::string&gt;&gt; listModels() const;

std::pair&lt;Status, ModelInfo&gt; getModelInfo(
    std::string_view model_name
) const;
</code></pre>
<h3 id="gnn_embeddings-batch-operations">Batch Operations<a class="headerlink" href="#gnn_embeddings-batch-operations" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">Status generateNodeEmbeddingsBatch(
    const std::vector&lt;std::string&gt;&amp; node_pks,
    std::string_view graph_id,
    std::string_view model_name,
    size_t batch_size = 32
);

Status generateEdgeEmbeddingsBatch(...);
</code></pre>
<h3 id="gnn_embeddings-statistics">Statistics<a class="headerlink" href="#gnn_embeddings-statistics" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">struct EmbeddingStats {
    int total_node_embeddings = 0;
    int total_edge_embeddings = 0;
    std::map&lt;std::string, int&gt; embeddings_per_model;
    std::map&lt;std::string, int&gt; embeddings_per_graph;
};

std::pair&lt;Status, EmbeddingStats&gt; getStats() const;
</code></pre>
<h2 id="gnn_embeddings-testing">Testing<a class="headerlink" href="#gnn_embeddings-testing" title="Permanent link">&para;</a></h2>
<p><strong>Test Suite:</strong> <code>test_gnn_embeddings.cpp</code><br />
<strong>Test Count:</strong> 13 tests<br />
<strong>Pass Rate:</strong> 100%  </p>
<p><strong>Test Coverage:</strong>
1. ✅ RegisterModel - Model registration and listing
2. ✅ GenerateNodeEmbeddings - Batch generation by label
3. ✅ UpdateNodeEmbedding - Single node update
4. ✅ GenerateEdgeEmbeddings - Batch generation by type
5. ✅ FindSimilarNodes - KNN similarity search
6. ✅ FindSimilarEdges - Edge similarity
7. ✅ GenerateGraphEmbedding - Graph-level aggregation
8. ✅ BatchOperations - Batch processing
9. ✅ GetStats - Statistics collection
10. ✅ MultiGraphIsolation - Graph isolation
11. ✅ FeatureExtraction - Multiple field types
12. ✅ MultiModelSupport - Multiple models
13. ✅ ErrorHandling - Error cases</p>
<p><strong>Run Tests:</strong></p>
<pre><code class="language-bash">.\build\Release\themis_tests.exe --gtest_filter=&quot;GNNEmbeddingTest.*&quot;
</code></pre>
<h2 id="gnn_embeddings-performance">Performance<a class="headerlink" href="#gnn_embeddings-performance" title="Permanent link">&para;</a></h2>
<p><strong>Embedding Generation (64-dim):</strong>
- Node embedding (feature extraction + normalization): ~0.5ms
- Edge embedding: ~0.5ms
- Batch processing (32 nodes): ~16ms</p>
<p><strong>Similarity Search (HNSW):</strong>
- KNN search (k=10): ~1-5ms
- Depends on index size (logarithmic scaling)</p>
<p><strong>Storage:</strong>
- Embedding size: ~256 bytes (64-dim float + metadata)
- 1M embeddings: ~256 MB</p>
<h2 id="gnn_embeddings-migration-guide">Migration Guide<a class="headerlink" href="#gnn_embeddings-migration-guide" title="Permanent link">&para;</a></h2>
<h3 id="gnn_embeddings-from-no-embeddings-gnn-embeddings">From No Embeddings → GNN Embeddings<a class="headerlink" href="#gnn_embeddings-from-no-embeddings-gnn-embeddings" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// 1. Initialize GNN manager
GNNEmbeddingManager gem(db, pgm, vim);

// 2. Register model
gem.registerModel(&quot;my_model&quot;, &quot;feature_based&quot;, 128);

// 3. Generate embeddings for existing nodes
auto [st, labels] = pgm.listLabels(&quot;my_graph&quot;);
for (const auto&amp; label : labels) {
    gem.generateNodeEmbeddings(&quot;my_graph&quot;, label, &quot;my_model&quot;);
}

// 4. Use similarity search
auto [st2, similar] = gem.findSimilarNodes(&quot;node123&quot;, &quot;my_graph&quot;, 10, &quot;my_model&quot;);
</code></pre>
<h3 id="gnn_embeddings-from-feature-vectors-gnn-models">From Feature Vectors → GNN Models<a class="headerlink" href="#gnn_embeddings-from-feature-vectors-gnn-models" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// MVP: Feature-based embeddings
gem.registerModel(&quot;features&quot;, &quot;feature_based&quot;, 64);
gem.updateNodeEmbedding(&quot;node1&quot;, &quot;g1&quot;, &quot;features&quot;);

// Future: Real GNN model
gem.registerModel(&quot;graphsage&quot;, &quot;GraphSAGE&quot;, 128, R&quot;({
    &quot;layers&quot;: 2,
    &quot;aggregator&quot;: &quot;mean&quot;,
    &quot;pretrained_path&quot;: &quot;/models/my_gnn.pt&quot;
})&quot;);
gem.updateNodeEmbedding(&quot;node1&quot;, &quot;g1&quot;, &quot;graphsage&quot;);
</code></pre>
<h2 id="gnn_embeddings-future-enhancements">Future Enhancements<a class="headerlink" href="#gnn_embeddings-future-enhancements" title="Permanent link">&para;</a></h2>
<h3 id="gnn_embeddings-1-real-gnn-models">1. Real GNN Models<a class="headerlink" href="#gnn_embeddings-1-real-gnn-models" title="Permanent link">&para;</a></h3>
<ul>
<li>PyTorch C++ API integration</li>
<li>GraphSAGE, GAT, GCN support</li>
<li>Multi-hop neighbor aggregation</li>
<li>Online training</li>
</ul>
<h3 id="gnn_embeddings-2-advanced-features">2. Advanced Features<a class="headerlink" href="#gnn_embeddings-2-advanced-features" title="Permanent link">&para;</a></h3>
<ul>
<li>Categorical feature encoding (one-hot, embeddings)</li>
<li>Text feature extraction (Sentence-BERT)</li>
<li>Image feature extraction (ResNet, CLIP)</li>
<li>Temporal features (time-aware embeddings)</li>
</ul>
<h3 id="gnn_embeddings-3-performance">3. Performance<a class="headerlink" href="#gnn_embeddings-3-performance" title="Permanent link">&para;</a></h3>
<ul>
<li>GPU acceleration (CUDA)</li>
<li>Distributed training</li>
<li>Incremental updates (avoid full recomputation)</li>
<li>Embedding caching</li>
</ul>
<h3 id="gnn_embeddings-4-ml-integration">4. ML Integration<a class="headerlink" href="#gnn_embeddings-4-ml-integration" title="Permanent link">&para;</a></h3>
<ul>
<li>Scikit-learn compatible API</li>
<li>Feature store integration (Task 9)</li>
<li>AutoML for hyperparameter tuning</li>
</ul>
<h2 id="gnn_embeddings-related-features">Related Features<a class="headerlink" href="#gnn_embeddings-related-features" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Task 1:</strong> Recursive Path Queries (context for GNN training)</li>
<li><strong>Task 2:</strong> Temporal Graphs (time-aware embeddings)</li>
<li><strong>Task 3:</strong> Property Graph Model (multi-label nodes)</li>
<li><strong>Task 9:</strong> ML Feature Store (embedding storage &amp; serving)</li>
</ul>
<h2 id="gnn_embeddings-summary">Summary<a class="headerlink" href="#gnn_embeddings-summary" title="Permanent link">&para;</a></h2>
<p>The GNN Embeddings module provides production-ready graph embedding generation with:
- ✅ <strong>13/13 tests passing</strong>
- ✅ <strong>Node, edge, graph-level embeddings</strong>
- ✅ <strong>Multi-model support</strong>
- ✅ <strong>Similarity search (HNSW)</strong>
- ✅ <strong>Multi-graph isolation</strong>
- ✅ <strong>Batch operations</strong>
- ✅ <strong>Extensible architecture (future GNN models)</strong></p>
<p><strong>Next Steps:</strong> Task 5 (Semantic Query Cache) builds on similarity search for caching frequent queries.</p></section><section class="print-page" id="hnsw_persistence" heading-number="11.3"><h1 id="hnsw_persistence-hnsw-persistenz-warmstart">HNSW Persistenz &amp; Warmstart<a class="headerlink" href="#hnsw_persistence-hnsw-persistenz-warmstart" title="Permanent link">&para;</a></h1>
<p>Diese Seite beschreibt die Persistierung und Wiederherstellung von HNSW-Vektorindizes für schnellere Warmstarts und robustes Recovery.</p>
<h2 id="hnsw_persistence-motivation">Motivation<a class="headerlink" href="#hnsw_persistence-motivation" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Problem:</strong> HNSW-Index wird bei jedem Neustart aus RocksDB neu aufgebaut (langsam bei &gt;100k Vektoren)</li>
<li><strong>Lösung:</strong> Index auf Disk speichern (<code>saveIndex</code>) und beim Start laden (<code>loadIndex</code>)</li>
<li><strong>Benefit:</strong> Warmstart &lt;10s statt mehrerer Minuten; kein Datenverlust</li>
</ul>
<h2 id="hnsw_persistence-lifecycle">Lifecycle<a class="headerlink" href="#hnsw_persistence-lifecycle" title="Permanent link">&para;</a></h2>
<pre><code>init(objectName, dim, metric, ..., savePath)
  ├─&gt; Falls savePath/meta.txt existiert: loadIndex(savePath)
  └─&gt; Sonst: leerer HNSW-Index

[Runtime: addEntity, searchKnn, ...]

setAutoSavePath(path, autoSave=true)
  └─&gt; Aktiviert automatisches Speichern bei shutdown()

shutdown()
  └─&gt; Falls autoSave: saveIndex(savePath)
</code></pre>
<h2 id="hnsw_persistence-api">API<a class="headerlink" href="#hnsw_persistence-api" title="Permanent link">&para;</a></h2>
<h3 id="hnsw_persistence-1-init-mit-save-path">1) Init mit Save-Path<a class="headerlink" href="#hnsw_persistence-1-init-mit-save-path" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">VectorIndexManager vix(db);
vix.init(&quot;chunks&quot;, 768, VectorIndexManager::Metric::COSINE, 
         /*M*/16, /*efC*/200, /*ef*/64, 
         /*savePath=*/&quot;./data/hnsw_chunks&quot;);
// Falls ./data/hnsw_chunks/meta.txt vorhanden → lädt Index automatisch
</code></pre>
<h3 id="hnsw_persistence-2-automatisches-speichern-aktivieren">2) Automatisches Speichern aktivieren<a class="headerlink" href="#hnsw_persistence-2-automatisches-speichern-aktivieren" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">vix.setAutoSavePath(&quot;./data/hnsw_chunks&quot;, /*autoSave*/true);
// Bei shutdown() wird Index gespeichert
</code></pre>
<h3 id="hnsw_persistence-3-manuelles-speichern">3) Manuelles Speichern<a class="headerlink" href="#hnsw_persistence-3-manuelles-speichern" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto status = vix.saveIndex(&quot;./data/hnsw_chunks&quot;);
if (!status.ok) {
    THEMIS_ERROR(&quot;Failed to save index: {}&quot;, status.message);
}
</code></pre>
<h3 id="hnsw_persistence-4-manuelles-laden">4) Manuelles Laden<a class="headerlink" href="#hnsw_persistence-4-manuelles-laden" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto status = vix.loadIndex(&quot;./data/hnsw_chunks&quot;);
if (!status.ok) {
    THEMIS_WARN(&quot;Failed to load index, rebuilding from storage&quot;);
    vix.rebuildFromStorage();
}
</code></pre>
<h2 id="hnsw_persistence-persistenz-format">Persistenz-Format<a class="headerlink" href="#hnsw_persistence-persistenz-format" title="Permanent link">&para;</a></h2>
<p>Verzeichnisstruktur:</p>
<pre><code>data/hnsw_chunks/
  ├─ index.bin      # HNSW Graph-Struktur (hnswlib-Format)
  ├─ meta.txt       # Metadaten (Dimension, Metric, M, efC)
  └─ mapping.txt    # PK-Mapping (Zeile i = PK für Label i)
</code></pre>
<h3 id="hnsw_persistence-metatxt">meta.txt<a class="headerlink" href="#hnsw_persistence-metatxt" title="Permanent link">&para;</a></h3>
<pre><code>dim=768
metric=1
M=16
efConstruction=200
count=50000
</code></pre>
<h3 id="hnsw_persistence-mappingtxt">mapping.txt<a class="headerlink" href="#hnsw_persistence-mappingtxt" title="Permanent link">&para;</a></h3>
<pre><code>chunk_doc123_0
chunk_doc123_1
chunk_doc456_0
...
</code></pre>
<h2 id="hnsw_persistence-workflow-startup-mit-warmstart">Workflow: Startup mit Warmstart<a class="headerlink" href="#hnsw_persistence-workflow-startup-mit-warmstart" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">// main_server.cpp
auto vix = std::make_shared&lt;VectorIndexManager&gt;(db);

// Setze Pfad vor init (optional)
vix-&gt;setAutoSavePath(&quot;./data/hnsw_index&quot;);

// Init lädt automatisch, falls vorhanden
vix-&gt;init(&quot;chunks&quot;, 768, VectorIndexManager::Metric::COSINE, 16, 200, 64);

// Nach Init prüfen
if (vix-&gt;getVectorCount() &gt; 0) {
    THEMIS_INFO(&quot;Warmstart: {} vectors loaded&quot;, vix-&gt;getVectorCount());
} else {
    THEMIS_INFO(&quot;Cold start: rebuilding index from storage&quot;);
    vix-&gt;rebuildFromStorage();
}

// Laufzeit: addEntity/searchKnn

// Bei Shutdown
vix-&gt;shutdown(); // Speichert automatisch, falls autoSave aktiviert
</code></pre>
<h2 id="hnsw_persistence-performance">Performance<a class="headerlink" href="#hnsw_persistence-performance" title="Permanent link">&para;</a></h2>
<h3 id="hnsw_persistence-cold-start-rebuild-from-rocksdb">Cold Start (rebuild from RocksDB)<a class="headerlink" href="#hnsw_persistence-cold-start-rebuild-from-rocksdb" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Vektoren</th>
<th>Dim</th>
<th>Rebuild-Zeit</th>
<th>Speichernutzung</th>
</tr>
</thead>
<tbody>
<tr>
<td>10k</td>
<td>768</td>
<td>~2s</td>
<td>~50 MB</td>
</tr>
<tr>
<td>100k</td>
<td>768</td>
<td>~30s</td>
<td>~500 MB</td>
</tr>
<tr>
<td>1M</td>
<td>768</td>
<td>~8min</td>
<td>~5 GB</td>
</tr>
</tbody>
</table>
<h3 id="hnsw_persistence-warmstart-loadindex">Warmstart (loadIndex)<a class="headerlink" href="#hnsw_persistence-warmstart-loadindex" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Vektoren</th>
<th>Dim</th>
<th>Load-Zeit</th>
<th>Disk-Größe</th>
</tr>
</thead>
<tbody>
<tr>
<td>10k</td>
<td>768</td>
<td>&lt;1s</td>
<td>~20 MB</td>
</tr>
<tr>
<td>100k</td>
<td>768</td>
<td>~3s</td>
<td>~200 MB</td>
</tr>
<tr>
<td>1M</td>
<td>768</td>
<td>~25s</td>
<td>~2 GB</td>
</tr>
</tbody>
</table>
<p><strong>Empfehlung:</strong> Ab &gt;50k Vektoren immer Persistenz nutzen.</p>
<h2 id="hnsw_persistence-konfiguration">Konfiguration<a class="headerlink" href="#hnsw_persistence-konfiguration" title="Permanent link">&para;</a></h2>
<p>In <code>config/vector_index.json</code> (optional):</p>
<pre><code class="language-json">{
  &quot;save_path&quot;: &quot;./data/hnsw_index&quot;,
  &quot;auto_save&quot;: true,
  &quot;save_interval_sec&quot;: 300
}
</code></pre>
<p>Falls <code>save_interval_sec</code> gesetzt: periodisches Auto-Save im Hintergrund (geplant).</p>
<h2 id="hnsw_persistence-fehlerbehandlung">Fehlerbehandlung<a class="headerlink" href="#hnsw_persistence-fehlerbehandlung" title="Permanent link">&para;</a></h2>
<h3 id="hnsw_persistence-korrupte-index-datei">Korrupte Index-Datei<a class="headerlink" href="#hnsw_persistence-korrupte-index-datei" title="Permanent link">&para;</a></h3>
<p>Falls <code>loadIndex</code> fehlschlägt:</p>
<pre><code class="language-cpp">auto status = vix-&gt;loadIndex(path);
if (!status.ok) {
    THEMIS_WARN(&quot;Corrupted index, rebuilding: {}&quot;, status.message);
    std::filesystem::remove_all(path); // Optional: alte Dateien löschen
    vix-&gt;rebuildFromStorage();
    vix-&gt;saveIndex(path); // Neu speichern
}
</code></pre>
<h3 id="hnsw_persistence-disk-space-fehler">Disk-Space-Fehler<a class="headerlink" href="#hnsw_persistence-disk-space-fehler" title="Permanent link">&para;</a></h3>
<p>Bei <code>saveIndex</code>:</p>
<pre><code class="language-cpp">auto status = vix-&gt;saveIndex(path);
if (!status.ok &amp;&amp; status.message.find(&quot;No space&quot;) != std::string::npos) {
    THEMIS_ERROR(&quot;Disk full, cannot save index&quot;);
    // Alarm auslösen, alte Backups löschen, etc.
}
</code></pre>
<h2 id="hnsw_persistence-backup-recovery">Backup &amp; Recovery<a class="headerlink" href="#hnsw_persistence-backup-recovery" title="Permanent link">&para;</a></h2>
<h3 id="hnsw_persistence-backup">Backup<a class="headerlink" href="#hnsw_persistence-backup" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Index-Verzeichnis sichern
tar -czf hnsw_index_backup_$(date +%Y%m%d).tar.gz ./data/hnsw_index/

# Optional: mit RocksDB-Checkpoint kombinieren
</code></pre>
<h3 id="hnsw_persistence-recovery">Recovery<a class="headerlink" href="#hnsw_persistence-recovery" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Index wiederherstellen
tar -xzf hnsw_index_backup_20251102.tar.gz -C ./data/

# Server starten → lädt Index automatisch
./themis_server
</code></pre>
<h2 id="hnsw_persistence-rebuild-strategien">Rebuild-Strategien<a class="headerlink" href="#hnsw_persistence-rebuild-strategien" title="Permanent link">&para;</a></h2>
<h3 id="hnsw_persistence-1-vollstandiger-rebuild">1) Vollständiger Rebuild<a class="headerlink" href="#hnsw_persistence-1-vollstandiger-rebuild" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">vix-&gt;rebuildFromStorage(); // Scannt alle Vektoren aus RocksDB
vix-&gt;saveIndex(path);
</code></pre>
<h3 id="hnsw_persistence-2-inkrementelles-update">2) Inkrementelles Update<a class="headerlink" href="#hnsw_persistence-2-inkrementelles-update" title="Permanent link">&para;</a></h3>
<p>Nach Bulk-Import:</p>
<pre><code class="language-cpp">// ... Batch-Insert von 10k Vektoren via WriteBatch

// Index ist in-memory aktualisiert; speichere
vix-&gt;saveIndex(path);
</code></pre>
<h3 id="hnsw_persistence-3-scheduled-rebuild">3) Scheduled Rebuild<a class="headerlink" href="#hnsw_persistence-3-scheduled-rebuild" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Cronjob oder Timer
std::thread([&amp;vix, path]() {
    while (running) {
        std::this_thread::sleep_for(std::chrono::hours(6));
        vix-&gt;rebuildFromStorage();
        vix-&gt;saveIndex(path);
    }
}).detach();
</code></pre>
<h2 id="hnsw_persistence-tests">Tests<a class="headerlink" href="#hnsw_persistence-tests" title="Permanent link">&para;</a></h2>
<p>Unit-Tests: <code>tests/test_vector_index_persistence.cpp</code> (geplant)</p>
<pre><code class="language-cpp">TEST(VectorPersistence, SaveLoadCycle) {
    // 1) Init + Insert 1000 Vektoren
    // 2) saveIndex
    // 3) Neuer VectorIndexManager
    // 4) loadIndex
    // 5) Query → prüfe gleiche Top-k-IDs
}
</code></pre>
<h2 id="hnsw_persistence-runbook">Runbook<a class="headerlink" href="#hnsw_persistence-runbook" title="Permanent link">&para;</a></h2>
<h3 id="hnsw_persistence-problem-index-nicht-geladen">Problem: Index nicht geladen<a class="headerlink" href="#hnsw_persistence-problem-index-nicht-geladen" title="Permanent link">&para;</a></h3>
<p><strong>Symptom:</strong> <code>getVectorCount() == 0</code> nach Init, obwohl RocksDB Daten enthält.</p>
<p><strong>Lösung:</strong></p>
<ol>
<li>Prüfe <code>savePath</code>-Existenz: <code>ls -lh ./data/hnsw_index/</code></li>
<li>Logs prüfen: <code>grep "VectorIndexManager::init" server.log</code></li>
<li>Falls <code>meta.txt</code> fehlt/korrupt → manueller Rebuild:</li>
</ol>
<pre><code class="language-cpp">vix-&gt;rebuildFromStorage();
vix-&gt;saveIndex(&quot;./data/hnsw_index&quot;);
</code></pre>
<h3 id="hnsw_persistence-problem-langsame-queries-nach-load">Problem: Langsame Queries nach Load<a class="headerlink" href="#hnsw_persistence-problem-langsame-queries-nach-load" title="Permanent link">&para;</a></h3>
<p><strong>Symptom:</strong> KNN-Suche dauert &gt;500ms (sollte &lt;50ms sein).</p>
<p><strong>Mögliche Ursachen:</strong></p>
<ul>
<li>efSearch zu niedrig → erhöhen:</li>
</ul>
<pre><code class="language-cpp">vix-&gt;setEfSearch(128); // statt 64
</code></pre>
<ul>
<li>Index nicht korrekt geladen → Rebuild erzwingen</li>
</ul>
<h2 id="hnsw_persistence-metriken">Metriken<a class="headerlink" href="#hnsw_persistence-metriken" title="Permanent link">&para;</a></h2>
<p>Prometheus <code>/metrics</code>:</p>
<ul>
<li><code>themis_vector_index_save_duration_seconds</code> — Histogram für saveIndex-Dauer</li>
<li><code>themis_vector_index_load_duration_seconds</code> — Histogram für loadIndex-Dauer</li>
<li><code>themis_vector_index_size_bytes</code> — Disk-Größe des Index</li>
<li><code>themis_vector_index_rebuild_total</code> — Counter für Rebuilds</li>
</ul>
<p>(Implementierung geplant)</p>
<h2 id="hnsw_persistence-referenzen">Referenzen<a class="headerlink" href="#hnsw_persistence-referenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#vector_ops">Vector Operations</a></li>
<li><a href="#indexes-vector-index">Indexes</a></li>
<li><a href="#performance_benchmarks-vector-suche-hnsw-tuning">Performance &amp; Benchmarks</a></li>
<li><a href="#operations_runbook-vector-index-maintenance">Operations Runbook</a></li>
</ul></section></section>
                    <section class='print-page md-section' id='section-12' heading-number='12'>
                        <h1>Sicherheit & Governance<a class='headerlink' href='#section-12' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="security-overview" heading-number="12.1"><h1 id="security-overview-sicherheit-governance-uberblick">Sicherheit &amp; Governance – Überblick<a class="headerlink" href="#security-overview-sicherheit-governance-uberblick" title="Permanent link">&para;</a></h1>
<p>Dieser Überblick fasst die sicherheitsrelevanten Bausteine von ThemisDB zusammen und verlinkt die Detailseiten.</p>
<ul>
<li>Schlüsselverwaltung (Key Management): Schlüsselarten, Rotation, Server-APIs, Provider</li>
<li>Verschlüsselung: Strategie, Deployment, Spaltenverschlüsselung</li>
<li>PII-Erkennung &amp; Klassifizierung: Regeln, Engine, Admin-APIs</li>
<li>Audit &amp; Retention: Changefeed (Audit-Trail), Statistiken, Aufbewahrung</li>
<li>Threat Model (light): Assets, Akteure, Vertrauensgrenzen, Risiken, Gegenmaßnahmen</li>
</ul>
<p>Weiterlesen:
- Schlüsselverwaltung: security/key_management.md
- PII-Detection: security/pii_detection.md
- Audit &amp; Retention: security/audit_and_retention.md
- Threat-Model: security/threat_model.md
- Verschlüsselung: encryption_strategy.md, encryption_deployment.md, column_encryption.md</p></section><section class="print-page" id="rbac_authorization" heading-number="12.2"><h1 id="rbac_authorization-rbac-authorization-mvp">RBAC &amp; Authorization (MVP)<a class="headerlink" href="#rbac_authorization-rbac-authorization-mvp" title="Permanent link">&para;</a></h1>
<p>Diese Seite beschreibt die API-Token-basierte Zugriffskontrolle in ThemisDB. MVP-Version nutzt statische Token mit Scopes; später erweitert um ABAC (Ranger-inspiriert).</p>
<h2 id="rbac_authorization-konzept">Konzept<a class="headerlink" href="#rbac_authorization-konzept" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Token-basiert:</strong> API-Clients senden <code>Authorization: Bearer &lt;token&gt;</code> Header</li>
<li><strong>Scopes:</strong> Jeder Token hat einen Satz von Scopes (z. B. <code>admin</code>, <code>config:write</code>, <code>cdc:read</code>, <code>metrics:read</code>)</li>
<li><strong>Endpoint-Schutz:</strong> Sensitive Endpunkte prüfen erforderliche Scopes</li>
<li><strong>Audit-Logs:</strong> Verweigerte Zugriffe werden geloggt</li>
<li><strong>Metriken:</strong> Prometheus-Zähler für Autorisierungsergebnisse</li>
</ul>
<h2 id="rbac_authorization-scope-matrix">Scope-Matrix<a class="headerlink" href="#rbac_authorization-scope-matrix" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Berechtigungen</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>admin</code></td>
<td>Voller Zugriff auf alle Endpoints (Superuser)</td>
</tr>
<tr>
<td><code>config:read</code></td>
<td>GET /config</td>
</tr>
<tr>
<td><code>config:write</code></td>
<td>POST /config (Hot-Reload)</td>
</tr>
<tr>
<td><code>cdc:read</code></td>
<td>GET /changefeed/*, CDC Stats</td>
</tr>
<tr>
<td><code>cdc:admin</code></td>
<td>POST /changefeed/retention (Konfiguration)</td>
</tr>
<tr>
<td><code>metrics:read</code></td>
<td>GET /metrics (Prometheus)</td>
</tr>
<tr>
<td><code>data:read</code></td>
<td>GET /entities/<em>, /query/</em>, /graph/<em>, /vector/</em></td>
</tr>
<tr>
<td><code>data:write</code></td>
<td>PUT/DELETE /entities/*, POST /query/aql (schreibend)</td>
</tr>
</tbody>
</table>
<h2 id="rbac_authorization-konfiguration">Konfiguration<a class="headerlink" href="#rbac_authorization-konfiguration" title="Permanent link">&para;</a></h2>
<p>Token werden in <code>config/auth.json</code> definiert (oder via ENV-Variablen):</p>
<pre><code class="language-json">{
  &quot;tokens&quot;: [
    {
      &quot;token&quot;: &quot;admin-secret-token-abc123&quot;,
      &quot;user_id&quot;: &quot;admin&quot;,
      &quot;scopes&quot;: [&quot;admin&quot;, &quot;config:write&quot;, &quot;config:read&quot;, &quot;cdc:read&quot;, &quot;cdc:admin&quot;, &quot;metrics:read&quot;, &quot;data:read&quot;, &quot;data:write&quot;]
    },
    {
      &quot;token&quot;: &quot;readonly-token-def456&quot;,
      &quot;user_id&quot;: &quot;monitoring&quot;,
      &quot;scopes&quot;: [&quot;metrics:read&quot;, &quot;cdc:read&quot;, &quot;data:read&quot;]
    }
  ]
}
</code></pre>
<p>Alternativ via Umgebungsvariablen (für Container):</p>
<pre><code class="language-bash">THEMIS_AUTH_TOKENS='[{&quot;token&quot;:&quot;abc123&quot;,&quot;user_id&quot;:&quot;admin&quot;,&quot;scopes&quot;:[&quot;admin&quot;]}]'
</code></pre>
<h2 id="rbac_authorization-api-nutzung">API-Nutzung<a class="headerlink" href="#rbac_authorization-api-nutzung" title="Permanent link">&para;</a></h2>
<p>Clients senden Token im Authorization-Header:</p>
<pre><code class="language-bash"># Erfolg (admin hat admin-Scope)
curl -H &quot;Authorization: Bearer admin-secret-token-abc123&quot; \
     http://localhost:8765/config

# Verweigert (readonly hat keinen config:write-Scope)
curl -X POST -H &quot;Authorization: Bearer readonly-token-def456&quot; \
     -H &quot;Content-Type: application/json&quot; \
     -d '{&quot;logging&quot;:{&quot;level&quot;:&quot;debug&quot;}}' \
     http://localhost:8765/config
# -&gt; 403 Forbidden
</code></pre>
<h2 id="rbac_authorization-geschutzte-endpunkte">Geschützte Endpunkte<a class="headerlink" href="#rbac_authorization-geschutzte-endpunkte" title="Permanent link">&para;</a></h2>
<p>MVP-Version schützt folgende Endpunkte:</p>
<ul>
<li><code>POST /config</code> → Scope: <code>config:write</code></li>
<li><code>GET /config</code> → Scope: <code>config:read</code></li>
<li><code>GET /changefeed/*</code> → Scope: <code>cdc:read</code></li>
<li><code>POST /changefeed/retention</code> → Scope: <code>cdc:admin</code></li>
<li><code>GET /metrics</code> → Scope: <code>metrics:read</code> (optional, für private Deployments)</li>
<li>Admin-Endpoints (z. B. <code>/admin/*</code>, falls vorhanden) → Scope: <code>admin</code></li>
</ul>
<p>Datenendpunkte (<code>/entities</code>, <code>/query</code>, <code>/graph</code>, <code>/vector</code>) sind zunächst offen; optionale Aktivierung via Feature-Flag <code>require_data_auth</code>.</p>
<h2 id="rbac_authorization-metriken">Metriken<a class="headerlink" href="#rbac_authorization-metriken" title="Permanent link">&para;</a></h2>
<p>Prometheus <code>/metrics</code> enthält:</p>
<ul>
<li><code>themis_authz_success_total</code> — Erfolgreiche Autorisierungen (Label: <code>user_id</code>, <code>scope</code>)</li>
<li><code>themis_authz_denied_total</code> — Verweigerte Zugriffe (Label: <code>user_id</code>, <code>scope</code>, <code>reason</code>)</li>
<li><code>themis_authz_invalid_token_total</code> — Ungültige/fehlende Token</li>
</ul>
<h2 id="rbac_authorization-audit-logs">Audit-Logs<a class="headerlink" href="#rbac_authorization-audit-logs" title="Permanent link">&para;</a></h2>
<p>Bei verweigertem Zugriff wird ein WARN-Log geschrieben:</p>
<pre><code>WARN: Authorization denied for user 'monitoring': Missing required scope: config:write
</code></pre>
<p>Für vollständige Audit-Trails können strukturierte Logs (JSON) aktiviert werden (<code>POST /config</code> → <code>logging.format = "json"</code>).</p>
<h2 id="rbac_authorization-sicherheitshinweise">Sicherheitshinweise<a class="headerlink" href="#rbac_authorization-sicherheitshinweise" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Token-Rotation:</strong> Aktuell statische Token; Rotation via Neustart oder <code>/config</code> Reload (geplant: Key-Rotation-API)</li>
<li><strong>TLS:</strong> In Produktion IMMER hinter TLS-Proxy (nginx/Caddy); Token sonst plain-text übertragen</li>
<li><strong>Secrets-Management:</strong> Token nicht in Git committen; nutze Secrets-Manager (Vault, K8s Secrets)</li>
<li><strong>Least Privilege:</strong> Verteile minimale Scopes; Admin-Token nur für ops/debugging</li>
</ul>
<h2 id="rbac_authorization-roadmap-abac-policy-engine">Roadmap: ABAC &amp; Policy-Engine<a class="headerlink" href="#rbac_authorization-roadmap-abac-policy-engine" title="Permanent link">&para;</a></h2>
<p>Mittelfristig (Sprint C/Q4):</p>
<ul>
<li>ABAC-Schema (resource, action, subject attributes)</li>
<li>Policy-Store (RocksDB), Evaluator, Caching</li>
<li>Apache Ranger-kompatible Konzepte (Policies, Deny-Overrides)</li>
<li>Admin-UI für Policy-Verwaltung</li>
</ul>
<h2 id="rbac_authorization-beispiel-workflows">Beispiel-Workflows<a class="headerlink" href="#rbac_authorization-beispiel-workflows" title="Permanent link">&para;</a></h2>
<h3 id="rbac_authorization-1-monitoring-setup">1) Monitoring-Setup<a class="headerlink" href="#rbac_authorization-1-monitoring-setup" title="Permanent link">&para;</a></h3>
<p>Token mit <code>metrics:read</code> + <code>cdc:read</code>:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer readonly-token-def456&quot; \
     http://localhost:8765/metrics
</code></pre>
<h3 id="rbac_authorization-2-config-hot-reload">2) Config Hot-Reload<a class="headerlink" href="#rbac_authorization-2-config-hot-reload" title="Permanent link">&para;</a></h3>
<p>Token mit <code>config:write</code>:</p>
<pre><code class="language-bash">curl -X POST \
     -H &quot;Authorization: Bearer admin-secret-token-abc123&quot; \
     -H &quot;Content-Type: application/json&quot; \
     -d '{&quot;logging&quot;:{&quot;level&quot;:&quot;info&quot;},&quot;request_timeout_sec&quot;:60}' \
     http://localhost:8765/config
</code></pre>
<h3 id="rbac_authorization-3-cdc-subscription">3) CDC-Subscription<a class="headerlink" href="#rbac_authorization-3-cdc-subscription" title="Permanent link">&para;</a></h3>
<p>Token mit <code>cdc:read</code>:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer readonly-token-def456&quot; \
     &quot;http://localhost:8765/changefeed?from_seq=0&amp;limit=100&quot;
</code></pre>
<h2 id="rbac_authorization-testing">Testing<a class="headerlink" href="#rbac_authorization-testing" title="Permanent link">&para;</a></h2>
<p>Unit-Tests: <code>tests/test_auth_middleware.cpp</code></p>
<pre><code class="language-bash"># Build + Test
cmake --build build --config Release
.\build\Release\themis_tests.exe --gtest_filter=AuthMiddlewareTest.*
</code></pre>
<h2 id="rbac_authorization-referenzen">Referenzen<a class="headerlink" href="#rbac_authorization-referenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#security-security_compliance_review">Security/Compliance Review</a></li>
<li><a href="#operations_runbook-authentication">Operations Runbook</a></li>
<li><a href="#deployment">Deployment</a></li>
</ul></section><section class="print-page" id="security-key_management" heading-number="12.3"><h1 id="security-key_management-schlusselverwaltung-key-management">Schlüsselverwaltung (Key Management)<a class="headerlink" href="#security-key_management-schlusselverwaltung-key-management" title="Permanent link">&para;</a></h1>
<p>ThemisDB unterstützt eine externe Schlüsselverwaltung via KeyProvider. Aktuell ist standardmäßig ein MockKeyProvider verdrahtet; eine Vault‑basierte Implementierung ist vorbereitet.</p>
<h2 id="security-key_management-schlusselarten-beispiele">Schlüsselarten (Beispiele)<a class="headerlink" href="#security-key_management-schlusselarten-beispiele" title="Permanent link">&para;</a></h2>
<ul>
<li>LEK: Local Encryption Key</li>
<li>KEK: Key Encryption Key</li>
<li>DEK: Data Encryption Key</li>
</ul>
<p>Hinweis: Die konkrete Nomenklatur hängt von der Deployment‑Strategie ab (siehe encryption_strategy.md).</p>
<h2 id="security-key_management-serverapis">Server‑APIs<a class="headerlink" href="#security-key_management-serverapis" title="Permanent link">&para;</a></h2>
<ul>
<li>GET /keys – Liste verwalteter Schlüssel</li>
<li>POST /keys/rotate – Schlüsselrotation auslösen</li>
<li>Parameter: key_id (im JSON‑Body <code>{ "key_id": "DEK" }</code> oder Query <code>?key_id=DEK</code>)</li>
<li>Antworten: { success, key_id, new_version }</li>
</ul>
<p>Fehlerfälle:
- 400 Missing key_id – Schlüssel auswählen
- 503 Keys API not available – KeyProvider nicht initialisiert</p>
<h2 id="security-key_management-provider">Provider<a class="headerlink" href="#security-key_management-provider" title="Permanent link">&para;</a></h2>
<ul>
<li>MockKeyProvider – zum Testen/Entwickeln</li>
<li>VaultKeyProvider – vorbereitet (siehe <code>src/security/vault_key_provider.cpp</code>), benötigt Vault‑Konfiguration (KV v1/v2, Mount Path, Auth)</li>
</ul>
<h2 id="security-key_management-betrieb">Betrieb<a class="headerlink" href="#security-key_management-betrieb" title="Permanent link">&para;</a></h2>
<ul>
<li>Absicherung der Endpunkte (Reverse‑Proxy/Firewall/RBAC): Nur autorisierte Admins dürfen /keys/rotate aufrufen.</li>
<li>Rotation regelmäßig in der Betriebsroutine einplanen (z. B. DEK monatlich, KEK vierteljährlich).</li>
<li>Überwachung: Anzahl/Versionen der Schlüssel im Admin‑Tool; Alarme für ablaufende Schlüssel.</li>
</ul>
<h2 id="security-key_management-konfiguration">Konfiguration<a class="headerlink" href="#security-key_management-konfiguration" title="Permanent link">&para;</a></h2>
<ul>
<li>Basis‑URL des Servers (Reverse‑Proxy ggf. /api → / umschreiben)</li>
<li>Vault‑Parameter (bei Nutzung): kv_version, kv_mount_path, Auth‑Methode, TLS‑Zertifikate</li>
</ul>
<p>Siehe auch:
- Admin‑Guide (Routing‑Hinweise)
- encryption_strategy.md / encryption_deployment.md</p></section><section class="print-page" id="encryption_strategy" heading-number="12.4"><h1 id="encryption_strategy-verschlusselungsstrategie-fur-themisdb-e2e-on-premise">Verschlüsselungsstrategie für ThemisDB (E2E On-Premise)<a class="headerlink" href="#encryption_strategy-verschlusselungsstrategie-fur-themisdb-e2e-on-premise" title="Permanent link">&para;</a></h1>
<h2 id="encryption_strategy-executive-summary">Executive Summary<a class="headerlink" href="#encryption_strategy-executive-summary" title="Permanent link">&para;</a></h2>
<p><strong>Ziel:</strong> End-to-End-Verschlüsselung für sensible Daten in ThemisDB mit on-premise PKI-basiertem Key-Management unter Nutzung des VCC-PKI-Systems (<code>c:\vcc\pki</code>) und VCC-User-Systems (<code>c:\vcc\user</code>).</p>
<p><strong>Kernprinzipien:</strong>
- 🔓 <strong>Metadaten sichtbar</strong>: Indexstrukturen, PKs, Timestamps, Kategorien bleiben unverschlüsselt für Query-Performance
- 🔐 <strong>Daten verschlüsselt</strong>: Graph-Properties, Relational-Fields, Content-Blobs, Vector-Embeddings verschlüsselt at-rest
- 🔑 <strong>PKI-basiert</strong>: Integration mit VCC-PKI für Zertifikat-basierte Schlüsselableitung
- 👤 <strong>User-Context</strong>: Per-User-Verschlüsselung via VCC-User-System (JWT-Propagation)
- 🚫 <strong>Zero-Knowledge</strong>: Ohne korrekten Schlüssel keine Datenrekonstruktion möglich</p>
<hr />
<h2 id="encryption_strategy-1-architektur-ubersicht">1. Architektur-Übersicht<a class="headerlink" href="#encryption_strategy-1-architektur-ubersicht" title="Permanent link">&para;</a></h2>
<h3 id="encryption_strategy-11-threat-model">1.1 Threat Model<a class="headerlink" href="#encryption_strategy-11-threat-model" title="Permanent link">&para;</a></h3>
<p><strong>Was wird geschützt:</strong>
- Graph: Edge-Properties (z.B. <code>weight</code>, <code>metadata</code>, benutzerdefinierte Felder)
- Relational: Sensitive Spalten (z.B. <code>email</code>, <code>phone</code>, <code>address</code>, Custom-Fields)
- Content: Binärblobs (PDF, DOCX, Bilder mit EXIF, Audio mit Metadaten)
- Vector: Embeddings (768-dim float32, rekonstruierbar → Originaldokument)</p>
<p><strong>Was NICHT verschlüsselt wird (Performance/Query):</strong>
- Primary Keys, Foreign Keys
- Index-Keys (SecondaryIndex, CompositeIndex)
- Timestamps (<code>created_at</code>, <code>modified_at</code>)
- Kategorien, Tags, MIME-Types
- Vector-Dimensionen (für Index-Initialisierung)
- Graph-Topologie (Knoten-IDs, Kanten-Richtung, Label)</p>
<p><strong>Angriffszenarien:</strong>
1. ❌ Disk-Theft: Festplatte gestohlen → verschlüsselte Daten unlesbar
2. ❌ Backup-Leak: Backup-Datei im Netz → ohne Schlüssel nutzlos
3. ❌ Insider-Threat: DB-Admin ohne User-Key kann Daten nicht lesen
4. ❌ Memory-Dump: Angreifer kann nur kurzlebige In-Memory-Schlüssel extrahieren</p>
<hr />
<h2 id="encryption_strategy-2-pki-integration-vcc-pki">2. PKI-Integration (VCC-PKI)<a class="headerlink" href="#encryption_strategy-2-pki-integration-vcc-pki" title="Permanent link">&para;</a></h2>
<h3 id="encryption_strategy-21-vcc-pki-system-cvccpki">2.1 VCC-PKI System (<code>c:\vcc\pki</code>)<a class="headerlink" href="#encryption_strategy-21-vcc-pki-system-cvccpki" title="Permanent link">&para;</a></h3>
<p><strong>Vorhandene Infrastruktur:</strong>
- <strong>Root CA</strong>: 10 Jahre Gültigkeit, 4096-bit RSA
- <strong>Intermediate CA</strong>: 5 Jahre, signiert Service-Zertifikate
- <strong>Service Certificates</strong>: Pro Service (veritas, covina, clara, themis)
- <strong>REST API</strong>: <code>https://localhost:8443/api/v1</code> (FastAPI)
- <strong>mTLS</strong>: Client-Zertifikat-basierte Authentifizierung (geplant)</p>
<p><strong>Nutzung für ThemisDB:</strong></p>
<pre><code>Root CA (VCC Root CA)
 └── Intermediate CA (VCC Intermediate CA)
      ├── Service Cert: themis-db.vcc.local
      └── Data Encryption Key (DEK) Wrapping Cert
</code></pre>
<h3 id="encryption_strategy-22-key-hierarchie">2.2 Key-Hierarchie<a class="headerlink" href="#encryption_strategy-22-key-hierarchie" title="Permanent link">&para;</a></h3>
<p><strong>3-Tier Key-Architektur:</strong></p>
<pre><code>┌─────────────────────────────────────────┐
└──────────────┬──────────────────────────┘
               │ verschlüsselt
               ▼
│  DEK (Data Encryption Key)              │
│  - AES-256-GCM Master-Key               │
│  - Pro Datenbank/Tenant                 │
│  - Gespeichert verschlüsselt in DB      │
│  - Rotierbar ohne Daten-Re-Encryption   │
└──────────────┬──────────────────────────┘
│  - Aus JWT-Token + DEK abgeleitet       │
│  - HKDF mit User-ID als Context         │
│  - Ephemeral (nur In-Memory)            │
└─────────────────────────────────────────┘
               │ verschlüsselt
               ▼
        [Sensitive Data]
</code></pre>
<p><strong>Key-Derivation:</strong></p>
<pre><code class="language-cpp">// 1. KEK aus PKI-Zertifikat (einmalig beim Start)
KEK = HKDF-SHA256(
    info=&quot;KEK for ThemisDB instance&quot;
)

// 2. DEK laden/erstellen (beim DB-Init)
encrypted_DEK = storage-&gt;get(&quot;config:dek_encrypted&quot;)
if (!encrypted_DEK) {
    DEK = random_bytes(32)  // AES-256
    encrypted_DEK = AES-GCM-encrypt(DEK, KEK, nonce=random(12))
    storage-&gt;put(&quot;config:dek_encrypted&quot;, encrypted_DEK)
} else {
    DEK = AES-GCM-decrypt(encrypted_DEK, KEK)
}

// 3. User-spezifischer Field-Key (bei jedem Request)
user_id = extract_from_jwt(request.headers[&quot;Authorization&quot;])
field_key = HKDF-SHA256(
    DEK,
    salt=user_id,
    info=&quot;field-encryption:&quot; + field_name
)
---
## 3. User-Context-Integration (VCC-User)

### 3.1 VCC-User System (`c:\vcc\user`)

**Identity Propagation:**
- **Keycloak**: OIDC Identity Provider mit AD-Föderation
- **JWT-Token**: Durchgängige Propagation durch alle Services
- **Zero-Trust**: Jeder Service validiert JWT unabhängig

**JWT-Claims für ThemisDB:**
```json
{
  &quot;sub&quot;: &quot;user123&quot;,
  &quot;email&quot;: &quot;alice@vcc.local&quot;,
  &quot;groups&quot;: [&quot;data_scientists&quot;, &quot;hr_team&quot;],
  &quot;roles&quot;: [&quot;data_reader&quot;, &quot;pii_access&quot;],
  &quot;iss&quot;: &quot;https://keycloak.vcc.local/realms/vcc&quot;,
  &quot;exp&quot;: 1730000000
}
</code></pre>
<h3 id="encryption_strategy-32-access-control-basierte-verschlusselung">3.2 Access-Control-basierte Verschlüsselung<a class="headerlink" href="#encryption_strategy-32-access-control-basierte-verschlusselung" title="Permanent link">&para;</a></h3>
<p><strong>Idee:</strong> Verschiedene User-Gruppen haben verschiedene Verschlüsselungskontext → Multi-User-Encryption</p>
<p><strong>Beispiel:</strong></p>
<pre><code class="language-cpp">// In ThemisDB HTTP-Handler
std::string jwt_token = request.get_header(&quot;Authorization&quot;);
auto claims = jwt_validator_.parse_and_validate(jwt_token);
std::string user_id = claims[&quot;sub&quot;];
std::vector&lt;std::string&gt; groups = claims[&quot;groups&quot;];

// Ableitung eines gruppenspezifischen Schlüssels
std::string encryption_context = user_id; // oder group[0] für Gruppenschlüssel
auto field_key = key_provider_-&gt;deriveUserKey(dek_, encryption_context, field_name);

// Verschlüsseln mit User-Context
EncryptedBlob blob = field_encryption_-&gt;encrypt(sensitive_data, field_key);
</code></pre>
<p><strong>Vorteil:</strong>
- 👤 <strong>User-Isolation</strong>: User A kann Daten von User B nicht entschlüsseln
- 👥 <strong>Gruppenschlüssel</strong>: HR-Gruppe verschlüsselt mit <code>group=hr_team</code> → alle HR-Mitglieder können lesen
- 🔄 <strong>Key-Rotation</strong>: Bei User-Austritt → Keys ungültig ohne Daten-Re-Encryption</p>
<hr />
<h2 id="encryption_strategy-4-datenmodell-spezifische-verschlusselung">4. Datenmodell-spezifische Verschlüsselung<a class="headerlink" href="#encryption_strategy-4-datenmodell-spezifische-verschlusselung" title="Permanent link">&para;</a></h2>
<h3 id="encryption_strategy-41-graph-property-graph">4.1 Graph (Property Graph)<a class="headerlink" href="#encryption_strategy-41-graph-property-graph" title="Permanent link">&para;</a></h3>
<p><strong>Was verschlüsseln:</strong></p>
<pre><code class="language-cpp">// BaseEntity für Graph-Edge
{
  &quot;pk&quot;: &quot;graph:edge:alice-&gt;bob&quot;,           // PLAIN (Index)
  &quot;from&quot;: &quot;alice&quot;,                          // PLAIN (Topologie)
  &quot;to&quot;: &quot;bob&quot;,                              // PLAIN (Topologie)
  &quot;label&quot;: &quot;KNOWS&quot;,                         // PLAIN (Query)
  &quot;created_at&quot;: 1730000000,                 // PLAIN (Index)
  &quot;weight&quot;: 0.95,                           // 🔐 ENCRYPTED
  &quot;metadata&quot;: {                             // 🔐 ENCRYPTED (ganzes Objekt)
    &quot;since&quot;: &quot;2020-01-01&quot;,
    &quot;context&quot;: &quot;university&quot;
  }
}
</code></pre>
<p><strong>Implementierung:</strong></p>
<pre><code class="language-cpp">// In GraphIndexManager::addEdge()
BaseEntity::FieldMap fields;
fields[&quot;pk&quot;] = edge.getPrimaryKey();
fields[&quot;from&quot;] = edge.getFieldAsString(&quot;from&quot;);
fields[&quot;to&quot;] = edge.getFieldAsString(&quot;to&quot;);
fields[&quot;label&quot;] = edge.getFieldAsString(&quot;label&quot;);
fields[&quot;created_at&quot;] = edge.getFieldAsInt(&quot;created_at&quot;);

// Sensitive Felder verschlüsseln
if (auto weight = edge.getField(&quot;weight&quot;)) {
    std::string user_key = deriveUserKey(jwt_context, &quot;edge.weight&quot;);
    auto encrypted = field_enc_-&gt;encrypt(serializeValue(*weight), user_key);
    fields[&quot;weight_encrypted&quot;] = encrypted.toBase64();
}
if (auto meta = edge.getField(&quot;metadata&quot;)) {
    std::string user_key = deriveUserKey(jwt_context, &quot;edge.metadata&quot;);
    auto encrypted = field_enc_-&gt;encrypt(serializeValue(*meta), user_key);
    fields[&quot;metadata_encrypted&quot;] = encrypted.toBase64();
}

BaseEntity encrypted_edge = BaseEntity::fromFields(pk, fields);
storage_-&gt;put(key, encrypted_edge.serialize());
</code></pre>
<h3 id="encryption_strategy-42-relational-baseentity-fields">4.2 Relational (BaseEntity Fields)<a class="headerlink" href="#encryption_strategy-42-relational-baseentity-fields" title="Permanent link">&para;</a></h3>
<p><strong>Schema-basierte Verschlüsselung:</strong></p>
<pre><code class="language-json">{
  &quot;schema&quot;: {
    &quot;users&quot;: {
      &quot;fields&quot;: {
        &quot;id&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;encrypted&quot;: false, &quot;indexed&quot;: true },
        &quot;email&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;encrypted&quot;: true, &quot;indexed&quot;: false },
        &quot;name&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;encrypted&quot;: false, &quot;indexed&quot;: true },
        &quot;ssn&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;encrypted&quot;: true, &quot;indexed&quot;: false },
        &quot;salary&quot;: { &quot;type&quot;: &quot;int64&quot;, &quot;encrypted&quot;: true, &quot;indexed&quot;: false }
      }
    }
  }
}
</code></pre>
<p><strong>Automatische Verschlüsselung:</strong></p>
<pre><code class="language-cpp">// In QueryEngine beim INSERT
auto schema = loadSchema(&quot;users&quot;);
for (const auto&amp; [field, config] : schema.fields) {
    if (config.encrypted) {
        auto value = entity.getField(field);
        auto user_key = deriveUserKey(jwt, &quot;users.&quot; + field);
        auto enc = field_enc_-&gt;encrypt(serializeValue(*value), user_key);
        entity.setField(field + &quot;_encrypted&quot;, enc.toBase64());
        entity.setField(field, std::monostate{}); // clear plaintext
    }
}
</code></pre>
<h3 id="encryption_strategy-43-content-binarblobs">4.3 Content (Binärblobs)<a class="headerlink" href="#encryption_strategy-43-content-binarblobs" title="Permanent link">&para;</a></h3>
<p><strong>Chunk-Level-Verschlüsselung:</strong></p>
<pre><code class="language-cpp">// In ContentManager::importContent()
if (config.encrypt_blobs &amp;&amp; blob.has_value()) {
    std::string user_key = deriveUserKey(jwt, &quot;content.blob:&quot; + meta.id);
    auto encrypted = field_enc_-&gt;encrypt(*blob, user_key);

    // Meta-Flag setzen
    meta.encrypted = true;
    meta.encryption_type = &quot;aes-256-gcm&quot;;
    meta.encryption_context = jwt_claims[&quot;sub&quot;]; // oder group

    storage_-&gt;put(&quot;content_blob:&quot; + meta.id, encrypted.toBase64());
}

// In ContentManager::getContentBlob()
if (meta.encrypted) {
    // User-Context validieren
    if (jwt_claims[&quot;sub&quot;] != meta.encryption_context &amp;&amp; 
        !hasGroupAccess(jwt_claims, meta.encryption_context)) {
        throw UnauthorizedException(&quot;No access to encrypted content&quot;);
    }

    auto user_key = deriveUserKey(jwt, &quot;content.blob:&quot; + meta.id);
    auto decrypted = field_enc_-&gt;decrypt(encrypted_blob, user_key);
    return decrypted;
}
</code></pre>
<h3 id="encryption_strategy-44-vector-embeddings">4.4 Vector (Embeddings)<a class="headerlink" href="#encryption_strategy-44-vector-embeddings" title="Permanent link">&para;</a></h3>
<p><strong>Trade-off: Verschlüsselung vs. Nearest-Neighbor-Search</strong></p>
<p><strong>Problem:</strong>
- ANN-Search (HNSW) benötigt float32-Vektoren im Klartext
- Verschlüsselte Vektoren → keine Distanz-Berechnung möglich</p>
<p><strong>Lösungen:</strong></p>
<h4 id="encryption_strategy-option-a-keine-vektor-verschlusselung-default">Option A: Keine Vektor-Verschlüsselung (Default)<a class="headerlink" href="#encryption_strategy-option-a-keine-vektor-verschlusselung-default" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Vektoren bleiben unverschlüsselt für ANN
// Zugriff nur über authorizierte API-Calls
// Audit-Logging aller Vector-Queries
</code></pre>
<p><strong>Vorteil:</strong> ✅ Volle ANN-Performance<br />
<strong>Nachteil:</strong> ⚠️ Vektoren at-rest rekonstruierbar</p>
<h4 id="encryption_strategy-option-b-encrypt-then-search-metadata-only">Option B: Encrypt-then-Search (Metadata-only)<a class="headerlink" href="#encryption_strategy-option-b-encrypt-then-search-metadata-only" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Nur Vektor-Metadaten verschlüsseln
BaseEntity vector_entity;
vector_entity.setField(&quot;pk&quot;, pk);                    // PLAIN
vector_entity.setField(&quot;embedding&quot;, embedding);      // PLAIN (für HNSW)
vector_entity.setField(&quot;source_text_encrypted&quot;, enc_text);  // 🔐 ENCRYPTED
vector_entity.setField(&quot;metadata_encrypted&quot;, enc_meta);     // 🔐 ENCRYPTED
</code></pre>
<p><strong>Vorteil:</strong> ✅ ANN funktioniert, Quelltext geschützt<br />
<strong>Nachteil:</strong> ⚠️ Embedding selbst im Klartext</p>
<h4 id="encryption_strategy-option-c-homomorphic-encryption-future">Option C: Homomorphic Encryption (Future)<a class="headerlink" href="#encryption_strategy-option-c-homomorphic-encryption-future" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Fully Homomorphic Encryption (FHE) für Distanz-Berechnung
// Aktuell nicht produktionsreif (100-1000x Slowdown)
</code></pre>
<p><strong>Empfehlung:</strong> Start mit <strong>Option B</strong> (Metadata-Verschlüsselung), später <strong>Option C</strong> evaluieren</p>
<hr />
<h2 id="encryption_strategy-5-implementierungsplan">5. Implementierungsplan<a class="headerlink" href="#encryption_strategy-5-implementierungsplan" title="Permanent link">&para;</a></h2>
<h3 id="encryption_strategy-51-phase-1-pki-integration-week-1">5.1 Phase 1: PKI-Integration (Week 1)<a class="headerlink" href="#encryption_strategy-51-phase-1-pki-integration-week-1" title="Permanent link">&para;</a></h3>
<p><strong>Tasks:</strong>
1. ✅ Bereits vorhanden: <code>FieldEncryption</code>, <code>KeyProvider</code>, <code>EncryptedBlob</code>
2. ❌ Neuer <code>PKIKeyProvider</code>:
   <code>cpp
   class PKIKeyProvider : public KeyProvider {
   public:
       PKIKeyProvider(std::string cert_path, std::string key_path);
       std::vector&lt;uint8_t&gt; getKey(const std::string&amp; key_id, uint32_t version) override;
   private:
       std::vector&lt;uint8_t&gt; kek_;  // aus Zertifikat
       std::vector&lt;uint8_t&gt; dek_;  // aus verschlüsseltem DB-Key
   };</code></p>
<ol>
<li>❌ VCC-PKI REST-Client:
   <code>cpp
   class VCCPKIClient {
   public:
       // Zertifikat von PKI-Server holen
       Certificate requestServiceCertificate(std::string service_id);
       void verifyCertificateChain(Certificate cert);
   };</code></li>
</ol>
<h3 id="encryption_strategy-52-phase-2-user-context-week-2">5.2 Phase 2: User-Context (Week 2)<a class="headerlink" href="#encryption_strategy-52-phase-2-user-context-week-2" title="Permanent link">&para;</a></h3>
<p><strong>Tasks:</strong>
1. ❌ JWT-Validator für Keycloak-Token:
   <code>cpp
   class JWTValidator {
   public:
       nlohmann::json parseAndValidate(const std::string&amp; token);
   private:
       std::string jwks_url_;  // Keycloak JWKS-Endpoint
   };</code></p>
<ol>
<li>❌ User-Key-Derivation:
   <code>cpp
   std::vector&lt;uint8_t&gt; deriveUserKey(
       const std::vector&lt;uint8_t&gt;&amp; dek,
       const std::string&amp; user_id,
       const std::string&amp; field_name
   ) {
       return HKDF(dek, user_id, "field:" + field_name);
   }</code></li>
</ol>
<h3 id="encryption_strategy-53-phase-3-storage-layer-integration-week-3">5.3 Phase 3: Storage-Layer-Integration (Week 3)<a class="headerlink" href="#encryption_strategy-53-phase-3-storage-layer-integration-week-3" title="Permanent link">&para;</a></h3>
<p><strong>Tasks:</strong>
1. ❌ GraphIndexManager: Verschlüssele <code>weight</code>, <code>metadata</code>
2. ❌ ContentManager: Verschlüssele Blobs (bereits vorbereitet mit <code>meta.encrypted</code>)
3. ❌ VectorIndexManager: Verschlüssele Vektor-Metadaten (Option B)
4. ❌ QueryEngine: Schema-basierte Auto-Verschlüsselung</p>
<h3 id="encryption_strategy-54-phase-4-testing-audit-week-4">5.4 Phase 4: Testing &amp; Audit (Week 4)<a class="headerlink" href="#encryption_strategy-54-phase-4-testing-audit-week-4" title="Permanent link">&para;</a></h3>
<p><strong>Tests:</strong>
- Unit-Tests: Encrypt/Decrypt-Roundtrip für alle Datentypen
- Integration: Multi-User-Szenarien (User A kann Daten von User B nicht lesen)
- Performance: Overhead-Messung (Encrypt: ~0.5ms/KB, Decrypt: ~0.5ms/KB)
- Security: Pen-Test mit gestohlenem Backup ohne Keys</p>
<hr />
<h2 id="encryption_strategy-6-konfiguration">6. Konfiguration<a class="headerlink" href="#encryption_strategy-6-konfiguration" title="Permanent link">&para;</a></h2>
<h3 id="encryption_strategy-61-db-config-configencryption-in-rocksdb">6.1 DB-Config (<code>config:encryption</code> in RocksDB)<a class="headerlink" href="#encryption_strategy-61-db-config-configencryption-in-rocksdb" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;enabled&quot;: true,
  &quot;algorithm&quot;: &quot;aes-256-gcm&quot;,
  &quot;key_provider&quot;: &quot;pki&quot;,
  &quot;pki&quot;: {
    &quot;server_url&quot;: &quot;https://localhost:8443/api/v1&quot;,
    &quot;service_id&quot;: &quot;themis-db&quot;,
    &quot;cert_path&quot;: &quot;/etc/themis/certs/themis-db.pem&quot;,
    &quot;key_path&quot;: &quot;/etc/themis/certs/themis-db-key.pem&quot;
  },
  &quot;user_context&quot;: {
    &quot;enabled&quot;: true,
    &quot;jwt_issuer&quot;: &quot;https://keycloak.vcc.local/realms/vcc&quot;,
    &quot;jwks_url&quot;: &quot;https://keycloak.vcc.local/realms/vcc/protocol/openid-connect/certs&quot;
  },
  &quot;encrypt_fields&quot;: {
    &quot;graph_edge_properties&quot;: true,
    &quot;content_blobs&quot;: true,
    &quot;vector_metadata&quot;: true,
    &quot;relational_sensitive&quot;: true
  }
}
</code></pre>
<h3 id="encryption_strategy-62-schema-definition-per-collectionobject">6.2 Schema-Definition (per Collection/Object)<a class="headerlink" href="#encryption_strategy-62-schema-definition-per-collectionobject" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;collections&quot;: {
    &quot;users&quot;: {
      &quot;encryption&quot;: {
        &quot;enabled&quot;: true,
        &quot;fields&quot;: [&quot;email&quot;, &quot;phone&quot;, &quot;ssn&quot;, &quot;address&quot;],
        &quot;context_type&quot;: &quot;user&quot;  // per-user oder &quot;group&quot;
      }
    },
    &quot;documents&quot;: {
      &quot;encryption&quot;: {
        &quot;enabled&quot;: true,
        &quot;fields&quot;: [&quot;content_blob&quot;],
        &quot;context_type&quot;: &quot;group&quot;,
        &quot;allowed_groups&quot;: [&quot;legal_team&quot;, &quot;executives&quot;]
      }
    }
  }
}
</code></pre>
<hr />
<h2 id="encryption_strategy-7-security-best-practices">7. Security Best-Practices<a class="headerlink" href="#encryption_strategy-7-security-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="encryption_strategy-71-key-management">7.1 Key-Management<a class="headerlink" href="#encryption_strategy-71-key-management" title="Permanent link">&para;</a></h3>
<p>✅ <strong>DO:</strong>
- KEK aus PKI-Zertifikat ableiten (Hardware-backed wenn möglich)
- DEK verschlüsselt in DB speichern
- User-Keys nur in-memory halten (ephemeral)
- Key-Rotation alle 90 Tage (DEK), Zertifikat-Erneuerung jährlich</p>
<p>❌ <strong>DON'T:</strong>
- Keys im Klartext in Config-Dateien
- Hardcoded Keys im Source-Code
- DEK unverschlüsselt in Environment Variables</p>
<h3 id="encryption_strategy-72-audit-logging">7.2 Audit-Logging<a class="headerlink" href="#encryption_strategy-72-audit-logging" title="Permanent link">&para;</a></h3>
<p><strong>Encrypt-then-Sign für sensible Logs (SAGA, AUDIT):</strong></p>
<ul>
<li>Canonical JSON erzeugen (stabile Key-Order, UTF-8)</li>
<li>Mit täglichem LEK (Log Encryption Key) via AES-256-GCM verschlüsseln</li>
<li>Hash über den Ciphertext bilden (SHA-256)</li>
<li>PKI-Signatur über den Ciphertext-Hash (VCC-PKI)</li>
<li>Persistieren: Ciphertext + iv + tag + lek_id + Signatur + Zert-Metadaten</li>
<li>Optional redaktierte Kurzform in stdout/file loggen (kein Klartext)</li>
</ul>
<p>Konfiguration siehe Governance (<code>config/governance.yaml</code>):
- <code>saga_signing.encrypt_then_sign: true</code>
- <code>saga_signing.categories.encrypt_before_sign: [SAGA, AUDIT]</code>
- <code>log_encryption.encrypt_categories: [SAGA, AUDIT]</code>
- <code>log_encryption.aad_fields: [log_id, category, timestamp]</code></p>
<p>LEK-Handling (täglich rotierend):
1) KEK aus PKI-Zertifikat per HKDF → KEK(date)
2) Zufälliger 256-bit LEK generiert → LEK(date)
3) LEK verschlüsselt mit KEK(date) in RocksDB abgelegt</p>
<p><strong>Log jede Verschlüsselungs-/Entschlüsselungs-Operation:</strong></p>
<pre><code class="language-json">{
  &quot;timestamp&quot;: &quot;2025-10-31T10:00:00Z&quot;,
  &quot;operation&quot;: &quot;decrypt&quot;,
  &quot;user_id&quot;: &quot;user123&quot;,
  &quot;field&quot;: &quot;content.blob:abc123&quot;,
  &quot;success&quot;: true,
  &quot;ip&quot;: &quot;192.168.1.50&quot;
}
</code></pre>
<h3 id="encryption_strategy-73-zero-knowledge-compliance">7.3 Zero-Knowledge-Compliance<a class="headerlink" href="#encryption_strategy-73-zero-knowledge-compliance" title="Permanent link">&para;</a></h3>
<p><strong>Verification:</strong></p>
<pre><code class="language-bash"># Backup ohne Keys erstellen
rocksdb_dump --db=/data/themis &gt; backup.sst

# Ohne DEK: Daten unlesbar
strings backup.sst | grep &quot;alice@example.com&quot;  # → Gibberish

# Mit DEK: Daten lesbar
themis-decrypt --dek-file=dek.bin --input=backup.sst | grep &quot;alice@&quot;  # → alice@example.com
</code></pre>
<hr />
<h2 id="encryption_strategy-8-zusammenfassung">8. Zusammenfassung<a class="headerlink" href="#encryption_strategy-8-zusammenfassung" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Technologie</th>
<th>Nutzen</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PKI-Integration</strong></td>
<td>❌ TODO</td>
<td>VCC-PKI (c:\vcc\pki)</td>
<td>Zertifikat-basierte KEK</td>
</tr>
<tr>
<td><strong>User-Context</strong></td>
<td>❌ TODO</td>
<td>VCC-User JWT (c:\vcc\user)</td>
<td>Per-User-Verschlüsselung</td>
</tr>
<tr>
<td><strong>Graph-Encryption</strong></td>
<td>❌ TODO</td>
<td>AES-256-GCM</td>
<td>Edge-Properties geschützt</td>
</tr>
<tr>
<td><strong>Content-Encryption</strong></td>
<td>🟡 PARTIAL</td>
<td>AES-256-GCM</td>
<td>Blob-Verschlüsselung vorbereitet</td>
</tr>
<tr>
<td><strong>Vector-Metadata-Enc</strong></td>
<td>❌ TODO</td>
<td>AES-256-GCM</td>
<td>Quelltext geschützt, ANN nutzbar</td>
</tr>
<tr>
<td><strong>Schema-based Auto-Enc</strong></td>
<td>❌ TODO</td>
<td>Config-driven</td>
<td>Deklarative Verschlüsselung</td>
</tr>
<tr>
<td><strong>Audit-Logging</strong></td>
<td>❌ TODO</td>
<td>Encrypt-then-Sign (AES-256-GCM + PKI)</td>
<td>Compliance &amp; Forensics</td>
</tr>
</tbody>
</table>
<p><strong>Nächste Schritte:</strong>
1. Implementiere <code>PKIKeyProvider</code> mit VCC-PKI REST-Client
2. Integriere JWT-Validator für Keycloak-Token
3. Erweitere <code>GraphIndexManager</code>, <code>ContentManager</code>, <code>VectorIndexManager</code>
4. Teste Multi-User-Szenarien mit verschiedenen JWT-Claims
5. Performance-Benchmarks mit verschlüsselten Daten</p></section><section class="print-page" id="encryption_deployment" heading-number="12.5"><h1 id="encryption_deployment-themis-column-level-encryption-production-deployment-guide">Themis Column-Level Encryption - Production Deployment Guide<a class="headerlink" href="#encryption_deployment-themis-column-level-encryption-production-deployment-guide" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 1.0<br />
<strong>Last Updated:</strong> 30. Oktober 2025<br />
<strong>Target Audience:</strong> DevOps Engineers, Security Engineers, Database Administrators</p>
<hr />
<h2 id="encryption_deployment-table-of-contents">Table of Contents<a class="headerlink" href="#encryption_deployment-table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#encryption_deployment-overview">Overview</a></li>
<li><a href="#encryption_deployment-prerequisites">Prerequisites</a></li>
<li><a href="#encryption_deployment-architecture">Architecture</a></li>
<li><a href="#encryption_deployment-hashicorp-vault-setup">HashiCorp Vault Setup</a></li>
<li><a href="#encryption_deployment-key-management-strategy">Key Management Strategy</a></li>
<li><a href="#encryption_deployment-application-configuration">Application Configuration</a></li>
<li><a href="#encryption_deployment-migration-from-plaintext">Migration from Plaintext</a></li>
<li><a href="#encryption_deployment-key-rotation-procedures">Key Rotation Procedures</a></li>
<li><a href="#encryption_deployment-monitoring--alerting">Monitoring &amp; Alerting</a></li>
<li><a href="#encryption_deployment-disaster-recovery">Disaster Recovery</a></li>
<li><a href="#encryption_deployment-security-best-practices">Security Best Practices</a></li>
<li><a href="#encryption_deployment-troubleshooting">Troubleshooting</a></li>
<li><a href="#encryption_deployment-performance-tuning">Performance Tuning</a></li>
</ol>
<hr />
<h2 id="encryption_deployment-overview">Overview<a class="headerlink" href="#encryption_deployment-overview" title="Permanent link">&para;</a></h2>
<p>Themis implements <strong>column-level encryption</strong> using <strong>AES-256-GCM</strong> to protect sensitive data at rest. This guide covers deploying the encryption system in production with HashiCorp Vault as the key management backend.</p>
<h3 id="encryption_deployment-key-features">Key Features<a class="headerlink" href="#encryption_deployment-key-features" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ <strong>AES-256-GCM</strong> encryption (NIST-approved)</li>
<li>✅ <strong>Authenticated encryption</strong> (integrity + confidentiality)</li>
<li>✅ <strong>Hardware acceleration</strong> (AES-NI auto-detected)</li>
<li>✅ <strong>Key versioning</strong> for zero-downtime rotation</li>
<li>✅ <strong>Vault integration</strong> for enterprise key management</li>
<li>✅ <strong>Transparent field-level encryption</strong> (minimal code changes)</li>
</ul>
<h3 id="encryption_deployment-compliance-coverage">Compliance Coverage<a class="headerlink" href="#encryption_deployment-compliance-coverage" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Regulation</th>
<th>Requirement</th>
<th>Themis Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GDPR</strong></td>
<td>Data encryption at rest</td>
<td>✅ AES-256-GCM</td>
</tr>
<tr>
<td><strong>HIPAA</strong></td>
<td>PHI encryption</td>
<td>✅ Separate key for medical data</td>
</tr>
<tr>
<td><strong>PCI DSS</strong></td>
<td>Cardholder data protection</td>
<td>✅ Field-level encryption</td>
</tr>
<tr>
<td><strong>SOC 2</strong></td>
<td>Key management controls</td>
<td>✅ Vault integration + audit logs</td>
</tr>
<tr>
<td><strong>CCPA</strong></td>
<td>Consumer data protection</td>
<td>✅ Right to be forgotten support</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="encryption_deployment-prerequisites">Prerequisites<a class="headerlink" href="#encryption_deployment-prerequisites" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-infrastructure-requirements">Infrastructure Requirements<a class="headerlink" href="#encryption_deployment-infrastructure-requirements" title="Permanent link">&para;</a></h3>
<h4 id="encryption_deployment-hashicorp-vault">HashiCorp Vault<a class="headerlink" href="#encryption_deployment-hashicorp-vault" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>Version:</strong> Vault 1.15+ recommended</li>
<li><strong>Deployment:</strong> HA cluster (3+ nodes) for production</li>
<li><strong>Storage Backend:</strong> Consul (recommended) or Raft integrated storage</li>
<li><strong>TLS:</strong> Required for production (mutual TLS recommended)</li>
</ul>
<h4 id="encryption_deployment-application-servers">Application Servers<a class="headerlink" href="#encryption_deployment-application-servers" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>CPU:</strong> AES-NI support (Intel/AMD x86-64)</li>
<li>Check: <code>grep -E 'aes|sse4_2' /proc/cpuinfo</code> (Linux)</li>
<li>Check: <code>sysctl -a | grep machdep.cpu.features</code> (macOS)</li>
<li><strong>Memory:</strong> +512MB heap for key cache</li>
<li><strong>Network:</strong> Low-latency connection to Vault (&lt;5ms RTT recommended)</li>
</ul>
<h4 id="encryption_deployment-database">Database<a class="headerlink" href="#encryption_deployment-database" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>RocksDB:</strong> Storage for encrypted data</li>
<li><strong>Disk:</strong> SSD recommended for encrypted blob performance</li>
<li><strong>Space:</strong> Plan for 20-30% overhead vs plaintext</li>
</ul>
<h3 id="encryption_deployment-software-dependencies">Software Dependencies<a class="headerlink" href="#encryption_deployment-software-dependencies" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Required libraries (installed via vcpkg)
curl &gt;= 8.0
openssl &gt;= 3.0
nlohmann-json &gt;= 3.11
rocksdb &gt;= 8.0
</code></pre>
<h3 id="encryption_deployment-access-requirements">Access Requirements<a class="headerlink" href="#encryption_deployment-access-requirements" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Vault Admin Access:</strong> For initial setup and key creation</li>
<li><strong>Application Service Account:</strong> Vault token or AppRole authentication</li>
<li><strong>Network Access:</strong> Application → Vault (port 8200, TLS)</li>
</ul>
<hr />
<h2 id="encryption_deployment-architecture">Architecture<a class="headerlink" href="#encryption_deployment-architecture" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-component-diagram">Component Diagram<a class="headerlink" href="#encryption_deployment-component-diagram" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                    Application Layer                     │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  ┌─────────────┐     ┌──────────────────┐              │
│  │   User      │────▶│ EncryptedField&lt;T&gt;│              │
│  │   Customer  │     │   - email        │              │
│  │   Document  │     │   - ssn          │              │
│  └─────────────┘     │   - credit_score │              │
│                      └──────────┬───────┘              │
│                                 │                        │
│                      ┌──────────▼────────┐              │
│                      │  FieldEncryption  │              │
│                      │  (AES-256-GCM)    │              │
│                      └──────────┬────────┘              │
│                                 │                        │
│                      ┌──────────▼────────┐              │
│                      │  VaultKeyProvider │              │
│                      │  - Key caching    │              │
│                      │  - Token refresh  │              │
│                      └──────────┬────────┘              │
└──────────────────────────────────┼──────────────────────┘
                                   │ HTTPS/TLS
                      ┌────────────▼─────────────┐
                      │   HashiCorp Vault        │
                      │   KV Secrets Engine v2   │
                      ├──────────────────────────┤
                      │  Keys:                   │
                      │   - user_pii (v1, v2)   │
                      │   - user_sensitive (v1) │
                      │   - customer_financial  │
                      └──────────────────────────┘
                                   │
                      ┌────────────▼─────────────┐
                      │   Vault Storage          │
                      │   (Consul/Raft)          │
                      └──────────────────────────┘
</code></pre>
<h3 id="encryption_deployment-data-flow">Data Flow<a class="headerlink" href="#encryption_deployment-data-flow" title="Permanent link">&para;</a></h3>
<p><strong>Write Path (Encryption):</strong></p>
<pre><code>1. User.email = &quot;alice@example.com&quot;
2. EncryptedField.encrypt(&quot;alice@example.com&quot;, &quot;user_pii&quot;)
3. VaultKeyProvider.getKey(&quot;user_pii&quot;) → [Check cache]
4. If cache miss: HTTP GET /v1/themis/data/keys/user_pii
5. Vault returns: {data: {key: &quot;&lt;base64&gt;&quot;, version: 2}}
6. Cache key for 1 hour
7. FieldEncryption.encrypt(plaintext, key) → AES-256-GCM
8. Generate random IV (96 bits)
9. Encrypt + generate auth tag (128 bits)
10. Return: &quot;user_pii:2:IV:ciphertext:tag&quot; (base64)
11. Store in RocksDB as JSON: {&quot;email&quot;: &quot;user_pii:2:...&quot;}
</code></pre>
<p><strong>Read Path (Decryption):</strong></p>
<pre><code>1. Fetch from RocksDB: {&quot;email&quot;: &quot;user_pii:2:IV:ciphertext:tag&quot;}
2. EncryptedField.fromBase64(&quot;user_pii:2:...&quot;)
3. Parse: key_id=&quot;user_pii&quot;, version=2, IV, ciphertext, tag
4. VaultKeyProvider.getKey(&quot;user_pii&quot;, version=2) → [Check cache]
5. If cache miss: HTTP GET /v1/themis/data/keys/user_pii?version=2
6. FieldEncryption.decrypt(ciphertext, key, IV, tag)
7. Verify authentication tag (prevents tampering)
8. Decrypt using AES-256-GCM
9. Return plaintext: &quot;alice@example.com&quot;
</code></pre>
<hr />
<h2 id="encryption_deployment-hashicorp-vault-setup">HashiCorp Vault Setup<a class="headerlink" href="#encryption_deployment-hashicorp-vault-setup" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-step-1-deploy-vault-cluster">Step 1: Deploy Vault Cluster<a class="headerlink" href="#encryption_deployment-step-1-deploy-vault-cluster" title="Permanent link">&para;</a></h3>
<h4 id="encryption_deployment-production-ha-setup-recommended">Production HA Setup (Recommended)<a class="headerlink" href="#encryption_deployment-production-ha-setup-recommended" title="Permanent link">&para;</a></h4>
<pre><code class="language-bash"># Using Docker Compose for quick setup
# For production, use Kubernetes/Nomad or systemd

cat &gt; docker-compose.yml &lt;&lt;EOF
version: '3.8'
services:
  vault1:
    image: hashicorp/vault:1.15
    container_name: vault-1
    ports:
      - &quot;8200:8200&quot;
    environment:
      VAULT_ADDR: 'https://0.0.0.0:8200'
      VAULT_API_ADDR: 'https://vault-1:8200'
    volumes:
      - ./vault/config:/vault/config:ro
      - ./vault/data:/vault/data
      - ./vault/logs:/vault/logs
    cap_add:
      - IPC_LOCK
    command: server

  vault2:
    image: hashicorp/vault:1.15
    container_name: vault-2
    ports:
      - &quot;8201:8200&quot;
    environment:
      VAULT_ADDR: 'https://0.0.0.0:8200'
      VAULT_API_ADDR: 'https://vault-2:8200'
    volumes:
      - ./vault/config:/vault/config:ro
      - ./vault/data2:/vault/data
      - ./vault/logs2:/vault/logs
    cap_add:
      - IPC_LOCK
    command: server

  vault3:
    image: hashicorp/vault:1.15
    container_name: vault-3
    ports:
      - &quot;8202:8200&quot;
    environment:
      VAULT_ADDR: 'https://0.0.0.0:8200'
      VAULT_API_ADDR: 'https://vault-3:8200'
    volumes:
      - ./vault/config:/vault/config:ro
      - ./vault/data3:/vault/data
      - ./vault/logs3:/vault/logs
    cap_add:
      - IPC_LOCK
    command: server

  consul:
    image: hashicorp/consul:1.16
    container_name: consul
    ports:
      - &quot;8500:8500&quot;
    command: agent -server -ui -bootstrap-expect=1 -client=0.0.0.0
EOF

# Vault configuration
mkdir -p vault/config
cat &gt; vault/config/vault.hcl &lt;&lt;EOF
storage &quot;consul&quot; {
  address = &quot;consul:8500&quot;
  path    = &quot;vault/&quot;
}

listener &quot;tcp&quot; {
  address     = &quot;0.0.0.0:8200&quot;
  tls_cert_file = &quot;/vault/config/tls/vault.crt&quot;
  tls_key_file  = &quot;/vault/config/tls/vault.key&quot;
}

api_addr = &quot;https://vault-1:8200&quot;
cluster_addr = &quot;https://vault-1:8201&quot;
ui = true

# Performance tuning
max_lease_ttl = &quot;87600h&quot;  # 10 years
default_lease_ttl = &quot;87600h&quot;

# Enable Prometheus metrics
telemetry {
  prometheus_retention_time = &quot;24h&quot;
  disable_hostname = true
}
EOF

docker-compose up -d
</code></pre>
<h4 id="encryption_deployment-generate-tls-certificates">Generate TLS Certificates<a class="headerlink" href="#encryption_deployment-generate-tls-certificates" title="Permanent link">&para;</a></h4>
<pre><code class="language-bash"># Create CA
openssl req -x509 -newkey rsa:4096 -keyout vault/config/tls/ca-key.pem \
  -out vault/config/tls/ca.pem -days 3650 -nodes \
  -subj &quot;/C=US/ST=CA/L=SF/O=Themis/CN=Vault CA&quot;

# Create Vault certificate
openssl req -newkey rsa:4096 -keyout vault/config/tls/vault.key \
  -out vault/config/tls/vault.csr -nodes \
  -subj &quot;/C=US/ST=CA/L=SF/O=Themis/CN=vault.example.com&quot;

openssl x509 -req -in vault/config/tls/vault.csr \
  -CA vault/config/tls/ca.pem -CAkey vault/config/tls/ca-key.pem \
  -CAcreateserial -out vault/config/tls/vault.crt -days 825 \
  -extensions v3_req -extfile &lt;(cat &lt;&lt;EOF
[v3_req]
subjectAltName = @alt_names
[alt_names]
DNS.1 = vault.example.com
DNS.2 = localhost
IP.1 = 127.0.0.1
EOF
)
</code></pre>
<h3 id="encryption_deployment-step-2-initialize-vault">Step 2: Initialize Vault<a class="headerlink" href="#encryption_deployment-step-2-initialize-vault" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">export VAULT_ADDR='https://vault.example.com:8200'
export VAULT_CACERT='/path/to/ca.pem'

# Initialize (DO THIS ONCE)
vault operator init -key-shares=5 -key-threshold=3 &gt; vault-init.txt

# CRITICAL: Store unseal keys and root token securely!
# Distribute unseal keys to different trusted personnel

# Unseal all 3 nodes (requires 3 of 5 keys)
vault operator unseal &lt;key1&gt;
vault operator unseal &lt;key2&gt;
vault operator unseal &lt;key3&gt;

# Login with root token
vault login &lt;root-token&gt;
</code></pre>
<h3 id="encryption_deployment-step-3-enable-kv-secrets-engine">Step 3: Enable KV Secrets Engine<a class="headerlink" href="#encryption_deployment-step-3-enable-kv-secrets-engine" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Enable KV v2 secrets engine
vault secrets enable -version=2 -path=themis kv

# Verify
vault secrets list
# Should show:
# themis/    kv    n/a       n/a     n/a        n/a   28h24m30s   n/a
</code></pre>
<h3 id="encryption_deployment-step-4-create-encryption-keys">Step 4: Create Encryption Keys<a class="headerlink" href="#encryption_deployment-step-4-create-encryption-keys" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Helper script to generate encryption keys
cat &gt; create-encryption-key.sh &lt;&lt;'EOF'
#!/bin/bash
set -e

KEY_ID=$1
DESCRIPTION=$2

if [ -z &quot;$KEY_ID&quot; ]; then
  echo &quot;Usage: $0 &lt;key_id&gt; [description]&quot;
  exit 1
fi

# Generate 256-bit random key
KEY=$(openssl rand -base64 32)

# Store in Vault
vault kv put themis/keys/$KEY_ID \
  key=&quot;$KEY&quot; \
  algorithm=&quot;AES-256-GCM&quot; \
  version=1 \
  description=&quot;$DESCRIPTION&quot; \
  created_at=&quot;$(date -u +%Y-%m-%dT%H:%M:%SZ)&quot;

echo &quot;✅ Created key: $KEY_ID&quot;
vault kv get themis/keys/$KEY_ID
EOF

chmod +x create-encryption-key.sh

# Create keys for different data categories
./create-encryption-key.sh user_pii &quot;General user PII (email, phone, address)&quot;
./create-encryption-key.sh user_sensitive &quot;High-sensitivity user data (SSN, medical records)&quot;
./create-encryption-key.sh customer_financial &quot;Financial data (credit scores, income)&quot;
./create-encryption-key.sh payment_info &quot;Payment card data (PCI DSS)&quot;
</code></pre>
<h3 id="encryption_deployment-step-5-create-application-policy">Step 5: Create Application Policy<a class="headerlink" href="#encryption_deployment-step-5-create-application-policy" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Policy for Themis application
cat &gt; themis-policy.hcl &lt;&lt;EOF
# Read access to encryption keys
path &quot;themis/data/keys/*&quot; {
  capabilities = [&quot;read&quot;, &quot;list&quot;]
}

# Read key metadata (for rotation monitoring)
path &quot;themis/metadata/keys/*&quot; {
  capabilities = [&quot;read&quot;, &quot;list&quot;]
}

# Deny write/delete (keys managed by admins only)
path &quot;themis/data/keys/*&quot; {
  capabilities = [&quot;deny&quot;]
  denied_parameters = {
    &quot;*&quot; = []
  }
}
EOF

vault policy write themis-app themis-policy.hcl

# Verify
vault policy read themis-app
</code></pre>
<h3 id="encryption_deployment-step-6-configure-approle-authentication">Step 6: Configure AppRole Authentication<a class="headerlink" href="#encryption_deployment-step-6-configure-approle-authentication" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Enable AppRole auth
vault auth enable approle

# Create role for Themis application
vault write auth/approle/role/themis-app \
  token_ttl=1h \
  token_max_ttl=4h \
  token_policies=&quot;themis-app&quot; \
  secret_id_ttl=0 \
  secret_id_num_uses=0

# Get role ID
vault read auth/approle/role/themis-app/role-id
# role_id: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx

# Generate secret ID
vault write -f auth/approle/role/themis-app/secret-id
# secret_id: yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy

# Store role_id and secret_id securely (e.g., Kubernetes secrets)
</code></pre>
<hr />
<h2 id="encryption_deployment-key-management-strategy">Key Management Strategy<a class="headerlink" href="#encryption_deployment-key-management-strategy" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-key-categorization">Key Categorization<a class="headerlink" href="#encryption_deployment-key-categorization" title="Permanent link">&para;</a></h3>
<p>Organize keys by <strong>data sensitivity</strong> and <strong>rotation frequency</strong>:</p>
<table>
<thead>
<tr>
<th>Key ID</th>
<th>Purpose</th>
<th>Data Examples</th>
<th>Rotation Frequency</th>
<th>Compliance</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user_pii</code></td>
<td>General PII</td>
<td>Email, phone, address</td>
<td>12 months</td>
<td>GDPR, CCPA</td>
</tr>
<tr>
<td><code>user_sensitive</code></td>
<td>High-sensitivity PII</td>
<td>SSN, passport, medical ID</td>
<td>6 months</td>
<td>HIPAA, GDPR</td>
</tr>
<tr>
<td><code>customer_financial</code></td>
<td>Financial data</td>
<td>Credit score, income</td>
<td>6 months</td>
<td>PCI DSS, SOC 2</td>
</tr>
<tr>
<td><code>payment_info</code></td>
<td>Payment cards</td>
<td>Card number, CVV</td>
<td>3 months</td>
<td>PCI DSS</td>
</tr>
<tr>
<td><code>healthcare_phi</code></td>
<td>Protected health info</td>
<td>Diagnoses, prescriptions</td>
<td>6 months</td>
<td>HIPAA</td>
</tr>
</tbody>
</table>
<h3 id="encryption_deployment-key-versioning-scheme">Key Versioning Scheme<a class="headerlink" href="#encryption_deployment-key-versioning-scheme" title="Permanent link">&para;</a></h3>
<pre><code>Key Format: &lt;key_id&gt;:&lt;version&gt;:&lt;iv&gt;:&lt;ciphertext&gt;:&lt;tag&gt;
Example:    user_pii:2:ghQO6IvYuVdlrXna:qh6kXp9P6dPJlceX4hMes4U=:H9/fjZNKYg==

Version Lifecycle:
  v1: ACTIVE    → Encrypts new data, decrypts old data
  v2: ROTATING  → Dual-write phase (v1 deprecated, v2 active)
  v1: DEPRECATED→ Decrypts old data only (no new encryptions)
  v1: DELETED   → After grace period (90 days), physically deleted
</code></pre>
<h3 id="encryption_deployment-key-rotation-schedule">Key Rotation Schedule<a class="headerlink" href="#encryption_deployment-key-rotation-schedule" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Automated rotation cron job (run monthly)
cat &gt; /etc/cron.monthly/rotate-encryption-keys.sh &lt;&lt;'EOF'
#!/bin/bash
set -e

VAULT_ADDR=&quot;https://vault.example.com:8200&quot;
VAULT_TOKEN=&quot;&lt;service-account-token&gt;&quot;

# Rotate keys older than 6 months
for KEY_ID in user_sensitive customer_financial healthcare_phi; do
  CURRENT_VERSION=$(vault kv get -format=json themis/keys/$KEY_ID | jq -r '.data.metadata.version')
  NEW_VERSION=$((CURRENT_VERSION + 1))

  NEW_KEY=$(openssl rand -base64 32)

  vault kv put themis/keys/$KEY_ID \
    key=&quot;$NEW_KEY&quot; \
    algorithm=&quot;AES-256-GCM&quot; \
    version=$NEW_VERSION \
    created_at=&quot;$(date -u +%Y-%m-%dT%H:%M:%SZ)&quot; \
    rotated_from_version=$CURRENT_VERSION

  echo &quot;✅ Rotated $KEY_ID: v$CURRENT_VERSION → v$NEW_VERSION&quot;

  # Trigger application re-encryption job
  curl -X POST https://themis-api.example.com/admin/re-encrypt \
    -H &quot;Authorization: Bearer $ADMIN_TOKEN&quot; \
    -d &quot;{\&quot;key_id\&quot;: \&quot;$KEY_ID\&quot;, \&quot;target_version\&quot;: $NEW_VERSION}&quot;
done
EOF

chmod +x /etc/cron.monthly/rotate-encryption-keys.sh
</code></pre>
<hr />
<h2 id="encryption_deployment-application-configuration">Application Configuration<a class="headerlink" href="#encryption_deployment-application-configuration" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-vaultkeyprovider-configuration">VaultKeyProvider Configuration<a class="headerlink" href="#encryption_deployment-vaultkeyprovider-configuration" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// config/encryption.hpp
#include &quot;security/vault_key_provider.h&quot;

themis::VaultKeyProvider::Config getVaultConfig() {
    themis::VaultKeyProvider::Config config;

    // Vault connection
    config.vault_addr = std::getenv(&quot;VAULT_ADDR&quot;) ?: &quot;https://vault.example.com:8200&quot;;
    config.vault_token = std::getenv(&quot;VAULT_TOKEN&quot;) ?: &quot;&quot;;  // From AppRole login
    config.kv_mount_path = &quot;themis&quot;;
    config.kv_version = &quot;v2&quot;;

    // TLS configuration
    config.verify_ssl = true;
    config.ca_cert_path = &quot;/etc/ssl/certs/vault-ca.pem&quot;;

    // Performance tuning
    config.cache_ttl_seconds = 3600;      // 1 hour cache
    config.cache_capacity = 1000;         // Max 1000 cached keys
    config.request_timeout_ms = 5000;     // 5 second timeout

    // Connection pooling (if using custom HTTP client)
    config.max_connections = 10;
    config.keepalive = true;

    return config;
}

// Initialize in application startup
void initializeEncryption() {
    auto vault_config = getVaultConfig();
    auto key_provider = std::make_shared&lt;themis::VaultKeyProvider&gt;(vault_config);
    auto encryption = std::make_shared&lt;themis::FieldEncryption&gt;(key_provider);

    // Set global encryption for all field types
    themis::EncryptedField&lt;std::string&gt;::setFieldEncryption(encryption);
    themis::EncryptedField&lt;int64_t&gt;::setFieldEncryption(encryption);
    themis::EncryptedField&lt;double&gt;::setFieldEncryption(encryption);

    // Warm up cache with frequently used keys
    key_provider-&gt;getKey(&quot;user_pii&quot;);
    key_provider-&gt;getKey(&quot;user_sensitive&quot;);
    key_provider-&gt;getKey(&quot;customer_financial&quot;);
}
</code></pre>
<h3 id="encryption_deployment-environment-variables">Environment Variables<a class="headerlink" href="#encryption_deployment-environment-variables" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Production environment (.env file)
VAULT_ADDR=https://vault.example.com:8200
VAULT_TOKEN=&lt;from-approle-login&gt;
VAULT_CACERT=/etc/ssl/certs/vault-ca.pem
VAULT_NAMESPACE=themis  # For Vault Enterprise

# Optional: Override defaults
ENCRYPTION_CACHE_TTL=3600
ENCRYPTION_CACHE_SIZE=1000
ENCRYPTION_KEY_MOUNT=themis
</code></pre>
<h3 id="encryption_deployment-kubernetes-deployment">Kubernetes Deployment<a class="headerlink" href="#encryption_deployment-kubernetes-deployment" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml"># kubernetes/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: themis-api
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: themis-api
  template:
    metadata:
      labels:
        app: themis-api
    spec:
      serviceAccountName: themis-app
      containers:
      - name: themis-api
        image: themis:latest
        env:
        - name: VAULT_ADDR
          value: &quot;https://vault.vault.svc.cluster.local:8200&quot;
        - name: VAULT_TOKEN
          valueFrom:
            secretKeyRef:
              name: vault-token
              key: token
        - name: VAULT_CACERT
          value: &quot;/vault/tls/ca.crt&quot;
        volumeMounts:
        - name: vault-tls
          mountPath: /vault/tls
          readOnly: true
        resources:
          requests:
            memory: &quot;2Gi&quot;
            cpu: &quot;1000m&quot;
          limits:
            memory: &quot;4Gi&quot;
            cpu: &quot;2000m&quot;
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: vault-tls
        secret:
          secretName: vault-ca-cert

---
# Vault token secret (from AppRole login)
apiVersion: v1
kind: Secret
metadata:
  name: vault-token
  namespace: production
type: Opaque
data:
  token: &lt;base64-encoded-vault-token&gt;
</code></pre>
<hr />
<h2 id="encryption_deployment-migration-from-plaintext">Migration from Plaintext<a class="headerlink" href="#encryption_deployment-migration-from-plaintext" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-phase-1-assessment-week-1">Phase 1: Assessment (Week 1)<a class="headerlink" href="#encryption_deployment-phase-1-assessment-week-1" title="Permanent link">&para;</a></h3>
<pre><code class="language-sql">-- Identify columns to encrypt
SELECT 
  table_name,
  column_name,
  data_type,
  COUNT(*) as row_count,
  SUM(LENGTH(column_name)) as total_bytes
FROM information_schema.columns
WHERE column_name IN ('email', 'ssn', 'phone', 'credit_card')
GROUP BY table_name, column_name;

-- Estimate migration time
-- Rule of thumb: 10,000 rows/second on modern hardware
</code></pre>
<h3 id="encryption_deployment-phase-2-schema-changes-week-2">Phase 2: Schema Changes (Week 2)<a class="headerlink" href="#encryption_deployment-phase-2-schema-changes-week-2" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Add encrypted columns alongside plaintext (dual-write phase)
struct User {
    std::string id;
    std::string username;

    // OLD: Plaintext (deprecated)
    std::string email_plaintext;
    std::string ssn_plaintext;

    // NEW: Encrypted
    EncryptedField&lt;std::string&gt; email;
    EncryptedField&lt;std::string&gt; ssn;

    // Migration flag
    bool is_encrypted = false;
};
</code></pre>
<h3 id="encryption_deployment-phase-3-dual-write-migration-week-3-4">Phase 3: Dual-Write Migration (Week 3-4)<a class="headerlink" href="#encryption_deployment-phase-3-dual-write-migration-week-3-4" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Write to both plaintext and encrypted columns
void saveUser(const User&amp; user) {
    // Write plaintext (for backward compatibility)
    db-&gt;put(&quot;user:&quot; + user.id + &quot;:email_plain&quot;, user.email_plaintext);

    // Write encrypted
    user.email.encrypt(user.email_plaintext, &quot;user_pii&quot;);
    auto encrypted_blob = user.email.toBase64();
    db-&gt;put(&quot;user:&quot; + user.id + &quot;:email_enc&quot;, encrypted_blob);

    // Mark as encrypted
    db-&gt;put(&quot;user:&quot; + user.id + &quot;:encrypted&quot;, &quot;true&quot;);
}

// Background migration job
void migrateUserData() {
    auto all_users = db-&gt;scan(&quot;user:&quot;);

    for (const auto&amp; [key, value] : all_users) {
        std::string user_id = extractUserId(key);

        // Skip if already encrypted
        auto encrypted_flag = db-&gt;get(&quot;user:&quot; + user_id + &quot;:encrypted&quot;);
        if (encrypted_flag == &quot;true&quot;) continue;

        // Migrate plaintext to encrypted
        auto email_plain = db-&gt;get(&quot;user:&quot; + user_id + &quot;:email_plain&quot;);
        if (!email_plain.empty()) {
            EncryptedField&lt;std::string&gt; email_enc;
            email_enc.encrypt(email_plain, &quot;user_pii&quot;);
            db-&gt;put(&quot;user:&quot; + user_id + &quot;:email_enc&quot;, email_enc.toBase64());
        }

        db-&gt;put(&quot;user:&quot; + user_id + &quot;:encrypted&quot;, &quot;true&quot;);

        // Log progress
        std::cout &lt;&lt; &quot;Migrated user: &quot; &lt;&lt; user_id &lt;&lt; std::endl;
    }
}
</code></pre>
<h3 id="encryption_deployment-phase-4-switch-reads-week-5">Phase 4: Switch Reads (Week 5)<a class="headerlink" href="#encryption_deployment-phase-4-switch-reads-week-5" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Preferentially read from encrypted columns
std::string getUserEmail(const std::string&amp; user_id) {
    // Try encrypted first
    auto encrypted_data = db-&gt;get(&quot;user:&quot; + user_id + &quot;:email_enc&quot;);
    if (!encrypted_data.empty()) {
        auto email_field = EncryptedField&lt;std::string&gt;::fromBase64(encrypted_data);
        return email_field.decrypt();
    }

    // Fallback to plaintext (for unmigrated users)
    return db-&gt;get(&quot;user:&quot; + user_id + &quot;:email_plain&quot;);
}
</code></pre>
<h3 id="encryption_deployment-phase-5-cleanup-week-6">Phase 5: Cleanup (Week 6+)<a class="headerlink" href="#encryption_deployment-phase-5-cleanup-week-6" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// After 100% migration confirmed, delete plaintext columns
void cleanupPlaintextData() {
    auto all_users = db-&gt;scan(&quot;user:&quot;);

    for (const auto&amp; [key, value] : all_users) {
        if (key.find(&quot;:email_plain&quot;) != std::string::npos ||
            key.find(&quot;:ssn_plain&quot;) != std::string::npos) {

            std::string user_id = extractUserId(key);

            // Verify encrypted version exists
            auto encrypted_flag = db-&gt;get(&quot;user:&quot; + user_id + &quot;:encrypted&quot;);
            if (encrypted_flag == &quot;true&quot;) {
                // Safe to delete plaintext
                db-&gt;del(key);
                std::cout &lt;&lt; &quot;Deleted plaintext: &quot; &lt;&lt; key &lt;&lt; std::endl;
            }
        }
    }
}
</code></pre>
<hr />
<h2 id="encryption_deployment-key-rotation-procedures">Key Rotation Procedures<a class="headerlink" href="#encryption_deployment-key-rotation-procedures" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-manual-rotation-process">Manual Rotation Process<a class="headerlink" href="#encryption_deployment-manual-rotation-process" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">#!/bin/bash
# rotate-key.sh - Manual key rotation script

set -e

KEY_ID=$1
if [ -z &quot;$KEY_ID&quot; ]; then
  echo &quot;Usage: $0 &lt;key_id&gt;&quot;
  exit 1
fi

echo &quot;🔄 Starting key rotation for: $KEY_ID&quot;

# Step 1: Get current version
CURRENT=$(vault kv get -format=json themis/keys/$KEY_ID | jq -r '.data.metadata.version')
NEW_VERSION=$((CURRENT + 1))

echo &quot;📊 Current version: $CURRENT&quot;
echo &quot;📊 New version: $NEW_VERSION&quot;

# Step 2: Generate new key
NEW_KEY=$(openssl rand -base64 32)

# Step 3: Store new version in Vault
vault kv put themis/keys/$KEY_ID \
  key=&quot;$NEW_KEY&quot; \
  algorithm=&quot;AES-256-GCM&quot; \
  version=$NEW_VERSION \
  created_at=&quot;$(date -u +%Y-%m-%dT%H:%M:%SZ)&quot; \
  rotated_from=$CURRENT \
  rotation_reason=&quot;Scheduled rotation&quot;

echo &quot;✅ New key version created in Vault&quot;

# Step 4: Trigger application cache invalidation
curl -X POST https://themis-api.example.com/admin/cache/invalidate \
  -H &quot;Authorization: Bearer $ADMIN_TOKEN&quot; \
  -d &quot;{\&quot;key_id\&quot;: \&quot;$KEY_ID\&quot;}&quot;

echo &quot;✅ Application caches invalidated&quot;

# Step 5: Start background re-encryption
curl -X POST https://themis-api.example.com/admin/re-encrypt \
  -H &quot;Authorization: Bearer $ADMIN_TOKEN&quot; \
  -d &quot;{
    \&quot;key_id\&quot;: \&quot;$KEY_ID\&quot;,
    \&quot;source_version\&quot;: $CURRENT,
    \&quot;target_version\&quot;: $NEW_VERSION,
    \&quot;batch_size\&quot;: 1000
  }&quot;

echo &quot;✅ Re-encryption job started&quot;
echo &quot;🎉 Key rotation completed!&quot;
</code></pre>
<h3 id="encryption_deployment-re-encryption-job-implementation">Re-Encryption Job Implementation<a class="headerlink" href="#encryption_deployment-re-encryption-job-implementation" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Background job to re-encrypt data with new key version
class ReEncryptionJob {
public:
    struct Config {
        std::string key_id;
        uint32_t source_version;
        uint32_t target_version;
        size_t batch_size = 1000;
        size_t parallelism = 4;
    };

    ReEncryptionJob(
        std::shared_ptr&lt;RocksDBWrapper&gt; db,
        std::shared_ptr&lt;FieldEncryption&gt; encryption,
        const Config&amp; config
    ) : db_(db), encryption_(encryption), config_(config) {}

    void run() {
        std::cout &lt;&lt; &quot;🔄 Starting re-encryption: &quot; &lt;&lt; config_.key_id 
                  &lt;&lt; &quot; v&quot; &lt;&lt; config_.source_version 
                  &lt;&lt; &quot; → v&quot; &lt;&lt; config_.target_version &lt;&lt; std::endl;

        auto start = std::chrono::steady_clock::now();
        size_t total_count = 0;
        size_t success_count = 0;

        // Scan all encrypted fields
        auto it = db_-&gt;newIterator();
        for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {
            std::string key = it-&gt;key().ToString();
            std::string value = it-&gt;value().ToString();

            try {
                // Parse encrypted blob
                json j = json::parse(value);

                for (auto&amp; [field_name, field_value] : j.items()) {
                    if (!field_value.is_string()) continue;

                    std::string blob_str = field_value.get&lt;std::string&gt;();

                    // Check if this field uses the key being rotated
                    if (blob_str.find(config_.key_id + &quot;:&quot;) == 0) {
                        auto blob = EncryptedBlob::fromBase64(blob_str);

                        if (blob.key_version == config_.source_version) {
                            // Decrypt with old key
                            std::string plaintext = encryption_-&gt;decryptToString(blob);

                            // Re-encrypt with new key
                            EncryptedField&lt;std::string&gt; new_field;
                            new_field.encrypt(plaintext, config_.key_id);

                            // Update JSON
                            j[field_name] = new_field.toBase64();

                            success_count++;
                        }
                    }
                }

                // Write updated record
                db_-&gt;put(key, j.dump());
                total_count++;

                if (total_count % 1000 == 0) {
                    std::cout &lt;&lt; &quot;Progress: &quot; &lt;&lt; total_count &lt;&lt; &quot; records processed, &quot;
                              &lt;&lt; success_count &lt;&lt; &quot; fields re-encrypted&quot; &lt;&lt; std::endl;
                }

            } catch (const std::exception&amp; e) {
                std::cerr &lt;&lt; &quot;Error processing key &quot; &lt;&lt; key &lt;&lt; &quot;: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
            }
        }

        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(end - start).count();

        std::cout &lt;&lt; &quot;✅ Re-encryption completed:&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;   Records processed: &quot; &lt;&lt; total_count &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;   Fields re-encrypted: &quot; &lt;&lt; success_count &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;   Duration: &quot; &lt;&lt; duration &lt;&lt; &quot;s&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;   Throughput: &quot; &lt;&lt; (total_count / duration) &lt;&lt; &quot; records/sec&quot; &lt;&lt; std::endl;
    }

private:
    std::shared_ptr&lt;RocksDBWrapper&gt; db_;
    std::shared_ptr&lt;FieldEncryption&gt; encryption_;
    Config config_;
};
</code></pre>
<hr />
<h2 id="encryption_deployment-monitoring-alerting">Monitoring &amp; Alerting<a class="headerlink" href="#encryption_deployment-monitoring-alerting" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-key-metrics">Key Metrics<a class="headerlink" href="#encryption_deployment-key-metrics" title="Permanent link">&para;</a></h3>
<h4 id="encryption_deployment-application-metrics">Application Metrics<a class="headerlink" href="#encryption_deployment-application-metrics" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Prometheus metrics (pseudocode)
class EncryptionMetrics {
public:
    // Counters
    prometheus::Counter encryption_operations;
    prometheus::Counter decryption_operations;
    prometheus::Counter encryption_errors;
    prometheus::Counter decryption_errors;

    // Histograms
    prometheus::Histogram encryption_duration_ms;
    prometheus::Histogram decryption_duration_ms;
    prometheus::Histogram vault_request_duration_ms;

    // Gauges
    prometheus::Gauge key_cache_size;
    prometheus::Gauge key_cache_hit_rate;
    prometheus::Gauge active_key_versions;
};

// Record metrics
void FieldEncryption::encrypt(const std::string&amp; plaintext, const std::string&amp; key_id) {
    auto start = std::chrono::steady_clock::now();

    try {
        // ... encryption logic ...

        metrics_.encryption_operations.Inc();

        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
            std::chrono::steady_clock::now() - start
        ).count();
        metrics_.encryption_duration_ms.Observe(duration);

    } catch (const std::exception&amp; e) {
        metrics_.encryption_errors.Inc();
        throw;
    }
}
</code></pre>
<h4 id="encryption_deployment-grafana-dashboard">Grafana Dashboard<a class="headerlink" href="#encryption_deployment-grafana-dashboard" title="Permanent link">&para;</a></h4>
<pre><code class="language-json">{
  &quot;dashboard&quot;: {
    &quot;title&quot;: &quot;Themis Encryption Metrics&quot;,
    &quot;panels&quot;: [
      {
        &quot;title&quot;: &quot;Encryption Operations/sec&quot;,
        &quot;targets&quot;: [
          {
            &quot;expr&quot;: &quot;rate(themis_encryption_operations_total[5m])&quot;
          }
        ]
      },
      {
        &quot;title&quot;: &quot;Decryption Latency (p95)&quot;,
        &quot;targets&quot;: [
          {
            &quot;expr&quot;: &quot;histogram_quantile(0.95, themis_decryption_duration_ms)&quot;
          }
        ]
      },
      {
        &quot;title&quot;: &quot;Cache Hit Rate&quot;,
        &quot;targets&quot;: [
          {
            &quot;expr&quot;: &quot;themis_key_cache_hit_rate&quot;
          }
        ]
      },
      {
        &quot;title&quot;: &quot;Vault Request Errors&quot;,
        &quot;targets&quot;: [
          {
            &quot;expr&quot;: &quot;rate(themis_vault_request_errors_total[5m])&quot;
          }
        ]
      }
    ]
  }
}
</code></pre>
<h3 id="encryption_deployment-alerting-rules">Alerting Rules<a class="headerlink" href="#encryption_deployment-alerting-rules" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml"># prometheus/alerts.yml
groups:
- name: encryption
  rules:

  # Alert if encryption failure rate &gt; 1%
  - alert: HighEncryptionErrorRate
    expr: |
      rate(themis_encryption_errors_total[5m]) / 
      rate(themis_encryption_operations_total[5m]) &gt; 0.01
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: &quot;High encryption error rate detected&quot;
      description: &quot;Encryption error rate is {{ $value | humanizePercentage }}&quot;

  # Alert if cache hit rate drops below 80%
  - alert: LowCacheHitRate
    expr: themis_key_cache_hit_rate &lt; 0.8
    for: 10m
    labels:
      severity: warning
    annotations:
      summary: &quot;Low key cache hit rate&quot;
      description: &quot;Cache hit rate is {{ $value | humanizePercentage }}&quot;

  # Alert if Vault requests are slow
  - alert: SlowVaultRequests
    expr: |
      histogram_quantile(0.95, 
        rate(themis_vault_request_duration_ms_bucket[5m])
      ) &gt; 100
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: &quot;Slow Vault API requests&quot;
      description: &quot;P95 latency is {{ $value }}ms&quot;

  # Alert if a key rotation is overdue
  - alert: KeyRotationOverdue
    expr: |
      (time() - themis_key_last_rotation_timestamp) / 86400 &gt; 180
    for: 1d
    labels:
      severity: warning
    annotations:
      summary: &quot;Key rotation overdue&quot;
      description: &quot;Key {{ $labels.key_id }} has not been rotated in {{ $value }} days&quot;
</code></pre>
<hr />
<h2 id="encryption_deployment-disaster-recovery">Disaster Recovery<a class="headerlink" href="#encryption_deployment-disaster-recovery" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-backup-procedures">Backup Procedures<a class="headerlink" href="#encryption_deployment-backup-procedures" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">#!/bin/bash
# backup-vault.sh - Automated Vault backup

BACKUP_DIR=&quot;/backups/vault/$(date +%Y%m%d)&quot;
mkdir -p $BACKUP_DIR

# Take Consul snapshot (Vault storage backend)
consul snapshot save $BACKUP_DIR/consul-snapshot.snap

# Export all encryption keys (encrypted with GPG)
vault kv get -format=json themis/keys | \
  gpg --encrypt --recipient backup@example.com &gt; \
  $BACKUP_DIR/encryption-keys.json.gpg

# Backup Vault unseal keys (should be in separate secure location)
# These should already be distributed to key custodians

# Upload to S3 with server-side encryption
aws s3 cp $BACKUP_DIR s3://vault-backups/$(date +%Y%m%d)/ \
  --recursive \
  --sse AES256

echo &quot;✅ Vault backup completed: $BACKUP_DIR&quot;
</code></pre>
<h3 id="encryption_deployment-recovery-procedures">Recovery Procedures<a class="headerlink" href="#encryption_deployment-recovery-procedures" title="Permanent link">&para;</a></h3>
<h4 id="encryption_deployment-scenario-1-lost-vault-token">Scenario 1: Lost Vault Token<a class="headerlink" href="#encryption_deployment-scenario-1-lost-vault-token" title="Permanent link">&para;</a></h4>
<pre><code class="language-bash"># Generate new token from AppRole
ROLE_ID=&quot;&lt;stored-role-id&gt;&quot;
SECRET_ID=$(vault write -f auth/approle/role/themis-app/secret-id | \
  grep 'secret_id ' | awk '{print $2}')

NEW_TOKEN=$(vault write auth/approle/login \
  role_id=$ROLE_ID \
  secret_id=$SECRET_ID | \
  grep 'token ' | awk '{print $2}')

# Update application configuration
kubectl set env deployment/themis-api VAULT_TOKEN=$NEW_TOKEN
</code></pre>
<h4 id="encryption_deployment-scenario-2-vault-cluster-failure">Scenario 2: Vault Cluster Failure<a class="headerlink" href="#encryption_deployment-scenario-2-vault-cluster-failure" title="Permanent link">&para;</a></h4>
<pre><code class="language-bash"># Restore from backup
consul snapshot restore /backups/vault/20251030/consul-snapshot.snap

# Unseal all Vault nodes
for NODE in vault-1 vault-2 vault-3; do
  vault operator unseal -address=https://$NODE:8200 &lt;unseal-key-1&gt;
  vault operator unseal -address=https://$NODE:8200 &lt;unseal-key-2&gt;
  vault operator unseal -address=https://$NODE:8200 &lt;unseal-key-3&gt;
done

# Verify key recovery
vault kv get themis/keys/user_pii
</code></pre>
<h4 id="encryption_deployment-scenario-3-corrupted-encryption-key">Scenario 3: Corrupted Encryption Key<a class="headerlink" href="#encryption_deployment-scenario-3-corrupted-encryption-key" title="Permanent link">&para;</a></h4>
<pre><code class="language-bash"># If a key becomes corrupted, restore from backup
gpg --decrypt /backups/vault/20251030/encryption-keys.json.gpg | \
  jq '.data.keys.user_pii' | \
  vault kv put themis/keys/user_pii -

# Verify
vault kv get themis/keys/user_pii
</code></pre>
<hr />
<h2 id="encryption_deployment-security-best-practices">Security Best Practices<a class="headerlink" href="#encryption_deployment-security-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-1-key-storage">1. Key Storage<a class="headerlink" href="#encryption_deployment-1-key-storage" title="Permanent link">&para;</a></h3>
<p>✅ <strong>DO:</strong>
- Store keys in HashiCorp Vault with encryption at rest
- Use hardware security modules (HSM) for Vault master key
- Implement key versioning for rotation
- Distribute unseal keys to 3+ trusted individuals
- Audit all key access via Vault audit logs</p>
<p>❌ <strong>DON'T:</strong>
- Store keys in environment variables or config files
- Commit keys to version control
- Share keys via email/Slack
- Use single-version keys (prevents rotation)</p>
<h3 id="encryption_deployment-2-access-control">2. Access Control<a class="headerlink" href="#encryption_deployment-2-access-control" title="Permanent link">&para;</a></h3>
<pre><code class="language-hcl"># Principle of least privilege
path &quot;themis/data/keys/user_pii&quot; {
  capabilities = [&quot;read&quot;]

  # Allow only from specific IP range
  allowed_parameters = {
    &quot;cidr_list&quot; = [&quot;10.0.0.0/8&quot;]
  }
}

# Separate admin policy for key rotation
path &quot;themis/data/keys/*&quot; {
  capabilities = [&quot;create&quot;, &quot;update&quot;, &quot;delete&quot;]

  # Require MFA for destructive operations
  mfa_methods = [&quot;totp&quot;]
}
</code></pre>
<h3 id="encryption_deployment-3-network-security">3. Network Security<a class="headerlink" href="#encryption_deployment-3-network-security" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>TLS 1.3</strong> for all Vault communications</li>
<li><strong>Mutual TLS</strong> (mTLS) in production</li>
<li><strong>Network policies</strong> to restrict Vault access</li>
<li><strong>Private subnets</strong> for Vault cluster</li>
</ul>
<h3 id="encryption_deployment-4-audit-logging">4. Audit Logging<a class="headerlink" href="#encryption_deployment-4-audit-logging" title="Permanent link">&para;</a></h3>
<pre><code class="language-hcl"># vault/config/audit.hcl
audit {
  type = &quot;file&quot;

  options = {
    file_path = &quot;/vault/logs/audit.log&quot;
    log_raw = false  # Don't log sensitive data
    hmac_accessor = true
    mode = &quot;0600&quot;
    format = &quot;json&quot;
  }
}
</code></pre>
<h3 id="encryption_deployment-5-monitoring">5. Monitoring<a class="headerlink" href="#encryption_deployment-5-monitoring" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Alert on failed authentication</strong> attempts</li>
<li><strong>Monitor key access patterns</strong> for anomalies</li>
<li><strong>Track cache hit rates</strong> (should be &gt;80%)</li>
<li><strong>Set up dead man's switch</strong> for unseal keys</li>
</ul>
<hr />
<h2 id="encryption_deployment-troubleshooting">Troubleshooting<a class="headerlink" href="#encryption_deployment-troubleshooting" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-issue-slow-encryption-performance">Issue: Slow Encryption Performance<a class="headerlink" href="#encryption_deployment-issue-slow-encryption-performance" title="Permanent link">&para;</a></h3>
<p><strong>Symptoms:</strong>
- Encryption operations &gt;10ms
- High CPU usage
- Low throughput</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Check if AES-NI is enabled
lscpu | grep aes
# Should show &quot;aes&quot; in flags

# Check OpenSSL version
openssl version
# Should be 3.0+

# Profile encryption calls
perf record -g ./themis_demo_encryption
perf report
</code></pre>
<p><strong>Solutions:</strong>
1. Verify AES-NI hardware support
2. Update OpenSSL to latest version
3. Increase key cache size
4. Use connection pooling for Vault requests</p>
<hr />
<h3 id="encryption_deployment-issue-vault-connection-timeouts">Issue: Vault Connection Timeouts<a class="headerlink" href="#encryption_deployment-issue-vault-connection-timeouts" title="Permanent link">&para;</a></h3>
<p><strong>Symptoms:</strong>
- <code>CURL error: Timeout was reached</code>
- Intermittent decryption failures</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-bash"># Test Vault connectivity
time curl -k https://vault.example.com:8200/v1/sys/health

# Check network latency
ping -c 10 vault.example.com

# Review Vault server logs
vault audit log | grep themis
</code></pre>
<p><strong>Solutions:</strong>
1. Increase <code>request_timeout_ms</code> in config
2. Deploy Vault closer to application (same datacenter)
3. Enable HTTP/2 keep-alive
4. Scale Vault cluster horizontally</p>
<hr />
<h3 id="encryption_deployment-issue-cache-thrashing">Issue: Cache Thrashing<a class="headerlink" href="#encryption_deployment-issue-cache-thrashing" title="Permanent link">&para;</a></h3>
<p><strong>Symptoms:</strong>
- Cache hit rate &lt;50%
- Frequent Vault API calls
- Increased latency</p>
<p><strong>Diagnosis:</strong></p>
<pre><code class="language-cpp">// Enable debug logging
auto stats = vault_provider-&gt;getCacheStats();
std::cout &lt;&lt; &quot;Hit rate: &quot; &lt;&lt; stats.hit_rate &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Total requests: &quot; &lt;&lt; stats.total_requests &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;Cache size: &quot; &lt;&lt; stats.cache_size &lt;&lt; std::endl;
</code></pre>
<p><strong>Solutions:</strong>
1. Increase <code>cache_capacity</code> (default: 1000)
2. Increase <code>cache_ttl_seconds</code> (default: 3600)
3. Pre-warm cache on application startup
4. Review key access patterns (consolidate similar keys)</p>
<hr />
<h2 id="encryption_deployment-performance-tuning">Performance Tuning<a class="headerlink" href="#encryption_deployment-performance-tuning" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-benchmark-results">Benchmark Results<a class="headerlink" href="#encryption_deployment-benchmark-results" title="Permanent link">&para;</a></h3>
<p><strong>Hardware:</strong> Intel Xeon 8375C (AES-NI), 16GB RAM, NVMe SSD</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Throughput</th>
<th>Latency (p50)</th>
<th>Latency (p95)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Encrypt (cached key)</td>
<td>256,000 ops/sec</td>
<td>0.004 ms</td>
<td>0.008 ms</td>
</tr>
<tr>
<td>Decrypt (cached key)</td>
<td>200,000 ops/sec</td>
<td>0.005 ms</td>
<td>0.010 ms</td>
</tr>
<tr>
<td>Vault key fetch (cold)</td>
<td>20 ops/sec</td>
<td>50 ms</td>
<td>100 ms</td>
</tr>
<tr>
<td>DB write (encrypted)</td>
<td>1,300 ops/sec</td>
<td>0.75 ms</td>
<td>2 ms</td>
</tr>
</tbody>
</table>
<h3 id="encryption_deployment-optimization-checklist">Optimization Checklist<a class="headerlink" href="#encryption_deployment-optimization-checklist" title="Permanent link">&para;</a></h3>
<ul>
<li>[x] <strong>Enable AES-NI</strong> hardware acceleration</li>
<li>[x] <strong>Cache keys</strong> in memory (1h TTL)</li>
<li>[x] <strong>Use connection pooling</strong> for Vault</li>
<li>[x] <strong>Batch operations</strong> where possible</li>
<li>[x] <strong>Pre-warm cache</strong> on startup</li>
<li>[ ] <strong>Implement circuit breaker</strong> for Vault failures</li>
<li>[ ] <strong>Use Vault agent</strong> for local caching</li>
<li>[ ] <strong>Deploy Vault replicas</strong> in each datacenter</li>
</ul>
<hr />
<h2 id="encryption_deployment-appendix">Appendix<a class="headerlink" href="#encryption_deployment-appendix" title="Permanent link">&para;</a></h2>
<h3 id="encryption_deployment-a-key-rotation-checklist">A. Key Rotation Checklist<a class="headerlink" href="#encryption_deployment-a-key-rotation-checklist" title="Permanent link">&para;</a></h3>
<pre><code>□ Generate new key version in Vault
□ Invalidate application key caches
□ Start background re-encryption job
□ Monitor re-encryption progress
□ Verify 100% migration to new version
□ Mark old key version as DEPRECATED
□ Wait 90-day grace period
□ Delete old key version from Vault
□ Update audit logs
</code></pre>
<h3 id="encryption_deployment-b-emergency-contacts">B. Emergency Contacts<a class="headerlink" href="#encryption_deployment-b-emergency-contacts" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Role</th>
<th>Name</th>
<th>Contact</th>
<th>Responsibility</th>
</tr>
</thead>
<tbody>
<tr>
<td>Security Lead</td>
<td>Alice Johnson</td>
<td>alice@example.com</td>
<td>Key management approval</td>
</tr>
<tr>
<td>DevOps Lead</td>
<td>Bob Smith</td>
<td>bob@example.com</td>
<td>Vault infrastructure</td>
</tr>
<tr>
<td>On-Call Engineer</td>
<td><rotation></td>
<td>oncall@example.com</td>
<td>24/7 incident response</td>
</tr>
</tbody>
</table>
<h3 id="encryption_deployment-c-compliance-matrix">C. Compliance Matrix<a class="headerlink" href="#encryption_deployment-c-compliance-matrix" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Implementation</th>
<th>Evidence</th>
</tr>
</thead>
<tbody>
<tr>
<td>GDPR Art. 32</td>
<td>AES-256-GCM encryption</td>
<td>Vault audit logs</td>
</tr>
<tr>
<td>HIPAA §164.312(a)(2)(iv)</td>
<td>Key versioning + rotation</td>
<td>Rotation schedule</td>
</tr>
<tr>
<td>PCI DSS 3.4</td>
<td>Cryptographic key management</td>
<td>Vault policies</td>
</tr>
<tr>
<td>SOC 2 CC6.1</td>
<td>Access controls</td>
<td>Vault AppRole logs</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Document Version:</strong> 1.0<br />
<strong>Last Review:</strong> 30. Oktober 2025<br />
<strong>Next Review:</strong> 30. Januar 2026<br />
<strong>Owner:</strong> Security Engineering Team</p></section><section class="print-page" id="column_encryption" heading-number="12.6"><h1 id="column_encryption-column-level-encryption-design">Column-Level Encryption Design<a class="headerlink" href="#column_encryption-column-level-encryption-design" title="Permanent link">&para;</a></h1>
<p><strong>Status:</strong> Design Phase (Sprint C.3)<br />
<strong>Datum:</strong> 30. Oktober 2025<br />
<strong>Autor:</strong> Themis Development Team</p>
<hr />
<h2 id="column_encryption-1-uberblick">1. Überblick<a class="headerlink" href="#column_encryption-1-uberblick" title="Permanent link">&para;</a></h2>
<p>Column-Level Encryption ermöglicht die Verschlüsselung sensibler Datenfelder at-rest in der Datenbank. Dies erfüllt Compliance-Anforderungen (DSGVO, HIPAA) und schützt vor Insider-Threats und Storage-Compromise-Szenarien.</p>
<h3 id="column_encryption-11-ziele">1.1 Ziele<a class="headerlink" href="#column_encryption-11-ziele" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Data-at-Rest Protection</strong>: Sensible Felder (Email, SSN, Kreditkarten) verschlüsselt speichern</li>
<li><strong>Transparent Usage</strong>: Entwickler arbeiten mit <code>EncryptedField&lt;T&gt;</code>, Verschlüsselung automatisch</li>
<li><strong>Key Rotation</strong>: Unterstützung für periodischen Schlüsselwechsel ohne Downtime</li>
<li><strong>Minimal Performance Impact</strong>: &lt;10ms Overhead für Encrypt/Decrypt Operationen</li>
<li><strong>Pluggable Key Management</strong>: Interface für HashiCorp Vault, AWS KMS, Azure Key Vault</li>
</ul>
<h3 id="column_encryption-12-nicht-ziele-v1">1.2 Nicht-Ziele (v1)<a class="headerlink" href="#column_encryption-12-nicht-ziele-v1" title="Permanent link">&para;</a></h3>
<ul>
<li>❌ Encryption-in-Transit (wird durch TLS abgedeckt)</li>
<li>❌ Homomorphic Encryption (zu langsam für produktive Nutzung)</li>
<li>❌ Searchable Encryption (zukünftiger Sprint)</li>
<li>❌ Database-Level Encryption (alternative Strategie via RocksDB encryption)</li>
</ul>
<hr />
<h2 id="column_encryption-2-threat-model">2. Threat Model<a class="headerlink" href="#column_encryption-2-threat-model" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-21-bedrohungsszenarien">2.1 Bedrohungsszenarien<a class="headerlink" href="#column_encryption-21-bedrohungsszenarien" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Threat</th>
<th>Beschreibung</th>
<th>Mitigation durch Column Encryption</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Storage Compromise</strong></td>
<td>Angreifer erhält Zugriff auf RocksDB SST-Files</td>
<td>✅ Daten sind verschlüsselt, Keys separat gespeichert</td>
</tr>
<tr>
<td><strong>Backup Leakage</strong></td>
<td>Backup-Files werden versehentlich öffentlich</td>
<td>✅ Verschlüsselte Daten unlesbar ohne Keys</td>
</tr>
<tr>
<td><strong>Insider Threat</strong></td>
<td>DB-Admin mit Disk-Zugriff</td>
<td>✅ Keys nur in Key Management System, nicht auf Disk</td>
</tr>
<tr>
<td><strong>Memory Dump</strong></td>
<td>Angreifer liest RAM-Inhalte</td>
<td>⚠️ Teilweise - entschlüsselte Daten temporär im RAM</td>
</tr>
<tr>
<td><strong>SQL Injection</strong></td>
<td>Angreifer extrahiert Daten via Query</td>
<td>❌ Nicht geschützt - AppSec Verantwortung</td>
</tr>
</tbody>
</table>
<h3 id="column_encryption-22-trust-boundaries">2.2 Trust Boundaries<a class="headerlink" href="#column_encryption-22-trust-boundaries" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────┐
│ Application Layer (Trusted)                             │
│ - EncryptedField&lt;T&gt; Templates                           │
│ - Plaintext briefly in memory during operations         │
└───────────────────┬─────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────┐
│ Encryption Layer (Trusted)                              │
│ - FieldEncryption: AES-256-GCM Encrypt/Decrypt          │
│ - Key Cache: In-memory cache (max 1000 keys, 1h TTL)   │
└───────────────────┬─────────────────────────────────────┘
                    │
         ┌──────────┴──────────┐
         ▼                     ▼
┌──────────────────┐  ┌──────────────────────┐
│ KeyProvider      │  │ Storage Layer        │
│ (External/Vault) │  │ (Untrusted)          │
│ - Stores KEKs    │  │ - Encrypted Data     │
│ - Access Control │  │ - Metadata (key ID)  │
└──────────────────┘  └──────────────────────┘
</code></pre>
<p><strong>Annahmen:</strong>
- Application-Memory ist vertrauenswürdig (OS-Level Security)
- Key Management System (Vault/KMS) ist extern und gehärtet
- Netzwerk zwischen App und KMS ist TLS-gesichert</p>
<hr />
<h2 id="column_encryption-3-architektur">3. Architektur<a class="headerlink" href="#column_encryption-3-architektur" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-31-komponenten-ubersicht">3.1 Komponenten-Übersicht<a class="headerlink" href="#column_encryption-31-komponenten-ubersicht" title="Permanent link">&para;</a></h3>
<pre><code>┌──────────────────────────────────────────────────────────┐
│                   Application Code                       │
│  User user;                                              │
│  user.email = EncryptedField&lt;std::string&gt;(&quot;foo@bar.com&quot;);│
│  std::string plaintext = user.email.decrypt();          │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│              EncryptedField&lt;T&gt; Template                  │
│  - Stores: {ciphertext, key_id, key_version, iv, tag}   │
│  - Methods: T decrypt(), void encrypt(T plaintext)      │
│  - Serialization: toJson() / fromJson()                 │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│               FieldEncryption Class                      │
│  - encrypt(plaintext, key_id) -&gt; EncryptedBlob          │
│  - decrypt(EncryptedBlob) -&gt; plaintext                  │
│  - Algorithm: AES-256-GCM (AEAD)                        │
│  - IV: Random 12 bytes per encryption                   │
│  - Tag: 16 bytes authentication tag                     │
└────────────────────┬─────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────┐
│              KeyProvider Interface                       │
│  virtual std::vector&lt;uint8_t&gt; getKey(std::string id) = 0│
│  virtual void rotateKey(std::string id) = 0             │
│  virtual std::vector&lt;KeyMetadata&gt; listKeys() = 0        │
└──────────────┬───────────────────────────────────────────┘
               │
      ┌────────┴────────┐
      ▼                 ▼
┌──────────────┐  ┌──────────────────┐
│MockKeyProvider│ │VaultKeyProvider  │
│(In-Memory)    │ │(HashiCorp Vault) │
└───────────────┘ └──────────────────┘
</code></pre>
<h3 id="column_encryption-32-datenstrukturen">3.2 Datenstrukturen<a class="headerlink" href="#column_encryption-32-datenstrukturen" title="Permanent link">&para;</a></h3>
<h4 id="column_encryption-321-encryptedblob">3.2.1 EncryptedBlob<a class="headerlink" href="#column_encryption-321-encryptedblob" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct EncryptedBlob {
    std::string key_id;           // &quot;user_pii_v1&quot;
    uint32_t key_version;         // 2 (for rotation)
    std::vector&lt;uint8_t&gt; iv;      // 12 bytes (AES-GCM standard)
    std::vector&lt;uint8_t&gt; ciphertext;
    std::vector&lt;uint8_t&gt; tag;     // 16 bytes authentication tag

    // Serialization: base64(key_id:version:iv:ciphertext:tag)
    std::string toBase64() const;
    static EncryptedBlob fromBase64(const std::string&amp; b64);
};
</code></pre>
<h4 id="column_encryption-322-keymetadata">3.2.2 KeyMetadata<a class="headerlink" href="#column_encryption-322-keymetadata" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">struct KeyMetadata {
    std::string key_id;
    uint32_t version;
    std::string algorithm;        // &quot;AES-256-GCM&quot;
    int64_t created_at_ms;
    int64_t expires_at_ms;        // 0 = never
    KeyStatus status;             // ACTIVE, ROTATING, DEPRECATED
};
</code></pre>
<hr />
<h2 id="column_encryption-4-encryption-flow">4. Encryption Flow<a class="headerlink" href="#column_encryption-4-encryption-flow" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-41-encryption-write-path">4.1 Encryption (Write Path)<a class="headerlink" href="#column_encryption-41-encryption-write-path" title="Permanent link">&para;</a></h3>
<pre><code>1. Application sets value:
   user.email = EncryptedField&lt;string&gt;(&quot;alice@example.com&quot;);

2. EncryptedField&lt;string&gt;::operator=()
   ├─&gt; FieldEncryption::encrypt(&quot;alice@example.com&quot;, &quot;user_pii&quot;)
   │   ├─&gt; KeyProvider::getKey(&quot;user_pii&quot;) -&gt; 32 bytes DEK
   │   ├─&gt; Generate random IV (12 bytes)
   │   ├─&gt; OpenSSL EVP_EncryptInit_ex(AES-256-GCM)
   │   ├─&gt; EVP_EncryptUpdate(plaintext)
   │   ├─&gt; EVP_EncryptFinal_ex() -&gt; ciphertext + tag
   │   └─&gt; return EncryptedBlob{key_id, version, iv, ciphertext, tag}
   └─&gt; Store EncryptedBlob internally

3. Storage Layer:
   ├─&gt; user.toJson() -&gt; {&quot;email&quot;: &quot;base64(blob)&quot;}
   └─&gt; RocksDB Put(&quot;d:users:123&quot;, json_string)
</code></pre>
<p><strong>Performance:</strong>
- Key lookup: ~1ms (cached) / ~50ms (Vault API call)
- AES-256-GCM encryption: ~0.5ms for 1KB plaintext
- <strong>Total: ~1.5ms (cached) / ~50ms (cold)</strong></p>
<h3 id="column_encryption-42-decryption-read-path">4.2 Decryption (Read Path)<a class="headerlink" href="#column_encryption-42-decryption-read-path" title="Permanent link">&para;</a></h3>
<pre><code>1. Application reads value:
   std::string email = user.email.decrypt();

2. EncryptedField&lt;string&gt;::decrypt()
   ├─&gt; FieldEncryption::decrypt(stored_blob)
   │   ├─&gt; KeyProvider::getKey(blob.key_id, blob.key_version)
   │   ├─&gt; OpenSSL EVP_DecryptInit_ex(AES-256-GCM)
   │   ├─&gt; EVP_DecryptUpdate(ciphertext)
   │   ├─&gt; EVP_CIPHER_CTX_ctrl(EVP_CTRL_GCM_SET_TAG, tag)
   │   ├─&gt; EVP_DecryptFinal_ex() -&gt; plaintext (or AUTH_FAILED)
   │   └─&gt; return plaintext
   └─&gt; return std::string

3. Error Handling:
   ├─&gt; Authentication failure -&gt; throw DecryptionException
   ├─&gt; Key not found -&gt; throw KeyNotFoundException
   └─&gt; Invalid base64 -&gt; throw DecodingException
</code></pre>
<hr />
<h2 id="column_encryption-5-key-management">5. Key Management<a class="headerlink" href="#column_encryption-5-key-management" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-51-key-hierarchy">5.1 Key Hierarchy<a class="headerlink" href="#column_encryption-51-key-hierarchy" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────┐
│ Key Encryption Key (KEK)                        │
│ - Stored in: Vault/KMS                          │
│ - Rotation: Annually                            │
│ - Access: Restricted to App Service Principal   │
└────────────────┬────────────────────────────────┘
                 │ (encrypts)
                 ▼
┌─────────────────────────────────────────────────┐
│ Data Encryption Keys (DEK)                      │
│ - Per field type: &quot;user_pii&quot;, &quot;payment_info&quot;   │
│ - Versioned: v1, v2, ... (for rotation)         │
│ - Size: 256 bits (32 bytes)                     │
│ - Cache: In-memory, 1h TTL, max 1000 keys       │
└─────────────────────────────────────────────────┘
</code></pre>
<p><strong>Rationale:</strong>
- KEK in Vault ermöglicht zentrale Kontrolle und Auditing
- DEKs gecached für Performance (1ms statt 50ms)
- Versionierung erlaubt sanfte Key Rotation ohne Re-Encryption</p>
<h3 id="column_encryption-52-key-rotation-process">5.2 Key Rotation Process<a class="headerlink" href="#column_encryption-52-key-rotation-process" title="Permanent link">&para;</a></h3>
<p><strong>Scenario:</strong> Rotate "user_pii" key from v2 to v3</p>
<pre><code>Phase 1: Dual-Write (Week 1-2)
1. Admin: vault_client.createKey(&quot;user_pii&quot;, version=3)
2. Config: Set write_key_version=3, read_key_versions=[2,3]
3. New data: Encrypted with v3
4. Old data: Still readable with v2

Phase 2: Background Re-Encryption (Week 3-4)
1. Job: SELECT id FROM users WHERE email_key_version = 2
2. For each row:
   ├─&gt; plaintext = decrypt(email, key_v2)
   ├─&gt; encrypted = encrypt(plaintext, key_v3)
   └─&gt; UPDATE users SET email = encrypted WHERE id = ?
3. Progress tracking: &quot;23,456 / 1,000,000 rows (2.3%)&quot;

Phase 3: Deprecation (Week 5)
1. Config: read_key_versions=[3]
2. Admin: vault_client.deprecateKey(&quot;user_pii&quot;, version=2)
3. Monitoring: Alert if v2 decrypt attempts &gt; 0

Phase 4: Deletion (Week 8+)
1. Admin: vault_client.deleteKey(&quot;user_pii&quot;, version=2)
2. Audit log: &quot;user_pii_v2 deleted by admin@example.com&quot;
</code></pre>
<p><strong>Rollback Safety:</strong>
- Alle Key-Versionen bleiben 30 Tage nach Deprecation verfügbar
- Re-Encryption ist idempotent (kann wiederholt werden)
- Config-Changes sind Feature-Flagged (sofort revertierbar)</p>
<h3 id="column_encryption-53-keyprovider-implementations">5.3 KeyProvider Implementations<a class="headerlink" href="#column_encryption-53-keyprovider-implementations" title="Permanent link">&para;</a></h3>
<h4 id="column_encryption-mockkeyprovider-testing">MockKeyProvider (Testing)<a class="headerlink" href="#column_encryption-mockkeyprovider-testing" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">class MockKeyProvider : public KeyProvider {
private:
    std::map&lt;std::string, std::map&lt;uint32_t, std::vector&lt;uint8_t&gt;&gt;&gt; keys_;
    std::mutex mutex_;

public:
    // Generates random 256-bit key
    void createKey(const std::string&amp; key_id, uint32_t version);

    // Returns key or throws KeyNotFoundException
    std::vector&lt;uint8_t&gt; getKey(const std::string&amp; key_id, 
                                 uint32_t version) override;

    // Not implemented (testing only)
    void rotateKey(const std::string&amp; key_id) override { 
        throw NotImplementedException();
    }
};
</code></pre>
<h4 id="column_encryption-vaultkeyprovider-production-interface-only">VaultKeyProvider (Production - Interface Only)<a class="headerlink" href="#column_encryption-vaultkeyprovider-production-interface-only" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">class VaultKeyProvider : public KeyProvider {
private:
    std::string vault_addr_;      // &quot;https://vault.example.com:8200&quot;
    std::string vault_token_;     // Service principal token
    std::unique_ptr&lt;KeyCache&gt; cache_;

public:
    // Authenticates via AppRole or K8s Service Account
    void authenticate();

    // GET /v1/secret/data/encryption/{key_id}/v{version}
    std::vector&lt;uint8_t&gt; getKey(const std::string&amp; key_id, 
                                 uint32_t version) override;

    // POST /v1/secret/data/encryption/{key_id}/v{next_version}
    void rotateKey(const std::string&amp; key_id) override;

    // Cache hit ratio metric
    double getCacheHitRate() const;
};
</code></pre>
<hr />
<h2 id="column_encryption-6-performance-considerations">6. Performance Considerations<a class="headerlink" href="#column_encryption-6-performance-considerations" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-61-benchmarks-target">6.1 Benchmarks (Target)<a class="headerlink" href="#column_encryption-61-benchmarks-target" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Latency (p50)</th>
<th>Latency (p99)</th>
<th>Throughput</th>
</tr>
</thead>
<tbody>
<tr>
<td>Encrypt (1KB)</td>
<td>0.5ms</td>
<td>2ms</td>
<td>2000 ops/sec</td>
</tr>
<tr>
<td>Decrypt (1KB)</td>
<td>0.5ms</td>
<td>2ms</td>
<td>2000 ops/sec</td>
</tr>
<tr>
<td>Key Lookup (cached)</td>
<td>0.01ms</td>
<td>0.1ms</td>
<td>100k ops/sec</td>
</tr>
<tr>
<td>Key Lookup (Vault)</td>
<td>50ms</td>
<td>200ms</td>
<td>20 ops/sec</td>
</tr>
</tbody>
</table>
<h3 id="column_encryption-62-optimizations">6.2 Optimizations<a class="headerlink" href="#column_encryption-62-optimizations" title="Permanent link">&para;</a></h3>
<p><strong>1. Key Caching Strategy</strong></p>
<pre><code class="language-cpp">class KeyCache {
    struct Entry {
        std::vector&lt;uint8_t&gt; key;
        int64_t expires_at_ms;
        uint64_t access_count;
    };

    std::map&lt;std::string, Entry&gt; cache_;  // key_id:version -&gt; Entry
    size_t max_size_ = 1000;
    int64_t ttl_ms_ = 3600000;  // 1 hour

    // LRU eviction when cache full
    void evictLRU();
};
</code></pre>
<p><strong>2. Batch Encryption</strong></p>
<pre><code class="language-cpp">// Instead of:
for (auto&amp; user : users) {
    user.email.encrypt();  // 1000 key lookups!
}

// Use:
auto key = key_provider-&gt;getKey(&quot;user_pii&quot;);
for (auto&amp; user : users) {
    user.email.encryptWithKey(key);  // 1 key lookup
}
</code></pre>
<p><strong>3. Lazy Decryption</strong></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
class EncryptedField {
    mutable std::optional&lt;T&gt; cached_plaintext_;

    T decrypt() const {
        if (!cached_plaintext_) {
            cached_plaintext_ = field_encryption_-&gt;decrypt(blob_);
        }
        return *cached_plaintext_;
    }
};
</code></pre>
<h3 id="column_encryption-63-monitoring-metrics">6.3 Monitoring Metrics<a class="headerlink" href="#column_encryption-63-monitoring-metrics" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Prometheus metrics
encryption_operations_total{operation=&quot;encrypt&quot;,key_id=&quot;user_pii&quot;} 45234
encryption_operations_total{operation=&quot;decrypt&quot;,key_id=&quot;user_pii&quot;} 128956
encryption_duration_seconds{operation=&quot;encrypt&quot;,quantile=&quot;0.5&quot;} 0.0005
encryption_duration_seconds{operation=&quot;encrypt&quot;,quantile=&quot;0.99&quot;} 0.002
key_cache_hit_rate{key_id=&quot;user_pii&quot;} 0.98
key_lookup_errors_total{error=&quot;key_not_found&quot;} 12
</code></pre>
<hr />
<h2 id="column_encryption-7-security-best-practices">7. Security Best Practices<a class="headerlink" href="#column_encryption-7-security-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-71-dos">7.1 Dos<a class="headerlink" href="#column_encryption-71-dos" title="Permanent link">&para;</a></h3>
<p>✅ <strong>Use authenticated encryption (AES-GCM)</strong> - Prevents tampering<br />
✅ <strong>Generate random IV per encryption</strong> - Prevents pattern analysis<br />
✅ <strong>Cache keys with TTL</strong> - Balance performance and key rotation<br />
✅ <strong>Log all key accesses</strong> - Audit trail for compliance<br />
✅ <strong>Encrypt in application layer</strong> - Database never sees plaintext<br />
✅ <strong>Use separate keys per field type</strong> - Limits blast radius<br />
✅ <strong>Implement key versioning</strong> - Enables rotation without downtime  </p>
<h3 id="column_encryption-72-donts">7.2 Don'ts<a class="headerlink" href="#column_encryption-72-donts" title="Permanent link">&para;</a></h3>
<p>❌ <strong>Never store keys with encrypted data</strong> - Defeats purpose<br />
❌ <strong>Don't use ECB mode</strong> - Vulnerable to pattern attacks<br />
❌ <strong>Don't reuse IVs</strong> - Breaks GCM security guarantees<br />
❌ <strong>Don't skip authentication tags</strong> - Allows tampering<br />
❌ <strong>Don't log plaintext</strong> - Audit logs must be redacted<br />
❌ <strong>Don't use hardcoded keys</strong> - Security nightmare<br />
❌ <strong>Don't encrypt everything</strong> - Performance &amp; operational overhead  </p>
<h3 id="column_encryption-73-field-selection-criteria">7.3 Field Selection Criteria<a class="headerlink" href="#column_encryption-73-field-selection-criteria" title="Permanent link">&para;</a></h3>
<p><strong>Encrypt:</strong>
- Personally Identifiable Information (PII): Email, Phone, SSN, Address
- Financial Data: Credit Cards, Bank Accounts, Salaries
- Health Records: Medical IDs, Diagnoses, Prescriptions
- Secrets: API Keys, Passwords (already hashed), OAuth Tokens</p>
<p><strong>Don't Encrypt:</strong>
- Primary Keys / Foreign Keys (needed for joins/indexes)
- Timestamps (used in range queries)
- Status Flags (frequent filtering)
- Non-sensitive Metadata (created_by, updated_at)</p>
<hr />
<h2 id="column_encryption-8-example-usage">8. Example Usage<a class="headerlink" href="#column_encryption-8-example-usage" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-81-schema-definition">8.1 Schema Definition<a class="headerlink" href="#column_encryption-81-schema-definition" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">struct User {
    std::string id;                              // Plaintext (PK)
    std::string username;                        // Plaintext (indexed)
    EncryptedField&lt;std::string&gt; email;          // Encrypted (PII)
    EncryptedField&lt;std::string&gt; phone;          // Encrypted (PII)
    std::string country;                         // Plaintext (indexed)
    int64_t created_at;                         // Plaintext (range queries)

    nlohmann::json toJson() const {
        return {
            {&quot;id&quot;, id},
            {&quot;username&quot;, username},
            {&quot;email&quot;, email.toBase64()},        // Serialized encrypted
            {&quot;phone&quot;, phone.toBase64()},
            {&quot;country&quot;, country},
            {&quot;created_at&quot;, created_at}
        };
    }

    static User fromJson(const nlohmann::json&amp; j) {
        User u;
        u.id = j[&quot;id&quot;];
        u.username = j[&quot;username&quot;];
        u.email = EncryptedField&lt;std::string&gt;::fromBase64(j[&quot;email&quot;]);
        u.phone = EncryptedField&lt;std::string&gt;::fromBase64(j[&quot;phone&quot;]);
        u.country = j[&quot;country&quot;];
        u.created_at = j[&quot;created_at&quot;];
        return u;
    }
};
</code></pre>
<h3 id="column_encryption-82-write-path">8.2 Write Path<a class="headerlink" href="#column_encryption-82-write-path" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Initialize encryption system
auto key_provider = std::make_shared&lt;VaultKeyProvider&gt;(
    &quot;https://vault.prod.example.com:8200&quot;,
    vault_token
);
auto field_encryption = std::make_shared&lt;FieldEncryption&gt;(key_provider);
EncryptedField&lt;std::string&gt;::setFieldEncryption(field_encryption);

// Create user with encrypted fields
User user;
user.id = &quot;u_12345&quot;;
user.username = &quot;alice&quot;;
user.email = EncryptedField&lt;std::string&gt;(&quot;alice@example.com&quot;, &quot;user_pii&quot;);
user.phone = EncryptedField&lt;std::string&gt;(&quot;+1-555-0123&quot;, &quot;user_pii&quot;);
user.country = &quot;US&quot;;
user.created_at = getCurrentTimeMs();

// Store in database
auto json_str = user.toJson().dump();
db-&gt;put(&quot;d:users:&quot; + user.id, json_str);
</code></pre>
<h3 id="column_encryption-83-read-path">8.3 Read Path<a class="headerlink" href="#column_encryption-83-read-path" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Retrieve from database
auto json_str = db-&gt;get(&quot;d:users:u_12345&quot;);
User user = User::fromJson(nlohmann::json::parse(json_str));

// Access encrypted fields (automatic decryption)
std::string email = user.email.decrypt();  // &quot;alice@example.com&quot;
std::string phone = user.phone.decrypt();  // &quot;+1-555-0123&quot;

// Plaintext fields accessible directly
std::cout &lt;&lt; user.username;  // &quot;alice&quot;
</code></pre>
<hr />
<h2 id="column_encryption-9-testing-strategy">9. Testing Strategy<a class="headerlink" href="#column_encryption-9-testing-strategy" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-91-unit-tests-teststest_encryptioncpp">9.1 Unit Tests (tests/test_encryption.cpp)<a class="headerlink" href="#column_encryption-91-unit-tests-teststest_encryptioncpp" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST(KeyProviderTest, MockProvider_StoresAndRetrievesKeys) {
    auto provider = std::make_shared&lt;MockKeyProvider&gt;();
    provider-&gt;createKey(&quot;test_key&quot;, 1);

    auto key = provider-&gt;getKey(&quot;test_key&quot;, 1);
    EXPECT_EQ(key.size(), 32);  // 256 bits
}

TEST(FieldEncryptionTest, EncryptDecrypt_Roundtrip) {
    auto provider = std::make_shared&lt;MockKeyProvider&gt;();
    provider-&gt;createKey(&quot;test&quot;, 1);

    FieldEncryption enc(provider);
    std::string plaintext = &quot;sensitive data&quot;;

    auto blob = enc.encrypt(plaintext, &quot;test&quot;);
    auto decrypted = enc.decrypt(blob);

    EXPECT_EQ(plaintext, decrypted);
}

TEST(FieldEncryptionTest, Decrypt_WithWrongKey_ThrowsException) {
    auto provider = std::make_shared&lt;MockKeyProvider&gt;();
    provider-&gt;createKey(&quot;key1&quot;, 1);
    provider-&gt;createKey(&quot;key2&quot;, 1);

    FieldEncryption enc(provider);
    auto blob = enc.encrypt(&quot;data&quot;, &quot;key1&quot;);
    blob.key_id = &quot;key2&quot;;  // Tamper

    EXPECT_THROW(enc.decrypt(blob), DecryptionException);
}

TEST(EncryptedFieldTest, StringField_SerializeDeserialize) {
    auto provider = std::make_shared&lt;MockKeyProvider&gt;();
    provider-&gt;createKey(&quot;test&quot;, 1);
    auto enc = std::make_shared&lt;FieldEncryption&gt;(provider);
    EncryptedField&lt;std::string&gt;::setFieldEncryption(enc);

    EncryptedField&lt;std::string&gt; field(&quot;alice@example.com&quot;, &quot;test&quot;);
    std::string b64 = field.toBase64();

    auto field2 = EncryptedField&lt;std::string&gt;::fromBase64(b64);
    EXPECT_EQ(field2.decrypt(), &quot;alice@example.com&quot;);
}

TEST(KeyRotationTest, DecryptWithOldKey_AfterRotation) {
    auto provider = std::make_shared&lt;MockKeyProvider&gt;();
    provider-&gt;createKey(&quot;key&quot;, 1);

    FieldEncryption enc(provider);
    auto blob_v1 = enc.encrypt(&quot;data&quot;, &quot;key&quot;);  // Uses v1

    provider-&gt;createKey(&quot;key&quot;, 2);  // Rotate to v2

    // Old data still decryptable
    EXPECT_EQ(enc.decrypt(blob_v1), &quot;data&quot;);
}
</code></pre>
<h3 id="column_encryption-92-integration-tests">9.2 Integration Tests<a class="headerlink" href="#column_encryption-92-integration-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST(EncryptionIntegrationTest, UserCRUD_WithEncryptedFields) {
    auto db = std::make_shared&lt;RocksDBWrapper&gt;(test_config);
    auto provider = std::make_shared&lt;MockKeyProvider&gt;();
    provider-&gt;createKey(&quot;user_pii&quot;, 1);
    // ... setup encryption ...

    // Create
    User user = createTestUser();
    db-&gt;put(&quot;d:users:&quot; + user.id, user.toJson().dump());

    // Read
    auto json = db-&gt;get(&quot;d:users:&quot; + user.id);
    User loaded = User::fromJson(nlohmann::json::parse(json));
    EXPECT_EQ(loaded.email.decrypt(), user.email.decrypt());

    // Update
    loaded.phone = EncryptedField&lt;std::string&gt;(&quot;+1-999-9999&quot;, &quot;user_pii&quot;);
    db-&gt;put(&quot;d:users:&quot; + loaded.id, loaded.toJson().dump());

    // Verify
    auto updated = User::fromJson(nlohmann::json::parse(db-&gt;get(&quot;d:users:&quot; + user.id)));
    EXPECT_EQ(updated.phone.decrypt(), &quot;+1-999-9999&quot;);
}
</code></pre>
<h3 id="column_encryption-93-performance-tests">9.3 Performance Tests<a class="headerlink" href="#column_encryption-93-performance-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST(EncryptionPerformanceTest, EncryptDecrypt_1000Operations) {
    auto provider = std::make_shared&lt;MockKeyProvider&gt;();
    provider-&gt;createKey(&quot;perf&quot;, 1);
    FieldEncryption enc(provider);

    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i &lt; 1000; i++) {
        auto blob = enc.encrypt(&quot;test data &quot; + std::to_string(i), &quot;perf&quot;);
        enc.decrypt(blob);
    }

    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
        std::chrono::high_resolution_clock::now() - start
    ).count();

    EXPECT_LT(duration, 2000);  // &lt;2ms per operation
}
</code></pre>
<hr />
<h2 id="column_encryption-10-rollout-plan">10. Rollout Plan<a class="headerlink" href="#column_encryption-10-rollout-plan" title="Permanent link">&para;</a></h2>
<h3 id="column_encryption-phase-1-core-implementation-week-1">Phase 1: Core Implementation (Week 1)<a class="headerlink" href="#column_encryption-phase-1-core-implementation-week-1" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] Implement KeyProvider interface + MockKeyProvider</li>
<li>[ ] Implement FieldEncryption (AES-256-GCM)</li>
<li>[ ] Unit tests (15+ tests)</li>
<li>[ ] Deliverable: <code>include/security/</code>, <code>src/security/</code>, <code>tests/test_encryption.cpp</code></li>
</ul>
<h3 id="column_encryption-phase-2-template-integration-week-2">Phase 2: Template &amp; Integration (Week 2)<a class="headerlink" href="#column_encryption-phase-2-template-integration-week-2" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] Implement EncryptedField<T> template</li>
<li>[ ] Add serialization (toBase64/fromBase64)</li>
<li>[ ] Integration tests with User struct</li>
<li>[ ] Deliverable: Working PoC with 2-3 encrypted fields</li>
</ul>
<h3 id="column_encryption-phase-3-vaultkeyprovider-interface-week-3">Phase 3: VaultKeyProvider Interface (Week 3)<a class="headerlink" href="#column_encryption-phase-3-vaultkeyprovider-interface-week-3" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] Define VaultKeyProvider interface (no implementation)</li>
<li>[ ] Document Vault API integration requirements</li>
<li>[ ] Add key cache implementation</li>
<li>[ ] Deliverable: <code>include/security/vault_key_provider.h</code> (header-only)</li>
</ul>
<h3 id="column_encryption-phase-4-documentation-review-week-4">Phase 4: Documentation &amp; Review (Week 4)<a class="headerlink" href="#column_encryption-phase-4-documentation-review-week-4" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] Performance benchmarks</li>
<li>[ ] Security review</li>
<li>[ ] Operator documentation (key rotation playbook)</li>
<li>[ ] Deliverable: This document + ops runbook</li>
</ul>
<hr />
<h2 id="column_encryption-11-open-questions">11. Open Questions<a class="headerlink" href="#column_encryption-11-open-questions" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Key Storage Location</strong>: Vault on-premise vs. Cloud KMS vs. Both?</li>
<li>
<p>Recommendation: Start with MockKeyProvider, add Vault interface for production readiness</p>
</li>
<li>
<p><strong>Searchable Encryption</strong>: Support for encrypted field queries?</p>
</li>
<li>
<p>Recommendation: Phase 2 feature - use deterministic encryption or bloom filters</p>
</li>
<li>
<p><strong>Bulk Re-Encryption</strong>: 10M+ rows, acceptable downtime?</p>
</li>
<li>
<p>Recommendation: Online migration with dual-write (see Section 5.2)</p>
</li>
<li>
<p><strong>Compliance</strong>: FIPS 140-2 certification required?</p>
</li>
<li>Recommendation: Use OpenSSL FIPS module if needed (build-time flag)</li>
</ol>
<hr />
<h2 id="column_encryption-12-references">12. References<a class="headerlink" href="#column_encryption-12-references" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf">NIST SP 800-38D</a> - GCM Mode Specification</li>
<li><a href="https://tools.ietf.org/html/rfc5084">RFC 5084</a> - AES-GCM and AES-CCM Algorithms</li>
<li><a href="https://www.vaultproject.io/docs/secrets/transit">HashiCorp Vault Encryption as a Service</a></li>
<li><a href="https://cloud.google.com/kms/docs/key-management-best-practices">Google Cloud KMS Best Practices</a></li>
<li><a href="https://docs.aws.amazon.com/kms/latest/developerguide/overview.html">AWS KMS Developer Guide</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/key-vault/">Azure Key Vault Documentation</a></li>
</ul>
<hr />
<p><strong>Next Steps:</strong>
1. Review and approval of this design document
2. Create GitHub issues for Phase 1-4 tasks
3. Allocate 2-3 week sprint for implementation
4. Security team review before production deployment</p></section><section class="print-page" id="security-pii_detection" heading-number="12.7"><h1 id="security-pii_detection-piierkennung-klassifizierung">PII‑Erkennung &amp; Klassifizierung<a class="headerlink" href="#security-pii_detection-piierkennung-klassifizierung" title="Permanent link">&para;</a></h1>
<p>ThemisDB nutzt eine regelbasierte PII‑Erkennung (PIIDetector) zur Klassifizierung von Inhalten.</p>
<h2 id="security-pii_detection-komponenten">Komponenten<a class="headerlink" href="#security-pii_detection-komponenten" title="Permanent link">&para;</a></h2>
<ul>
<li>PIIDetector (Regex‑Engine): erkennt Entitäten wie EMAIL, PHONE, IBAN etc.</li>
<li>Classification API: stellt Regeln bereit und ermöglicht Test‑Klassifikationen</li>
</ul>
<h2 id="security-pii_detection-serverapis">Server‑APIs<a class="headerlink" href="#security-pii_detection-serverapis" title="Permanent link">&para;</a></h2>
<ul>
<li>GET /classification/rules – Liste aktiver Regeln</li>
<li>POST /classification/test – Test einer Probe</li>
<li>Body: { "text": "...", "metadata": { ... } }</li>
<li>Response (Beispiel): { "classification": "CONFIDENTIAL", "confidence": 0.92, "detected_entities": [ { "type": "EMAIL", "value": "a@b.c" } ] }</li>
</ul>
<p>Fehlerfälle:
- 400 Missing JSON body – Eingabe erforderlich
- 503 Classification API not available – PIIDetector nicht initialisiert</p>
<h2 id="security-pii_detection-grenzen-hinweise">Grenzen &amp; Hinweise<a class="headerlink" href="#security-pii_detection-grenzen-hinweise" title="Permanent link">&para;</a></h2>
<ul>
<li>Regex‑basiert: Heuristiken, false positives/negatives möglich</li>
<li>Kontextabhängige Klassifikation kann ergänzende Logik/Modelle benötigen</li>
<li>Protokollierung sensibler Treffer nur pseudonymisiert/aggregiert ablegen</li>
</ul>
<p>Weiterlesen:
- pii_detection_engines.md
- compliance_integration.md</p></section><section class="print-page" id="pii_detection_engines" heading-number="12.8"><h1 id="pii_detection_engines-pii-detection-engine-extensions">PII Detection Engine Extensions<a class="headerlink" href="#pii_detection_engines-pii-detection-engine-extensions" title="Permanent link">&para;</a></h1>
<h2 id="pii_detection_engines-overview">Overview<a class="headerlink" href="#pii_detection_engines-overview" title="Permanent link">&para;</a></h2>
<p>The PII detection system uses a plugin architecture that allows multiple detection engines to work together:</p>
<ol>
<li><strong>RegexDetectionEngine</strong> (default, always available)</li>
<li><strong>NERDetectionEngine</strong> (optional, requires external dependencies)</li>
<li><strong>EmbeddingDetectionEngine</strong> (optional, requires external dependencies)</li>
</ol>
<h2 id="pii_detection_engines-current-status">Current Status<a class="headerlink" href="#pii_detection_engines-current-status" title="Permanent link">&para;</a></h2>
<p>✅ <strong>Implemented:</strong>
- Plugin architecture (<code>IPIIDetectionEngine</code> interface)
- RegexDetectionEngine with YAML configuration
- Engine factory and orchestration
- Runtime reload with validation</p>
<p>⏳ <strong>Ready for Implementation:</strong>
- NERDetectionEngine (requires MITIE or ONNX Runtime)
- EmbeddingDetectionEngine (requires fastText or word2vec)</p>
<h2 id="pii_detection_engines-future-engine-ner-named-entity-recognition">Future Engine: NER (Named Entity Recognition)<a class="headerlink" href="#pii_detection_engines-future-engine-ner-named-entity-recognition" title="Permanent link">&para;</a></h2>
<h3 id="pii_detection_engines-dependencies">Dependencies<a class="headerlink" href="#pii_detection_engines-dependencies" title="Permanent link">&para;</a></h3>
<p><strong>Option 1: MITIE (Recommended for C++)</strong></p>
<pre><code class="language-bash">vcpkg install mitie
</code></pre>
<p><strong>Option 2: ONNX Runtime (For pre-trained BERT/RoBERTa models)</strong></p>
<pre><code class="language-bash">vcpkg install onnxruntime
</code></pre>
<h3 id="pii_detection_engines-yaml-configuration">YAML Configuration<a class="headerlink" href="#pii_detection_engines-yaml-configuration" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml">detection_engines:
  - type: &quot;ner&quot;
    enabled: true
    settings:
      model_path: &quot;models/pii_ner.dat&quot;  # MITIE model
      # OR
      model_path: &quot;models/bert_ner.onnx&quot;  # ONNX BERT model
      model_type: &quot;mitie&quot;  # or &quot;onnx_bert&quot;
      confidence_threshold: 0.85
      batch_size: 32  # For ONNX models

    entity_types:
      - name: &quot;PERSON&quot;
        pii_type: &quot;PERSON_NAME&quot;
        redaction_mode: &quot;strict&quot;
        enabled: true

      - name: &quot;GPE&quot;  # Geo-Political Entity (locations)
        pii_type: &quot;LOCATION&quot;
        redaction_mode: &quot;partial&quot;
        enabled: false

      - name: &quot;ORG&quot;
        pii_type: &quot;ORGANIZATION&quot;
        redaction_mode: &quot;none&quot;
        enabled: false
</code></pre>
<h3 id="pii_detection_engines-implementation-sketch">Implementation Sketch<a class="headerlink" href="#pii_detection_engines-implementation-sketch" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class NERDetectionEngine : public IPIIDetectionEngine {
private:
    std::unique_ptr&lt;MitieNER&gt; ner_model_;  // or ONNXRuntime
    std::unordered_map&lt;std::string, PIIType&gt; entity_mapping_;

public:
    bool initialize(const nlohmann::json&amp; config) override {
        std::string model_path = config[&quot;settings&quot;][&quot;model_path&quot;];
        std::string model_type = config[&quot;settings&quot;][&quot;model_type&quot;];

        if (model_type == &quot;mitie&quot;) {
            ner_model_ = std::make_unique&lt;MitieNER&gt;(model_path);
        } else if (model_type == &quot;onnx_bert&quot;) {
            ner_model_ = std::make_unique&lt;OnnxBertNER&gt;(model_path);
        }

        // Map entity types to PII types
        for (const auto&amp; entity : config[&quot;entity_types&quot;]) {
            if (entity[&quot;enabled&quot;].get&lt;bool&gt;()) {
                entity_mapping_[entity[&quot;name&quot;]] = 
                    PIITypeUtils::fromString(entity[&quot;pii_type&quot;]);
            }
        }

        return ner_model_-&gt;isLoaded();
    }

    std::vector&lt;PIIFinding&gt; detectInText(const std::string&amp; text) const override {
        auto entities = ner_model_-&gt;extract(text);
        std::vector&lt;PIIFinding&gt; findings;

        for (const auto&amp; entity : entities) {
            auto it = entity_mapping_.find(entity.label);
            if (it != entity_mapping_.end()) {
                PIIFinding finding;
                finding.type = it-&gt;second;
                finding.value = entity.text;
                finding.start_offset = entity.start;
                finding.end_offset = entity.end;
                finding.confidence = entity.score;
                finding.pattern_name = entity.label;
                finding.engine_name = &quot;ner&quot;;
                findings.push_back(finding);
            }
        }

        return findings;
    }
};
</code></pre>
<h3 id="pii_detection_engines-training-custom-ner-models">Training Custom NER Models<a class="headerlink" href="#pii_detection_engines-training-custom-ner-models" title="Permanent link">&para;</a></h3>
<p><strong>MITIE Training:</strong></p>
<pre><code class="language-bash"># Prepare annotated data (CoNLL format)
# Train MITIE model
mitie-train ner_trainer pii_training_data.txt pii_ner.dat
</code></pre>
<p><strong>ONNX Models:</strong>
- Use pre-trained models from Hugging Face
- Convert to ONNX format with <code>transformers</code> library
- Example models:
  - <code>dslim/bert-base-NER</code> (English)
  - <code>dbmdz/bert-large-cased-finetuned-conll03-english</code>
  - German: <code>deepset/gbert-base-germandpr</code></p>
<h2 id="pii_detection_engines-future-engine-embeddings-semantic-similarity">Future Engine: Embeddings (Semantic Similarity)<a class="headerlink" href="#pii_detection_engines-future-engine-embeddings-semantic-similarity" title="Permanent link">&para;</a></h2>
<h3 id="pii_detection_engines-dependencies_1">Dependencies<a class="headerlink" href="#pii_detection_engines-dependencies_1" title="Permanent link">&para;</a></h3>
<p><strong>fastText (Recommended)</strong></p>
<pre><code class="language-bash">vcpkg install fasttext
</code></pre>
<h3 id="pii_detection_engines-yaml-configuration_1">YAML Configuration<a class="headerlink" href="#pii_detection_engines-yaml-configuration_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml">detection_engines:
  - type: &quot;embedding&quot;
    enabled: true
    settings:
      model_path: &quot;models/cc.de.300.bin&quot;  # fastText German model
      model_type: &quot;fasttext&quot;
      similarity_threshold: 0.80
      context_window: 5  # Words before/after to consider

    sensitive_keywords:
      - keyword: &quot;gehalt&quot;
        pii_type: &quot;SALARY&quot;
        similarity_threshold: 0.85
        redaction_mode: &quot;strict&quot;

      - keyword: &quot;krankheit&quot;
        pii_type: &quot;HEALTH_INFO&quot;
        similarity_threshold: 0.85
        redaction_mode: &quot;strict&quot;

      - keyword: &quot;passwort&quot;
        pii_type: &quot;CREDENTIAL&quot;
        similarity_threshold: 0.90
        redaction_mode: &quot;strict&quot;
</code></pre>
<h3 id="pii_detection_engines-implementation-sketch_1">Implementation Sketch<a class="headerlink" href="#pii_detection_engines-implementation-sketch_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class EmbeddingDetectionEngine : public IPIIDetectionEngine {
private:
    std::unique_ptr&lt;fasttext::FastText&gt; model_;
    std::vector&lt;SensitiveKeyword&gt; keywords_;

    struct SensitiveKeyword {
        std::string keyword;
        PIIType type;
        double threshold;
        std::string redaction_mode;
    };

public:
    std::vector&lt;PIIFinding&gt; detectInText(const std::string&amp; text) const override {
        auto words = tokenize(text);
        std::vector&lt;PIIFinding&gt; findings;

        for (size_t i = 0; i &lt; words.size(); ++i) {
            auto word_vec = model_-&gt;getWordVector(words[i]);

            for (const auto&amp; keyword : keywords_) {
                auto keyword_vec = model_-&gt;getWordVector(keyword.keyword);
                double similarity = cosineSimilarity(word_vec, keyword_vec);

                if (similarity &gt;= keyword.threshold) {
                    // Extract context window
                    std::string context = extractContext(words, i, context_window_);

                    PIIFinding finding;
                    finding.type = keyword.type;
                    finding.value = context;
                    finding.confidence = similarity;
                    finding.pattern_name = keyword.keyword;
                    finding.engine_name = &quot;embedding&quot;;
                    findings.push_back(finding);
                }
            }
        }

        return findings;
    }
};
</code></pre>
<h3 id="pii_detection_engines-pre-trained-models">Pre-trained Models<a class="headerlink" href="#pii_detection_engines-pre-trained-models" title="Permanent link">&para;</a></h3>
<p><strong>fastText:</strong>
- Download: https://fasttext.cc/docs/en/crawl-vectors.html
- German: <code>cc.de.300.bin</code> (6.7 GB)
- English: <code>cc.en.300.bin</code> (5.8 GB)</p>
<p><strong>word2vec:</strong>
- Google News: <code>GoogleNews-vectors-negative300.bin</code>
- German: <code>german.model</code> (DeReWo)</p>
<h2 id="pii_detection_engines-integration-steps">Integration Steps<a class="headerlink" href="#pii_detection_engines-integration-steps" title="Permanent link">&para;</a></h2>
<h3 id="pii_detection_engines-1-add-dependencies-to-vcpkgjson">1. Add Dependencies to vcpkg.json<a class="headerlink" href="#pii_detection_engines-1-add-dependencies-to-vcpkgjson" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;dependencies&quot;: [
    &quot;mitie&quot;,        // For NER
    &quot;onnxruntime&quot;,  // For BERT-based NER
    &quot;fasttext&quot;      // For embeddings
  ],
  &quot;overrides&quot;: [
    {
      &quot;name&quot;: &quot;mitie&quot;,
      &quot;version&quot;: &quot;0.7&quot;
    }
  ]
}
</code></pre>
<h3 id="pii_detection_engines-2-update-cmakeliststxt">2. Update CMakeLists.txt<a class="headerlink" href="#pii_detection_engines-2-update-cmakeliststxt" title="Permanent link">&para;</a></h3>
<pre><code class="language-cmake"># Optional NER support
option(ENABLE_PII_NER &quot;Enable NER-based PII detection&quot; OFF)
if(ENABLE_PII_NER)
    find_package(mitie CONFIG)
    if(mitie_FOUND)
        target_link_libraries(themis_core PRIVATE mitie::mitie)
        target_compile_definitions(themis_core PRIVATE THEMIS_ENABLE_NER)
    endif()
endif()

# Optional embedding support
option(ENABLE_PII_EMBEDDING &quot;Enable embedding-based PII detection&quot; OFF)
if(ENABLE_PII_EMBEDDING)
    find_package(fastText CONFIG)
    if(fastText_FOUND)
        target_link_libraries(themis_core PRIVATE fastText::fastText)
        target_compile_definitions(themis_core PRIVATE THEMIS_ENABLE_EMBEDDING)
    endif()
endif()
</code></pre>
<h3 id="pii_detection_engines-3-conditional-compilation">3. Conditional Compilation<a class="headerlink" href="#pii_detection_engines-3-conditional-compilation" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// In pii_detection_engine_factory.cpp
std::unique_ptr&lt;IPIIDetectionEngine&gt; PIIDetectionEngineFactory::create(
    const std::string&amp; engine_type) {

    if (engine_type == &quot;regex&quot;) {
        return std::make_unique&lt;RegexDetectionEngine&gt;();
    }

#ifdef THEMIS_ENABLE_NER
    if (engine_type == &quot;ner&quot;) {
        return std::make_unique&lt;NERDetectionEngine&gt;();
    }
#endif

#ifdef THEMIS_ENABLE_EMBEDDING
    if (engine_type == &quot;embedding&quot;) {
        return std::make_unique&lt;EmbeddingDetectionEngine&gt;();
    }
#endif

    return nullptr;
}
</code></pre>
<h2 id="pii_detection_engines-performance-considerations">Performance Considerations<a class="headerlink" href="#pii_detection_engines-performance-considerations" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Engine</th>
<th>Speed</th>
<th>Accuracy</th>
<th>Memory</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>Regex</td>
<td>Very Fast</td>
<td>Good (95%+)</td>
<td>Low</td>
<td>Structured PII (email, SSN, cards)</td>
</tr>
<tr>
<td>NER</td>
<td>Medium</td>
<td>Excellent (98%+)</td>
<td>Medium</td>
<td>Names, locations, organizations</td>
</tr>
<tr>
<td>Embedding</td>
<td>Slow</td>
<td>Variable</td>
<td>High</td>
<td>Context-based, semantic PII</td>
</tr>
</tbody>
</table>
<p><strong>Recommendation:</strong>
- Default: Regex only (fast, low overhead)
- Enhanced: Regex + NER (best balance)
- Advanced: All three (highest accuracy, higher latency)</p>
<h2 id="pii_detection_engines-testing-strategy">Testing Strategy<a class="headerlink" href="#pii_detection_engines-testing-strategy" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">TEST(PIIDetectorTest, MultiEngineDetection) {
    // Enable both regex and NER
    PIIDetector detector(&quot;config/pii_patterns_with_ner.yaml&quot;);

    std::string text = &quot;Contact Max Mustermann at max@example.com&quot;;
    auto findings = detector.detectInText(text);

    // Should find:
    // 1. &quot;Max Mustermann&quot; via NER (PERSON_NAME)
    // 2. &quot;max@example.com&quot; via Regex (EMAIL)
    ASSERT_EQ(findings.size(), 2);

    EXPECT_EQ(findings[0].engine_name, &quot;ner&quot;);
    EXPECT_EQ(findings[0].type, PIIType::PERSON_NAME);

    EXPECT_EQ(findings[1].engine_name, &quot;regex&quot;);
    EXPECT_EQ(findings[1].type, PIIType::EMAIL);
}
</code></pre>
<h2 id="pii_detection_engines-deployment">Deployment<a class="headerlink" href="#pii_detection_engines-deployment" title="Permanent link">&para;</a></h2>
<p><strong>Production Checklist:</strong>
1. ✅ Regex engine always enabled (safe default)
2. ⏳ NER engine optional (enable for high-value data)
3. ⏳ Embedding engine optional (enable for advanced use cases)
4. ✅ YAML config with engine sections
5. ✅ Fallback to embedded defaults
6. ⏳ Model files deployed to <code>models/</code> directory
7. ⏳ Memory limits configured (prevent OOM)
8. ⏳ Performance monitoring (track detection latency)</p>
<h2 id="pii_detection_engines-future-enhancements">Future Enhancements<a class="headerlink" href="#pii_detection_engines-future-enhancements" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Multi-language Support</strong>: Load language-specific models per tenant</li>
<li><strong>Custom Training</strong>: API for training custom NER models on tenant data</li>
<li><strong>Explainability</strong>: Return detection reasoning (which words triggered)</li>
<li><strong>Confidence Calibration</strong>: Adjust thresholds based on false positive rates</li>
<li><strong>GPU Acceleration</strong>: Use CUDA for ONNX models in high-throughput scenarios</li>
</ul></section><section class="print-page" id="pii_engine_signing" heading-number="12.9"><h1 id="pii_engine_signing-pii-detection-engine-signing">PII Detection Engine Signing<a class="headerlink" href="#pii_engine_signing-pii-detection-engine-signing" title="Permanent link">&para;</a></h1>
<h2 id="pii_engine_signing-overview">Overview<a class="headerlink" href="#pii_engine_signing-overview" title="Permanent link">&para;</a></h2>
<p>All PII detection engines must be signed with PKI signatures before they can be loaded by the PIIDetector orchestrator. This ensures:</p>
<ul>
<li><strong>Integrity</strong>: Engine configurations cannot be tampered with</li>
<li><strong>Authenticity</strong>: Only trusted entities can create detection engines</li>
<li><strong>Auditability</strong>: All signature verifications are logged</li>
<li><strong>Non-repudiation</strong>: Signer identity is cryptographically verified</li>
</ul>
<h2 id="pii_engine_signing-security-architecture">Security Architecture<a class="headerlink" href="#pii_engine_signing-security-architecture" title="Permanent link">&para;</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  PII Detection Engine Loading Flow (with PKI Verification)  │
└─────────────────────────────────────────────────────────────┘

1. Load YAML Config
   ↓
2. Extract Engine Config + Signature
   ↓
3. Compute Config Hash (SHA-256)
   ├─ Normalize to JSON (deterministic)
   ├─ Exclude signature block
   └─ Hash with SHA-256
   ↓
4. Verify PKI Signature
   ├─ Decode base64 signature
   ├─ Verify with public key
   └─ Compare with computed hash
   ↓
5. [PASS] Initialize Engine  OR  [FAIL] Reject + Log
</code></pre>
<h2 id="pii_engine_signing-quick-start">Quick Start<a class="headerlink" href="#pii_engine_signing-quick-start" title="Permanent link">&para;</a></h2>
<h3 id="pii_engine_signing-1-generate-test-keys-development-only">1. Generate Test Keys (Development Only)<a class="headerlink" href="#pii_engine_signing-1-generate-test-keys-development-only" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">cd tools
python sign_pii_engine.py keygen --output-dir ../config/keys

# Output:
# [✓] Generated test key pair:
#     Private key: ../config/keys/private_key.pem
#     Public key: ../config/keys/public_key.pem
# [!] WARNING: These are test keys. Use HSM for production!
</code></pre>
<h3 id="pii_engine_signing-2-sign-an-engine-configuration">2. Sign an Engine Configuration<a class="headerlink" href="#pii_engine_signing-2-sign-an-engine-configuration" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">python sign_pii_engine.py sign \
    --config ../config/pii_patterns.yaml \
    --engine regex \
    --key ../config/keys/private_key.pem \
    --output ../config/pii_patterns_signed.yaml \
    --signer &quot;VCC Security Team&quot;

# Output:
# [*] Found regex engine configuration
# [*] Configuration hash (SHA-256): e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
# [*] Generated signature: BASE64_ENCODED_SIGNATURE...
# [✓] Signed configuration written to ../config/pii_patterns_signed.yaml
# [✓] Signature ID: pii-regex-engine-v1.0.0
# [✓] Signed by: VCC Security Team
# [✓] Signed at: 2025-11-01T12:34:56+00:00
</code></pre>
<h3 id="pii_engine_signing-3-use-signed-configuration-in-c">3. Use Signed Configuration in C++<a class="headerlink" href="#pii_engine_signing-3-use-signed-configuration-in-c" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &quot;utils/pii_detector.h&quot;
#include &quot;utils/pki_client.h&quot;

// Initialize PKI client with public key
PKIConfig pki_config;
pki_config.public_key_path = &quot;config/keys/public_key.pem&quot;;
auto pki_client = std::make_shared&lt;VCCPKIClient&gt;(pki_config);

// Create PII detector with PKI verification
PIIDetector detector(&quot;config/pii_patterns_signed.yaml&quot;, pki_client);

// All engines are now verified with PKI signatures!
auto findings = detector.detectInText(&quot;Contact alice@example.com&quot;);
</code></pre>
<h2 id="pii_engine_signing-production-deployment">Production Deployment<a class="headerlink" href="#pii_engine_signing-production-deployment" title="Permanent link">&para;</a></h2>
<h3 id="pii_engine_signing-hardware-security-module-hsm">Hardware Security Module (HSM)<a class="headerlink" href="#pii_engine_signing-hardware-security-module-hsm" title="Permanent link">&para;</a></h3>
<p>For production environments, private keys should be stored in an HSM:</p>
<pre><code class="language-cpp">// Production PKI client with HSM backing
PKIConfig pki_config;
pki_config.use_hsm = true;
pki_config.hsm_slot = 0;
pki_config.hsm_pin = std::getenv(&quot;HSM_PIN&quot;);
pki_config.public_key_id = &quot;VCC-PKI-001&quot;;

auto pki_client = std::make_shared&lt;VCCPKIClient&gt;(pki_config);
PIIDetector detector(&quot;config/pii_patterns.yaml&quot;, pki_client);
</code></pre>
<h3 id="pii_engine_signing-cicd-integration">CI/CD Integration<a class="headerlink" href="#pii_engine_signing-cicd-integration" title="Permanent link">&para;</a></h3>
<p>Add signing to your deployment pipeline:</p>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
- name: Sign PII Engine Configurations
  run: |
    python tools/sign_pii_engine.py sign \
      --config config/pii_patterns.yaml \
      --engine regex \
      --key ${{ secrets.PII_SIGNING_KEY }} \
      --output config/pii_patterns_signed.yaml \
      --signer &quot;VCC CI/CD Pipeline&quot;

- name: Verify Signatures
  run: |
    python tools/verify_pii_signatures.py \
      --config config/pii_patterns_signed.yaml \
      --public-key config/keys/public_key.pem
</code></pre>
<h2 id="pii_engine_signing-signature-format">Signature Format<a class="headerlink" href="#pii_engine_signing-signature-format" title="Permanent link">&para;</a></h2>
<h3 id="pii_engine_signing-in-yaml-configuration">In YAML Configuration<a class="headerlink" href="#pii_engine_signing-in-yaml-configuration" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml">detection_engines:
  - type: &quot;regex&quot;
    version: &quot;1.0.0&quot;
    enabled: true

    # PKI Signature Block
    signature:
      config_hash: &quot;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855&quot;
      signature: &quot;BASE64_ENCODED_SIGNATURE&quot;
      signature_id: &quot;pii-regex-engine-v1.0.0&quot;
      cert_serial: &quot;VCC-PKI-001&quot;
      signed_at: &quot;2025-11-01T12:34:56Z&quot;
      signer: &quot;VCC Security Team&quot;

    # Engine configuration (included in hash)
    settings:
      min_confidence: 0.75
      # ...
    patterns:
      - name: EMAIL
        # ...
</code></pre>
<h3 id="pii_engine_signing-signature-verification-in-c">Signature Verification in C++<a class="headerlink" href="#pii_engine_signing-signature-verification-in-c" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// In PIIDetectionEngineFactory::createSigned()

// 1. Extract signature from config
auto sig_node = config[&quot;signature&quot;];
PluginSignature signature;
signature.config_hash = sig_node[&quot;config_hash&quot;];
signature.signature = sig_node[&quot;signature&quot;];
signature.signature_id = sig_node[&quot;signature_id&quot;];
// ...

// 2. Compute hash of config (excluding signature)
auto config_copy = config;
config_copy.erase(&quot;signature&quot;);
std::string computed_hash = PluginSignature::computeConfigHash(config_copy);

// 3. Verify signature
if (computed_hash != signature.config_hash) {
    error_msg = &quot;Config hash mismatch&quot;;
    return nullptr;
}

if (!pki_client.verifyHash(signature.config_hash, signature.signature)) {
    error_msg = &quot;PKI signature verification failed&quot;;
    return nullptr;
}

// 4. Create engine (signature is valid)
auto engine = createUnsigned(engine_type);
engine-&gt;initialize(config);
</code></pre>
<h2 id="pii_engine_signing-security-considerations">Security Considerations<a class="headerlink" href="#pii_engine_signing-security-considerations" title="Permanent link">&para;</a></h2>
<h3 id="pii_engine_signing-threat-model">Threat Model<a class="headerlink" href="#pii_engine_signing-threat-model" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Threat</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tampered engine config</td>
<td>Config hash mismatch detected, engine rejected</td>
</tr>
<tr>
<td>Unsigned engine</td>
<td>No signature block, engine rejected (unless fallback enabled)</td>
</tr>
<tr>
<td>Expired signature</td>
<td>Signature age check in global_settings.max_signature_age_days</td>
</tr>
<tr>
<td>Untrusted signer</td>
<td>Signer whitelist in global_settings.pki_verification.trusted_signers</td>
</tr>
<tr>
<td>Key compromise</td>
<td>Rotate keys, re-sign all engines, deploy new public key</td>
</tr>
<tr>
<td>Replay attack</td>
<td>Signature includes timestamp, old signatures rejected</td>
</tr>
</tbody>
</table>
<h3 id="pii_engine_signing-key-rotation-procedure">Key Rotation Procedure<a class="headerlink" href="#pii_engine_signing-key-rotation-procedure" title="Permanent link">&para;</a></h3>
<ol>
<li>Generate new key pair (keep old keys for transition period)</li>
<li>Re-sign all engine configurations with new key</li>
<li>Deploy signed configs + new public key to all instances</li>
<li>Monitor logs for verification failures</li>
<li>After transition period, revoke old keys</li>
</ol>
<h3 id="pii_engine_signing-audit-logging">Audit Logging<a class="headerlink" href="#pii_engine_signing-audit-logging" title="Permanent link">&para;</a></h3>
<p>All signature verification attempts are logged:</p>
<pre><code>[INFO] PIIDetector: Verifying signature for engine 'regex' v1.0.0
[INFO] PKI signature verification succeeded for 'pii-regex-engine-v1.0.0'
[INFO] Engine 'regex' loaded successfully (signed by: VCC Security Team)
</code></pre>
<p>Failures trigger alerts:</p>
<pre><code>[ERROR] PKI signature verification FAILED for engine 'regex'
[ERROR] Config hash mismatch: expected e3b0c44..., computed a1b2c3...
[ERROR] Falling back to embedded unsigned defaults
</code></pre>
<h2 id="pii_engine_signing-troubleshooting">Troubleshooting<a class="headerlink" href="#pii_engine_signing-troubleshooting" title="Permanent link">&para;</a></h2>
<h3 id="pii_engine_signing-config-hash-mismatch-error">"Config hash mismatch" Error<a class="headerlink" href="#pii_engine_signing-config-hash-mismatch-error" title="Permanent link">&para;</a></h3>
<p><strong>Cause:</strong> Engine configuration was modified after signing.</p>
<p><strong>Solution:</strong> Re-sign the configuration:</p>
<pre><code class="language-bash">python tools/sign_pii_engine.py sign --config pii_patterns.yaml --engine regex --key private_key.pem --output pii_patterns_signed.yaml
</code></pre>
<h3 id="pii_engine_signing-pki-signature-verification-failed-error">"PKI signature verification failed" Error<a class="headerlink" href="#pii_engine_signing-pki-signature-verification-failed-error" title="Permanent link">&para;</a></h3>
<p><strong>Cause:</strong> Signature doesn't match public key (wrong key, corrupted signature, etc.)</p>
<p><strong>Solution:</strong> 
1. Verify public key matches private key used for signing
2. Check signature wasn't corrupted (base64 encoding issues)
3. Re-sign with correct key</p>
<h3 id="pii_engine_signing-untrusted-signer-error">"Untrusted signer" Error<a class="headerlink" href="#pii_engine_signing-untrusted-signer-error" title="Permanent link">&para;</a></h3>
<p><strong>Cause:</strong> Signer not in <code>trusted_signers</code> list.</p>
<p><strong>Solution:</strong> Add signer to <code>global_settings.pki_verification.trusted_signers</code> in YAML:</p>
<pre><code class="language-yaml">global_settings:
  pki_verification:
    trusted_signers:
      - &quot;VCC Security Team&quot;
      - &quot;Your New Signer&quot;  # Add here
</code></pre>
<h3 id="pii_engine_signing-fallback-to-unsigned-defaults">Fallback to Unsigned Defaults<a class="headerlink" href="#pii_engine_signing-fallback-to-unsigned-defaults" title="Permanent link">&para;</a></h3>
<p>If all signed engines fail to load, the detector falls back to embedded unsigned regex patterns:</p>
<pre><code>[WARN] All signed engines failed PKI verification
[WARN] Falling back to embedded unsigned RegexDetectionEngine
[INFO] Using 7 embedded regex patterns (EMAIL, PHONE, SSN, ...)
</code></pre>
<p>To disable fallback (enforce signature requirement):</p>
<pre><code class="language-yaml">global_settings:
  pki_verification:
    allow_embedded_fallback: false
</code></pre>
<h2 id="pii_engine_signing-advanced-usage">Advanced Usage<a class="headerlink" href="#pii_engine_signing-advanced-usage" title="Permanent link">&para;</a></h2>
<h3 id="pii_engine_signing-multiple-signers-chain-of-trust">Multiple Signers (Chain of Trust)<a class="headerlink" href="#pii_engine_signing-multiple-signers-chain-of-trust" title="Permanent link">&para;</a></h3>
<p>For critical environments, require multiple signatures:</p>
<pre><code class="language-yaml">signature:
  signatures:  # Array of signatures
    - signer: &quot;VCC Security Team&quot;
      signature: &quot;...&quot;
      signed_at: &quot;2025-11-01T12:00:00Z&quot;

    - signer: &quot;VCC Compliance Officer&quot;
      signature: &quot;...&quot;
      signed_at: &quot;2025-11-01T12:30:00Z&quot;
</code></pre>
<h3 id="pii_engine_signing-signature-revocation">Signature Revocation<a class="headerlink" href="#pii_engine_signing-signature-revocation" title="Permanent link">&para;</a></h3>
<p>Maintain a revocation list:</p>
<pre><code class="language-yaml">global_settings:
  pki_verification:
    revoked_signatures:
      - &quot;pii-regex-engine-v0.9.0&quot;  # Old version, revoked
      - &quot;pii-ner-compromised-2024&quot;  # Compromised key
</code></pre>
<h3 id="pii_engine_signing-emergency-unsigned-mode">Emergency Unsigned Mode<a class="headerlink" href="#pii_engine_signing-emergency-unsigned-mode" title="Permanent link">&para;</a></h3>
<p>For disaster recovery, temporarily disable PKI verification:</p>
<pre><code class="language-cpp">// Emergency bypass (log extensively!)
PIIDetector detector(&quot;config/pii_patterns.yaml&quot;, nullptr);  // nullptr = no PKI client
spdlog::critical(&quot;EMERGENCY: Running without PKI verification!&quot;);
</code></pre>
<h2 id="pii_engine_signing-references">References<a class="headerlink" href="#pii_engine_signing-references" title="Permanent link">&para;</a></h2>
<ul>
<li>PKI Client Implementation: <code>include/utils/pki_client.h</code></li>
<li>Plugin Interface: <code>include/utils/pii_detection_engine.h</code></li>
<li>Orchestrator: <code>include/utils/pii_detector.h</code></li>
<li>YAML Configuration: <code>config/pii_patterns.yaml</code></li>
</ul></section><section class="print-page" id="security-audit_and_retention" heading-number="12.10"><h1 id="security-audit_and_retention-audit-retention">Audit &amp; Retention<a class="headerlink" href="#security-audit_and_retention-audit-retention" title="Permanent link">&para;</a></h1>
<p>Audit-Trails und Datenaufbewahrung sind Kernbausteine der Sicherheit &amp; Compliance.</p>
<h2 id="security-audit_and_retention-changefeed-audittrail">Changefeed (Audit‑Trail)<a class="headerlink" href="#security-audit_and_retention-changefeed-audittrail" title="Permanent link">&para;</a></h2>
<ul>
<li>Append‑only Log aller Mutationen (PUT/DELETE)</li>
<li>Endpunkte:</li>
<li>GET /changefeed – Events listen (Parameter: from_seq, limit, long_poll_ms, key_prefix)</li>
<li>GET /changefeed/stats – Gesamtereignisse, letzte Sequence, Größe</li>
<li>POST /changefeed/retention – Löschung bis Sequence: { "before_sequence": <uint64> }</li>
<li>GET /changefeed/stream – Server‑Sent Events (siehe APIs/SSE)</li>
<li>Einsatzzwecke: Echtzeit‑Sync, Audit, Event Processing</li>
</ul>
<p>Details: siehe docs/change_data_capture.md</p>
<h2 id="security-audit_and_retention-retentionpolicies">Retention‑Policies<a class="headerlink" href="#security-audit_and_retention-retentionpolicies" title="Permanent link">&para;</a></h2>
<ul>
<li>Changefeed: Sequenz‑basierte Bereinigung via /changefeed/retention</li>
<li>Time‑Series: RetentionManager (per‑Metric Policies) – siehe docs/time_series.md</li>
<li>Content/Entities: Fachliche Policies (z. B. DSGVO Art. 17) außerhalb des Changefeeds umsetzen</li>
</ul>
<h2 id="security-audit_and_retention-empfehlungen">Empfehlungen<a class="headerlink" href="#security-audit_and_retention-empfehlungen" title="Permanent link">&para;</a></h2>
<ul>
<li>Minimale Aufbewahrungszeit für Audit‑Zwecke definieren (rechtlich/organisatorisch)</li>
<li>Automatisierte Bereinigung (Cron/Jobs) etablieren; Metriken überwachen</li>
<li>Export/Archivierung vor Löschung (WORM‑Storage optional)</li>
</ul>
<p>Weiterlesen:
- change_data_capture.md
- compliance_audit.md, compliance_governance_strategy.md</p></section><section class="print-page" id="security-threat_model" heading-number="12.11"><h1 id="security-threat_model-threat-model-light">Threat Model (light)<a class="headerlink" href="#security-threat_model-threat-model-light" title="Permanent link">&para;</a></h1>
<p>Ziel: Risiken sichtbar machen und mit pragmatischen Kontrollen adressieren.</p>
<h2 id="security-threat_model-assets">Assets<a class="headerlink" href="#security-threat_model-assets" title="Permanent link">&para;</a></h2>
<ul>
<li>Datenbankinhalte (Dokumente, Inhalte, Vektoren, Zeitreihen)</li>
<li>Schlüsselmaterial (LEK/KEK/DEK)</li>
<li>Audit‑Trails (Changefeed)</li>
</ul>
<h2 id="security-threat_model-akteure">Akteure<a class="headerlink" href="#security-threat_model-akteure" title="Permanent link">&para;</a></h2>
<ul>
<li>Admin/Operator (berechtigt)</li>
<li>Anwendung/Service (technisch)</li>
<li>Angreifer extern/intern (unberechtigt/teilberechtigt)</li>
</ul>
<h2 id="security-threat_model-vertrauensgrenzen">Vertrauensgrenzen<a class="headerlink" href="#security-threat_model-vertrauensgrenzen" title="Permanent link">&para;</a></h2>
<ul>
<li>Client ↔ Reverse‑Proxy ↔ Themis‑Server ↔ Storage (RocksDB)</li>
<li>Externe Schlüsselverwaltung (Vault o. ä.)</li>
</ul>
<h2 id="security-threat_model-hauptrisiken-auszug">Hauptrisiken (Auszug)<a class="headerlink" href="#security-threat_model-hauptrisiken-auszug" title="Permanent link">&para;</a></h2>
<ul>
<li>Unautorisierte Schlüsselrotation/Schlüsselabgriff</li>
<li>Datenexfiltration über Admin‑APIs</li>
<li>PII‑Leakage in Logs/Exports</li>
<li>Manipulation Audit‑Trail</li>
</ul>
<h2 id="security-threat_model-gegenmanahmen">Gegenmaßnahmen<a class="headerlink" href="#security-threat_model-gegenmanahmen" title="Permanent link">&para;</a></h2>
<ul>
<li>RBAC/Netzwerk‑Kontrollen vor Admin‑APIs (/keys/rotate, /changefeed/retention)</li>
<li>TLS‑Terminations‑Proxy, mTLS optional</li>
<li>Secrets‑Management (kein Klartext im Repo/Config)</li>
<li>Minimierte Logs; Pseudonymisierung sensibler Werte</li>
<li>Regelmäßige Rotation, Least‑Privilege, Vier‑Augen‑Prinzip bei kritischen Aktionen</li>
<li>Backup/Restore mit Integritätsprüfungen</li>
</ul>
<h2 id="security-threat_model-beobachtbarkeit">Beobachtbarkeit<a class="headerlink" href="#security-threat_model-beobachtbarkeit" title="Permanent link">&para;</a></h2>
<ul>
<li>Health/Metrics Endpunkte überwachen (/health, /metrics)</li>
<li>Alarme für Schlüsselablauf, Retention‑Fehler, Anomalien im Changefeed</li>
</ul>
<p>Weiterlesen:
- security/key_management.md, security/audit_and_retention.md
- encryption_strategy.md, security_hardening_guide.md, security_audit_checklist.md</p></section><section class="print-page" id="security_hardening_guide" heading-number="12.12"><h1 id="security_hardening_guide-themis-security-hardening-guide">Themis – Security Hardening Guide<a class="headerlink" href="#security_hardening_guide-themis-security-hardening-guide" title="Permanent link">&para;</a></h1>
<p>Praxisleitfaden zur Härtung von Themis-Server und Admin-Tools.</p>
<h2 id="security_hardening_guide-server-hartung">Server-Härtung<a class="headerlink" href="#security_hardening_guide-server-hartung" title="Permanent link">&para;</a></h2>
<ul>
<li>Reverse Proxy vor Themis (TLS, Rate Limiting, Auth): Nginx/Traefik empfohlen</li>
<li>TLS: TLS 1.2+, HSTS, sichere Cipher Suites, OCSP Stapling</li>
<li>Accounts: Least-Privilege Service User, kein Admin-Kontext</li>
<li>Firewall: Nur benötigte Ports (8765) freigeben, IP-Restriktionen erwägen</li>
<li>Logging: Security-Events zentralisieren; Log Rotation, WORM/ELK/Graylog</li>
<li>Ressourcen: Request-Timeouts, Body-Size-Limits, Parallelitätsgrenzen</li>
<li>Build: Reproducible, vcpkg Baseline fixiert; ASAN/UBSAN im Testlauf</li>
</ul>
<h2 id="security_hardening_guide-admin-tools-wpf">Admin-Tools (WPF)<a class="headerlink" href="#security_hardening_guide-admin-tools-wpf" title="Permanent link">&para;</a></h2>
<ul>
<li>Code Signing der EXEs und Installer (MSIX/WiX)</li>
<li>Updates: Signierte Updates; Hash-Validierung bei Verteilung</li>
<li>Netzwerk: Nur HTTPS-Endpoints verwenden; Zertifikatsvalidierung aktiv</li>
<li>Konfiguration: Keine Secrets in Klartextdateien; Windows Credential Locker/DPAPI</li>
<li>Telemetrie/Logs: Keine PII im Klartext; Minimalprinzip</li>
</ul>
<h2 id="security_hardening_guide-secrets-management">Secrets-Management<a class="headerlink" href="#security_hardening_guide-secrets-management" title="Permanent link">&para;</a></h2>
<ul>
<li>Keinerlei Secrets im Repo halten; .gitignore beachten</li>
<li>Nutzung von Secret Stores (Windows, Azure Key Vault, HashiCorp Vault)</li>
<li>Rotationspläne definieren (LEK/KEK/DEK + App-Secrets)</li>
</ul>
<h2 id="security_hardening_guide-compliance-aspekte">Compliance-Aspekte<a class="headerlink" href="#security_hardening_guide-compliance-aspekte" title="Permanent link">&para;</a></h2>
<ul>
<li>DSGVO: Recht auf Löschung, Auskunft, Pseudonymisierung</li>
<li>Auditierbarkeit: Export-/Löschaktionen protokollieren</li>
<li>Aufbewahrung: Retention-Policies technisch durchsetzen</li>
</ul>
<h2 id="security_hardening_guide-checklisten-gates">Checklisten &amp; Gates<a class="headerlink" href="#security_hardening_guide-checklisten-gates" title="Permanent link">&para;</a></h2>
<ul>
<li>Vor Release: <code>docs/security_audit_checklist.md</code> durchgehen</li>
<li>Vulnerability-Scans ohne kritische Funde</li>
<li>Signierte, versionierte Artefakte im <code>dist/</code>-Pfad</li>
</ul></section><section class="print-page" id="security_audit_checklist" heading-number="12.13"><h1 id="security_audit_checklist-themis-sicherheits-audit-checkliste">Themis – Sicherheits-Audit Checkliste<a class="headerlink" href="#security_audit_checklist-themis-sicherheits-audit-checkliste" title="Permanent link">&para;</a></h1>
<p>Diese Checkliste unterstützt ein wiederholbares Sicherheits-Audit für Themis-Server und Admin-Tools.</p>
<h2 id="security_audit_checklist-1-architektur-threat-modeling">1) Architektur &amp; Threat Modeling<a class="headerlink" href="#security_audit_checklist-1-architektur-threat-modeling" title="Permanent link">&para;</a></h2>
<ul>
<li>Datenflüsse und Vertrauensgrenzen dokumentiert (Client ↔ Server ↔ Storage)</li>
<li>Angriffsflächen identifiziert (HTTP-API, Admin-Tools, Datei-Importe)</li>
<li>Missbrauchsfälle (Abuse Cases) erfasst (API-Scraping, DoS, unautorisierte Exporte)</li>
</ul>
<h2 id="security_audit_checklist-2-abhangigkeiten-vulnerability-scan">2) Abhängigkeiten &amp; Vulnerability-Scan<a class="headerlink" href="#security_audit_checklist-2-abhangigkeiten-vulnerability-scan" title="Permanent link">&para;</a></h2>
<ul>
<li>.NET: <code>dotnet list package --vulnerable</code> in allen Tools</li>
<li>C++/vcpkg: Versionen und CVEs prüfen (vcpkg-Baseline aktuell, Release Notes)</li>
<li>Container-Images (falls genutzt): Trivy/Grype Scan</li>
<li>Repo-Scan: <code>security-scan.ps1</code> ausführen (C/C++ Risky-APIs, Secret-Pattern, .NET Vulnerabilities)</li>
</ul>
<h2 id="security_audit_checklist-3-buildcompiler-hartung">3) Build/Compiler-Härtung<a class="headerlink" href="#security_audit_checklist-3-buildcompiler-hartung" title="Permanent link">&para;</a></h2>
<ul>
<li>C++: Warnings auf Maximum, Sanitizer im CI-Testlauf (ASAN/UBSAN) aktivierbar</li>
<li>Windows: ASLR/DEP standardmäßig aktiv, Code Signing für EXEs/Installer</li>
<li>Release-Builds reproduzierbar (vcpkg Baseline, deterministische Flags)</li>
</ul>
<h2 id="security_audit_checklist-4-authentifizierung-autorisierung">4) Authentifizierung &amp; Autorisierung<a class="headerlink" href="#security_audit_checklist-4-authentifizierung-autorisierung" title="Permanent link">&para;</a></h2>
<ul>
<li>Admin-APIs nur für authentisierte Nutzer (Token/Bearer, mTLS oder Reverse Proxy Auth)</li>
<li>Rollen/Rechte getrennt (View vs. Export vs. Löschfunktionen)</li>
<li>Sensitive Aktionen (PII-Delete, Key-Rotation) auditierbar</li>
</ul>
<h2 id="security_audit_checklist-5-transport-sicherheit">5) Transport-Sicherheit<a class="headerlink" href="#security_audit_checklist-5-transport-sicherheit" title="Permanent link">&para;</a></h2>
<ul>
<li>TLS erzwingen (Reverse Proxy wie Nginx/Traefik vor Themis-Server)</li>
<li>Sichere Cipher Suites, HSTS, TLS 1.2+</li>
<li>Interne Admin-Tools: Kommunikation nur über HTTPS</li>
</ul>
<h2 id="security_audit_checklist-6-input-validierung-serialisierung">6) Input-Validierung &amp; Serialisierung<a class="headerlink" href="#security_audit_checklist-6-input-validierung-serialisierung" title="Permanent link">&para;</a></h2>
<ul>
<li>Strikte Schema-Validierung für JSON-Inputs</li>
<li>Limitierung von Eingabegrößen (Body Size, Felder)</li>
<li>Schutz gegen Path Traversal, SSRF, Open Redirects (URL/Path-Validierung)</li>
</ul>
<h2 id="security_audit_checklist-7-ratenbegrenzung-ressourcen-schutz">7) Ratenbegrenzung &amp; Ressourcen-Schutz<a class="headerlink" href="#security_audit_checklist-7-ratenbegrenzung-ressourcen-schutz" title="Permanent link">&para;</a></h2>
<ul>
<li>Rate Limiting / Backoff bei teuren Endpoints (Export, Query)</li>
<li>Timeouts, maximale Parallelität, Queue-Limits</li>
<li>DoS-Schutz auf Proxy-Ebene</li>
</ul>
<h2 id="security_audit_checklist-8-logging-audit">8) Logging &amp; Audit<a class="headerlink" href="#security_audit_checklist-8-logging-audit" title="Permanent link">&para;</a></h2>
<ul>
<li>Security-relevante Events protokolliert (Login, Export, Löschungen, Rotation)</li>
<li>Log-Integrität (WORM/zentral, manipulationssicher)</li>
<li>PII-Logging minimieren, keine sensiblen Daten im Klartext</li>
</ul>
<h2 id="security_audit_checklist-9-secrets-konfiguration">9) Secrets &amp; Konfiguration<a class="headerlink" href="#security_audit_checklist-9-secrets-konfiguration" title="Permanent link">&para;</a></h2>
<ul>
<li>Keine Secrets im Repo (API Keys, Zertifikate) – Geheimnis-Scan</li>
<li>Konfiguration via Umgebung/geschützte Stores (Windows DPAPI/KeyVault)</li>
<li>Rotationspläne und Notfall-Rollback definiert</li>
</ul>
<h2 id="security_audit_checklist-10-privacy-compliance">10) Privacy &amp; Compliance<a class="headerlink" href="#security_audit_checklist-10-privacy-compliance" title="Permanent link">&para;</a></h2>
<ul>
<li>Data Minimization, Zweckbindung, Löschkonzepte (Art. 17)</li>
<li>Export-/Reporting-Pfade DSGVO-konform (Berechtigungen, Pseudonymisierung)</li>
<li>Auftragsverarbeitung und TOMs dokumentiert</li>
</ul>
<h2 id="security_audit_checklist-11-testen-review">11) Testen &amp; Review<a class="headerlink" href="#security_audit_checklist-11-testen-review" title="Permanent link">&para;</a></h2>
<ul>
<li>Security Code Review (C++/C#) gegen diese Checkliste</li>
<li>Fuzzing-Kampagnen (Parser, Query, Import)</li>
<li>Penetration-Test gegen die bereitgestellte Staging-Umgebung</li>
</ul>
<h2 id="security_audit_checklist-12-release-gates">12) Release-Gates<a class="headerlink" href="#security_audit_checklist-12-release-gates" title="Permanent link">&para;</a></h2>
<ul>
<li>Build/Lint/Tests PASS</li>
<li>Vulnerability-Scan: keine kritischen offenen CVEs</li>
<li>Signierte Artefakte (Code Signing), Hashes veröffentlicht</li>
<li>Geheimnis-Scan ohne Treffer (oder Findings adressiert): <code>security-scan.ps1</code></li>
</ul></section><section class="print-page" id="compliance_audit" heading-number="12.14"><h1 id="compliance_audit-compliance-audit-pki-signing-und-audit-logger">Compliance &amp; Audit: PKI-Signing und Audit Logger<a class="headerlink" href="#compliance_audit-compliance-audit-pki-signing-und-audit-logger" title="Permanent link">&para;</a></h1>
<h2 id="compliance_audit-uberblick">Überblick<a class="headerlink" href="#compliance_audit-uberblick" title="Permanent link">&para;</a></h2>
<p>Dieses Dokument beschreibt die ersten Schritte der Compliance- und Audit-Implementierung:
- <strong>PKI Client</strong>: Minimale Schnittstelle zum Signieren und Verifizieren von Hashes (Stub).
- <strong>AuditLogger</strong>: Encrypt-then-Sign für strukturierte Audit-Logs.</p>
<h2 id="compliance_audit-1-pki-client-vccpkiclient">1. PKI Client (<code>VCCPKIClient</code>)<a class="headerlink" href="#compliance_audit-1-pki-client-vccpkiclient" title="Permanent link">&para;</a></h2>
<h3 id="compliance_audit-zweck">Zweck<a class="headerlink" href="#compliance_audit-zweck" title="Permanent link">&para;</a></h3>
<p>Bietet eine zentrale Schnittstelle zum Signieren von Daten-Hashes (z. B. SHA-256 über verschlüsselte Audit-Logs). Später erweiterbar auf echte PKI-Backends (HSM, Remote-Signing-Dienst).</p>
<h3 id="compliance_audit-konfiguration">Konfiguration<a class="headerlink" href="#compliance_audit-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">PKIConfig pki_cfg;
pki_cfg.service_id = &quot;audit_service&quot;;
pki_cfg.endpoint = &quot;https://pki.example.com/api/v1&quot;;  // optional
pki_cfg.cert_path = &quot;/path/to/cert.pem&quot;;              // optional
pki_cfg.key_path = &quot;/path/to/key.pem&quot;;                // optional
pki_cfg.signature_algorithm = &quot;RSA-SHA256&quot;;           // Standard
</code></pre>
<h3 id="compliance_audit-verwendung">Verwendung<a class="headerlink" href="#compliance_audit-verwendung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto pki = std::make_shared&lt;VCCPKIClient&gt;(pki_cfg);

// 1. Berechne SHA-256 über Daten
std::vector&lt;uint8_t&gt; hash = sha256(ciphertext);

// 2. Signiere Hash
auto sig = pki-&gt;signHash(hash);
if (sig.ok) {
    // sig.signature_id, sig.signature_b64, sig.cert_serial verfügbar
}

// 3. Verifiziere Signatur
bool valid = pki-&gt;verifyHash(hash, sig);
</code></pre>
<h3 id="compliance_audit-stub-verhalten-aktuell">Stub-Verhalten (aktuell)<a class="headerlink" href="#compliance_audit-stub-verhalten-aktuell" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>signHash</strong>: Gibt Base64-kodierten Hash zurück (kein echtes Signing).</li>
<li><strong>verifyHash</strong>: Vergleicht Base64(hash) mit gespeicherter Signatur.</li>
<li>Für Produktion: Echte Kryptografie über OpenSSL oder HSM integrieren.</li>
</ul>
<h2 id="compliance_audit-2-auditlogger">2. AuditLogger<a class="headerlink" href="#compliance_audit-2-auditlogger" title="Permanent link">&para;</a></h2>
<h3 id="compliance_audit-zweck_1">Zweck<a class="headerlink" href="#compliance_audit-zweck_1" title="Permanent link">&para;</a></h3>
<p>Strukturierte, nachvollziehbare Protokollierung sicherheitskritischer Ereignisse mit <strong>Encrypt-then-Sign</strong>:
1. Verschlüssle Event-JSON mit AES-256-GCM (<code>FieldEncryption</code>).
2. Hash Verschlüsselter Blob (iv || ciphertext || tag).
3. Signiere Hash über PKI Client.
4. Schreibe JSONL-Record mit Payload, Signatur und Metadaten.</p>
<h3 id="compliance_audit-konfiguration_1">Konfiguration<a class="headerlink" href="#compliance_audit-konfiguration_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">AuditLoggerConfig cfg;
cfg.enabled = true;
cfg.encrypt_then_sign = true;        // Aktiviere Encrypt-then-Sign
cfg.log_path = &quot;data/logs/audit.jsonl&quot;;
cfg.key_id = &quot;saga_log&quot;;             // Key für Log-Verschlüsselung

auto logger = std::make_shared&lt;AuditLogger&gt;(field_enc, pki, cfg);
</code></pre>
<h3 id="compliance_audit-verwendung_1">Verwendung<a class="headerlink" href="#compliance_audit-verwendung_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">nlohmann::json event = {
    {&quot;user&quot;, &quot;admin&quot;},
    {&quot;action&quot;, &quot;read&quot;},
    {&quot;resource&quot;, &quot;/content/doc123&quot;},
    {&quot;classification&quot;, &quot;VS-NfD&quot;},
    {&quot;result&quot;, &quot;success&quot;},
    {&quot;ip&quot;, &quot;192.168.1.42&quot;}
};

logger-&gt;logEvent(event);
</code></pre>
<h3 id="compliance_audit-log-format">Log-Format<a class="headerlink" href="#compliance_audit-log-format" title="Permanent link">&para;</a></h3>
<h4 id="compliance_audit-encrypt-then-sign-standard">Encrypt-then-Sign (Standard)<a class="headerlink" href="#compliance_audit-encrypt-then-sign-standard" title="Permanent link">&para;</a></h4>
<pre><code class="language-json">{
  &quot;ts&quot;: 1700000000123,
  &quot;category&quot;: &quot;AUDIT&quot;,
  &quot;payload&quot;: {
    &quot;type&quot;: &quot;ciphertext&quot;,
    &quot;key_id&quot;: &quot;saga_log&quot;,
    &quot;key_version&quot;: 1,
    &quot;iv_b64&quot;: &quot;abc123...&quot;,
    &quot;ciphertext_b64&quot;: &quot;xyz789...&quot;,
    &quot;tag_b64&quot;: &quot;def456...&quot;
  },
  &quot;signature&quot;: {
    &quot;ok&quot;: true,
    &quot;id&quot;: &quot;sig_a1b2c3d4&quot;,
    &quot;algorithm&quot;: &quot;RSA-SHA256&quot;,
    &quot;sig_b64&quot;: &quot;base64(...)&quot;,
    &quot;cert_serial&quot;: &quot;DEMO-CERT-SERIAL&quot;
  }
}
</code></pre>
<h4 id="compliance_audit-plaintext-sign-fur-weniger-sensitive-logs">Plaintext-Sign (für weniger sensitive Logs)<a class="headerlink" href="#compliance_audit-plaintext-sign-fur-weniger-sensitive-logs" title="Permanent link">&para;</a></h4>
<p>Setze <code>encrypt_then_sign = false</code>:</p>
<pre><code class="language-json">{
  &quot;ts&quot;: 1700000000456,
  &quot;category&quot;: &quot;AUDIT&quot;,
  &quot;payload&quot;: {
    &quot;type&quot;: &quot;plaintext&quot;,
    &quot;data_b64&quot;: &quot;eyJ1c2VyIjoidXNlcjEiLCAi...&quot;
  },
  &quot;signature&quot;: {
    &quot;ok&quot;: true,
    &quot;id&quot;: &quot;sig_xyz&quot;,
    ...
  }
}
</code></pre>
<h3 id="compliance_audit-wiederherstellungverifikation">Wiederherstellung/Verifikation<a class="headerlink" href="#compliance_audit-wiederherstellungverifikation" title="Permanent link">&para;</a></h3>
<pre><code class="language-python"># Beispiel in Python (zur Demonstration)
import json
import base64
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

with open(&quot;data/logs/audit.jsonl&quot;) as f:
    for line in f:
        record = json.loads(line)

        # 1. Hole Ciphertext und Signatur
        payload = record[&quot;payload&quot;]
        signature = record[&quot;signature&quot;]

        # 2. Verifiziere Signatur über hash(iv||ct||tag)
        iv = base64.b64decode(payload[&quot;iv_b64&quot;])
        ct = base64.b64decode(payload[&quot;ciphertext_b64&quot;])
        tag = base64.b64decode(payload[&quot;tag_b64&quot;])

        to_verify = iv + ct + tag
        hash_bytes = sha256(to_verify)

        # Verifikation via PKI (hier stub):
        # verify_signature(hash_bytes, signature[&quot;sig_b64&quot;])

        # 3. Entschlüssele mit Key
        key = get_key(payload[&quot;key_id&quot;], payload[&quot;key_version&quot;])
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag))
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ct) + decryptor.finalize()

        event = json.loads(plaintext)
        print(event)  # Original Event
</code></pre>
<h2 id="compliance_audit-integration-in-http-server">Integration in HTTP Server<a class="headerlink" href="#compliance_audit-integration-in-http-server" title="Permanent link">&para;</a></h2>
<h3 id="compliance_audit-automatische-initialisierung">Automatische Initialisierung<a class="headerlink" href="#compliance_audit-automatische-initialisierung" title="Permanent link">&para;</a></h3>
<p>Der HTTP-Server initialisiert den AuditLogger automatisch beim Start:</p>
<pre><code class="language-cpp">// Aus HttpServer::HttpServer() Konstruktor:
auto key_provider = std::make_shared&lt;MockKeyProvider&gt;();
key_provider-&gt;createKey(&quot;saga_log&quot;, 1);
auto field_enc = std::make_shared&lt;FieldEncryption&gt;(key_provider);

themis::utils::PKIConfig pki_cfg;
pki_cfg.service_id = &quot;themis_server&quot;;
pki_cfg.signature_algorithm = &quot;RSA-SHA256&quot;;
auto pki_client = std::make_shared&lt;themis::utils::VCCPKIClient&gt;(pki_cfg);

themis::utils::AuditLoggerConfig audit_cfg;
audit_cfg.enabled = true;
audit_cfg.encrypt_then_sign = true;
audit_cfg.log_path = &quot;data/logs/audit.jsonl&quot;;
audit_cfg.key_id = &quot;saga_log&quot;;

audit_logger_ = std::make_shared&lt;themis::utils::AuditLogger&gt;(
    field_enc, pki_client, audit_cfg);

// Verbinde mit PolicyEngine
policy_engine_-&gt;setAuditLogger(audit_logger_);
</code></pre>
<h3 id="compliance_audit-automatisches-logging-durch-policyengine">Automatisches Logging durch PolicyEngine<a class="headerlink" href="#compliance_audit-automatisches-logging-durch-policyengine" title="Permanent link">&para;</a></h3>
<p>Die <code>PolicyEngine</code> loggt automatisch alle Enforcement-Entscheidungen:</p>
<pre><code class="language-cpp">// In PolicyEngine::evaluate():
if (audit_logger_ &amp;&amp; d.mode == &quot;enforce&quot;) {
    nlohmann::json audit_event = {
        {&quot;event_type&quot;, &quot;policy_evaluation&quot;},
        {&quot;route&quot;, route},
        {&quot;classification&quot;, d.classification},
        {&quot;mode&quot;, d.mode},
        {&quot;require_content_encryption&quot;, d.require_content_encryption},
        {&quot;encrypt_logs&quot;, d.encrypt_logs},
        {&quot;redaction&quot;, d.redaction},
        {&quot;retention_days&quot;, d.retention_days},
        {&quot;timestamp&quot;, getCurrentTimeMs()}
    };

    if (headers.find(&quot;X-User-Id&quot;) != headers.end()) {
        audit_event[&quot;user_id&quot;] = headers[&quot;X-User-Id&quot;];
    }

    audit_logger_-&gt;logEvent(audit_event);
}
</code></pre>
<h3 id="compliance_audit-szenario-log-alle-vs-nfd-content-zugriffe">Szenario: Log alle VS-NfD+ Content-Zugriffe<a class="headerlink" href="#compliance_audit-szenario-log-alle-vs-nfd-content-zugriffe" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// In handleContentImport:
if (audit_logger_ &amp;&amp; (pdec.classification == &quot;vs-nfd&quot; || 
                      pdec.classification == &quot;geheim&quot; || 
                      pdec.classification == &quot;streng-geheim&quot;)) {
    nlohmann::json audit_event = {
        {&quot;event_type&quot;, &quot;content_import&quot;},
        {&quot;classification&quot;, pdec.classification},
        {&quot;mode&quot;, pdec.mode},
        {&quot;require_encryption&quot;, pdec.require_content_encryption},
        {&quot;content_id&quot;, content_id},
        {&quot;timestamp&quot;, getCurrentTimeMs()}
    };

    if (user_id_header.has_value()) {
        audit_event[&quot;user_id&quot;] = user_id_header.value();
    }

    audit_logger_-&gt;logEvent(audit_event);
}
</code></pre>
<h3 id="compliance_audit-szenario-blob-zugriff-logging">Szenario: Blob-Zugriff Logging<a class="headerlink" href="#compliance_audit-szenario-blob-zugriff-logging" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// In handleGetContentBlob:
if (audit_logger_) {
    nlohmann::json audit_event = {
        {&quot;event_type&quot;, &quot;content_blob_access&quot;},
        {&quot;content_id&quot;, id},
        {&quot;timestamp&quot;, getCurrentTimeMs()}
    };

    // Optional: User-ID aus Headers extrahieren
    if (req.contains(&quot;X-User-Id&quot;)) {
        audit_event[&quot;user_id&quot;] = req[&quot;X-User-Id&quot;];
    }

    audit_logger_-&gt;logEvent(audit_event);
}
</code></pre>
<h2 id="compliance_audit-retention-archivierung-roadmap">Retention &amp; Archivierung (Roadmap)<a class="headerlink" href="#compliance_audit-retention-archivierung-roadmap" title="Permanent link">&para;</a></h2>
<h3 id="compliance_audit-retention-manager">Retention Manager<a class="headerlink" href="#compliance_audit-retention-manager" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">RetentionManager mgr(cfg.log_path, policy_engine);

// Archiviere Logs älter als 90 Tage (nach Klassifikation)
mgr.archiveOldLogs(90);

// Lösche nach 7 Jahren (gesetzlich)
mgr.purgeExpiredLogs();
</code></pre>
<h3 id="compliance_audit-signatur-verkettung-chain-of-custody">Signatur-Verkettung (Chain-of-Custody)<a class="headerlink" href="#compliance_audit-signatur-verkettung-chain-of-custody" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// In logEvent:
// Berechne Hash über vorherigem Record + aktuellem Event
auto prev_hash = readLastRecordHash();
auto chain_input = prev_hash + current_event_json;
auto sig = pki_-&gt;signHash(sha256(chain_input));
</code></pre>
<h2 id="compliance_audit-testen">Testen<a class="headerlink" href="#compliance_audit-testen" title="Permanent link">&para;</a></h2>
<pre><code class="language-bash"># AuditLogger Tests
ctest -C Release -R &quot;^AuditLoggerTest\.&quot; --output-on-failure

# Governance + Audit Integration Tests
ctest -C Release -R &quot;^HttpGovernanceTest\.|^AuditLoggerTest\.&quot; --output-on-failure
</code></pre>
<p><strong>Alle Tests bestehen</strong> (19/19):
- AuditLogger-Tests (4/4):
  - <code>EncryptThenSignFlow</code>: Verschlüsselter Log mit Signatur
  - <code>PlaintextSignFlow</code>: Nur signierter Log
  - <code>DisabledLogger</code>: Logging deaktiviert (keine Datei)
  - <code>MultipleEvents</code>: Mehrere Events in JSONL
- Governance-Tests (15/15): Alle Klassifikationen, Resource-Mappings und Policy-Header validiert</p>
<h3 id="compliance_audit-live-test-audit-logs-uberprufen">Live-Test: Audit-Logs überprüfen<a class="headerlink" href="#compliance_audit-live-test-audit-logs-uberprufen" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Server starten
./themis_server

# Content mit VS-NfD klassifizieren
curl -X POST http://localhost:8080/content/import \
  -H &quot;Content-Type: application/json&quot; \
  -H &quot;X-Classification: VS-NfD&quot; \
  -H &quot;X-User-Id: admin&quot; \
  -d '{
    &quot;content&quot;: {
      &quot;id&quot;: &quot;test123&quot;,
      &quot;mime_type&quot;: &quot;text/plain&quot;,
      &quot;category&quot;: &quot;document&quot;
    },
    &quot;blob&quot;: &quot;Sensitive document content&quot;
  }'

# Audit-Log prüfen
cat data/logs/audit.jsonl
</code></pre>
<p>Erwartete Log-Einträge:
1. <strong>Policy Evaluation</strong> (automatisch durch PolicyEngine):
   <code>json
   {
     "ts": 1700000000123,
     "category": "AUDIT",
     "payload": {
       "type": "ciphertext",
       "key_id": "saga_log",
       "key_version": 1,
       "iv_b64": "...",
       "ciphertext_b64": "...",
       "tag_b64": "..."
     },
     "signature": {
       "ok": true,
       "id": "sig_abc123",
       "algorithm": "RSA-SHA256",
       "sig_b64": "...",
       "cert_serial": "DEMO-CERT-SERIAL"
     }
   }</code></p>
<ol>
<li><strong>Content Import</strong> (bei VS-NfD+ Klassifikation):</li>
<li>Ähnliche Struktur mit verschlüsseltem Event-JSON</li>
</ol>
<p>Entschlüsseltes Event-JSON (für Demonstration):</p>
<pre><code class="language-json">{
  &quot;event_type&quot;: &quot;policy_evaluation&quot;,
  &quot;route&quot;: &quot;/content/import&quot;,
  &quot;classification&quot;: &quot;vs-nfd&quot;,
  &quot;mode&quot;: &quot;enforce&quot;,
  &quot;require_content_encryption&quot;: true,
  &quot;encrypt_logs&quot;: true,
  &quot;redaction&quot;: &quot;standard&quot;,
  &quot;retention_days&quot;: 365,
  &quot;timestamp&quot;: 1700000000123,
  &quot;user_id&quot;: &quot;admin&quot;
}
</code></pre>
<h2 id="compliance_audit-nachste-schritte">Nächste Schritte<a class="headerlink" href="#compliance_audit-nachste-schritte" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Echtes PKI-Signing</strong>: OpenSSL RSA-Signaturen über SHA-256-Hash.</li>
<li><strong>PII Detection</strong>: Automatische Erkennung und Markierung von PII-Feldern in Logs.</li>
<li><strong>Retention Manager</strong>: Automatische Archivierung/Löschung basierend auf <code>retention_days</code>.</li>
<li><strong>Governance Integration</strong>: Automatisches Logging bei enforce-Verstößen.</li>
<li><strong>Redaction</strong>: PII-Redaction in Logs für niedrigere Klassifikationen.</li>
<li><strong>Compliance Reports</strong>: Aggregierte Audit-Reports für Compliance-Checks.</li>
</ol>
<h2 id="compliance_audit-referenzen">Referenzen<a class="headerlink" href="#compliance_audit-referenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><code>include/utils/pki_client.h</code></li>
<li><code>src/utils/pki_client.cpp</code></li>
<li><code>include/utils/audit_logger.h</code></li>
<li><code>src/utils/audit_logger.cpp</code></li>
<li><code>tests/test_audit_logger.cpp</code></li>
</ul></section><section class="print-page" id="compliance_governance_strategy" heading-number="12.15"><h1 id="compliance_governance_strategy-compliance-governance-strategie-fur-themisdb">Compliance &amp; Governance-Strategie für ThemisDB<a class="headerlink" href="#compliance_governance_strategy-compliance-governance-strategie-fur-themisdb" title="Permanent link">&para;</a></h1>
<h2 id="compliance_governance_strategy-executive-summary">Executive Summary<a class="headerlink" href="#compliance_governance_strategy-executive-summary" title="Permanent link">&para;</a></h2>
<p><strong>Ziel:</strong> Umfassende Compliance- und Governance-Architektur für ThemisDB mit PKI-signiertem Audit-Trail, DSGVO-by-Design, automatischer PII-Erkennung und konfigurierbaren Governance-Policies.</p>
<p><strong>Kernprinzipien:</strong>
- 📝 <strong>Unveränderlicher Audit-Trail</strong>: SAGA-Log regelmäßig PKI-signiert, Log-Keys sicher gespeichert
- 🔐 <strong>DSGVO by Design</strong>: Automatische PII-Erkennung, UUID-Ersetzung, Original-Blob zugriffsbeschränkt
- ⚖️ <strong>Regulatory Compliance</strong>: GDPR/DSGVO, HIPAA, BSI C5, SOC2 Unterstützung
- 🎯 <strong>Policy-Driven</strong>: Alle Governance-Regeln in YAML/JSON konfigurierbar
- 🔍 <strong>Transparenz</strong>: Vollständige Nachvollziehbarkeit aller Datenoperationen</p>
<hr />
<h2 id="compliance_governance_strategy-1-architektur-ubersicht">1. Architektur-Übersicht<a class="headerlink" href="#compliance_governance_strategy-1-architektur-ubersicht" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-11-compliance-komponenten">1.1 Compliance-Komponenten<a class="headerlink" href="#compliance_governance_strategy-11-compliance-komponenten" title="Permanent link">&para;</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                    ThemisDB Compliance Layer                 │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ SAGA Logger  │  │ PII Detector │  │ Retention    │      │
│  │ + PKI Sign   │  │ + Anonymizer │  │ Manager      │      │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘      │
│         │                  │                  │              │
│         ▼                  ▼                  ▼              │
│  ┌──────────────────────────────────────────────────┐       │
│  │         Governance Policy Engine (GPE)            │       │
│  │   - Policy Validation &amp; Enforcement               │       │
│  │   - Config-Driven Rules (YAML/JSON)              │       │
│  │   - Audit Trail Generation                        │       │
│  └──────────────────────────────────────────────────┘       │
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ VCC-PKI      │  │ VCC-User     │  │ Encryption   │      │
│  │ Integration  │  │ Integration  │  │ Layer        │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="compliance_governance_strategy-12-threat-model-compliance-perspektive">1.2 Threat Model (Compliance-Perspektive)<a class="headerlink" href="#compliance_governance_strategy-12-threat-model-compliance-perspektive" title="Permanent link">&para;</a></h3>
<p><strong>Was wird geschützt:</strong>
- ✅ <strong>Audit-Integrität</strong>: SAGA-Logs unveränderlich durch PKI-Signaturen
- ✅ <strong>PII-Schutz</strong>: Automatische Erkennung und Anonymisierung sensibler Daten
- ✅ <strong>Rechtssicherheit</strong>: Vollständige Nachvollziehbarkeit aller Operationen
- ✅ <strong>Datensouveränität</strong>: On-Premise mit VCC-PKI/User Integration</p>
<p><strong>Compliance-Szenarien:</strong>
1. ✅ <strong>DSGVO Artikel 17 (Recht auf Vergessenwerden)</strong>: PII durch UUID ersetzt, Original-Zugriff widerrufbar
2. ✅ <strong>DSGVO Artikel 30 (Verarbeitungsverzeichnis)</strong>: SAGA-Log als lückenloser Audit-Trail
3. ✅ <strong>DSGVO Artikel 32 (Datensicherheit)</strong>: Verschlüsselung + PKI-Signaturen
4. ✅ <strong>HIPAA Audit Controls</strong>: Strukturierte JSON-Logs mit medizinischen Daten-Tags
5. ✅ <strong>BSI C5 Logging</strong>: Zeitstempel, User-ID, Operation, Result in jedem Log-Entry</p>
<hr />
<h2 id="compliance_governance_strategy-2-saga-log-pki-signierung">2. SAGA-Log PKI-Signierung<a class="headerlink" href="#compliance_governance_strategy-2-saga-log-pki-signierung" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-21-konzept">2.1 Konzept<a class="headerlink" href="#compliance_governance_strategy-21-konzept" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> SAGA-Logs (Transaktions-Kompensationen) müssen manipulationssicher sein für rechtliche Nachweisbarkeit.</p>
<p><strong>Lösung:</strong> Regelmäßige PKI-Signierung von Log-Batches mit VCC-PKI Intermediate CA.</p>
<pre><code class="language-cpp">// Beispiel: SAGA-Log Entry (vor Signierung)
{
  &quot;saga_id&quot;: &quot;tx_20251031_123456_789&quot;,
  &quot;timestamp&quot;: &quot;2025-10-31T14:23:45.123Z&quot;,
  &quot;operation&quot;: &quot;vectorAdd&quot;,
  &quot;entity_pk&quot;: &quot;doc_12345&quot;,
  &quot;user_id&quot;: &quot;user_alice@example.com&quot;,
  &quot;compensated&quot;: false,
  &quot;duration_ms&quot;: 42,
  &quot;status&quot;: &quot;success&quot;
}
</code></pre>
<h3 id="compliance_governance_strategy-22-signierungsprozess">2.2 Signierungsprozess<a class="headerlink" href="#compliance_governance_strategy-22-signierungsprozess" title="Permanent link">&para;</a></h3>
<p><strong>Workflow:</strong>
1. <strong>Batch-Collection</strong>: Alle SAGA-Steps seit letzter Signierung sammeln (z.B. 1000 Einträge oder 5 Minuten)
2. <strong>Canonical JSON</strong>: Sortierte Keys, UTF-8, keine Whitespace → deterministischer Klartext
3. <strong>AES-Verschlüsselung (LEK)</strong>: Klartext-Batch mit täglichem LEK per AES-256-GCM verschlüsseln → Ciphertext + IV + Tag
4. <strong>SHA-256 Hash (über Ciphertext)</strong>: <code>hash = SHA256(ciphertext_batch)</code>  ← Encrypt-then-Hash
5. <strong>PKI-Signierung (Ciphertext-Hash)</strong>: VCC-PKI REST API aufrufen → <code>POST /api/v1/sign</code>
   <code>json
   {
     "service_id": "themis-db",
     "data_hash": "abcdef123456...",
     "signature_type": "RSA-SHA256"
   }</code>
6. <strong>Signatur speichern</strong>: In RocksDB unter <code>saga:signature:&lt;timestamp&gt;</code>
   <code>json
   {
     "batch_id": "batch_20251031_142300",
     "log_entries": 1000,
     "first_saga_id": "tx_...",
     "last_saga_id": "tx_...",
     "hash": "abcdef...",              
     "signature": "MIIBIjANBg...",
     "cert_serial": "03:A5:B2:...",
     "signed_at": "2025-10-31T14:25:00Z",
     "signer": "themis-service-cert",
     "enc": {
       "alg": "AES-256-GCM",
       "lek_id": "lek:20251031",
       "iv": "base64(...)",
       "tag": "base64(...)"
     }
   }</code></p>
<p><strong>Verifizierung (Ciphertext zuerst):</strong></p>
<pre><code class="language-cpp">bool verifySAGABatch(const std::string&amp; batch_id) {
    // 1. Lade Signatur-Metadata
    auto sig_data = db_.get(&quot;saga:signature:&quot; + batch_id);

    // 2. Lade gespeicherten Ciphertext-Batch (ohne Entschlüsselung)
    std::string ciphertext = loadEncryptedBatch(sig_data[&quot;batch_id&quot;]);

    // 3. Hash über Ciphertext bilden
    std::string hash = sha256(ciphertext);

    // 4. VCC-PKI Signature Verify (Ciphertext-Hash)
    return vcc_pki_client_-&gt;verify(
        hash, 
        sig_data[&quot;signature&quot;], 
        sig_data[&quot;cert_serial&quot;]
    );
}
</code></pre>
<h3 id="compliance_governance_strategy-23-log-key-management">2.3 Log-Key Management<a class="headerlink" href="#compliance_governance_strategy-23-log-key-management" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Log-Einträge können sensitive Daten enthalten (vor Anonymisierung) → Verschlüsselung erforderlich.</p>
<p><strong>Lösung:</strong> Separater Log-Encryption-Key (LEK) pro Zeitperiode (z.B. täglich).</p>
<pre><code class="language-yaml"># config/governance.yaml
saga_log:
  signature:
    enabled: true
    batch_size: 1000
    batch_interval_minutes: 5
    algorithm: &quot;RSA-SHA256&quot;
    pki_service: &quot;https://localhost:8443/api/v1&quot;

  encryption:
    enabled: true
    key_rotation: &quot;daily&quot;  # daily, weekly, monthly
    algorithm: &quot;AES-256-GCM&quot;
    key_storage: &quot;rocksdb&quot;  # Key encrypted with KEK from PKI

  retention:
    keep_signed_logs_days: 2555  # 7 Jahre (DSGVO Artikel 17)
    archive_to_cold_storage: true
    cold_storage_path: &quot;/mnt/archive/saga_logs&quot;
</code></pre>
<p><strong>LEK-Ablauf:</strong>
1. <strong>Tägliche KEK-Ableitung</strong>: VCC-PKI Service-Zertifikat → HKDF → KEK(date)
2. <strong>LEK-Generierung</strong>: Zufällige 256-bit AES-Key → LEK(date)
3. <strong>LEK-Speicherung</strong>: <code>lek:20251031 = AES-GCM-Encrypt(KEK, LEK)</code> in RocksDB
4. <strong>Log-Verschlüsselung</strong>: Jeder SAGA-Entry → <code>AES-GCM-Encrypt(LEK, canonical_json)</code>
5. <strong>Dekodierung</strong>: Bei Audit-Anfrage → Lade LEK → Entschlüssele Logs</p>
<p><strong>Vorteil:</strong> Bei Daten-Leak nur aktuelle LEK kompromittiert, nicht gesamte Historie.</p>
<hr />
<h2 id="compliance_governance_strategy-3-dsgvo-by-design-pii-erkennung-anonymisierung">3. DSGVO by Design: PII-Erkennung &amp; Anonymisierung<a class="headerlink" href="#compliance_governance_strategy-3-dsgvo-by-design-pii-erkennung-anonymisierung" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-31-konzept">3.1 Konzept<a class="headerlink" href="#compliance_governance_strategy-31-konzept" title="Permanent link">&para;</a></h3>
<p><strong>DSGVO Artikel 25 (Data Protection by Design):</strong>
- Sensitive PII automatisch erkennen
- Original-Entität durch UUID ersetzen (Pseudonymisierung)
- Original-Blob bleibt verschlüsselt, Zugriff nur mit User-Berechtigung
- Löschung: UUID-Mapping löschen → Original unwiederbringlich</p>
<h3 id="compliance_governance_strategy-32-pii-detection-engine">3.2 PII-Detection Engine<a class="headerlink" href="#compliance_governance_strategy-32-pii-detection-engine" title="Permanent link">&para;</a></h3>
<p><strong>Multi-Strategy-Ansatz:</strong></p>
<pre><code class="language-cpp">class PIIDetector {
public:
    enum class PIIType {
        EMAIL,           // RFC 5322 Email-Regex
        PHONE,           // E.164 + lokale Formate
        SSN,             // Social Security Number (US, DE, etc.)
        IBAN,            // International Bank Account Number
        CREDIT_CARD,     // Luhn-Algorithm Validation
        PASSPORT,        // Country-specific patterns
        IP_ADDRESS,      // IPv4/IPv6
        MEDICAL_ID,      // Krankenversicherungsnummer
        TAX_ID,          // Steuernummer, UID
        CUSTOM           // User-defined regex
    };

    struct PIIMatch {
        PIIType type;
        std::string field_path;  // e.g., &quot;user.profile.email&quot;
        std::string original_value;
        std::string anonymized_value;  // UUID
        size_t offset;
        size_t length;
    };

    std::vector&lt;PIIMatch&gt; detectPII(
        const json&amp; entity_data,
        const PIIConfig&amp; config
    );
};
</code></pre>
<p><strong>Detection-Strategien:</strong></p>
<ol>
<li><strong>Regex-Based Detection</strong> (schnell, hohe Präzision):
   ```cpp
   const std::regex EMAIL_REGEX(
       R"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}\b)"
   );</li>
</ol>
<p>const std::regex IBAN_REGEX(
       R"([A-Z]{2}\d{2}[A-Z0-9]{10,30})"
   );
   ```</p>
<ol>
<li><strong>NER (Named Entity Recognition)</strong> (Machine Learning, optional):</li>
<li>Integration mit lokalen NER-Modellen (z.B. spaCy, Flair)</li>
<li>
<p>Erkennung von Namen, Adressen, Organisationen in Freitext</p>
</li>
<li>
<p><strong>Schema-Based Detection</strong> (Metadaten):
   ```yaml
   # config/pii_schema.yaml
   field_annotations:</p>
<ul>
<li>field: "email"
   type: EMAIL
   auto_anonymize: true</li>
<li>field: "phone_number"
   type: PHONE
   auto_anonymize: true</li>
<li>field: "medical_records.patient_id"
   type: MEDICAL_ID
   auto_anonymize: true
   retention_days: 3650  # 10 Jahre HIPAA
   ```</li>
</ul>
</li>
</ol>
<h3 id="compliance_governance_strategy-33-anonymisierung-workflow">3.3 Anonymisierung-Workflow<a class="headerlink" href="#compliance_governance_strategy-33-anonymisierung-workflow" title="Permanent link">&para;</a></h3>
<p><strong>Beispiel: Graph-Entity mit PII</strong></p>
<pre><code class="language-cpp">// Original-Entity (vor Import)
{
  &quot;pk&quot;: &quot;patient_001&quot;,
  &quot;name&quot;: &quot;Max Mustermann&quot;,
  &quot;email&quot;: &quot;max.mustermann@example.com&quot;,
  &quot;ssn&quot;: &quot;123-45-6789&quot;,
  &quot;diagnosis&quot;: &quot;...&quot;
}

// Nach PII-Detection &amp; Anonymisierung
{
  &quot;pk&quot;: &quot;patient_001&quot;,
  &quot;name&quot;: &quot;pii_uuid_7a3f2e1b-4c5d-6a7b-8c9d-0e1f2a3b4c5d&quot;,
  &quot;email&quot;: &quot;pii_uuid_9f8e7d6c-5b4a-3c2d-1e0f-a9b8c7d6e5f4&quot;,
  &quot;ssn&quot;: &quot;pii_uuid_3e2d1c0b-a9f8-e7d6-c5b4-a3f2e1d0c9b8&quot;,
  &quot;diagnosis&quot;: &quot;...&quot;
}

// PII-Mapping in separater CF (RocksDB Column Family)
Key: pii_uuid_7a3f2e1b-4c5d-6a7b-8c9d-0e1f2a3b4c5d
Value: {
  &quot;original_value&quot;: &quot;Max Mustermann&quot;,  // AES-256-GCM encrypted
  &quot;field&quot;: &quot;name&quot;,
  &quot;entity_pk&quot;: &quot;patient_001&quot;,
  &quot;pii_type&quot;: &quot;PERSON_NAME&quot;,
  &quot;detected_at&quot;: &quot;2025-10-31T14:30:00Z&quot;,
  &quot;detected_by&quot;: &quot;regex_ner&quot;,
  &quot;retention_policy&quot;: &quot;gdpr_erasure&quot;,
  &quot;access_control&quot;: {
    &quot;allowed_roles&quot;: [&quot;doctor&quot;, &quot;admin&quot;],
    &quot;audit_access&quot;: true
  }
}
</code></pre>
<p><strong>Zugriff auf Original:</strong></p>
<pre><code class="language-cpp">std::string revealPII(
    const std::string&amp; pii_uuid,
    const UserContext&amp; user
) {
    // 1. Lade PII-Mapping
    auto pii_data = db_.get(&quot;pii:&quot; + pii_uuid);

    // 2. ACL-Check
    if (!checkAccess(pii_data[&quot;access_control&quot;], user)) {
        THEMIS_AUDIT_LOG(&quot;PII_ACCESS_DENIED&quot;, {
            {&quot;pii_uuid&quot;, pii_uuid},
            {&quot;user_id&quot;, user.id},
            {&quot;timestamp&quot;, now()}
        });
        throw AuthorizationException(&quot;Access to PII denied&quot;);
    }

    // 3. Audit-Log
    THEMIS_AUDIT_LOG(&quot;PII_ACCESS_GRANTED&quot;, {
        {&quot;pii_uuid&quot;, pii_uuid},
        {&quot;user_id&quot;, user.id},
        {&quot;field&quot;, pii_data[&quot;field&quot;]},
        {&quot;entity_pk&quot;, pii_data[&quot;entity_pk&quot;]}
    });

    // 4. Entschlüsseln &amp; Zurückgeben
    std::string encrypted = pii_data[&quot;original_value&quot;];
    return decryptField(encrypted, user.field_key);
}
</code></pre>
<p><strong>Recht auf Vergessenwerden (DSGVO Artikel 17):</strong></p>
<pre><code class="language-cpp">void erasePII(const std::string&amp; entity_pk) {
    // 1. Finde alle PII-UUIDs für Entity
    auto pii_uuids = findPIIForEntity(entity_pk);

    // 2. Lösche PII-Mappings (Original unwiederbringlich)
    for (const auto&amp; uuid : pii_uuids) {
        db_.delete(&quot;pii:&quot; + uuid);

        THEMIS_AUDIT_LOG(&quot;PII_ERASED&quot;, {
            {&quot;pii_uuid&quot;, uuid},
            {&quot;entity_pk&quot;, entity_pk},
            {&quot;timestamp&quot;, now()},
            {&quot;reason&quot;, &quot;gdpr_article_17&quot;}
        });
    }

    // 3. Entity bleibt mit UUIDs (Pseudonymisiert, aber nutzbar für Statistik)
}
</code></pre>
<hr />
<h2 id="compliance_governance_strategy-4-audit-trail-structured-logging">4. Audit-Trail &amp; Structured Logging<a class="headerlink" href="#compliance_governance_strategy-4-audit-trail-structured-logging" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-41-log-kategorien">4.1 Log-Kategorien<a class="headerlink" href="#compliance_governance_strategy-41-log-kategorien" title="Permanent link">&para;</a></h3>
<p>ThemisDB unterscheidet mehrere Log-Typen:</p>
<table>
<thead>
<tr>
<th>Kategorie</th>
<th>Zweck</th>
<th>Signiert</th>
<th>Verschlüsselt</th>
<th>Retention</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SAGA</strong></td>
<td>Transaktions-Kompensationen</td>
<td>✅ Ja</td>
<td>✅ Ja</td>
<td>7 Jahre</td>
</tr>
<tr>
<td><strong>AUDIT</strong></td>
<td>Datenzugriffe, ACL-Prüfungen</td>
<td>✅ Ja</td>
<td>✅ Ja (Encrypt-then-Sign bei Query-Daten)</td>
<td>7 Jahre</td>
</tr>
<tr>
<td><strong>SECURITY</strong></td>
<td>Auth-Failures, Anomalien</td>
<td>✅ Ja</td>
<td>❌ Nein</td>
<td>10 Jahre</td>
</tr>
<tr>
<td><strong>OPERATIONAL</strong></td>
<td>Performance, Errors</td>
<td>❌ Nein</td>
<td>❌ Nein</td>
<td>90 Tage</td>
</tr>
<tr>
<td><strong>DEBUG</strong></td>
<td>Entwickler-Traces</td>
<td>❌ Nein</td>
<td>❌ Nein</td>
<td>7 Tage</td>
</tr>
<tr>
<td>### 4.4 Vertraulichkeitswahrende Signierung (Encrypt-then-Sign)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Für alle Log-Kategorien, die Query-Daten, Query-Parameter, Result-Samples oder PII enthalten können (insb. AUDIT, SAGA), gilt:</p>
<ul>
<li>Erst wird der Log-Eintrag als Canonical JSON serialisiert</li>
<li>Dann wird der Klartext mit dem tagesaktuellen LEK via AES-256-GCM verschlüsselt</li>
<li>Der Hash für die PKI-Signatur wird über den Ciphertext gebildet (nicht über den Klartext)</li>
<li>Signatur und AES-Metadaten (iv, tag, lek_id, optional aad) werden gemeinsam persistiert</li>
<li>Eine redaktierte, nicht sensible Kurzform wird optional in stdout/file geloggt</li>
</ul>
<p>Diese Reihenfolge verhindert, dass sensible Daten in Signaturvorlagen, SIEM-Pipelines oder Transportebenen im Klartext erscheinen.</p>
<h3 id="compliance_governance_strategy-42-structured-json-logging">4.2 Structured JSON-Logging<a class="headerlink" href="#compliance_governance_strategy-42-structured-json-logging" title="Permanent link">&para;</a></h3>
<p><strong>Standard-Schema:</strong></p>
<pre><code class="language-json">{
  &quot;log_id&quot;: &quot;uuid_v7&quot;,
  &quot;timestamp&quot;: &quot;2025-10-31T14:45:32.123Z&quot;,
  &quot;category&quot;: &quot;AUDIT&quot;,
  &quot;severity&quot;: &quot;INFO&quot;,
  &quot;service&quot;: &quot;themis-server&quot;,
  &quot;host&quot;: &quot;themis-prod-01&quot;,
  &quot;user&quot;: {
    &quot;id&quot;: &quot;user_alice@example.com&quot;,
    &quot;role&quot;: &quot;analyst&quot;,
    &quot;ip&quot;: &quot;192.168.1.42&quot;,
    &quot;session_id&quot;: &quot;jwt_...&quot;
  },
  &quot;operation&quot;: {
    &quot;type&quot;: &quot;query&quot;,
    &quot;resource&quot;: &quot;graph:patients&quot;,
    &quot;action&quot;: &quot;read&quot;,
    &quot;query_aql&quot;: &quot;FOR p IN patients FILTER p.age &gt; 50 RETURN p&quot;,
    &quot;result_count&quot;: 42,
    &quot;duration_ms&quot;: 156
  },
  &quot;compliance&quot;: {
    &quot;pii_accessed&quot;: [&quot;email&quot;, &quot;ssn&quot;],
    &quot;purpose&quot;: &quot;medical_research&quot;,
    &quot;legal_basis&quot;: &quot;gdpr_article_6_1_e&quot;
  },
  &quot;metadata&quot;: {
    &quot;saga_id&quot;: &quot;tx_...&quot;,
    &quot;trace_id&quot;: &quot;otel_...&quot;,
    &quot;correlation_id&quot;: &quot;req_...&quot;
  }
}
</code></pre>
<p><strong>Log-Sink Integration:</strong></p>
<pre><code class="language-cpp">// include/utils/audit_logger.h
class AuditLogger {
public:
    static void logDataAccess(
        const UserContext&amp; user,
        const std::string&amp; resource,
        const std::string&amp; action,
        const std::vector&lt;std::string&gt;&amp; pii_fields,
        int64_t duration_ms
    );

    static void logSecurityEvent(
        const std::string&amp; event_type,
        const json&amp; details
    );

    static void logSAGAStep(
        const Saga::Step&amp; step,
        const std::string&amp; saga_id
    );
};
</code></pre>
<p><strong>spdlog Integration (Encrypt-then-Sign):</strong></p>
<pre><code class="language-cpp">// src/utils/audit_logger.cpp
void AuditLogger::logDataAccess(...) {
  json log_entry = {
        {&quot;log_id&quot;, generate_uuid_v7()},
        {&quot;timestamp&quot;, iso8601_now()},
        {&quot;category&quot;, &quot;AUDIT&quot;},
        {&quot;user&quot;, {
            {&quot;id&quot;, user.id},
            {&quot;role&quot;, user.role},
            {&quot;ip&quot;, user.ip_address}
        }},
        {&quot;operation&quot;, {
            {&quot;resource&quot;, resource},
            {&quot;action&quot;, action},
            {&quot;duration_ms&quot;, duration_ms}
        }},
        {&quot;compliance&quot;, {
            {&quot;pii_accessed&quot;, pii_fields}
        }}
    };

  // 1) Canonical JSON
  std::string canonical = toCanonicalJSON(log_entry);

  // 2) Encrypt with LEK (AES-256-GCM) if category contains query data
  if (governance_-&gt;shouldEncryptLogs(&quot;AUDIT&quot;)) {
    AAD aad{ {&quot;log_id&quot;, log_entry[&quot;log_id&quot;]}, {&quot;category&quot;, &quot;AUDIT&quot;}, {&quot;timestamp&quot;, log_entry[&quot;timestamp&quot;]} };
    auto enc = aes_gcm_encrypt(lek_manager_.current(), canonical, aad);

    // 3) Hash ciphertext and queue for signing (Encrypt-then-Sign)
    auto hash = sha256(enc.ciphertext);
    queueForSigning(hash, enc.meta); // enc.meta carries iv, tag, lek_id, aad

    // 4) Persist encrypted envelope for audit storage
    persistEncryptedAudit(enc, log_entry[&quot;log_id&quot;]);

    // 5) Emit redacted line to console/file sinks only
    auto logger = spdlog::get(&quot;audit&quot;);
    logger-&gt;info(&quot;{{\&quot;log_id\&quot;:\&quot;{}\&quot;,\&quot;category\&quot;:\&quot;AUDIT\&quot;,\&quot;encrypted\&quot;:true}}&quot;, (std::string)log_entry[&quot;log_id&quot;]);
  } else {
    // Non-sensitive: plain JSON to sinks and to signing queue (still encrypted if policy enforces)
    auto logger = spdlog::get(&quot;audit&quot;);
    logger-&gt;info(canonical);
    addToPendingSAGABatch(log_entry);
  }
}
</code></pre>
<h3 id="compliance_governance_strategy-43-siem-integration">4.3 SIEM-Integration<a class="headerlink" href="#compliance_governance_strategy-43-siem-integration" title="Permanent link">&para;</a></h3>
<p><strong>Export zu externen SIEM-Systemen:</strong></p>
<pre><code class="language-yaml"># config/governance.yaml
audit_export:
  enabled: true
  destinations:
    - type: syslog
      host: &quot;siem.internal.vcc&quot;
      port: 514
      protocol: &quot;TCP&quot;
      tls: true
      categories: [&quot;AUDIT&quot;, &quot;SECURITY&quot;]
      encryption:
        encrypt_payloads: true
        sign_ciphertext: true
        redact_console_output: true

    - type: elasticsearch
      url: &quot;https://elastic.internal.vcc:9200&quot;
      index: &quot;themis-audit-{date}&quot;
      auth_type: &quot;api_key&quot;
      api_key_env: &quot;ELASTIC_API_KEY&quot;
      encryption:
        encrypt_payloads: true
        sign_ciphertext: true

    - type: file
      path: &quot;/var/log/themis/audit_{date}.json.gz&quot;
      rotation: &quot;daily&quot;
      compression: true
      max_size_mb: 500
      encryption:
        encrypt_payloads: true
        sign_ciphertext: true
</code></pre>
<hr />
<h2 id="compliance_governance_strategy-5-governance-policy-engine-gpe">5. Governance Policy Engine (GPE)<a class="headerlink" href="#compliance_governance_strategy-5-governance-policy-engine-gpe" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-51-policy-definition-yaml">5.1 Policy-Definition (YAML)<a class="headerlink" href="#compliance_governance_strategy-51-policy-definition-yaml" title="Permanent link">&para;</a></h3>
<p><strong>Zentrale Governance-Konfiguration:</strong></p>
<pre><code class="language-yaml"># config/governance_policies.yaml
governance:
  version: &quot;1.0&quot;
  effective_date: &quot;2025-11-01&quot;

  # ========== DATA CLASSIFICATION ==========
  data_classification:
    levels:
      - name: &quot;public&quot;
        encryption_required: false
        pii_detection: false
        retention_days: 365

      - name: &quot;internal&quot;
        encryption_required: true
        pii_detection: true
        retention_days: 2555  # 7 Jahre
        access_control: &quot;role_based&quot;

      - name: &quot;confidential&quot;
        encryption_required: true
        pii_detection: true
        retention_days: 3650  # 10 Jahre
        access_control: &quot;attribute_based&quot;
        audit_all_access: true

      - name: &quot;restricted&quot;
        encryption_required: true
        encryption_algorithm: &quot;AES-256-GCM&quot;
        pii_detection: true
        pii_auto_anonymize: true
        retention_days: 3650
        access_control: &quot;multi_factor&quot;
        audit_all_access: true
        require_approval: true

  # ========== PII DETECTION RULES ==========
  pii_detection:
    enabled: true
    strategies:
      - type: &quot;regex&quot;
        patterns:
          email: '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
          phone_de: '\+49\s?\d{2,5}\s?\d{3,10}'
          iban: '[A-Z]{2}\d{2}[A-Z0-9]{10,30}'
          ssn_us: '\d{3}-\d{2}-\d{4}'

      - type: &quot;schema_annotation&quot;
        fields:
          - path: &quot;*.email&quot;
            type: EMAIL
          - path: &quot;patient.medical_id&quot;
            type: MEDICAL_ID
          - path: &quot;user.ssn&quot;
            type: SSN

    anonymization:
      method: &quot;uuid_replacement&quot;
      uuid_prefix: &quot;pii_uuid_&quot;
      store_mapping: true
      mapping_encryption: true

    access_control:
      default_deny: true
      allowed_roles:
        - &quot;gdpr_officer&quot;
        - &quot;compliance_admin&quot;
      audit_all_reveals: true

  # ========== RETENTION POLICIES ==========
  retention:
    default_days: 2555  # 7 Jahre DSGVO

    overrides:
      - resource_pattern: &quot;medical_records.*&quot;
        retention_days: 3650  # 10 Jahre HIPAA
        legal_basis: &quot;HIPAA_164_316&quot;

      - resource_pattern: &quot;financial.*&quot;
        retention_days: 3650  # 10 Jahre HGB
        legal_basis: &quot;HGB_257&quot;

      - resource_pattern: &quot;debug_logs.*&quot;
        retention_days: 7
        auto_purge: true

    archive:
      enabled: true
      after_days: 365
      storage: &quot;cold_storage&quot;
      compression: &quot;zstd&quot;
      encryption: true

  # ========== SAGA LOG SIGNING ==========
  saga_signing:
    enabled: true
    batch_size: 1000
    batch_interval_minutes: 5
    signature_algorithm: &quot;RSA-SHA256&quot;
    pki_endpoint: &quot;https://localhost:8443/api/v1/sign&quot;
    cert_service_id: &quot;themis-db&quot;
    encrypt_then_sign: true   # Erzwingt: erst AES-256-GCM verschlüsseln, dann Ciphertext hash/sign
    categories:
      encrypt_before_sign: [&quot;SAGA&quot;, &quot;AUDIT&quot;]

    verification:
      on_query: true  # Bei Audit-Anfragen automatisch verifizieren
      periodic_check: true
      check_interval_hours: 24

  # ========== COMPLIANCE FRAMEWORKS ==========
  compliance_frameworks:
    gdpr:
      enabled: true
      data_protection_officer: &quot;dpo@example.com&quot;
      article_30_register: &quot;/var/themis/gdpr_register.json&quot;
      breach_notification_hours: 72

    hipaa:
      enabled: true
      covered_entity: true
      business_associate: false
      security_officer: &quot;ciso@example.com&quot;

    bsi_c5:
      enabled: true
      attestation_level: &quot;Type 2&quot;
      audit_frequency_months: 12

    soc2:
      enabled: false

  # ========== DE (VS) KLASSIFIZIERUNG ==========
  vs_classification:
    levels:
      - name: &quot;offen&quot;
        encryption_profile:
          required: false
          algorithm: &quot;AES-256-GCM&quot;
          double_encrypt: false
          hsm_only: false
        logs:
          encrypt_then_sign: false
          redact: false
        vector_policy: &quot;allow&quot;
        export_policy: &quot;allow&quot;
        cache_policy: { persistent: true, ttl_seconds: 86400 }

      - name: &quot;vs-nfd&quot;
        encryption_profile:
          required: true
          algorithm: &quot;AES-256-GCM&quot;
          double_encrypt: false
          hsm_only: false
        logs:
          encrypt_then_sign: true
          lek_rotation: &quot;daily&quot;
          redact: true
        vector_policy: &quot;allow_metadata_only&quot;
        export_policy: &quot;allow_with_approval&quot;
        cache_policy: { persistent: false, ttl_seconds: 3600 }

      - name: &quot;geheim&quot;
        encryption_profile:
          required: true
          algorithm: &quot;AES-256-GCM&quot;
          double_encrypt: true
          hsm_only: true
        logs:
          encrypt_then_sign: true
          lek_rotation: &quot;daily&quot;
          redact: &quot;strict&quot;
        vector_policy: &quot;restricted&quot;   # keine Klartext-Embeddings-Exporte
        export_policy: &quot;approval_only&quot;
        cache_policy: { persistent: false, ttl_seconds: 0 }

      - name: &quot;streng-geheim&quot;
        encryption_profile:
          required: true
          algorithm: &quot;AES-256-GCM&quot;
          double_encrypt: true
          hsm_only: true
        logs:
          encrypt_then_sign: true
          lek_rotation: &quot;daily&quot;
          redact: &quot;strict&quot;
          minimal_plain_meta: [&quot;log_id&quot;, &quot;category&quot;, &quot;timestamp&quot;]
        vector_policy: &quot;disable_ann&quot;
        export_policy: &quot;forbidden&quot;
        cache_policy: { persistent: false, ttl_seconds: 0 }

  enforcement:
    default_classification: &quot;vs-nfd&quot;
    map_resources:
      - resource_pattern: &quot;patients.*&quot;
        classification: &quot;geheim&quot;
      - resource_pattern: &quot;intelligence.*&quot;
        classification: &quot;streng-geheim&quot;
      - resource_pattern: &quot;public_docs.*&quot;
        classification: &quot;offen&quot;
    endpoint_switches:
      headers:
        classification: &quot;X-Classification&quot;   # offen|vs-nfd|geheim|streng-geheim
        governance_mode: &quot;X-Governance-Mode&quot; # enforce|simulate
        encrypt_logs: &quot;X-Encrypt-Logs&quot;       # on|off|auto
        redaction_level: &quot;X-Redaction-Level&quot; # none|standard|strict
      response_headers:
        policy: &quot;X-Themis-Policy&quot;
        integrity: &quot;X-Themis-Integrity&quot;
</code></pre>
<h3 id="compliance_governance_strategy-52-policy-validation-enforcement">5.2 Policy Validation &amp; Enforcement<a class="headerlink" href="#compliance_governance_strategy-52-policy-validation-enforcement" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// include/governance/policy_engine.h
class GovernancePolicyEngine {
public:
    explicit GovernancePolicyEngine(const std::string&amp; config_path);

    // Policy-Validierung
    bool validateOperation(
        const UserContext&amp; user,
        const std::string&amp; resource,
        const std::string&amp; action
    );

    // Data Classification
    std::string getClassificationLevel(const std::string&amp; resource);

    // Retention
    int getRetentionDays(const std::string&amp; resource);
    bool shouldArchive(const std::string&amp; resource, int age_days);
    bool shouldPurge(const std::string&amp; resource, int age_days);

    // PII
    bool shouldDetectPII(const std::string&amp; resource);
    bool shouldAutoAnonymize(const std::string&amp; resource);
    std::vector&lt;std::string&gt; getAllowedPIIRoles();

    // Audit
    bool shouldAuditAccess(const std::string&amp; resource);
    std::vector&lt;std::string&gt; getComplianceFrameworks();

  // VS-Classification helpers
  std::string resolveClassification(const std::string&amp; resource, const std::optional&lt;std::string&gt;&amp; header_cls);
  EncryptionProfile getEncryptionProfile(const std::string&amp; classification);
  LogRules getLogRules(const std::string&amp; classification);
  VectorPolicy getVectorPolicy(const std::string&amp; classification);
  bool isExportAllowed(const std::string&amp; classification, bool hasApproval);

private:
    json config_;
    std::unordered_map&lt;std::string, json&gt; classification_cache_;
};
</code></pre>
<p>Endpoint-Durchsetzung (Skizze):</p>
<pre><code class="language-cpp">auto hdr_cls = req.header(&quot;X-Classification&quot;);
auto cls = gpe.resolveClassification(resource, hdr_cls);
auto enc = gpe.getEncryptionProfile(cls);
auto logs = gpe.getLogRules(cls);
auto vecp = gpe.getVectorPolicy(cls);

if (vecp == VectorPolicy::DISABLE_ANN) {
  return Status::PermissionDenied(&quot;ANN disabled for classification: &quot; + cls);
}

applyEncryptionProfile(entity, enc, user);
auditLogger.logWithRules(user, resource, action, logs);
</code></pre>
<p><strong>Verwendung im Query-Engine:</strong></p>
<pre><code class="language-cpp">// src/query/query_executor.cpp
Status QueryExecutor::executeQuery(
    const AQLQuery&amp; query,
    const UserContext&amp; user,
    QueryResult&amp; result
) {
    auto start = std::chrono::steady_clock::now();

    // 1. Policy-Check
    for (const auto&amp; collection : query.collections) {
        if (!gpe_-&gt;validateOperation(user, collection, &quot;read&quot;)) {
            THEMIS_AUDIT_LOG(&quot;QUERY_DENIED&quot;, {
                {&quot;user&quot;, user.id},
                {&quot;collection&quot;, collection},
                {&quot;reason&quot;, &quot;policy_violation&quot;}
            });
            return Status::PermissionDenied(&quot;Access to &quot; + collection + &quot; denied&quot;);
        }
    }

    // 2. PII-Detection aktivieren?
    bool detect_pii = gpe_-&gt;shouldDetectPII(query.collections[0]);

    // 3. Query ausführen
    auto status = executor_-&gt;execute(query, result);

    // 4. PII-Anonymisierung (wenn konfiguriert)
    if (detect_pii &amp;&amp; gpe_-&gt;shouldAutoAnonymize(query.collections[0])) {
        anonymizePIIInResult(result, user);
    }

    // 5. Audit-Log
    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
        std::chrono::steady_clock::now() - start
    );

    if (gpe_-&gt;shouldAuditAccess(query.collections[0])) {
        AuditLogger::logDataAccess(
            user,
            query.collections[0],
            &quot;query&quot;,
            extractPIIFields(result),
            duration.count()
        );
    }

    return status;
}
</code></pre>
<hr />
<h2 id="compliance_governance_strategy-6-data-retention-archival">6. Data Retention &amp; Archival<a class="headerlink" href="#compliance_governance_strategy-6-data-retention-archival" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-61-retention-manager">6.1 Retention Manager<a class="headerlink" href="#compliance_governance_strategy-61-retention-manager" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// include/governance/retention_manager.h
class RetentionManager {
public:
    struct RetentionPolicy {
        std::string resource_pattern;  // Regex: &quot;medical_records.*&quot;
        int retention_days;
        bool auto_archive;
        int archive_after_days;
        bool auto_purge;
        std::string legal_basis;
    };

    explicit RetentionManager(
        RocksDBWrapper&amp; db,
        const GovernancePolicyEngine&amp; gpe
    );

    // Background-Task (täglich ausgeführt)
    void runRetentionSweep();

    // Manuelle Operationen
    std::vector&lt;std::string&gt; findExpiredEntities(const std::string&amp; collection);
    void archiveEntity(const std::string&amp; pk);
    void purgeEntity(const std::string&amp; pk);

private:
    RocksDBWrapper&amp; db_;
    const GovernancePolicyEngine&amp; gpe_;
};
</code></pre>
<p><strong>Workflow:</strong></p>
<pre><code class="language-cpp">void RetentionManager::runRetentionSweep() {
    THEMIS_INFO(&quot;Starting retention sweep&quot;);

    // Alle Collections durchlaufen
    for (const auto&amp; collection : getAllCollections()) {
        auto policy = gpe_.getRetentionPolicy(collection);

        // Finde alte Entities (via created_at/modified_at)
        auto expired = findExpiredEntities(collection);

        for (const auto&amp; pk : expired) {
            auto age_days = getEntityAgeDays(pk);

            // Archivierung?
            if (policy.auto_archive &amp;&amp; age_days &gt;= policy.archive_after_days) {
                archiveEntity(pk);
                THEMIS_AUDIT_LOG(&quot;ENTITY_ARCHIVED&quot;, {
                    {&quot;pk&quot;, pk},
                    {&quot;collection&quot;, collection},
                    {&quot;age_days&quot;, age_days},
                    {&quot;legal_basis&quot;, policy.legal_basis}
                });
            }

            // Löschung?
            if (policy.auto_purge &amp;&amp; age_days &gt;= policy.retention_days) {
                purgeEntity(pk);
                THEMIS_AUDIT_LOG(&quot;ENTITY_PURGED&quot;, {
                    {&quot;pk&quot;, pk},
                    {&quot;collection&quot;, collection},
                    {&quot;age_days&quot;, age_days},
                    {&quot;legal_basis&quot;, policy.legal_basis}
                });
            }
        }
    }

    THEMIS_INFO(&quot;Retention sweep completed&quot;);
}
</code></pre>
<h3 id="compliance_governance_strategy-62-cold-storage-export">6.2 Cold Storage Export<a class="headerlink" href="#compliance_governance_strategy-62-cold-storage-export" title="Permanent link">&para;</a></h3>
<p><strong>Archivierung zu externem Storage:</strong></p>
<pre><code class="language-cpp">void RetentionManager::archiveEntity(const std::string&amp; pk) {
    // 1. Lade vollständige Entity-Daten
    auto entity = loadFullEntity(pk);  // Mit Graph-Kanten, Content-Blobs, etc.

    // 2. Serialize als JSON
    json archive_entry = {
        {&quot;pk&quot;, pk},
        {&quot;archived_at&quot;, iso8601_now()},
        {&quot;original_data&quot;, entity},
        {&quot;metadata&quot;, {
            {&quot;collection&quot;, entity[&quot;_collection&quot;]},
            {&quot;created_at&quot;, entity[&quot;created_at&quot;]},
            {&quot;data_classification&quot;, gpe_.getClassificationLevel(pk)}
        }}
    };

    // 3. Kompression (ZSTD)
    auto json_str = archive_entry.dump();
    auto compressed = zstd_compress(json_str.data(), json_str.size(), 19);

    // 4. Verschlüsselung (optional, je nach Policy)
    auto encrypted = encryptArchive(compressed);

    // 5. Export zu Cold Storage
    std::string archive_path = config_[&quot;cold_storage_path&quot;].get&lt;std::string&gt;() 
                             + &quot;/&quot; + getCurrentDatePath() 
                             + &quot;/&quot; + pk + &quot;.zst.enc&quot;;
    writeToFile(archive_path, encrypted);

    // 6. Markiere in DB als archived (nicht löschen, nur Flag)
    db_.put(pk + &quot;:metadata&quot;, json{{&quot;archived&quot;, true}, {&quot;archive_path&quot;, archive_path}}.dump());
}
</code></pre>
<hr />
<h2 id="compliance_governance_strategy-7-compliance-reports">7. Compliance-Reports<a class="headerlink" href="#compliance_governance_strategy-7-compliance-reports" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-71-dsgvo-artikel-30-verarbeitungsverzeichnis">7.1 DSGVO Artikel 30: Verarbeitungsverzeichnis<a class="headerlink" href="#compliance_governance_strategy-71-dsgvo-artikel-30-verarbeitungsverzeichnis" title="Permanent link">&para;</a></h3>
<p><strong>Automatische Generierung:</strong></p>
<pre><code class="language-cpp">json generateGDPRArticle30Register() {
    json reg = {
        {&quot;controller&quot;, {
            {&quot;name&quot;, &quot;VCC GmbH&quot;},
            {&quot;contact&quot;, &quot;dpo@example.com&quot;},
            {&quot;address&quot;, &quot;Musterstraße 1, 12345 Berlin&quot;}
        }},
        {&quot;processing_activities&quot;, json::array()}
    };

    // Alle Collections analysieren
    for (const auto&amp; collection : getAllCollections()) {
        auto classification = gpe_.getClassificationLevel(collection);
        auto retention = gpe_.getRetentionDays(collection);

        json activity = {
            {&quot;purpose&quot;, collection + &quot; data processing&quot;},
            {&quot;legal_basis&quot;, &quot;GDPR Article 6(1)(e)&quot;},  // Public interest
            {&quot;data_categories&quot;, getDataCategories(collection)},
            {&quot;recipients&quot;, &quot;Internal staff only&quot;},
            {&quot;retention_period&quot;, std::to_string(retention) + &quot; days&quot;},
            {&quot;security_measures&quot;, {
                &quot;AES-256-GCM encryption&quot;,
                &quot;PKI-signed audit logs&quot;,
                &quot;Role-based access control&quot;,
                &quot;PII auto-anonymization&quot;
            }},
            {&quot;data_subjects&quot;, &quot;EU citizens&quot;}
        };

        reg[&quot;processing_activities&quot;].push_back(activity);
    }

    return reg;
}
</code></pre>
<p><strong>Export:</strong></p>
<pre><code class="language-bash"># HTTP Endpoint
GET /api/compliance/gdpr/article30

# CLI Tool
$ themis-cli compliance gdpr-register --format json &gt; gdpr_register.json
$ themis-cli compliance gdpr-register --format pdf &gt; gdpr_register.pdf
</code></pre>
<h3 id="compliance_governance_strategy-72-audit-trail-report">7.2 Audit-Trail-Report<a class="headerlink" href="#compliance_governance_strategy-72-audit-trail-report" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">json generateAuditReport(
    const std::string&amp; start_date,
    const std::string&amp; end_date,
    const std::vector&lt;std::string&gt;&amp; categories
) {
    json report = {
        {&quot;period&quot;, {{&quot;start&quot;, start_date}, {&quot;end&quot;, end_date}}},
        {&quot;categories&quot;, categories},
        {&quot;entries&quot;, json::array()},
        {&quot;summary&quot;, {}}
    };

    // Lade SAGA-Logs aus Zeitraum
    auto logs = loadSAGALogs(start_date, end_date, categories);

    // Verifiziere Signaturen
    int verified = 0, failed = 0;
    for (const auto&amp; batch : getSAGABatches(start_date, end_date)) {
        if (verifySAGABatch(batch.id)) {
            verified++;
        } else {
            failed++;
            report[&quot;integrity_violations&quot;].push_back({
                {&quot;batch_id&quot;, batch.id},
                {&quot;signed_at&quot;, batch.signed_at}
            });
        }
    }

    report[&quot;summary&quot;] = {
        {&quot;total_entries&quot;, logs.size()},
        {&quot;verified_batches&quot;, verified},
        {&quot;failed_batches&quot;, failed},
        {&quot;pii_accesses&quot;, countPIIAccesses(logs)},
        {&quot;security_events&quot;, countSecurityEvents(logs)}
    };

    report[&quot;entries&quot;] = logs;

    return report;
}
</code></pre>
<hr />
<h2 id="compliance_governance_strategy-8-implementation-roadmap">8. Implementation Roadmap<a class="headerlink" href="#compliance_governance_strategy-8-implementation-roadmap" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-phase-1-audit-logging-saga-signierung-woche-1-2">Phase 1: Audit-Logging &amp; SAGA-Signierung (Woche 1-2)<a class="headerlink" href="#compliance_governance_strategy-phase-1-audit-logging-saga-signierung-woche-1-2" title="Permanent link">&para;</a></h3>
<p><strong>Deliverables:</strong>
- ✅ <code>AuditLogger</code> Klasse mit spdlog JSON-Output
- ✅ SAGA-Log-Erweiterung mit Batch-Collection
- ✅ VCC-PKI Client für Signierung (<code>POST /api/v1/sign</code>)
- ✅ LEK (Log Encryption Key) Management mit täglicher Rotation
- ✅ <code>verifySAGABatch()</code> Funktion für Signatur-Validierung</p>
<p><strong>Config:</strong></p>
<pre><code class="language-yaml"># config/governance.yaml (initial)
saga_log:
  signature:
    enabled: true
    batch_size: 1000
    batch_interval_minutes: 5
  encryption:
    enabled: true
    key_rotation: daily
</code></pre>
<h3 id="compliance_governance_strategy-phase-2-pii-detection-anonymisierung-woche-3-4">Phase 2: PII-Detection &amp; Anonymisierung (Woche 3-4)<a class="headerlink" href="#compliance_governance_strategy-phase-2-pii-detection-anonymisierung-woche-3-4" title="Permanent link">&para;</a></h3>
<p><strong>Deliverables:</strong>
- ✅ <code>PIIDetector</code> Klasse mit Regex + Schema-Strategien
- ✅ UUID-Replacement-Logik in Entity-Import
- ✅ PII-Mapping-Storage in separater RocksDB CF
- ✅ <code>revealPII()</code> mit ACL-Check + Audit-Log
- ✅ <code>erasePII()</code> für DSGVO Artikel 17</p>
<p><strong>Config:</strong></p>
<pre><code class="language-yaml">pii_detection:
  enabled: true
  strategies:
    - type: regex
    - type: schema_annotation
  anonymization:
    method: uuid_replacement
</code></pre>
<h3 id="compliance_governance_strategy-phase-3-governance-policy-engine-woche-5-6">Phase 3: Governance Policy Engine (Woche 5-6)<a class="headerlink" href="#compliance_governance_strategy-phase-3-governance-policy-engine-woche-5-6" title="Permanent link">&para;</a></h3>
<p><strong>Deliverables:</strong>
- ✅ <code>GovernancePolicyEngine</code> Klasse mit YAML-Parsing
- ✅ Data Classification API
- ✅ Policy-Validation in Query-Engine
- ✅ Retention-Policy-Integration
- ✅ Multi-Framework Support (GDPR, HIPAA, BSI C5)</p>
<p><strong>Config:</strong></p>
<pre><code class="language-yaml">governance:
  data_classification:
    levels: [public, internal, confidential, restricted]
  compliance_frameworks:
    gdpr: {enabled: true}
    hipaa: {enabled: true}
</code></pre>
<h3 id="compliance_governance_strategy-phase-4-retention-archival-woche-7-8">Phase 4: Retention &amp; Archival (Woche 7-8)<a class="headerlink" href="#compliance_governance_strategy-phase-4-retention-archival-woche-7-8" title="Permanent link">&para;</a></h3>
<p><strong>Deliverables:</strong>
- ✅ <code>RetentionManager</code> Klasse
- ✅ Background-Task für Daily Sweep
- ✅ Cold-Storage-Export (ZSTD + Verschlüsselung)
- ✅ Archiv-Metadata in RocksDB
- ✅ Compliance-Reports (GDPR Artikel 30, Audit-Trails)</p>
<p><strong>Config:</strong></p>
<pre><code class="language-yaml">retention:
  default_days: 2555
  archive:
    enabled: true
    storage: /mnt/archive/themis
</code></pre>
<h3 id="compliance_governance_strategy-phase-5-testing-compliance-validation-woche-9-10">Phase 5: Testing &amp; Compliance Validation (Woche 9-10)<a class="headerlink" href="#compliance_governance_strategy-phase-5-testing-compliance-validation-woche-9-10" title="Permanent link">&para;</a></h3>
<p><strong>Tests:</strong>
- ✅ SAGA-Signatur-Roundtrip (Sign → Verify)
- ✅ PII-Detection für alle Typen (Email, Phone, SSN, etc.)
- ✅ Anonymisierung + Reveal + Erase Workflow
- ✅ Policy-Engine mit allen Klassifizierungen
- ✅ Retention-Sweep mit Archivierung
- ✅ GDPR Artikel 30 Register-Generierung
- ✅ Multi-User Audit-Trail (verschiedene Rollen)</p>
<p><strong>Performance:</strong>
- Benchmark: SAGA-Signierung Overhead (&lt;5% bei Batch=1000)
- Benchmark: PII-Detection Latenz (&lt;1ms pro Entity)
- Load-Test: 1M Entities mit Retention-Sweep (&lt;10min)</p>
<hr />
<h2 id="compliance_governance_strategy-9-configuration-examples">9. Configuration Examples<a class="headerlink" href="#compliance_governance_strategy-9-configuration-examples" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-91-produktions-konfiguration">9.1 Produktions-Konfiguration<a class="headerlink" href="#compliance_governance_strategy-91-produktions-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml"># config/governance.yaml (Production)
governance:
  version: &quot;1.0&quot;
  environment: &quot;production&quot;

  # Audit-Logging
  audit:
    enabled: true
    categories:
      - SAGA
      - AUDIT
      - SECURITY
    sinks:
      - type: file
        path: /var/log/themis/audit.json
      - type: syslog
        host: siem.internal.vcc
        port: 514
        tls: true
      - type: elasticsearch
        url: https://elastic.internal.vcc:9200
        index: themis-audit-{date}

  # SAGA-Signierung
  saga_signing:
    enabled: true
    batch_size: 1000
    batch_interval_minutes: 5
    signature_algorithm: RSA-SHA256
    pki_endpoint: https://pki.internal.vcc:8443/api/v1/sign
    cert_service_id: themis-db-prod
    encrypt_then_sign: true
    categories:
      encrypt_before_sign: [SAGA, AUDIT]
    verification:
      on_query: true
      periodic_check: true
      check_interval_hours: 24

  # Log-Verschlüsselung
  log_encryption:
    enabled: true
    key_rotation: daily
    algorithm: AES-256-GCM
    key_storage: rocksdb
    aad_fields: [log_id, category, timestamp]
    encrypt_categories: [SAGA, AUDIT]

  # PII-Erkennung
  pii_detection:
    enabled: true
    strategies:
      - type: regex
        patterns_file: /etc/themis/pii_patterns.yaml
      - type: schema_annotation
        schema_file: /etc/themis/pii_schema.yaml
    anonymization:
      method: uuid_replacement
      uuid_prefix: &quot;pii_&quot;
      store_mapping: true
      mapping_encryption: true
    access_control:
      default_deny: true
      allowed_roles: [gdpr_officer, compliance_admin, legal]
      audit_all_reveals: true

  # Data Classification
  data_classification:
    levels:
      - name: public
        encryption_required: false
        pii_detection: false
        retention_days: 365
      - name: internal
        encryption_required: true
        pii_detection: true
        retention_days: 2555  # 7 Jahre
        access_control: role_based
      - name: confidential
        encryption_required: true
        pii_detection: true
        retention_days: 3650  # 10 Jahre
        access_control: attribute_based
        audit_all_access: true
      - name: restricted
        encryption_required: true
        encryption_algorithm: AES-256-GCM
        pii_detection: true
        pii_auto_anonymize: true
        retention_days: 3650
        access_control: multi_factor
        audit_all_access: true
        require_approval: true

  # Retention
  retention:
    default_days: 2555
    archive:
      enabled: true
      after_days: 365
      storage: /mnt/cold_storage/themis
      compression: zstd
      encryption: true
    policies:
      - resource_pattern: &quot;medical_records.*&quot;
        retention_days: 3650
        legal_basis: HIPAA_164_316
      - resource_pattern: &quot;financial.*&quot;
        retention_days: 3650
        legal_basis: HGB_257
      - resource_pattern: &quot;debug_logs.*&quot;
        retention_days: 7
        auto_purge: true

  # Compliance-Frameworks
  compliance_frameworks:
    gdpr:
      enabled: true
      data_protection_officer: dpo@vcc.internal
      article_30_register: /var/themis/gdpr_register.json
      breach_notification_hours: 72
    hipaa:
      enabled: true
      covered_entity: true
      security_officer: ciso@vcc.internal
    bsi_c5:
      enabled: true
      attestation_level: Type 2
      audit_frequency_months: 12
</code></pre>
<h3 id="compliance_governance_strategy-92-development-konfiguration">9.2 Development-Konfiguration<a class="headerlink" href="#compliance_governance_strategy-92-development-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml"># config/governance.dev.yaml
governance:
  version: &quot;1.0&quot;
  environment: &quot;development&quot;

  saga_signing:
    enabled: false  # Schnelleres Testing

  log_encryption:
    enabled: false

  pii_detection:
    enabled: true
    strategies:
      - type: regex
        patterns:
          email: '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    anonymization:
      method: uuid_replacement
      store_mapping: true
      mapping_encryption: false  # Dev: PII in Klartext für Debugging
    access_control:
      default_deny: false  # Dev: Offener Zugriff

  retention:
    default_days: 7  # Kurze Retention für Dev-DB
    archive:
      enabled: false

  compliance_frameworks:
    gdpr:
      enabled: true
    hipaa:
      enabled: false
</code></pre>
<hr />
<h2 id="compliance_governance_strategy-10-security-best-practices">10. Security Best Practices<a class="headerlink" href="#compliance_governance_strategy-10-security-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-101-least-privilege-fur-pii-zugriff">10.1 Least Privilege für PII-Zugriff<a class="headerlink" href="#compliance_governance_strategy-101-least-privilege-fur-pii-zugriff" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml"># config/rbac_policies.yaml
roles:
  - name: analyst
    permissions:
      - resource: &quot;patients.*&quot;
        actions: [read]
        pii_reveal: false  # Sieht nur UUIDs

  - name: doctor
    permissions:
      - resource: &quot;patients.*&quot;
        actions: [read, write]
        pii_reveal: true  # Kann PII entschlüsseln
        pii_types: [EMAIL, PHONE, MEDICAL_ID]

  - name: gdpr_officer
    permissions:
      - resource: &quot;*&quot;
        actions: [read, write, delete]
        pii_reveal: true
        pii_erase: true  # Kann DSGVO-Löschung durchführen

  - name: compliance_admin
    permissions:
      - resource: &quot;*&quot;
        actions: [read]
        pii_reveal: true
        audit_access: true
        compliance_reports: true
</code></pre>
<h3 id="compliance_governance_strategy-102-signature-verification-bei-audit-anfragen">10.2 Signature-Verification bei Audit-Anfragen<a class="headerlink" href="#compliance_governance_strategy-102-signature-verification-bei-audit-anfragen" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Automatische Verifizierung bei /api/audit/logs Anfragen
GET /api/audit/logs?start=2025-10-01&amp;end=2025-10-31

Response:
{
  &quot;logs&quot;: [...],
  &quot;signature_verification&quot;: {
    &quot;total_batches&quot;: 42,
    &quot;verified&quot;: 42,
    &quot;failed&quot;: 0,
    &quot;integrity_status&quot;: &quot;OK&quot;
  }
}
</code></pre>
<h3 id="compliance_governance_strategy-103-immutable-audit-logs-rocksdb-sst-sealing">10.3 Immutable Audit-Logs (RocksDB SST-Sealing)<a class="headerlink" href="#compliance_governance_strategy-103-immutable-audit-logs-rocksdb-sst-sealing" title="Permanent link">&para;</a></h3>
<p><strong>Optional:</strong> RocksDB SST-Files als Read-Only nach Signierung:</p>
<pre><code class="language-cpp">void sealSignedSAGABatch(const std::string&amp; batch_id) {
    // 1. Force Flush to SST
    db_.flush();

    // 2. Hole SST-File-Pfad für Batch
    auto sst_file = getSSTFileForBatch(batch_id);

    // 3. Setze Read-Only (OS-Level)
    chmod(sst_file.c_str(), 0444);  // r--r--r--

    // 4. Optional: Kopiere zu WORM-Storage (Write-Once-Read-Many)
    copyToWORMStorage(sst_file);
}
</code></pre>
<hr />
<h2 id="compliance_governance_strategy-11-compliance-verification-checklist">11. Compliance Verification Checklist<a class="headerlink" href="#compliance_governance_strategy-11-compliance-verification-checklist" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-dsgvo-gdpr">DSGVO (GDPR)<a class="headerlink" href="#compliance_governance_strategy-dsgvo-gdpr" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Anforderung</th>
<th>Artikel</th>
<th>Implementierung</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Verschlüsselung at-rest</td>
<td>Art. 32</td>
<td>AES-256-GCM</td>
<td>✅</td>
</tr>
<tr>
<td>Audit-Trail</td>
<td>Art. 30</td>
<td>PKI-signierte SAGA-Logs</td>
<td>✅</td>
</tr>
<tr>
<td>Recht auf Vergessenwerden</td>
<td>Art. 17</td>
<td><code>erasePII()</code> mit UUID-Löschung</td>
<td>✅</td>
</tr>
<tr>
<td>Datenminimierung</td>
<td>Art. 5(1)(c)</td>
<td>Auto-Anonymisierung</td>
<td>✅</td>
</tr>
<tr>
<td>Privacy by Design</td>
<td>Art. 25</td>
<td>PII-Detection bei Import</td>
<td>✅</td>
</tr>
<tr>
<td>Meldepflicht Datenpanne</td>
<td>Art. 33</td>
<td>Security-Event-Logging</td>
<td>✅</td>
</tr>
<tr>
<td>Verarbeitungsverzeichnis</td>
<td>Art. 30</td>
<td>Auto-Generierung <code>/compliance/gdpr/article30</code></td>
<td>✅</td>
</tr>
</tbody>
</table>
<h3 id="compliance_governance_strategy-hipaa">HIPAA<a class="headerlink" href="#compliance_governance_strategy-hipaa" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Anforderung</th>
<th>Section</th>
<th>Implementierung</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access Controls</td>
<td>§164.312(a)(1)</td>
<td>RBAC + ABAC</td>
<td>✅</td>
</tr>
<tr>
<td>Audit Controls</td>
<td>§164.312(b)</td>
<td>Structured Audit-Logs</td>
<td>✅</td>
</tr>
<tr>
<td>Integrity Controls</td>
<td>§164.312(c)(1)</td>
<td>PKI-Signaturen</td>
<td>✅</td>
</tr>
<tr>
<td>Transmission Security</td>
<td>§164.312(e)(1)</td>
<td>TLS 1.3 + mTLS</td>
<td>✅</td>
</tr>
<tr>
<td>Encryption at Rest</td>
<td>§164.312(a)(2)(iv)</td>
<td>AES-256-GCM</td>
<td>✅</td>
</tr>
<tr>
<td>Log Retention</td>
<td>§164.316(b)(2)(i)</td>
<td>10 Jahre für Medical Records</td>
<td>✅</td>
</tr>
</tbody>
</table>
<h3 id="compliance_governance_strategy-bsi-c5">BSI C5<a class="headerlink" href="#compliance_governance_strategy-bsi-c5" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Kontrolle</th>
<th>Beschreibung</th>
<th>Implementierung</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>ORP-4</td>
<td>Datenschutzbeauftragter</td>
<td>Config: <code>dpo@example.com</code></td>
<td>✅</td>
</tr>
<tr>
<td>OPS-11</td>
<td>Protokollierung</td>
<td>Structured JSON-Logs</td>
<td>✅</td>
</tr>
<tr>
<td>OPS-12</td>
<td>Überwachung</td>
<td>SIEM-Export</td>
<td>✅</td>
</tr>
<tr>
<td>IAM-01</td>
<td>Identitätsmanagement</td>
<td>VCC-User Integration</td>
<td>✅</td>
</tr>
<tr>
<td>IAM-03</td>
<td>Zugriffsrechte</td>
<td>RBAC + Policy Engine</td>
<td>✅</td>
</tr>
<tr>
<td>CRY-01</td>
<td>Verschlüsselung</td>
<td>AES-256-GCM</td>
<td>✅</td>
</tr>
<tr>
<td>CRY-02</td>
<td>Schlüsselmanagement</td>
<td>VCC-PKI Integration</td>
<td>✅</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="compliance_governance_strategy-12-next-steps">12. Next Steps<a class="headerlink" href="#compliance_governance_strategy-12-next-steps" title="Permanent link">&para;</a></h2>
<h3 id="compliance_governance_strategy-immediate-woche-1-2">Immediate (Woche 1-2)<a class="headerlink" href="#compliance_governance_strategy-immediate-woche-1-2" title="Permanent link">&para;</a></h3>
<ol>
<li>✅ SAGA-Log-Erweiterung mit Batch-Collection</li>
<li>✅ VCC-PKI REST-Client für Signierung</li>
<li>✅ LEK (Log Encryption Key) Rotation-Logik</li>
<li>✅ <code>AuditLogger</code> mit spdlog JSON-Output</li>
</ol>
<h3 id="compliance_governance_strategy-short-term-woche-3-6">Short-Term (Woche 3-6)<a class="headerlink" href="#compliance_governance_strategy-short-term-woche-3-6" title="Permanent link">&para;</a></h3>
<ol>
<li>✅ <code>PIIDetector</code> mit Regex + Schema-Strategien</li>
<li>✅ UUID-Replacement in Entity-Import</li>
<li>✅ <code>GovernancePolicyEngine</code> mit YAML-Config</li>
<li>✅ Policy-Validation in Query-Engine</li>
</ol>
<h3 id="compliance_governance_strategy-medium-term-woche-7-10">Medium-Term (Woche 7-10)<a class="headerlink" href="#compliance_governance_strategy-medium-term-woche-7-10" title="Permanent link">&para;</a></h3>
<ol>
<li>✅ <code>RetentionManager</code> mit Background-Sweep</li>
<li>✅ Cold-Storage-Export mit ZSTD + Encryption</li>
<li>✅ Compliance-Report-Generierung (GDPR, HIPAA)</li>
<li>✅ Integration-Tests für alle Compliance-Features</li>
</ol>
<h3 id="compliance_governance_strategy-long-term-woche-11">Long-Term (Woche 11+)<a class="headerlink" href="#compliance_governance_strategy-long-term-woche-11" title="Permanent link">&para;</a></h3>
<ol>
<li>❌ NER (Named Entity Recognition) für ML-basierte PII-Detection</li>
<li>❌ Blockchain-Anchoring für SAGA-Signaturen (zusätzliche Unveränderlichkeit)</li>
<li>❌ GDPR-DSR-Workflow (Data Subject Request Automation)</li>
<li>❌ Compliance-Dashboard (Web-UI für DPO/CISO)</li>
</ol>
<hr />
<h2 id="compliance_governance_strategy-zusammenfassung">Zusammenfassung<a class="headerlink" href="#compliance_governance_strategy-zusammenfassung" title="Permanent link">&para;</a></h2>
<p>Diese Strategie definiert eine umfassende <strong>Compliance &amp; Governance-Architektur</strong> für ThemisDB:</p>
<ul>
<li>📝 <strong>PKI-signierte SAGA-Logs</strong> für unveränderliche Audit-Trails</li>
<li>🔐 <strong>DSGVO by Design</strong> mit automatischer PII-Erkennung und UUID-Anonymisierung</li>
<li>⚖️ <strong>Multi-Framework-Support</strong> (GDPR, HIPAA, BSI C5)</li>
<li>🎯 <strong>Policy-Driven</strong> mit YAML/JSON-Konfiguration für alle Governance-Regeln</li>
<li>🔒 <strong>Log-Verschlüsselung</strong> mit täglicher LEK-Rotation</li>
<li>📦 <strong>Retention &amp; Archival</strong> mit Cold-Storage-Export</li>
<li>🔍 <strong>Audit-Reports</strong> mit automatischer Signatur-Verifizierung</li>
</ul>
<p><strong>Kerntechnologien:</strong>
- VCC-PKI für Signierung &amp; Verschlüsselung
- RocksDB für unveränderliche Log-Storage
- spdlog für Structured JSON-Logging
- YAML/JSON für Policy-Konfiguration</p>
<p>Die Implementierung erfolgt in <strong>10 Wochen</strong> mit vollständiger Integration in bestehende ThemisDB-Infrastruktur (Encryption, VCC-PKI, VCC-User).</p></section><section class="print-page" id="compliance_integration" heading-number="12.16"><h1 id="compliance_integration-themis-compliance-integration-guide">Themis Compliance Integration Guide<a class="headerlink" href="#compliance_integration-themis-compliance-integration-guide" title="Permanent link">&para;</a></h1>
<h2 id="compliance_integration-ubersicht">Übersicht<a class="headerlink" href="#compliance_integration-ubersicht" title="Permanent link">&para;</a></h2>
<p>Themis bietet eine vollständige Compliance-Pipeline für DSGVO/eIDAS-konforme Datenverarbeitung:</p>
<ol>
<li><strong>Data Governance</strong>: Klassifizierung nach VS-NfD/Geheim/Streng Geheim</li>
<li><strong>PII Detection</strong>: Automatische Erkennung personenbezogener Daten</li>
<li><strong>Audit Logging</strong>: Encrypt-then-Sign mit PKI</li>
<li><strong>Retention Management</strong>: Automatische Archivierung und Löschung</li>
</ol>
<hr />
<h2 id="compliance_integration-1-data-governance">1. Data Governance<a class="headerlink" href="#compliance_integration-1-data-governance" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-klassifizierungsstufen">Klassifizierungsstufen<a class="headerlink" href="#compliance_integration-klassifizierungsstufen" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Level</th>
<th>Beschreibung</th>
<th>Regeln</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>offen</code></td>
<td>Öffentliche Daten</td>
<td>Keine Einschränkungen</td>
</tr>
<tr>
<td><code>vs-nfd</code></td>
<td>Verschlusssache - Nur für den Dienstgebrauch</td>
<td>Verschlüsselung erforderlich</td>
</tr>
<tr>
<td><code>geheim</code></td>
<td>Geheime Daten</td>
<td>Verschlüsselung + Zugriffskontrolle + kein ANN</td>
</tr>
<tr>
<td><code>streng_geheim</code></td>
<td>Streng geheim</td>
<td>Maximale Sicherheit + Audit-Trail</td>
</tr>
</tbody>
</table>
<h3 id="compliance_integration-http-header">HTTP-Header<a class="headerlink" href="#compliance_integration-http-header" title="Permanent link">&para;</a></h3>
<pre><code class="language-http">X-Data-Classification: geheim
X-Governance-Mode: enforce
</code></pre>
<h3 id="compliance_integration-governance-policies">Governance-Policies<a class="headerlink" href="#compliance_integration-governance-policies" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;classification&quot;: &quot;geheim&quot;,
  &quot;encryption_required&quot;: true,
  &quot;retention_days&quot;: 90,
  &quot;allow_ann_indexing&quot;: false,
  &quot;require_audit&quot;: true,
  &quot;cache_policy&quot;: &quot;no-cache&quot;,
  &quot;export_policy&quot;: &quot;deny&quot;
}
</code></pre>
<h3 id="compliance_integration-beispiel-klassifizierter-request">Beispiel: Klassifizierter Request<a class="headerlink" href="#compliance_integration-beispiel-klassifizierter-request" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:8765/entities \
  -H &quot;Content-Type: application/json&quot; \
  -H &quot;X-Data-Classification: vs-nfd&quot; \
  -H &quot;X-Governance-Mode: enforce&quot; \
  -d '{
    &quot;object_type&quot;: &quot;patient_record&quot;,
    &quot;name&quot;: &quot;Max Mustermann&quot;,
    &quot;ssn&quot;: &quot;123-45-6789&quot;,
    &quot;created_at&quot;: 1730505600
  }'
</code></pre>
<p><strong>Response Headers:</strong></p>
<pre><code class="language-http">X-Data-Classification: vs-nfd
X-Encryption-Required: true
X-Retention-Days: 365
X-Allow-ANN: false
</code></pre>
<hr />
<h2 id="compliance_integration-2-pii-detection">2. PII Detection<a class="headerlink" href="#compliance_integration-2-pii-detection" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-unterstutzte-pii-typen">Unterstützte PII-Typen<a class="headerlink" href="#compliance_integration-unterstutzte-pii-typen" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Typ</th>
<th>Beispiel</th>
<th>Regex-Pattern</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EMAIL</code></td>
<td><code>user@example.com</code></td>
<td>RFC 5322</td>
</tr>
<tr>
<td><code>PHONE</code></td>
<td><code>+49 123 456789</code>, <code>(555) 123-4567</code></td>
<td>International + US</td>
</tr>
<tr>
<td><code>SSN</code></td>
<td><code>123-45-6789</code></td>
<td>US Social Security</td>
</tr>
<tr>
<td><code>CREDIT_CARD</code></td>
<td><code>4532-1234-5678-9010</code></td>
<td>Luhn-validiert</td>
</tr>
<tr>
<td><code>IBAN</code></td>
<td><code>DE89370400440532013000</code></td>
<td>IBAN-Format</td>
</tr>
<tr>
<td><code>IP_ADDRESS</code></td>
<td><code>192.168.1.1</code></td>
<td>IPv4</td>
</tr>
<tr>
<td><code>URL</code></td>
<td><code>https://example.com/path</code></td>
<td>HTTP(S) URLs</td>
</tr>
</tbody>
</table>
<h3 id="compliance_integration-yaml-konfiguration">YAML-Konfiguration<a class="headerlink" href="#compliance_integration-yaml-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml"># config/pii_detection.yaml
engines:
  - name: regex_engine
    type: regex
    enabled: true
    patterns:
      - type: CREDIT_CARD
        pattern: '\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b'
        validate_luhn: true
      - type: EMAIL
        pattern: '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
</code></pre>
<h3 id="compliance_integration-automatische-pii-erkennung">Automatische PII-Erkennung<a class="headerlink" href="#compliance_integration-automatische-pii-erkennung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &quot;utils/pii_detector.h&quot;

vcc::PIIDetector detector(&quot;./config/pii_detection.yaml&quot;);

nlohmann::json data = {
    {&quot;email&quot;, &quot;john.doe@example.com&quot;},
    {&quot;phone&quot;, &quot;+49 30 12345678&quot;},
    {&quot;ssn&quot;, &quot;123-45-6789&quot;},
    {&quot;credit_card&quot;, &quot;4532123456789010&quot;}
};

auto findings = detector.detectInJson(data);

for (const auto&amp; finding : findings) {
    std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; finding.type 
              &lt;&lt; &quot; at &quot; &lt;&lt; finding.json_path 
              &lt;&lt; &quot;: &quot; &lt;&lt; finding.value &lt;&lt; &quot;\n&quot;;

    // Redact based on classification
    auto redacted = detector.maskValue(finding.value, finding.type, 
                                       vcc::PIIDetector::RedactionMode::PARTIAL);
    std::cout &lt;&lt; &quot;Redacted: &quot; &lt;&lt; redacted &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Found EMAIL at $.email: john.doe@example.com
Redacted: j***@example.com
Found PHONE at $.phone: +49 30 12345678
Redacted: +49 *** *** **78
Found SSN at $.ssn: 123-45-6789
Redacted: ***-**-6789
Found CREDIT_CARD at $.credit_card: 4532123456789010
Redacted: 4532-****-****-9010
</code></pre>
<h3 id="compliance_integration-field-hint-klassifizierung">Field-Hint-Klassifizierung<a class="headerlink" href="#compliance_integration-field-hint-klassifizierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Automatische Erkennung via Feldnamen
auto hint = detector.classifyFieldName(&quot;user_email&quot;);
// hint = PIIType::EMAIL

auto hint2 = detector.classifyFieldName(&quot;credit_card_number&quot;);
// hint2 = PIIType::CREDIT_CARD
</code></pre>
<hr />
<h2 id="compliance_integration-3-audit-logging">3. Audit Logging<a class="headerlink" href="#compliance_integration-3-audit-logging" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-konfiguration">Konfiguration<a class="headerlink" href="#compliance_integration-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &quot;utils/audit_logger.h&quot;
#include &quot;utils/pki_client.h&quot;
#include &quot;security/encryption.h&quot;

// Setup
auto key_provider = std::make_shared&lt;MockKeyProvider&gt;();
key_provider-&gt;createKey(&quot;audit_key&quot;, 32);

auto field_enc = std::make_shared&lt;FieldEncryption&gt;(key_provider);

PKIConfig pki_cfg;
pki_cfg.service_id = &quot;themis-audit&quot;;
pki_cfg.endpoint = &quot;https://pki.example.com&quot;;
auto pki_client = std::make_shared&lt;VCCPKIClient&gt;(pki_cfg);

AuditLoggerConfig cfg;
cfg.enabled = true;
cfg.encrypt_then_sign = true;
cfg.log_path = &quot;data/logs/audit.jsonl&quot;;
cfg.key_id = &quot;audit_key&quot;;

auto audit_logger = std::make_shared&lt;AuditLogger&gt;(field_enc, pki_client, cfg);
</code></pre>
<h3 id="compliance_integration-ereignis-loggen">Ereignis loggen<a class="headerlink" href="#compliance_integration-ereignis-loggen" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">nlohmann::json event;
event[&quot;action&quot;] = &quot;DATA_ACCESS&quot;;
event[&quot;user_id&quot;] = &quot;user_12345&quot;;
event[&quot;resource&quot;] = &quot;/entities/patient_123&quot;;
event[&quot;classification&quot;] = &quot;geheim&quot;;
event[&quot;timestamp&quot;] = std::time(nullptr);
event[&quot;ip_address&quot;] = &quot;192.168.1.42&quot;;

audit_logger-&gt;logEvent(event);
</code></pre>
<h3 id="compliance_integration-audit-log-format-jsonl">Audit-Log-Format (JSONL)<a class="headerlink" href="#compliance_integration-audit-log-format-jsonl" title="Permanent link">&para;</a></h3>
<pre><code class="language-jsonl">{&quot;encrypted_data&quot;:&quot;base64...&quot;, &quot;signature&quot;:&quot;base64...&quot;, &quot;key_id&quot;:&quot;audit_key&quot;, &quot;algorithm&quot;:&quot;RSA-SHA256&quot;}
{&quot;encrypted_data&quot;:&quot;base64...&quot;, &quot;signature&quot;:&quot;base64...&quot;, &quot;key_id&quot;:&quot;audit_key&quot;, &quot;algorithm&quot;:&quot;RSA-SHA256&quot;}
</code></pre>
<hr />
<h2 id="compliance_integration-4-retention-management">4. Retention Management<a class="headerlink" href="#compliance_integration-4-retention-management" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-policy-konfiguration">Policy-Konfiguration<a class="headerlink" href="#compliance_integration-policy-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml"># config/retention_policies.yaml
policies:
  - name: user_personal_data
    retention_period: 365d
    archive_after: 180d
    auto_purge_enabled: true
    require_audit_trail: true
    classification_level: geheim
    metadata:
      legal_basis: &quot;DSGVO Art. 17&quot;

  - name: transaction_logs
    retention_period: 2555d  # 7 Jahre
    archive_after: 1095d     # 3 Jahre
    auto_purge_enabled: false
    require_audit_trail: true
    classification_level: vs-nfd
    metadata:
      legal_basis: &quot;HGB §257&quot;
</code></pre>
<h3 id="compliance_integration-server-konfiguration">Server-Konfiguration<a class="headerlink" href="#compliance_integration-server-konfiguration" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">// config/config.json
{
  &quot;features&quot;: {
    &quot;retention&quot;: {
      &quot;enabled&quot;: true,
      &quot;interval_hours&quot;: 24,
      &quot;policies_path&quot;: &quot;./config/retention_policies.yaml&quot;
    }
  }
}
</code></pre>
<h3 id="compliance_integration-automatischer-retention-check">Automatischer Retention-Check<a class="headerlink" href="#compliance_integration-automatischer-retention-check" title="Permanent link">&para;</a></h3>
<p>Der Server führt automatisch täglich (konfigurierbar) Retention-Checks durch:</p>
<pre><code>[INFO] Retention worker started (interval: 24h)
[INFO] [Retention] Completed: scanned=1523, archived=42, purged=18, retained=1463, errors=0
</code></pre>
<h3 id="compliance_integration-manuelle-retention-prufung">Manuelle Retention-Prüfung<a class="headerlink" href="#compliance_integration-manuelle-retention-prufung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &quot;utils/retention_manager.h&quot;

RetentionManager mgr(&quot;./config/retention_policies.yaml&quot;);

// Prüfe einzelne Entity
auto created_at = std::chrono::system_clock::now() - std::chrono::hours(24 * 200);

if (mgr.shouldArchive(&quot;entity_123&quot;, created_at, &quot;user_personal_data&quot;)) {
    auto archive_handler = [](const std::string&amp; id) {
        // Export to S3, Tape, etc.
        return true;
    };
    mgr.archiveEntity(&quot;entity_123&quot;, &quot;user_personal_data&quot;, archive_handler);
}

if (mgr.shouldPurge(&quot;entity_456&quot;, created_at, &quot;user_personal_data&quot;)) {
    auto purge_handler = [](const std::string&amp; id) {
        // Delete from DB
        return true;
    };
    mgr.purgeEntity(&quot;entity_456&quot;, &quot;user_personal_data&quot;, purge_handler);
}
</code></pre>
<hr />
<h2 id="compliance_integration-5-end-to-end-beispiel">5. End-to-End-Beispiel<a class="headerlink" href="#compliance_integration-5-end-to-end-beispiel" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-szenario-dsgvo-konforme-patientendaten-verarbeitung">Szenario: DSGVO-konforme Patientendaten-Verarbeitung<a class="headerlink" href="#compliance_integration-szenario-dsgvo-konforme-patientendaten-verarbeitung" title="Permanent link">&para;</a></h3>
<h4 id="compliance_integration-1-daten-empfangen-klassifizieren">1. Daten empfangen &amp; klassifizieren<a class="headerlink" href="#compliance_integration-1-daten-empfangen-klassifizieren" title="Permanent link">&para;</a></h4>
<pre><code class="language-bash">curl -X POST http://localhost:8765/entities \
  -H &quot;Content-Type: application/json&quot; \
  -H &quot;X-Data-Classification: geheim&quot; \
  -H &quot;X-Governance-Mode: enforce&quot; \
  -d '{
    &quot;object_type&quot;: &quot;patient&quot;,
    &quot;name&quot;: &quot;Anna Schmidt&quot;,
    &quot;email&quot;: &quot;anna.schmidt@example.de&quot;,
    &quot;ssn&quot;: &quot;123-45-6789&quot;,
    &quot;credit_card&quot;: &quot;4532123456789010&quot;,
    &quot;diagnosis&quot;: &quot;Diabetes Typ 2&quot;,
    &quot;created_at&quot;: 1730505600
  }'
</code></pre>
<p><strong>Governance-Response:</strong></p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;ok&quot;,
  &quot;entity_id&quot;: &quot;patient_789&quot;,
  &quot;governance&quot;: {
    &quot;classification&quot;: &quot;geheim&quot;,
    &quot;encryption_required&quot;: true,
    &quot;retention_days&quot;: 365,
    &quot;allow_ann&quot;: false,
    &quot;audit_logged&quot;: true
  }
}
</code></pre>
<h4 id="compliance_integration-2-pii-detection-im-hintergrund">2. PII-Detection im Hintergrund<a class="headerlink" href="#compliance_integration-2-pii-detection-im-hintergrund" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Server-seitig automatisch
auto findings = pii_detector.detectInJson(request_body);
// Findings: EMAIL, SSN, CREDIT_CARD

for (const auto&amp; finding : findings) {
    nlohmann::json audit_pii;
    audit_pii[&quot;action&quot;] = &quot;PII_DETECTED&quot;;
    audit_pii[&quot;type&quot;] = finding.type;
    audit_pii[&quot;path&quot;] = finding.json_path;
    audit_pii[&quot;entity_id&quot;] = &quot;patient_789&quot;;
    audit_logger-&gt;logEvent(audit_pii);
}
</code></pre>
<h4 id="compliance_integration-3-verschlusselte-speicherung">3. Verschlüsselte Speicherung<a class="headerlink" href="#compliance_integration-3-verschlusselte-speicherung" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Sensitive Felder verschlüsseln
EncryptedField&lt;std::string&gt; encrypted_ssn(key_provider, &quot;patient_key&quot;);
encrypted_ssn.encrypt(&quot;123-45-6789&quot;);

EncryptedField&lt;std::string&gt; encrypted_cc(key_provider, &quot;patient_key&quot;);
encrypted_cc.encrypt(&quot;4532123456789010&quot;);

// In DB speichern
entity.setField(&quot;ssn_encrypted&quot;, encrypted_ssn.toBase64());
entity.setField(&quot;credit_card_encrypted&quot;, encrypted_cc.toBase64());
</code></pre>
<h4 id="compliance_integration-4-audit-log-bei-zugriff">4. Audit-Log bei Zugriff<a class="headerlink" href="#compliance_integration-4-audit-log-bei-zugriff" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">// Bei jedem Zugriff
nlohmann::json access_event;
access_event[&quot;action&quot;] = &quot;DATA_ACCESS&quot;;
access_event[&quot;user_id&quot;] = request.headers[&quot;X-User-ID&quot;];
access_event[&quot;entity_id&quot;] = &quot;patient_789&quot;;
access_event[&quot;classification&quot;] = &quot;geheim&quot;;
access_event[&quot;timestamp&quot;] = std::time(nullptr);
access_event[&quot;ip&quot;] = request.remote_addr;

audit_logger-&gt;logEvent(access_event);
</code></pre>
<h4 id="compliance_integration-5-automatische-retention">5. Automatische Retention<a class="headerlink" href="#compliance_integration-5-automatische-retention" title="Permanent link">&para;</a></h4>
<p>Nach 180 Tagen (archive_after):</p>
<pre><code>[INFO] [Retention] Archive entity patient_789
[INFO] Audit: {&quot;action&quot;:&quot;RETENTION_ARCHIVE&quot;,&quot;entity_id&quot;:&quot;patient_789&quot;}
</code></pre>
<p>Nach 365 Tagen (retention_period):</p>
<pre><code>[INFO] [Retention] Purge entity patient_789
[INFO] Audit: {&quot;action&quot;:&quot;RETENTION_PURGE&quot;,&quot;entity_id&quot;:&quot;patient_789&quot;}
</code></pre>
<hr />
<h2 id="compliance_integration-6-compliance-checkliste">6. Compliance-Checkliste<a class="headerlink" href="#compliance_integration-6-compliance-checkliste" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-dsgvo-art-5-17-25-32">DSGVO (Art. 5, 17, 25, 32)<a class="headerlink" href="#compliance_integration-dsgvo-art-5-17-25-32" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ <strong>Datenminimierung</strong>: PII-Detection hilft, nur nötige Daten zu erheben</li>
<li>✅ <strong>Speicherbegrenzung</strong>: Retention-Policies mit auto-purge</li>
<li>✅ <strong>Recht auf Vergessenwerden</strong>: Purge-Handler löscht Daten unwiderruflich</li>
<li>✅ <strong>Privacy by Design</strong>: Verschlüsselung per Governance-Policy erzwungen</li>
<li>✅ <strong>Sicherheit der Verarbeitung</strong>: AES-256-GCM + PKI-Signierung</li>
<li>✅ <strong>Rechenschaftspflicht</strong>: Audit-Logs mit Zeitstempel + Integrität</li>
</ul>
<h3 id="compliance_integration-eidas-vertrauensdienste">eIDAS (Vertrauensdienste)<a class="headerlink" href="#compliance_integration-eidas-vertrauensdienste" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ <strong>Signatur</strong>: PKI-Client für qualifizierte Signaturen</li>
<li>✅ <strong>Zeitstempel</strong>: Audit-Events mit präziser Zeiterfassung</li>
<li>✅ <strong>Langzeitarchivierung</strong>: Archive-Handler für 7-10 Jahre Retention</li>
<li>✅ <strong>Nachweisbarkeit</strong>: Encrypt-then-Sign für manipulationssichere Logs</li>
</ul>
<h3 id="compliance_integration-hgb-257-aufbewahrungsfristen">HGB §257 (Aufbewahrungsfristen)<a class="headerlink" href="#compliance_integration-hgb-257-aufbewahrungsfristen" title="Permanent link">&para;</a></h3>
<ul>
<li>✅ <strong>Geschäftsbriefe</strong>: 6 Jahre (konfigurierbar via YAML)</li>
<li>✅ <strong>Buchungsbelege</strong>: 10 Jahre (transaction_logs Policy)</li>
<li>✅ <strong>Inventare</strong>: 10 Jahre (inventory Policy)</li>
</ul>
<hr />
<h2 id="compliance_integration-7-monitoring-debugging">7. Monitoring &amp; Debugging<a class="headerlink" href="#compliance_integration-7-monitoring-debugging" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-governance-metriken">Governance-Metriken<a class="headerlink" href="#compliance_integration-governance-metriken" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">curl http://localhost:8765/metrics | grep governance
</code></pre>
<pre><code>themis_governance_requests_total{classification=&quot;geheim&quot;} 1523
themis_governance_encryption_enforced_total 892
themis_governance_ann_blocked_total 234
</code></pre>
<h3 id="compliance_integration-retention-statistiken">Retention-Statistiken<a class="headerlink" href="#compliance_integration-retention-statistiken" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">auto stats = retention_mgr.getPolicyStats(&quot;user_personal_data&quot;);
std::cout &lt;&lt; &quot;Archived: &quot; &lt;&lt; stats.archived_count &lt;&lt; &quot;\n&quot;;
std::cout &lt;&lt; &quot;Purged: &quot; &lt;&lt; stats.purged_count &lt;&lt; &quot;\n&quot;;
std::cout &lt;&lt; &quot;Retained: &quot; &lt;&lt; stats.retained_count &lt;&lt; &quot;\n&quot;;
</code></pre>
<h3 id="compliance_integration-audit-log-analyse">Audit-Log-Analyse<a class="headerlink" href="#compliance_integration-audit-log-analyse" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Anzahl PII-Detections
grep &quot;PII_DETECTED&quot; data/logs/audit.jsonl | wc -l

# Retention-Aktionen
grep &quot;RETENTION_&quot; data/logs/retention_audit.jsonl | jq '.action' | sort | uniq -c
</code></pre>
<hr />
<h2 id="compliance_integration-8-best-practices">8. Best Practices<a class="headerlink" href="#compliance_integration-8-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-1-klassifizierung-fruh-festlegen">1. Klassifizierung früh festlegen<a class="headerlink" href="#compliance_integration-1-klassifizierung-fruh-festlegen" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Bei Entity-Erstellung
entity.setField(&quot;_classification&quot;, &quot;geheim&quot;);
entity.setField(&quot;_created_at&quot;, std::time(nullptr));
</code></pre>
<h3 id="compliance_integration-2-pii-detection-in-cicd">2. PII-Detection in CI/CD<a class="headerlink" href="#compliance_integration-2-pii-detection-in-cicd" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Pre-commit Hook
./bin/pii_scan --config=pii_detection.yaml --input=dump.json
</code></pre>
<h3 id="compliance_integration-3-retention-tests">3. Retention-Tests<a class="headerlink" href="#compliance_integration-3-retention-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Unit-Test für Policy-Compliance
TEST(RetentionTest, GDPR_Article17_RightToErasure) {
    RetentionManager mgr;
    auto policy = mgr.getPolicy(&quot;user_personal_data&quot;);
    ASSERT_TRUE(policy-&gt;auto_purge_enabled);
    ASSERT_EQ(policy-&gt;retention_period, std::chrono::hours(24 * 365));
}
</code></pre>
<h3 id="compliance_integration-4-audit-log-rotation">4. Audit-Log-Rotation<a class="headerlink" href="#compliance_integration-4-audit-log-rotation" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Logrotate-Config
/var/log/themis/audit.jsonl {
    daily
    rotate 365
    compress
    delaycompress
    notifempty
    create 0640 themis themis
}
</code></pre>
<hr />
<h2 id="compliance_integration-9-troubleshooting">9. Troubleshooting<a class="headerlink" href="#compliance_integration-9-troubleshooting" title="Permanent link">&para;</a></h2>
<h3 id="compliance_integration-pii-nicht-erkannt">PII nicht erkannt<a class="headerlink" href="#compliance_integration-pii-nicht-erkannt" title="Permanent link">&para;</a></h3>
<p><strong>Problem</strong>: Kreditkarte <code>4532-1234-5678-9010</code> wird nicht erkannt</p>
<p><strong>Lösung</strong>: Luhn-Validierung prüfen</p>
<pre><code class="language-cpp">auto is_valid = vcc::validateLuhn(&quot;4532123456789010&quot;); // true
auto is_invalid = vcc::validateLuhn(&quot;1234123412341234&quot;); // false
</code></pre>
<h3 id="compliance_integration-retention-lauft-nicht">Retention läuft nicht<a class="headerlink" href="#compliance_integration-retention-lauft-nicht" title="Permanent link">&para;</a></h3>
<p><strong>Problem</strong>: Keine Retention-Logs im Server</p>
<p><strong>Lösung</strong>: Config prüfen</p>
<pre><code class="language-json">{
  &quot;features&quot;: {
    &quot;retention&quot;: {
      &quot;enabled&quot;: true  // &lt;- muss true sein
    }
  }
}
</code></pre>
<h3 id="compliance_integration-audit-log-verschlusselt-nicht">Audit-Log verschlüsselt nicht<a class="headerlink" href="#compliance_integration-audit-log-verschlusselt-nicht" title="Permanent link">&para;</a></h3>
<p><strong>Problem</strong>: Plaintext in audit.jsonl</p>
<p><strong>Lösung</strong>: encrypt_then_sign aktivieren</p>
<pre><code class="language-cpp">AuditLoggerConfig cfg;
cfg.encrypt_then_sign = true; // &lt;- wichtig!
cfg.enabled = true;
</code></pre>
<hr />
<h2 id="compliance_integration-10-weiterfuhrende-ressourcen">10. Weiterführende Ressourcen<a class="headerlink" href="#compliance_integration-10-weiterfuhrende-ressourcen" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://dsgvo-gesetz.de/">DSGVO-Volltext</a></li>
<li><a href="https://eur-lex.europa.eu/legal-content/DE/TXT/?uri=CELEX:32014R0910">eIDAS-Verordnung</a></li>
<li><a href="https://www.bsi.bund.de/DE/Themen/Unternehmen-und-Organisationen/Standards-und-Zertifizierung/IT-Grundschutz/it-grundschutz_node.html">BSI IT-Grundschutz</a></li>
<li><a href="https://www.gesetze-im-internet.de/hgb/__257.html">HGB Aufbewahrungsfristen</a></li>
</ul>
<hr />
<p><strong>Version</strong>: 0.1.0<br />
<strong>Letztes Update</strong>: 1. November 2025<br />
<strong>Maintainer</strong>: Themis Compliance Team</p></section><section class="print-page" id="governance_usage" heading-number="12.17"><h1 id="governance_usage-governance-policy-engine-usage-examples">Governance Policy Engine - Usage Examples<a class="headerlink" href="#governance_usage-governance-policy-engine-usage-examples" title="Permanent link">&para;</a></h1>
<p>This document demonstrates how to use the YAML-based governance policy engine in Themis.</p>
<h2 id="governance_usage-overview">Overview<a class="headerlink" href="#governance_usage-overview" title="Permanent link">&para;</a></h2>
<p>The Governance Policy Engine provides:
- <strong>Classification-based data protection</strong> (offen, vs-nfd, geheim, streng-geheim)
- <strong>Fine-grained access control</strong> (ANN, export, cache)
- <strong>Retention policies</strong> per classification
- <strong>Encrypt-then-Sign</strong> log handling
- <strong>Observe/Enforce modes</strong> for gradual rollout</p>
<h2 id="governance_usage-configuration">Configuration<a class="headerlink" href="#governance_usage-configuration" title="Permanent link">&para;</a></h2>
<p>Governance policies are defined in <code>config/governance.yaml</code>:</p>
<pre><code class="language-yaml">vs_classification:
  offen:
    encryption_required: false
    ann_allowed: true
    export_allowed: true
    cache_allowed: true
    redaction_level: &quot;none&quot;
    retention_days: 365
    log_encryption: false

  geheim:
    encryption_required: true
    ann_allowed: false  # ANN disabled; exact search only
    export_allowed: false
    cache_allowed: false
    redaction_level: &quot;strict&quot;
    retention_days: 3650  # 10 years
    log_encryption: true

enforcement:
  resource_mapping:
    &quot;/admin/*&quot;: &quot;vs-nfd&quot;
    &quot;/admin/status&quot;: &quot;vs-nfd&quot;  # explizit gemappt
    &quot;/vector/search&quot;: &quot;offen&quot;

  default_mode: &quot;enforce&quot;
</code></pre>
<h3 id="governance_usage-konfig-dateipfade-suchreihenfolge">Konfig-Dateipfade (Suchreihenfolge)<a class="headerlink" href="#governance_usage-konfig-dateipfade-suchreihenfolge" title="Permanent link">&para;</a></h3>
<p>Der Server lädt <code>governance.yaml</code> aus den folgenden Pfaden (erste gefundene Datei gewinnt):</p>
<ol>
<li><code>config/governance.yaml</code> (aus Repo-Root gestartet)</li>
<li><code>../config/governance.yaml</code> (selten, falls CWD <code>build/</code> ist)</li>
<li><code>../../config/governance.yaml</code> (CTest/IDE: CWD ist häufig <code>build/&lt;Config&gt;</code> wie <code>build/Release</code>)</li>
<li><code>./governance.yaml</code> (Fallback im aktuellen Verzeichnis)</li>
</ol>
<p>Hinweis: Diese Reihenfolge stellt sicher, dass CTest-Läufe aus <code>build/&lt;Config&gt;</code> die zentrale Konfiguration unter <code>config/</code> finden.</p>
<h2 id="governance_usage-http-headers">HTTP Headers<a class="headerlink" href="#governance_usage-http-headers" title="Permanent link">&para;</a></h2>
<h3 id="governance_usage-request-headers">Request Headers<a class="headerlink" href="#governance_usage-request-headers" title="Permanent link">&para;</a></h3>
<p>Clients can specify governance requirements via HTTP headers:</p>
<ul>
<li><code>X-Classification</code>: Data classification level (offen, vs-nfd, geheim, streng-geheim)</li>
<li><code>X-Governance-Mode</code>: Enforcement mode (enforce, observe)</li>
<li><code>X-Encrypt-Logs</code>: Force log encryption (true, false, auto)</li>
<li><code>X-Redaction-Level</code>: Redaction profile (none, standard, strict)</li>
</ul>
<h3 id="governance_usage-response-headers">Response Headers<a class="headerlink" href="#governance_usage-response-headers" title="Permanent link">&para;</a></h3>
<p>Server returns applied policy decisions:</p>
<ul>
<li><code>X-Themis-Policy</code>: Compact policy summary</li>
<li><code>X-Themis-Integrity</code>: Signature status (signed-ciphertext:policy-only)</li>
<li><code>X-Themis-ANN</code>: ANN availability (allowed, disabled)</li>
<li><code>X-Themis-Content-Enc</code>: Content encryption requirement (required, optional)</li>
<li><code>X-Themis-Export</code>: Export permission (allowed, forbidden)</li>
<li><code>X-Themis-Cache</code>: Cache permission (allowed, disabled)</li>
<li><code>X-Themis-Retention-Days</code>: Data retention period</li>
</ul>
<p>Im Observe-Modus können zusätzlich Warnhinweise erscheinen:</p>
<ul>
<li><code>X-Themis-Policy-Warn</code>: z. B. <code>ann_disabled_but_observed</code> oder <code>content_encryption_required_but_observed</code></li>
</ul>
<h2 id="governance_usage-usage-examples">Usage Examples<a class="headerlink" href="#governance_usage-usage-examples" title="Permanent link">&para;</a></h2>
<h3 id="governance_usage-example-1-public-data-offen">Example 1: Public Data (offen)<a class="headerlink" href="#governance_usage-example-1-public-data-offen" title="Permanent link">&para;</a></h3>
<p><strong>Request:</strong></p>
<pre><code class="language-http">POST /vector/search
X-Classification: offen
Content-Type: application/json

{
  &quot;vector&quot;: [0.1, 0.2, ...],
  &quot;k&quot;: 10
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-http">HTTP/1.1 200 OK
X-Themis-Policy: classification=offen;mode=enforce;encrypt_logs=false;redaction=none
X-Themis-ANN: allowed
X-Themis-Content-Enc: optional
X-Themis-Export: allowed
X-Themis-Cache: allowed
X-Themis-Retention-Days: 365

{
  &quot;results&quot;: [...]
}
</code></pre>
<h3 id="governance_usage-example-2-secret-data-geheim-enforce-mode">Example 2: Secret Data (geheim) - Enforce Mode<a class="headerlink" href="#governance_usage-example-2-secret-data-geheim-enforce-mode" title="Permanent link">&para;</a></h3>
<p><strong>Request:</strong></p>
<pre><code class="language-http">POST /vector/search
X-Classification: geheim
X-Governance-Mode: enforce
Content-Type: application/json

{
  &quot;vector&quot;: [0.1, 0.2, ...],
  &quot;k&quot;: 10
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-http">HTTP/1.1 403 Forbidden
X-Themis-Policy: classification=geheim;mode=enforce;encrypt_logs=true;redaction=strict
X-Themis-ANN: disabled

{
  &quot;error&quot;: true,
  &quot;message&quot;: &quot;Approximate vector search (ANN) is disabled for classification 'geheim'&quot;
}
</code></pre>
<h3 id="governance_usage-example-3-secret-data-geheim-observe-mode">Example 3: Secret Data (geheim) - Observe Mode<a class="headerlink" href="#governance_usage-example-3-secret-data-geheim-observe-mode" title="Permanent link">&para;</a></h3>
<p><strong>Request:</strong></p>
<pre><code class="language-http">POST /vector/search
X-Classification: geheim
X-Governance-Mode: observe
Content-Type: application/json

{
  &quot;vector&quot;: [0.1, 0.2, ...],
  &quot;k&quot;: 10
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-http">HTTP/1.1 200 OK
X-Themis-Policy: classification=geheim;mode=observe;encrypt_logs=true;redaction=strict
X-Themis-ANN: disabled
X-Themis-Policy-Warn: ann_disabled_but_observed
X-Themis-Export: forbidden
X-Themis-Cache: disabled
X-Themis-Retention-Days: 3650

{
  &quot;results&quot;: [...]
}
</code></pre>
<h3 id="governance_usage-example-4-content-import-with-encryption-requirement">Example 4: Content Import with Encryption Requirement<a class="headerlink" href="#governance_usage-example-4-content-import-with-encryption-requirement" title="Permanent link">&para;</a></h3>
<p><strong>Request:</strong></p>
<pre><code class="language-http">POST /content/import
X-Classification: streng-geheim
X-Governance-Mode: enforce
Content-Type: application/json

{
  &quot;content&quot;: {
    &quot;id&quot;: &quot;doc123&quot;,
    &quot;mime_type&quot;: &quot;application/pdf&quot;,
    &quot;encrypted&quot;: false
  },
  &quot;blob&quot;: &quot;base64encodeddata...&quot;
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-http">HTTP/1.1 422 Unprocessable Entity
X-Themis-Policy: classification=streng-geheim;mode=enforce;encrypt_logs=true;redaction=strict

{
  &quot;error&quot;: true,
  &quot;message&quot;: &quot;Content encryption required for classification 'streng-geheim'&quot;
}
</code></pre>
<h3 id="governance_usage-example-5-default-classification-from-resource-mapping">Example 5: Default Classification from Resource Mapping<a class="headerlink" href="#governance_usage-example-5-default-classification-from-resource-mapping" title="Permanent link">&para;</a></h3>
<p><strong>Request:</strong></p>
<pre><code class="language-http">GET /admin/backup
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-http">HTTP/1.1 200 OK
X-Themis-Policy: classification=vs-nfd;mode=enforce;encrypt_logs=true;redaction=standard
X-Themis-Retention-Days: 1825

{
  &quot;status&quot;: &quot;ok&quot;
}
</code></pre>
<h2 id="governance_usage-classification-profiles">Classification Profiles<a class="headerlink" href="#governance_usage-classification-profiles" title="Permanent link">&para;</a></h2>
<h3 id="governance_usage-offen-public">offen (Public)<a class="headerlink" href="#governance_usage-offen-public" title="Permanent link">&para;</a></h3>
<ul>
<li>No encryption required</li>
<li>ANN allowed</li>
<li>Export/cache allowed</li>
<li>1 year retention</li>
</ul>
<h3 id="governance_usage-vs-nfd-restricted">vs-nfd (Restricted)<a class="headerlink" href="#governance_usage-vs-nfd-restricted" title="Permanent link">&para;</a></h3>
<ul>
<li>Encryption required</li>
<li>ANN allowed</li>
<li>Export/cache allowed</li>
<li>5 years retention</li>
</ul>
<h3 id="governance_usage-geheim-secret">geheim (Secret)<a class="headerlink" href="#governance_usage-geheim-secret" title="Permanent link">&para;</a></h3>
<ul>
<li>Encryption required</li>
<li><strong>ANN disabled</strong> (exact search only)</li>
<li>Export/cache forbidden</li>
<li>10 years retention</li>
</ul>
<h3 id="governance_usage-streng-geheim-top-secret">streng-geheim (Top Secret)<a class="headerlink" href="#governance_usage-streng-geheim-top-secret" title="Permanent link">&para;</a></h3>
<ul>
<li>Encryption required</li>
<li><strong>ANN disabled</strong></li>
<li>Export/cache forbidden</li>
<li>20 years retention</li>
</ul>
<h2 id="governance_usage-gradual-rollout-with-observe-mode">Gradual Rollout with Observe Mode<a class="headerlink" href="#governance_usage-gradual-rollout-with-observe-mode" title="Permanent link">&para;</a></h2>
<p>Use <code>X-Governance-Mode: observe</code> to test policies without enforcement:</p>
<ol>
<li>Deploy with <code>default_mode: observe</code> in <code>governance.yaml</code></li>
<li>Monitor <code>X-Themis-Policy-Warn</code> headers in production</li>
<li>Identify and fix policy violations</li>
<li>Switch to <code>default_mode: enforce</code></li>
</ol>
<h2 id="governance_usage-policy-customization">Policy Customization<a class="headerlink" href="#governance_usage-policy-customization" title="Permanent link">&para;</a></h2>
<p>Edit <code>config/governance.yaml</code> to customize:
- Classification levels and their properties
- Resource-to-classification mappings
- Default enforcement mode
- Retention periods
- SAGA signing and log encryption settings</p>
<p>Changes take effect after server restart (hot-reload planned for future).</p>
<h2 id="governance_usage-integration-with-encryption">Integration with Encryption<a class="headerlink" href="#governance_usage-integration-with-encryption" title="Permanent link">&para;</a></h2>
<p>The governance engine works with the encryption strategy:
- <code>encryption_required: true</code> → Data-at-rest encryption mandatory
- <code>log_encryption: true</code> → SAGA/Audit logs encrypted before PKI signing (Encrypt-then-Sign)
- Classification determines key hierarchy and access controls</p>
<h2 id="governance_usage-compliance-frameworks">Compliance Frameworks<a class="headerlink" href="#governance_usage-compliance-frameworks" title="Permanent link">&para;</a></h2>
<p>Supported frameworks (configurable in <code>governance.yaml</code>):
- GDPR (EU General Data Protection Regulation)
- VSA (German Federal Classification System)
- BSI-C5 (German Cloud Security Standard)</p>
<h2 id="governance_usage-api-reference">API Reference<a class="headerlink" href="#governance_usage-api-reference" title="Permanent link">&para;</a></h2>
<h3 id="governance_usage-get-tsconfig">GET /ts/config<a class="headerlink" href="#governance_usage-get-tsconfig" title="Permanent link">&para;</a></h3>
<p>Returns current time-series compression configuration.</p>
<h3 id="governance_usage-put-tsconfig">PUT /ts/config<a class="headerlink" href="#governance_usage-put-tsconfig" title="Permanent link">&para;</a></h3>
<p>Updates time-series compression settings.</p>
<h3 id="governance_usage-all-endpoints">All Endpoints<a class="headerlink" href="#governance_usage-all-endpoints" title="Permanent link">&para;</a></h3>
<p>All endpoints respect governance headers and return policy decisions in response headers.</p>
<h2 id="governance_usage-testing">Testing<a class="headerlink" href="#governance_usage-testing" title="Permanent link">&para;</a></h2>
<p>Test policy enforcement with curl:</p>
<pre><code class="language-bash"># Test ANN restriction (enforce)
curl -X POST http://localhost:8080/vector/search \
  -H &quot;X-Classification: geheim&quot; \
  -H &quot;X-Governance-Mode: enforce&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;vector&quot;: [0.1, 0.2], &quot;k&quot;: 10}'
# Expected: 403 Forbidden

# Test ANN restriction (observe)
curl -X POST http://localhost:8080/vector/search \
  -H &quot;X-Classification: geheim&quot; \
  -H &quot;X-Governance-Mode: observe&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;vector&quot;: [0.1, 0.2], &quot;k&quot;: 10}'
# Expected: 200 OK with X-Themis-Policy-Warn header
</code></pre>
<h3 id="governance_usage-gezielte-testlaufe-ctest">Gezielte Testläufe (CTest)<a class="headerlink" href="#governance_usage-gezielte-testlaufe-ctest" title="Permanent link">&para;</a></h3>
<p>Unter Windows PowerShell lassen sich gezielt nur Governance- oder Time-Series-Tests ausführen. Beispiele (aus <code>build/</code>):</p>
<pre><code class="language-powershell"># Alle Governance-Tests (mehrere Suites via Regex)
ctest -C Release -R &quot;StatsApiTest|MetricsApiTest|HttpRangeIndexTest|HttpGovernanceTest&quot; --output-on-failure

# Nur drei spezifische Governance-Fälle
ctest -C Release -R &quot;HttpGovernanceTest.Classification_VsNfd_RequiresEncryption|HttpGovernanceTest.ResourceMapping_AppliesClassification|HttpGovernanceTest.RetentionDays_ReturnsPolicy&quot; --output-on-failure

# Alle Time-Series-bezogenen Suites
ctest -C Release -R &quot;^HttpTimeSeriesTest\.|^TSStoreTest\.|^GorillaCodecTest\.|^ContinuousAggTest\.&quot; --output-on-failure
</code></pre>
<p>Tipps:
- Verwende Anker (<code>^</code>) und das Escapen des Punkts (<code>\.</code>) für exakte Präfix-Matches.
- In PowerShell sind doppelte Anführungszeichen empfohlen, damit Regex-Sonderzeichen korrekt übergeben werden.</p>
<h2 id="governance_usage-future-enhancements">Future Enhancements<a class="headerlink" href="#governance_usage-future-enhancements" title="Permanent link">&para;</a></h2>
<p>Planned features:
- Hot-reload of <code>governance.yaml</code> without restart
- Per-user classification overrides (via JWT claims)
- Audit trail for policy violations
- Automated compliance reports
- Field-level encryption based on classification</p></section><section class="print-page" id="security-security_compliance_review" heading-number="12.18"><h1 id="security-security_compliance_review-security-compliance-review">Security &amp; Compliance Review<a class="headerlink" href="#security-security_compliance_review-security-compliance-review" title="Permanent link">&para;</a></h1>
<p>Dieses Dokument fasst den Sicherheits- und Compliance-Status von ThemisDB zusammen, verlinkt die relevanten Detaildokumente und enthält eine überprüfbare Checkliste für Audits.</p>
<h2 id="security-security_compliance_review-geltungsbereich">Geltungsbereich<a class="headerlink" href="#security-security_compliance_review-geltungsbereich" title="Permanent link">&para;</a></h2>
<ul>
<li>Daten-at-Rest und Daten-in-Transit</li>
<li>Schlüsselverwaltung und Kryptokonfiguration</li>
<li>PII-Erkennung, Audit/Retention</li>
<li>Härtung, Bedrohungsmodell, Betriebsprozesse</li>
<li>Compliance-Mappings (GDPR/DSGVO, ISO 27001-nahe Praktiken)</li>
</ul>
<h2 id="security-security_compliance_review-referenz-dokumente">Referenz-Dokumente<a class="headerlink" href="#security-security_compliance_review-referenz-dokumente" title="Permanent link">&para;</a></h2>
<ul>
<li>Überblick: <a href="#security-overview">Security Overview</a></li>
<li>Schlüsselverwaltung: <a href="#security-key_management">Key Management</a></li>
<li>Verschlüsselung: <a href="#encryption_strategy">Encryption Strategy</a>, <a href="#encryption_deployment">Encryption Deployment</a>, <a href="#column_encryption">Column Encryption</a></li>
<li>PII: <a href="#security-pii_detection">PII Detection (Overview)</a>, <a href="#pii_detection_engines">PII Engines</a>, <a href="#pii_engine_signing">PII Engine Signing</a></li>
<li>Audit &amp; Retention: <a href="#security-audit_and_retention">Audit &amp; Retention</a></li>
<li>Threat Modeling: <a href="#security-threat_model">Threat Model</a></li>
<li>Hardening: <a href="#security_hardening_guide">Security Hardening Guide</a></li>
<li>Compliance: <a href="#compliance_audit">Compliance Audit</a>, <a href="#compliance_governance_strategy">Governance-Strategie</a>, <a href="#compliance_integration">Compliance-Integration</a>, <a href="#governance_usage">Governance Usage</a></li>
<li>Operations: <a href="#deployment">Deployment &amp; Betrieb</a>, <a href="#operations_runbook">Operations Runbook</a>, <a href="#tracing">Tracing &amp; Observability</a></li>
</ul>
<h2 id="security-security_compliance_review-audit-checkliste-kernpunkte">Audit-Checkliste (Kernpunkte)<a class="headerlink" href="#security-security_compliance_review-audit-checkliste-kernpunkte" title="Permanent link">&para;</a></h2>
<ul>
<li>Kryptographie</li>
<li>Transportverschlüsselung (TLS/Reverse Proxy) konfiguriert</li>
<li>At-Rest: Komponentenspezifische Verschlüsselung (SST/Blob/Spalten) bewertet und konfiguriert</li>
<li>Schlüsselrotation, KMS-Integration (Konzept &amp; Schnittstellen) dokumentiert</li>
<li>Zugriff &amp; AuthZ</li>
<li>Admin-Endpoints abgesichert, sensible Operationen geloggt</li>
<li>Optionales RBAC/Scopes (Roadmap) definiert</li>
<li>PII &amp; Datenschutz</li>
<li>PII-Detection Flows und Ausnahmenprozess dokumentiert</li>
<li>Retention-Policies (TTL/Archivierung) technisch verankert</li>
<li>Auditierbarkeit</li>
<li>Audit-Events definiert (Create/Update/Delete, Indexops, Admin)</li>
<li>Retention &amp; Export der Auditdaten beschrieben</li>
<li>Härtung</li>
<li>Container/K8s Best Practices, minimaler OS-Footprint, Secrets-Handling</li>
<li>Angriffspunkte aus Threat Model gemappt auf Mitigations</li>
<li>Observability &amp; Incident Response</li>
<li>Prometheus-/Tracing-Integration, Alarme (SLOs) vorhanden</li>
<li>Runbook: Playbooks für Ausfälle, Rebuilds, Backups</li>
</ul>
<h2 id="security-security_compliance_review-verifikation-stichproben">Verifikation (Stichproben)<a class="headerlink" href="#security-security_compliance_review-verifikation-stichproben" title="Permanent link">&para;</a></h2>
<ul>
<li>/metrics enthält sicherheitsrelevante Zähler (z. B. Fehler, Auth-Fehlschläge sofern implementiert)</li>
<li>Konfiguration (Secrets, Ports, CORS) in <code>deployment.md</code>/<code>docker-compose.yml</code> nachvollziehbar</li>
<li>CDC-/SSE-Endpunkte: Hinweis auf Reverse-Proxy-Konfiguration (TLS, Timeouts)</li>
</ul>
<h2 id="security-security_compliance_review-offene-punkte-empfehlungen">Offene Punkte / Empfehlungen<a class="headerlink" href="#security-security_compliance_review-offene-punkte-empfehlungen" title="Permanent link">&para;</a></h2>
<ul>
<li>RBAC/Policies: Ausarbeitung und Implementierungsfahrplan (siehe Roadmap)</li>
<li>Keys at rest: Optionale Integration externer KMS (HashiCorp Vault, AWS KMS)</li>
<li>Secrets-Scanning in CI (gitleaks) und SBOM/Signaturen (Syft/Cosign)</li>
<li>Penetrationstest-Checkliste ergänzen; Fuzzing-Pfade (Parser) prüfen</li>
</ul>
<h2 id="security-security_compliance_review-anderungsverlauf">Änderungsverlauf<a class="headerlink" href="#security-security_compliance_review-anderungsverlauf" title="Permanent link">&para;</a></h2>
<ul>
<li>2025-11-02: Erstveröffentlichung der konsolidierten Review-Seite</li>
</ul></section></section>
                    <section class='print-page md-section' id='section-13' heading-number='13'>
                        <h1>Deployment & Betrieb<a class='headerlink' href='#section-13' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="deployment" heading-number="13.1"><h1 id="deployment-themis-deployment-guide">THEMIS Deployment Guide<a class="headerlink" href="#deployment-themis-deployment-guide" title="Permanent link">&para;</a></h1>
<h2 id="deployment-table-of-contents">Table of Contents<a class="headerlink" href="#deployment-table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#deployment-system-requirements">System Requirements</a></li>
<li><a href="#deployment-installation-methods">Installation Methods</a></li>
<li><a href="#deployment-configuration">Configuration</a></li>
<li><a href="#deployment-production-deployment">Production Deployment</a></li>
<li><a href="#deployment-monitoring--observability">Monitoring &amp; Observability</a></li>
<li><a href="#deployment-backup--recovery">Backup &amp; Recovery</a></li>
<li><a href="#deployment-performance-tuning">Performance Tuning</a></li>
<li><a href="#deployment-security">Security</a></li>
<li><a href="#deployment-troubleshooting">Troubleshooting</a></li>
</ol>
<h2 id="deployment-system-requirements">System Requirements<a class="headerlink" href="#deployment-system-requirements" title="Permanent link">&para;</a></h2>
<h3 id="deployment-minimum-requirements">Minimum Requirements<a class="headerlink" href="#deployment-minimum-requirements" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>CPU</strong>: 4 cores (x86_64 or ARM64)</li>
<li><strong>RAM</strong>: 2 GB (1 GB for RocksDB, 1 GB for system/buffers)</li>
<li><strong>Disk</strong>: 20 GB SSD (NVMe recommended)</li>
<li><strong>OS</strong>: Windows 10/11, Linux (Ubuntu 20.04+, RHEL 8+), macOS 12+</li>
<li><strong>Network</strong>: 1 Gbps (for distributed deployments)</li>
</ul>
<h3 id="deployment-recommended-requirements">Recommended Requirements<a class="headerlink" href="#deployment-recommended-requirements" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>CPU</strong>: 8+ cores (Intel Xeon, AMD EPYC, or Apple Silicon M-series)</li>
<li><strong>RAM</strong>: 8 GB (4 GB block cache, 1 GB memtable, 3 GB system)</li>
<li><strong>Disk</strong>: 100 GB+ NVMe SSD (read: 3000 MB/s, write: 1500 MB/s)</li>
<li><strong>OS</strong>: Linux (kernel 5.10+) for production workloads</li>
<li><strong>Network</strong>: 10 Gbps (low-latency network for replication)</li>
</ul>
<h2 id="deployment-installation-methods">Installation Methods<a class="headerlink" href="#deployment-installation-methods" title="Permanent link">&para;</a></h2>
<h3 id="deployment-method-1-binary-release-recommended-for-production">Method 1: Binary Release (Recommended for Production)<a class="headerlink" href="#deployment-method-1-binary-release-recommended-for-production" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Download latest release
wget https://github.com/&lt;org&gt;/vccdb/releases/download/v1.0.0/vccdb-linux-x64.tar.gz

# Extract
tar -xzf vccdb-linux-x64.tar.gz
cd vccdb

# Verify installation
./themis_server --version
# Output: THEMIS v1.0.0 (build: 2025-10-28, commit: abc1234)
</code></pre>
<h3 id="deployment-method-2-docker-recommended-for-containers">Method 2: Docker (Recommended for Containers)<a class="headerlink" href="#deployment-method-2-docker-recommended-for-containers" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Pull image
docker pull vccdb/vccdb:latest

# Run with persistent storage
docker run -d \
  --name vccdb \
  -p 8765:8765 \
  -v $(pwd)/data:/data \
  -v $(pwd)/config.json:/etc/vccdb/config.json \
  vccdb/vccdb:latest

# Check logs
docker logs -f vccdb
</code></pre>
<h3 id="deployment-method-3-build-from-source-development">Method 3: Build from Source (Development)<a class="headerlink" href="#deployment-method-3-build-from-source-development" title="Permanent link">&para;</a></h3>
<pre><code class="language-powershell"># Windows (PowerShell)
git clone https://github.com/&lt;org&gt;/vccdb.git
cd vccdb
.\setup.ps1      # Install vcpkg dependencies
.\build.ps1      # Build Release binaries
</code></pre>
<pre><code class="language-bash"># Linux/macOS (Bash)
git clone https://github.com/&lt;org&gt;/vccdb.git
cd vccdb
./setup.sh       # Install dependencies
./build.sh       # Build Release binaries
</code></pre>
<h2 id="deployment-configuration">Configuration<a class="headerlink" href="#deployment-configuration" title="Permanent link">&para;</a></h2>
<h3 id="deployment-basic-configuration-configjson">Basic Configuration (<code>config.json</code>)<a class="headerlink" href="#deployment-basic-configuration-configjson" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;storage&quot;: {
    &quot;rocksdb_path&quot;: &quot;/var/lib/vccdb/data&quot;,
    &quot;memtable_size_mb&quot;: 256,
    &quot;block_cache_size_mb&quot;: 1024,
    &quot;max_open_files&quot;: 10000,
    &quot;enable_statistics&quot;: true,
    &quot;compression&quot;: {
      &quot;default&quot;: &quot;lz4&quot;,
      &quot;bottommost&quot;: &quot;zstd&quot;
    }
  },
  &quot;server&quot;: {
    &quot;host&quot;: &quot;0.0.0.0&quot;,
    &quot;port&quot;: 8765,
    &quot;worker_threads&quot;: 8,
    &quot;request_timeout_ms&quot;: 30000,
    &quot;max_request_size_mb&quot;: 10
  },
  &quot;logging&quot;: {
    &quot;level&quot;: &quot;info&quot;,
    &quot;file&quot;: &quot;/var/log/vccdb/server.log&quot;,
    &quot;rotation_size_mb&quot;: 100,
    &quot;max_files&quot;: 10
  },
  &quot;vector_index&quot;: {
    &quot;engine&quot;: &quot;hnsw&quot;,
    &quot;hnsw_m&quot;: 16,
    &quot;hnsw_ef_construction&quot;: 200,
    &quot;use_gpu&quot;: false
  }
}
</code></pre>
<h3 id="deployment-environment-variables">Environment Variables<a class="headerlink" href="#deployment-environment-variables" title="Permanent link">&para;</a></h3>
<p>Override config values with environment variables:</p>
<pre><code class="language-bash">export THEMIS_SERVER_PORT=9000
export THEMIS_STORAGE_PATH=/mnt/nvme/vccdb
export THEMIS_LOG_LEVEL=debug
export THEMIS_WORKER_THREADS=16

./themis_server --config config.json
# Port 9000, custom storage path, debug logging, 16 threads
</code></pre>
<h3 id="deployment-configuration-validation">Configuration Validation<a class="headerlink" href="#deployment-configuration-validation" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Validate config before starting server
./themis_server --config config.json --validate

# Output:
# ✓ Config file valid
# ✓ Storage path accessible: /var/lib/vccdb/data
# ✓ Port 8765 available
# ✓ Memory limits: memtable (256 MB) + block_cache (1024 MB) = 1280 MB
# ✓ Worker threads: 8 (optimal for 8-core CPU)
</code></pre>
<h3 id="deployment-runtime-configuration-hot-reload">Runtime Configuration (Hot-Reload)<a class="headerlink" href="#deployment-runtime-configuration-hot-reload" title="Permanent link">&para;</a></h3>
<p>THEMIS supports <strong>hot-reload</strong> for specific configuration values without requiring a server restart.</p>
<h4 id="deployment-supported-hot-reload-settings">Supported Hot-Reload Settings<a class="headerlink" href="#deployment-supported-hot-reload-settings" title="Permanent link">&para;</a></h4>
<p>The following settings can be updated at runtime via <code>POST /config</code>:</p>
<ol>
<li><strong>Logging Configuration</strong></li>
<li><code>logging.level</code>: "trace", "debug", "info", "warn", "error"</li>
<li>
<p><code>logging.format</code>: "text" (human-readable), "json" (structured logs for aggregation)</p>
</li>
<li>
<p><strong>Request Timeout</strong></p>
</li>
<li>
<p><code>request_timeout_ms</code>: 1000-300000 (1 second to 5 minutes)</p>
</li>
<li>
<p><strong>Feature Flags</strong> (Beta features)</p>
</li>
<li><code>features.semantic_cache</code>: Enable/disable semantic query caching</li>
<li><code>features.llm_store</code>: Enable/disable LLM interaction storage</li>
<li><code>features.cdc</code>: Enable/disable Change Data Capture streaming</li>
<li>
<p><code>features.timeseries</code>: Enable/disable time-series data store</p>
</li>
<li>
<p><strong>CDC Retention Policy</strong> (Logging only - requires manual cleanup)</p>
</li>
<li><code>cdc_retention_hours</code>: 1-8760 (1 hour to 1 year)</li>
</ol>
<h4 id="deployment-hot-reload-examples">Hot-Reload Examples<a class="headerlink" href="#deployment-hot-reload-examples" title="Permanent link">&para;</a></h4>
<p><strong>Example 1: Enable JSON Logging</strong></p>
<pre><code class="language-bash">curl -X POST http://localhost:8765/config \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;logging&quot;: {
      &quot;level&quot;: &quot;info&quot;,
      &quot;format&quot;: &quot;json&quot;
    }
  }'

# Response: Updated config with all current settings
# Server logs now output structured JSON
</code></pre>
<p><strong>Example 2: Update Request Timeout</strong></p>
<pre><code class="language-bash">curl -X POST http://localhost:8765/config \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;request_timeout_ms&quot;: 60000
  }'

# Timeout increased to 60 seconds for long-running queries
</code></pre>
<p><strong>Example 3: Enable CDC Feature</strong></p>
<pre><code class="language-bash">curl -X POST http://localhost:8765/config \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;features&quot;: {
      &quot;cdc&quot;: true
    }
  }'

# CDC streaming endpoints now accessible: /changefeed/stream
</code></pre>
<p><strong>Example 4: Multiple Settings at Once</strong></p>
<pre><code class="language-bash">curl -X POST http://localhost:8765/config \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;logging&quot;: {
      &quot;level&quot;: &quot;debug&quot;,
      &quot;format&quot;: &quot;json&quot;
    },
    &quot;request_timeout_ms&quot;: 45000,
    &quot;features&quot;: {
      &quot;semantic_cache&quot;: true,
      &quot;cdc&quot;: true
    }
  }'
</code></pre>
<h4 id="deployment-limitations">Limitations<a class="headerlink" href="#deployment-limitations" title="Permanent link">&para;</a></h4>
<p><strong>Cannot be changed at runtime (requires restart):</strong></p>
<ul>
<li><code>server.port</code>: HTTP server port</li>
<li><code>server.threads</code>: Number of worker threads (thread pool is fixed at startup)</li>
<li><code>rocksdb.*</code>: All RocksDB storage settings (memtable size, block cache, compression, etc.)</li>
<li><code>vector.dimension</code>: Vector index dimensionality</li>
<li>Data directory paths</li>
</ul>
<p><strong>Validation Rules:</strong></p>
<ul>
<li><code>request_timeout_ms</code>: Must be between 1000 and 300000 (1s-5min)</li>
<li><code>cdc_retention_hours</code>: Must be between 1 and 8760 (1h-1yr)</li>
<li>Feature flags: Boolean values only</li>
</ul>
<h4 id="deployment-verify-current-configuration">Verify Current Configuration<a class="headerlink" href="#deployment-verify-current-configuration" title="Permanent link">&para;</a></h4>
<pre><code class="language-bash"># GET current config
curl http://localhost:8765/config | jq .

# Output includes all settings (read-only + hot-reload capable)
{
  &quot;server&quot;: {
    &quot;port&quot;: 8765,
    &quot;threads&quot;: 8,
    &quot;request_timeout_ms&quot;: 30000
  },
  &quot;features&quot;: {
    &quot;semantic_cache&quot;: false,
    &quot;llm_store&quot;: false,
    &quot;cdc&quot;: true,
    &quot;timeseries&quot;: false
  },
  &quot;rocksdb&quot;: {
    &quot;db_path&quot;: &quot;/var/lib/vccdb/data&quot;,
    &quot;memtable_size_mb&quot;: 256,
    ...
  }
}
</code></pre>
<h2 id="deployment-production-deployment">Production Deployment<a class="headerlink" href="#deployment-production-deployment" title="Permanent link">&para;</a></h2>
<h3 id="deployment-systemd-service-linux">Systemd Service (Linux)<a class="headerlink" href="#deployment-systemd-service-linux" title="Permanent link">&para;</a></h3>
<p>Create <code>/etc/systemd/system/vccdb.service</code>:</p>
<pre><code class="language-ini">[Unit]
Description=THEMIS Multi-Model Database Server
After=network.target

[Service]
Type=simple
User=vccdb
Group=vccdb
WorkingDirectory=/opt/vccdb
ExecStart=/opt/vccdb/themis_server --config /etc/vccdb/config.json
Restart=on-failure
RestartSec=10

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/vccdb /var/log/vccdb

# Resource limits
LimitNOFILE=65536
MemoryMax=8G
CPUQuota=800%

[Install]
WantedBy=multi-user.target
</code></pre>
<pre><code class="language-bash"># Enable and start service
sudo systemctl daemon-reload
sudo systemctl enable vccdb
sudo systemctl start vccdb

# Check status
sudo systemctl status vccdb
sudo journalctl -u vccdb -f
</code></pre>
<h3 id="deployment-docker-compose-container-orchestration">Docker Compose (Container Orchestration)<a class="headerlink" href="#deployment-docker-compose-container-orchestration" title="Permanent link">&para;</a></h3>
<p>Hinweis zu Ports:
- Der mitgelieferte <code>docker-compose.yml</code> im Repository nutzt standardmäßig Port <code>8080</code> (Mapping <code>8080:8080</code>).
- In den Beispielen dieses Guides wird Port <code>8765</code> verwendet. Passe den Port in Compose entsprechend an (oder setze <code>THEMIS_PORT</code>).</p>
<p>Create <code>docker-compose.yml</code>:</p>
<pre><code class="language-yaml">version: '3.8'

services:
  vccdb:
    image: vccdb/vccdb:latest
    container_name: vccdb
    ports:
  - &quot;8765:8765&quot;  # ggf. zu &quot;8080:8080&quot; anpassen, wenn Image/Entrypoint 8080 nutzt
    volumes:
      - vccdb-data:/data
      - ./config.json:/etc/vccdb/config.json:ro
    environment:
      - THEMIS_LOG_LEVEL=info
      - THEMIS_WORKER_THREADS=8
    restart: unless-stopped
    healthcheck:
      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:8765/health&quot;]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '8'
          memory: 8G
        reservations:
          cpus: '4'
          memory: 4G

  prometheus:
    image: prom/prometheus:latest
    ports:
      - &quot;9090:9090&quot;
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'

  grafana:
    image: grafana/grafana:latest
    ports:
      - &quot;3000:3000&quot;
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana-dashboards:/etc/grafana/provisioning/dashboards:ro
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_INSTALL_PLUGINS=grafana-piechart-panel

volumes:
  vccdb-data:
  prometheus-data:
  grafana-data:
</code></pre>
<pre><code class="language-bash"># Start stack
docker-compose up -d

# View logs
docker-compose logs -f vccdb

# Scale (if using load balancer)
docker-compose up -d --scale vccdb=3
</code></pre>
<h3 id="deployment-kubernetes-deployment">Kubernetes Deployment<a class="headerlink" href="#deployment-kubernetes-deployment" title="Permanent link">&para;</a></h3>
<p>Create <code>k8s/deployment.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: vccdb-config
data:
  config.json: |
    {
      &quot;storage&quot;: {
        &quot;rocksdb_path&quot;: &quot;/data/vccdb&quot;,
        &quot;memtable_size_mb&quot;: 512,
        &quot;block_cache_size_mb&quot;: 2048
      },
      &quot;server&quot;: {
        &quot;host&quot;: &quot;0.0.0.0&quot;,
        &quot;port&quot;: 8765,
        &quot;worker_threads&quot;: 16
      }
    }
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: vccdb-data
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: fast-ssd
  resources:
    requests:
      storage: 100Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vccdb
  labels:
    app: vccdb
spec:
  replicas: 3
  selector:
    matchLabels:
      app: vccdb
  template:
    metadata:
      labels:
        app: vccdb
      annotations:
        prometheus.io/scrape: &quot;true&quot;
        prometheus.io/port: &quot;8765&quot;
        prometheus.io/path: &quot;/metrics&quot;
    spec:
      containers:
      - name: vccdb
        image: vccdb/vccdb:latest
        ports:
        - containerPort: 8765
          name: http
        volumeMounts:
        - name: data
          mountPath: /data
        - name: config
          mountPath: /etc/vccdb
          readOnly: true
        resources:
          requests:
            cpu: 4000m
            memory: 8Gi
          limits:
            cpu: 8000m
            memory: 16Gi
        livenessProbe:
          httpGet:
            path: /health
            port: 8765
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8765
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: vccdb-data
      - name: config
        configMap:
          name: vccdb-config
---
apiVersion: v1
kind: Service
metadata:
  name: vccdb
  labels:
    app: vccdb
spec:
  type: ClusterIP
  ports:
  - port: 8765
    targetPort: 8765
    protocol: TCP
    name: http
  selector:
    app: vccdb
</code></pre>
<pre><code class="language-bash"># Deploy to Kubernetes
kubectl apply -f k8s/deployment.yaml

# Check status
kubectl get pods -l app=vccdb
kubectl logs -l app=vccdb -f

# Expose externally (LoadBalancer)
kubectl expose deployment vccdb --type=LoadBalancer --port=8765
</code></pre>
<h2 id="deployment-monitoring-observability">Monitoring &amp; Observability<a class="headerlink" href="#deployment-monitoring-observability" title="Permanent link">&para;</a></h2>
<h3 id="deployment-reverse-proxy-und-ssekeep-alive-hinweise">Reverse Proxy und SSE/Keep-Alive Hinweise<a class="headerlink" href="#deployment-reverse-proxy-und-ssekeep-alive-hinweise" title="Permanent link">&para;</a></h3>
<p>Server‑Sent Events (SSE) nutzen eine langlebige HTTP/1.1‑Verbindung mit kontinuierlichen Datenflüssen. Für stabile Streams sollten Reverse Proxies und Load Balancer speziell konfiguriert werden:</p>
<ul>
<li>HTTP/1.1 erzwingen und Keep‑Alive aktiv halten</li>
<li>Timeouts großzügig setzen (Lese‑/Idle‑Timeout ≥ 60s)</li>
<li>Pufferung und Komprimierung für SSE deaktivieren</li>
<li>Sticky Sessions/Session Affinity aktivieren, wenn mehrere Backend‑Instanzen genutzt werden</li>
</ul>
<p>Beispiele:</p>
<p>1) Nginx</p>
<pre><code>location /changefeed/stream {
  proxy_http_version 1.1;
  proxy_set_header Connection &quot;&quot;;           # Keep-Alive nicht explizit schließen
  proxy_set_header Cache-Control no-cache;
  proxy_buffering off;                       # wichtig für SSE
  gzip off;                                  # keine Komprimierung für SSE
  chunked_transfer_encoding on;
  proxy_read_timeout 120s;                   # ausreichend hoch
  proxy_send_timeout 120s;
}
</code></pre>
<p>2) HAProxy</p>
<pre><code>frontend http
  bind *:80
  default_backend app

backend app
  option http-keep-alive
  option http-server-close          # optional je nach Setup
  timeout server  120s
  timeout client  120s
  timeout http-keep-alive 120s
  http-response set-header Cache-Control no-cache
</code></pre>
<p>3) Windows/IIS (Beispielauszug web.config)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;configuration&gt;
  &lt;system.webServer&gt;
    &lt;httpProtocol&gt;
      &lt;customHeaders&gt;
        &lt;add name=&quot;Cache-Control&quot; value=&quot;no-cache&quot; /&gt;
      &lt;/customHeaders&gt;
    &lt;/httpProtocol&gt;
    &lt;serverRuntime frequentHitThreshold=&quot;1&quot; frequentHitTimePeriod=&quot;00:00:10&quot; /&gt;
    &lt;httpCompression directory=&quot;%SystemDrive%\\inetpub\\temp\\IIS Temporary Compressed Files&quot;&gt;
      &lt;dynamicTypes&gt;
        &lt;add enabled=&quot;false&quot; mimeType=&quot;text/event-stream&quot; /&gt;
      &lt;/dynamicTypes&gt;
    &lt;/httpCompression&gt;
    &lt;handlers&gt;
      &lt;add name=&quot;SSE&quot; path=&quot;changefeed/stream&quot; verb=&quot;GET&quot; modules=&quot;IsapiModule&quot; scriptProcessor=&quot;%windir%\\system32\\inetsrv\\asp.dll&quot; resourceType=&quot;Unspecified&quot; requireAccess=&quot;Read&quot; /&gt;
    &lt;/handlers&gt;
  &lt;/system.webServer&gt;
&lt;/configuration&gt;
</code></pre>
<p>Zusätzlich in der Anwendungspool‑Konfiguration Idle‑Timeout ≥ 2 Minuten setzen und ggf. Request Filtering Limits (z. B. responseBufferLimit) erhöhen/abschalten.</p>
<p>Hinweis: Detaillierte Betriebsaspekte zum CDC‑Stream siehe <code>docs/change_data_capture.md</code>.</p>
<h3 id="deployment-prometheus-configuration">Prometheus Configuration<a class="headerlink" href="#deployment-prometheus-configuration" title="Permanent link">&para;</a></h3>
<p>Create <code>prometheus.yml</code>:</p>
<pre><code class="language-yaml">global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'vccdb'
    static_configs:
      - targets: ['vccdb:8765']
    metrics_path: /metrics
</code></pre>
<p>Zusätzliche, themis-spezifische Metriken (Auszug):
- <code>themis_index_rebuild_count</code>, <code>themis_index_rebuild_duration_ms_total</code>, <code>themis_index_rebuild_entities_processed_total</code>
- <code>themis_index_cursor_anchor_hits_total</code>, <code>themis_index_range_scan_steps_total</code>
Siehe auch: <code>docs/index_stats_maintenance.md</code>.</p>
<h3 id="deployment-cdc-quick-start-ops">CDC Quick Start (Ops)<a class="headerlink" href="#deployment-cdc-quick-start-ops" title="Permanent link">&para;</a></h3>
<p>1) Feature aktivieren (config/config.json):</p>
<pre><code class="language-json">{
  &quot;features&quot;: { &quot;cdc&quot;: true }
}
</code></pre>
<p>2) Endpoint prüfen:</p>
<pre><code class="language-bash">curl &quot;http://localhost:8765/changefeed?from_seq=0&amp;limit=1&quot;
</code></pre>
<p>3) Reverse Proxy für SSE konfigurieren, falls <code>/changefeed/stream</code> genutzt wird (siehe Hinweise oben) und Details in <code>docs/change_data_capture.md</code>.</p>
<h3 id="deployment-grafana-dashboard">Grafana Dashboard<a class="headerlink" href="#deployment-grafana-dashboard" title="Permanent link">&para;</a></h3>
<p>Key metrics to monitor:</p>
<p><strong>Server Metrics:</strong>
- <code>vccdb_requests_total</code> (counter): Total requests
- <code>vccdb_errors_total</code> (counter): Total errors
- <code>vccdb_qps</code> (gauge): Queries per second
- <code>process_uptime_seconds</code> (gauge): Server uptime</p>
<p><strong>RocksDB Metrics:</strong>
- <code>rocksdb_block_cache_usage_bytes</code> / <code>rocksdb_block_cache_capacity_bytes</code>: Cache utilization
- <code>rocksdb_estimate_num_keys</code>: Total entities in database
- <code>rocksdb_pending_compaction_bytes</code>: Compaction backlog
- <code>rocksdb_memtable_size_bytes</code>: Write buffer usage
- <code>rocksdb_files_level{level="L0...L6"}</code>: SST files per level</p>
<p><strong>Query Metrics:</strong>
- Request latency (p50, p95, p99)
- Index hit rate
- Full scan fallback rate</p>
<h3 id="deployment-alerting-rules">Alerting Rules<a class="headerlink" href="#deployment-alerting-rules" title="Permanent link">&para;</a></h3>
<p>Create <code>alerts.yml</code>:</p>
<pre><code class="language-yaml">groups:
  - name: vccdb_alerts
    interval: 30s
    rules:
      - alert: THEMISHighErrorRate
        expr: rate(vccdb_errors_total[5m]) &gt; 10
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: &quot;High error rate detected&quot;
          description: &quot;Error rate is {{ $value }} errors/sec&quot;

      - alert: THEMISLowCacheHitRate
        expr: |
          rocksdb_block_cache_hit / 
          (rocksdb_block_cache_hit + rocksdb_block_cache_miss) &lt; 0.8
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: &quot;Low block cache hit rate&quot;
          description: &quot;Cache hit rate is {{ $value | humanizePercentage }}&quot;

      - alert: THEMISHighCompactionBacklog
        expr: rocksdb_pending_compaction_bytes &gt; 10737418240  # 10 GB
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: &quot;High compaction backlog&quot;
          description: &quot;Pending compaction: {{ $value | humanize1024 }}B&quot;

      - alert: THEMISDown
        expr: up{job=&quot;themis&quot;} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: &quot;THEMIS server is down&quot;
          description: &quot;THEMIS instance {{ $labels.instance }} is unreachable&quot;
</code></pre>
<h2 id="deployment-backup-recovery">Backup &amp; Recovery<a class="headerlink" href="#deployment-backup-recovery" title="Permanent link">&para;</a></h2>
<h3 id="deployment-snapshot-backup-rocksdb-checkpoint">Snapshot Backup (RocksDB Checkpoint)<a class="headerlink" href="#deployment-snapshot-backup-rocksdb-checkpoint" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Create snapshot
curl -X POST http://localhost:8765/admin/snapshot \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;path&quot;:&quot;/backups/vccdb-snapshot-2025-10-28&quot;}'

# Verify snapshot
ls -lh /backups/vccdb-snapshot-2025-10-28/
# Output: CURRENT, MANIFEST, *.sst files

# Restore from snapshot
./themis_server --restore /backups/vccdb-snapshot-2025-10-28 \
               --target /var/lib/vccdb/data
</code></pre>
<h3 id="deployment-continuous-backup-wal-archival">Continuous Backup (WAL Archival)<a class="headerlink" href="#deployment-continuous-backup-wal-archival" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;storage&quot;: {
    &quot;wal_archive_path&quot;: &quot;/backups/wal&quot;,
    &quot;wal_ttl_seconds&quot;: 86400,  // Keep WAL for 24 hours
    &quot;enable_wal_archival&quot;: true
  }
}
</code></pre>
<pre><code class="language-bash"># Backup script (cron job: 0 */6 * * *)
#!/bin/bash
BACKUP_DIR=&quot;/backups/$(date +%Y%m%d-%H%M%S)&quot;
cp -r /var/lib/vccdb/data &quot;$BACKUP_DIR&quot;
tar -czf &quot;$BACKUP_DIR.tar.gz&quot; &quot;$BACKUP_DIR&quot;
rm -rf &quot;$BACKUP_DIR&quot;

# Retention: keep last 7 days
find /backups -name &quot;*.tar.gz&quot; -mtime +7 -delete
</code></pre>
<h3 id="deployment-disaster-recovery-procedure">Disaster Recovery Procedure<a class="headerlink" href="#deployment-disaster-recovery-procedure" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># 1. Stop server
sudo systemctl stop vccdb

# 2. Restore data directory
tar -xzf /backups/20251028-120000.tar.gz -C /var/lib/vccdb/

# 3. Verify data integrity
./themis_server --config config.json --verify

# 4. Restart server
sudo systemctl start vccdb

# 5. Verify health
curl http://localhost:8765/health
curl http://localhost:8765/stats | jq .storage.rocksdb.estimate_num_keys
</code></pre>
<h2 id="deployment-performance-tuning">Performance Tuning<a class="headerlink" href="#deployment-performance-tuning" title="Permanent link">&para;</a></h2>
<h3 id="deployment-rocksdb-tuning-for-workload-types">RocksDB Tuning for Workload Types<a class="headerlink" href="#deployment-rocksdb-tuning-for-workload-types" title="Permanent link">&para;</a></h3>
<p><strong>Write-Heavy (High Ingestion Rate):</strong></p>
<pre><code class="language-json">{
  &quot;storage&quot;: {
    &quot;memtable_size_mb&quot;: 512,
    &quot;max_write_buffer_number&quot;: 4,
    &quot;min_write_buffer_number_to_merge&quot;: 2,
    &quot;level0_file_num_compaction_trigger&quot;: 4,
    &quot;level0_slowdown_writes_trigger&quot;: 20,
    &quot;level0_stop_writes_trigger&quot;: 36,
    &quot;compression&quot;: &quot;lz4&quot;
  }
}
</code></pre>
<p><strong>Read-Heavy (Analytics Workload):</strong></p>
<pre><code class="language-json">{
  &quot;storage&quot;: {
    &quot;memtable_size_mb&quot;: 128,
    &quot;block_cache_size_mb&quot;: 4096,
    &quot;enable_bloom_filters&quot;: true,
    &quot;bloom_bits_per_key&quot;: 10,
    &quot;compression&quot;: &quot;zstd&quot;
  }
}
</code></pre>
<p><strong>Balanced (Mixed Workload):</strong></p>
<pre><code class="language-json">{
  &quot;storage&quot;: {
    &quot;memtable_size_mb&quot;: 256,
    &quot;block_cache_size_mb&quot;: 2048,
    &quot;compression&quot;: {
      &quot;default&quot;: &quot;lz4&quot;,
      &quot;bottommost&quot;: &quot;zstd&quot;
    }
  }
}
</code></pre>
<h3 id="deployment-query-engine-tuning">Query Engine Tuning<a class="headerlink" href="#deployment-query-engine-tuning" title="Permanent link">&para;</a></h3>
<p>Edit <code>src/query/query_engine.cpp</code>:</p>
<pre><code class="language-cpp">// Low-latency tuning (reduce parallelization overhead)
constexpr size_t PARALLEL_THRESHOLD = 50;   // Start parallel at 50 entities
constexpr size_t BATCH_SIZE = 25;           // Smaller batches

// High-throughput tuning (maximize CPU utilization)
constexpr size_t PARALLEL_THRESHOLD = 200;  // Less overhead
constexpr size_t BATCH_SIZE = 100;          // Larger batches
</code></pre>
<h3 id="deployment-network-tuning-linux">Network Tuning (Linux)<a class="headerlink" href="#deployment-network-tuning-linux" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Increase TCP buffer sizes
sudo sysctl -w net.core.rmem_max=16777216
sudo sysctl -w net.core.wmem_max=16777216
sudo sysctl -w net.ipv4.tcp_rmem=&quot;4096 87380 16777216&quot;
sudo sysctl -w net.ipv4.tcp_wmem=&quot;4096 65536 16777216&quot;

# Enable TCP Fast Open
sudo sysctl -w net.ipv4.tcp_fastopen=3

# Increase connection queue
sudo sysctl -w net.core.somaxconn=4096
</code></pre>
<h2 id="deployment-security">Security<a class="headerlink" href="#deployment-security" title="Permanent link">&para;</a></h2>
<h3 id="deployment-authentication-api-key">Authentication (API Key)<a class="headerlink" href="#deployment-authentication-api-key" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;server&quot;: {
    &quot;enable_auth&quot;: true,
    &quot;api_keys&quot;: [
      {&quot;key&quot;: &quot;sk-prod-abc123...&quot;, &quot;role&quot;: &quot;admin&quot;},
      {&quot;key&quot;: &quot;sk-readonly-xyz789...&quot;, &quot;role&quot;: &quot;readonly&quot;}
    ]
  }
}
</code></pre>
<pre><code class="language-bash"># Authenticated request
curl -H &quot;Authorization: Bearer sk-prod-abc123...&quot; \
     http://localhost:8765/entities/users:alice
</code></pre>
<h3 id="deployment-tlsssl-encryption">TLS/SSL Encryption<a class="headerlink" href="#deployment-tlsssl-encryption" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;server&quot;: {
    &quot;enable_tls&quot;: true,
    &quot;tls_cert&quot;: &quot;/etc/vccdb/certs/server.crt&quot;,
    &quot;tls_key&quot;: &quot;/etc/vccdb/certs/server.key&quot;,
    &quot;tls_ca&quot;: &quot;/etc/vccdb/certs/ca.crt&quot;
  }
}
</code></pre>
<pre><code class="language-bash"># Generate self-signed certificate (testing only)
openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt \
        -days 365 -nodes -subj &quot;/CN=localhost&quot;

# HTTPS request
curl --cacert ca.crt https://localhost:8765/health
</code></pre>
<h3 id="deployment-firewall-configuration">Firewall Configuration<a class="headerlink" href="#deployment-firewall-configuration" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Allow THEMIS port (Linux - ufw)
sudo ufw allow 8765/tcp
sudo ufw enable

# Allow from specific IP only
sudo ufw allow from 10.0.1.0/24 to any port 8765

# Windows Firewall
netsh advfirewall firewall add rule name=&quot;THEMIS Server&quot; dir=in action=allow protocol=TCP localport=8765
</code></pre>
<h2 id="deployment-troubleshooting">Troubleshooting<a class="headerlink" href="#deployment-troubleshooting" title="Permanent link">&para;</a></h2>
<h3 id="deployment-common-issues">Common Issues<a class="headerlink" href="#deployment-common-issues" title="Permanent link">&para;</a></h3>
<p><strong>Issue 1: Server fails to start - "Database not open"</strong></p>
<pre><code class="language-bash"># Check storage path permissions
ls -ld /var/lib/vccdb/data
# Fix: sudo chown -R vccdb:vccdb /var/lib/vccdb/data

# Check disk space
df -h /var/lib/vccdb
# Fix: Clean up old data or resize volume
</code></pre>
<p><strong>Issue 2: High memory usage</strong></p>
<pre><code class="language-bash"># Check RocksDB memory usage
curl http://localhost:8765/stats | jq '.storage.rocksdb | {
  block_cache: .block_cache_usage_bytes,
  memtable: .memtable_size_bytes,
  total_mem_tables: .cur_size_all_mem_tables_bytes
}'

# Fix: Reduce block_cache_size_mb or memtable_size_mb in config.json
</code></pre>
<p><strong>Issue 3: Slow queries</strong></p>
<pre><code class="language-bash"># Check index usage
curl -X POST http://localhost:8765/query \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;table&quot;:&quot;users&quot;,&quot;predicates&quot;:[{&quot;column&quot;:&quot;city&quot;,&quot;value&quot;:&quot;Berlin&quot;}],&quot;explain&quot;:true}'

# Output: {&quot;plan&quot;: {&quot;mode&quot;: &quot;full_scan_fallback&quot;}}
# Fix: Create index on 'city' column
curl -X POST http://localhost:8765/index/create \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;table&quot;:&quot;users&quot;,&quot;column&quot;:&quot;city&quot;}'
</code></pre>
<p><strong>Issue 4: Compaction backlog</strong></p>
<pre><code class="language-bash"># Check compaction stats
curl http://localhost:8765/stats | jq '.storage.rocksdb | {
  pending: .estimate_pending_compaction_bytes,
  running: .num_running_compactions
}'

# Fix: Increase compaction threads
# config.json: &quot;max_background_compactions&quot;: 8
</code></pre>
<h3 id="deployment-debug-logging">Debug Logging<a class="headerlink" href="#deployment-debug-logging" title="Permanent link">&para;</a></h3>
<p>Enable debug logging:</p>
<pre><code class="language-json">{
  &quot;logging&quot;: {
    &quot;level&quot;: &quot;debug&quot;,
    &quot;file&quot;: &quot;/var/log/vccdb/debug.log&quot;
  }
}
</code></pre>
<pre><code class="language-bash"># Tail debug log
tail -f /var/log/vccdb/debug.log

# Filter specific component
grep &quot;QueryEngine&quot; /var/log/vccdb/debug.log
grep &quot;RocksDBWrapper&quot; /var/log/vccdb/debug.log
</code></pre>
<h3 id="deployment-performance-profiling">Performance Profiling<a class="headerlink" href="#deployment-performance-profiling" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># CPU profiling (Linux - perf)
sudo perf record -F 99 -p $(pgrep themis_server) -g -- sleep 60
sudo perf report

# Memory profiling (valgrind)
valgrind --tool=massif ./themis_server --config config.json
ms_print massif.out.12345

# Network profiling (tcpdump)
sudo tcpdump -i any port 8765 -w vccdb-traffic.pcap
wireshark vccdb-traffic.pcap
</code></pre>
<h2 id="deployment-migration-guide">Migration Guide<a class="headerlink" href="#deployment-migration-guide" title="Permanent link">&para;</a></h2>
<h3 id="deployment-from-standalone-to-docker">From Standalone to Docker<a class="headerlink" href="#deployment-from-standalone-to-docker" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># 1. Stop standalone server
sudo systemctl stop vccdb

# 2. Copy data directory
sudo cp -r /var/lib/vccdb/data ./docker-data/

# 3. Start Docker container
docker run -d \
  --name vccdb \
  -p 8765:8765 \
  -v $(pwd)/docker-data:/data \
  vccdb/vccdb:latest

# 4. Verify data
curl http://localhost:8765/stats | jq .storage.rocksdb.estimate_num_keys
</code></pre>
<h3 id="deployment-from-v0x-to-v10">From v0.x to v1.0<a class="headerlink" href="#deployment-from-v0x-to-v10" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># 1. Backup current data
./themis_server --backup /backups/pre-upgrade-$(date +%Y%m%d)

# 2. Download v1.0 binary
wget https://github.com/&lt;org&gt;/vccdb/releases/download/v1.0.0/vccdb-linux-x64.tar.gz
tar -xzf vccdb-linux-x64.tar.gz

# 3. Run migration tool
./vccdb-migrate --from /var/lib/vccdb/data \
                --to /var/lib/vccdb/data-v1 \
                --version 0.9 --target 1.0

# 4. Update config.json (new format)
# See: https://github.com/&lt;org&gt;/vccdb/wiki/v1.0-Migration-Guide

# 5. Start v1.0 server
./themis_server --config config-v1.json
</code></pre>
<h2 id="deployment-support">Support<a class="headerlink" href="#deployment-support" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Documentation</strong>: https://docs.vccdb.io</li>
<li><strong>GitHub Issues</strong>: https://github.com/<org>/vccdb/issues</li>
<li><strong>Community Chat</strong>: https://discord.gg/vccdb</li>
<li><strong>Email</strong>: support@vccdb.io</li>
</ul></section><section class="print-page" id="tracing" heading-number="13.2"><h1 id="tracing-opentelemetry-distributed-tracing">OpenTelemetry Distributed Tracing<a class="headerlink" href="#tracing-opentelemetry-distributed-tracing" title="Permanent link">&para;</a></h1>
<p><strong>Themis</strong> unterstützt verteiltes Tracing via OpenTelemetry für Production-Debugging und Performance-Analyse.</p>
<h2 id="tracing-features">Features<a class="headerlink" href="#tracing-features" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>OTLP HTTP Exporter</strong>: Sendet Traces an Jaeger, Grafana Tempo oder andere OTLP-kompatible Backends</li>
<li><strong>RAII Span Management</strong>: Automatisches Span-Lifetime-Management via C++ RAII</li>
<li><strong>Conditional Compilation</strong>: Tracing kann zur Build-Zeit deaktiviert werden (kein Runtime-Overhead)</li>
<li><strong>Flexible Configuration</strong>: Runtime-Konfiguration via <code>config.json</code></li>
</ul>
<h2 id="tracing-architektur">Architektur<a class="headerlink" href="#tracing-architektur" title="Permanent link">&para;</a></h2>
<h3 id="tracing-komponenten">Komponenten<a class="headerlink" href="#tracing-komponenten" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Tracer Wrapper</strong> (<code>utils/tracing.h</code>/<code>.cpp</code>)</li>
<li>Initialisierung des OTLP HTTP Exporters</li>
<li>TracerProvider mit Resource Attributes (service.name, version)</li>
<li>
<p>SimpleSpanProcessor für sofortigen Export</p>
</li>
<li>
<p><strong>Span RAII Wrapper</strong></p>
</li>
<li><code>Tracer::Span</code>: Move-only Span mit automatischem <code>end()</code> im Destruktor</li>
<li><code>ScopedSpan</code>: Convenience-Wrapper für lokale Spans</li>
<li>
<p>Attribute-Support: <code>setAttribute(key, value)</code> für string, int64, double, bool</p>
</li>
<li>
<p><strong>No-Op Fallback</strong></p>
</li>
<li>Wenn <code>THEMIS_ENABLE_TRACING</code> nicht definiert, sind alle Methoden No-Ops</li>
<li>Kein Linking gegen OpenTelemetry-Libraries notwendig</li>
</ol>
<h3 id="tracing-datenfluss">Datenfluss<a class="headerlink" href="#tracing-datenfluss" title="Permanent link">&para;</a></h3>
<pre><code>HTTP Request → ScopedSpan(&quot;handleAqlQuery&quot;)
                ↓
           QueryEngine::executeQuery() → ScopedSpan(&quot;executeQuery&quot;)
                ↓
           Index Scans → Child Spans
                ↓
         OTLP HTTP Exporter → Jaeger/Tempo/Collector
</code></pre>
<h2 id="tracing-konfiguration">Konfiguration<a class="headerlink" href="#tracing-konfiguration" title="Permanent link">&para;</a></h2>
<h3 id="tracing-build-zeit">Build-Zeit<a class="headerlink" href="#tracing-build-zeit" title="Permanent link">&para;</a></h3>
<p>In <code>CMakeLists.txt</code>:</p>
<pre><code class="language-cmake">option(THEMIS_ENABLE_TRACING &quot;Enable OpenTelemetry distributed tracing&quot; ON)
</code></pre>
<p>Deaktivieren:</p>
<pre><code class="language-bash">cmake -DTHEMIS_ENABLE_TRACING=OFF ..
</code></pre>
<h3 id="tracing-runtime">Runtime<a class="headerlink" href="#tracing-runtime" title="Permanent link">&para;</a></h3>
<p>In <code>config/config.json</code>:</p>
<pre><code class="language-json">{
  &quot;tracing&quot;: {
    &quot;enabled&quot;: true,
    &quot;service_name&quot;: &quot;themis-server&quot;,
    &quot;otlp_endpoint&quot;: &quot;http://localhost:4318&quot;
  }
}
</code></pre>
<p><strong>Wichtig:</strong> <code>otlp_endpoint</code> ist der Base-URL des OTLP HTTP Receivers. Der Tracer fügt automatisch <code>/v1/traces</code> hinzu.</p>
<h2 id="tracing-nutzung">Nutzung<a class="headerlink" href="#tracing-nutzung" title="Permanent link">&para;</a></h2>
<h3 id="tracing-instrumentierte-komponenten-aktuell">Instrumentierte Komponenten (aktuell)<a class="headerlink" href="#tracing-instrumentierte-komponenten-aktuell" title="Permanent link">&para;</a></h3>
<h4 id="tracing-http-handler-top-level-spans">HTTP-Handler (Top-Level Spans)<a class="headerlink" href="#tracing-http-handler-top-level-spans" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>GET /entities/:key</strong>: <code>entity.key</code>, <code>entity.size_bytes</code></li>
<li><strong>PUT /entities/:key</strong>: <code>entity.key</code>, <code>entity.table</code>, <code>entity.pk</code>, <code>entity.size_bytes</code>, <code>entity.cdc_recorded</code></li>
<li><strong>DELETE /entities/:key</strong>: <code>entity.key</code>, <code>entity.table</code>, <code>entity.pk</code>, <code>entity.cdc_recorded</code></li>
<li><strong>POST /query</strong>: <code>query.table</code>, <code>query.predicates_count</code>, <code>query.exec_mode</code>, <code>query.result_count</code></li>
<li><strong>POST /query/aql</strong>: <code>aql.query</code>, <code>aql.explain</code>, <code>aql.optimize</code>, <code>aql.allow_full_scan</code>, <code>aql.result_count</code></li>
<li><strong>POST /graph/traverse</strong>: <code>graph.start_vertex</code>, <code>graph.max_depth</code>, <code>graph.visited_count</code></li>
<li><strong>POST /vector/search</strong>: <code>vector.dimension</code>, <code>vector.k</code>, <code>vector.results_count</code></li>
</ul>
<h4 id="tracing-queryengine-query-execution-spans">QueryEngine (Query Execution Spans)<a class="headerlink" href="#tracing-queryengine-query-execution-spans" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>QueryEngine.executeAndKeys</strong>: <code>query.table</code>, <code>query.eq_count</code>, <code>query.range_count</code>, <code>query.order_by</code>, <code>query.result_count</code></li>
<li><strong>QueryEngine.executeAndEntities</strong>: <code>query.table</code>, <code>query.entities_count</code></li>
<li><strong>QueryEngine.executeOrKeys</strong>: <code>query.table</code>, <code>query.disjuncts</code>, <code>query.result_count</code></li>
<li><strong>QueryEngine.executeOrEntities</strong>: <code>query.table</code>, <code>query.entities_count</code></li>
<li><strong>QueryEngine.executeAndKeysSequential</strong>: <code>query.table</code>, <code>query.eq_count</code>, <code>query.result_count</code></li>
<li><strong>QueryEngine.executeAndEntitiesSequential</strong>: <code>query.table</code>, <code>query.entities_count</code></li>
<li><strong>QueryEngine.fullScan</strong>: <code>query.table</code>, <code>query.eq_count</code>, <code>query.range_count</code>, <code>fullscan.scanned</code>, <code>query.result_count</code></li>
<li><strong>QueryEngine.executeAndKeysWithFallback</strong>: <code>query.table</code>, <code>query.exec_mode</code> (full_scan, range_aware, index_optimized, index_parallel, full_scan_fallback), <code>query.result_count</code></li>
<li><strong>QueryEngine.executeAndEntitiesWithFallback</strong>: <code>query.table</code>, <code>query.entities_count</code></li>
<li><strong>QueryEngine.executeAndKeysRangeAware</strong>: <code>query.table</code>, <code>query.range_count</code>, <code>query.result_count</code> oder <code>query.ordered_count</code></li>
<li><strong>QueryEngine.executeAndEntitiesRangeAware</strong>: <code>query.table</code>, <code>query.entities_count</code></li>
</ul>
<h4 id="tracing-aql-execution-pipeline-operator-level-spans">AQL Execution Pipeline (Operator-Level Spans)<a class="headerlink" href="#tracing-aql-execution-pipeline-operator-level-spans" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>aql.parse</strong>: <code>aql.query_length</code> - Parsen der AQL-Query in AST</li>
<li><strong>aql.translate</strong> - Übersetzung des AST in ConjunctiveQuery oder TraversalQuery</li>
<li><strong>aql.for</strong>: <code>for.table</code>, <code>for.predicates_count</code>, <code>for.range_predicates_count</code>, <code>for.order_by</code>, <code>for.order_desc</code>, <code>for.result_count</code>, <code>for.exec_mode</code></li>
<li>Iteriert über Collection (scan oder traversal)</li>
<li><strong>aql.filter</strong> - Filterung der Ergebnisse (innerhalb von Traversal/FOR)</li>
<li>Bei Traversal: <code>filter.evaluations_total</code>, <code>filter.short_circuits</code></li>
<li><strong>aql.limit</strong>: <code>limit.offset</code>, <code>limit.count</code>, <code>limit.input_count</code>, <code>limit.output_count</code></li>
<li>Begrenzt Ergebnismenge (LIMIT offset, count)</li>
<li><strong>aql.collect</strong>: <code>collect.input_count</code>, <code>collect.group_by_count</code>, <code>collect.aggregates_count</code>, <code>collect.group_count</code></li>
<li>Gruppierung und Aggregation (GROUP BY, SUM, AVG, COUNT, MIN, MAX)</li>
<li><strong>aql.return</strong>: <code>return.input_count</code></li>
<li>Finalisiert Ausgabe und serialisiert Entities</li>
<li><strong>aql.traversal</strong>: <code>traversal.start_vertex</code>, <code>traversal.min_depth</code>, <code>traversal.max_depth</code>, <code>traversal.direction</code>, <code>traversal.result_count</code></li>
<li>Child-Span: <strong>aql.traversal.bfs</strong>: <code>traversal.max_frontier_size_limit</code>, <code>traversal.max_results_limit</code>, <code>traversal.visited_count</code>, <code>traversal.edges_expanded</code>, <code>traversal.filter_evaluations</code></li>
</ul>
<h4 id="tracing-index-scans-child-spans">Index-Scans (Child-Spans)<a class="headerlink" href="#tracing-index-scans-child-spans" title="Permanent link">&para;</a></h4>
<ul>
<li><strong>index.scanEqual</strong>: <code>index.table</code>, <code>index.column</code>, <code>index.result_count</code></li>
<li><strong>index.scanRange</strong>: <code>index.table</code>, <code>index.column</code>, <code>index.result_count</code>, <code>range.has_lower</code>, <code>range.has_upper</code>, <code>range.includeLower</code>, <code>range.includeUpper</code></li>
<li><strong>or.disjunct.execute</strong>: <code>disjunct.eq_count</code>, <code>disjunct.range_count</code>, <code>disjunct.result_count</code></li>
</ul>
<p>Diese Spans erlauben die Analyse von Ausführungsmodus, Cardinalities und Hotspots pro Prädikat/Operator.</p>
<h3 id="tracing-span-in-http-handler-erstellen">Span in HTTP Handler erstellen<a class="headerlink" href="#tracing-span-in-http-handler-erstellen" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &quot;utils/tracing.h&quot;

void handleAqlQuery(const Request&amp; req, Response&amp; res) {
    auto span = Tracer::ScopedSpan(&quot;handleAqlQuery&quot;);
    span.setAttribute(&quot;http.method&quot;, &quot;POST&quot;);
    span.setAttribute(&quot;http.path&quot;, &quot;/aql&quot;);

    try {
        // ... query execution ...
      span.setAttribute(&quot;query.table&quot;, tableName);
      span.setStatus(true);
    } catch (const std::exception&amp; e) {
        span.recordError(e.what());
      span.setStatus(false, e.what());
        throw;
    }
}
</code></pre>
<h3 id="tracing-child-span-erstellen">Child Span erstellen<a class="headerlink" href="#tracing-child-span-erstellen" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">void QueryEngine::executeQuery(...) {
    auto parentSpan = Tracer::ScopedSpan(&quot;executeQuery&quot;);

    {
        auto childSpan = Tracer::startSpan(&quot;loadIndexes&quot;);
        childSpan.setAttribute(&quot;index.count&quot;, indexCount);
        // ... index loading ...
    } // childSpan endet automatisch

    // ... weiter mit parentSpan ...
}
</code></pre>
<h3 id="tracing-fehler-aufzeichnen">Fehler aufzeichnen<a class="headerlink" href="#tracing-fehler-aufzeichnen" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">try {
    // ... operation ...
} catch (const std::exception&amp; e) {
    span.recordError(e.what());
     span.setStatus(false, errorMessage);
    throw;
}
</code></pre>
<h2 id="tracing-jaeger-integration-development">Jaeger Integration (Development)<a class="headerlink" href="#tracing-jaeger-integration-development" title="Permanent link">&para;</a></h2>
<h3 id="tracing-jaeger-via-docker-starten">Jaeger via Docker starten<a class="headerlink" href="#tracing-jaeger-via-docker-starten" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">docker run -d --name jaeger \
  -p 4318:4318 \
  -p 16686:16686 \
  jaegertracing/all-in-one:latest
</code></pre>
<p><strong>Ports:</strong>
- <code>4318</code>: OTLP HTTP receiver (für Themis)
- <code>16686</code>: Jaeger UI</p>
<h3 id="tracing-themis-konfigurieren">Themis konfigurieren<a class="headerlink" href="#tracing-themis-konfigurieren" title="Permanent link">&para;</a></h3>
<pre><code class="language-json">{
  &quot;tracing&quot;: {
    &quot;enabled&quot;: true,
    &quot;service_name&quot;: &quot;themis-dev&quot;,
    &quot;otlp_endpoint&quot;: &quot;http://localhost:4318&quot;
  }
}
</code></pre>
<h3 id="tracing-themis-starten">Themis starten<a class="headerlink" href="#tracing-themis-starten" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">.\build\Release\themis_server.exe
</code></pre>
<h3 id="tracing-traces-anzeigen">Traces anzeigen<a class="headerlink" href="#tracing-traces-anzeigen" title="Permanent link">&para;</a></h3>
<ol>
<li>Öffne http://localhost:16686 (Jaeger UI)</li>
<li>Wähle Service "themis-dev"</li>
<li>Klicke "Find Traces"</li>
</ol>
<h2 id="tracing-grafana-tempo-integration-production">Grafana Tempo Integration (Production)<a class="headerlink" href="#tracing-grafana-tempo-integration-production" title="Permanent link">&para;</a></h2>
<h3 id="tracing-tempo-via-docker-compose">Tempo via Docker Compose<a class="headerlink" href="#tracing-tempo-via-docker-compose" title="Permanent link">&para;</a></h3>
<pre><code class="language-yaml">version: '3'
services:
  tempo:
    image: grafana/tempo:latest
    command: [&quot;-config.file=/etc/tempo.yaml&quot;]
    volumes:
      - ./tempo.yaml:/etc/tempo.yaml
    ports:
      - &quot;4318:4318&quot;   # OTLP HTTP
      - &quot;3200:3200&quot;   # Tempo API

  grafana:
    image: grafana/grafana:latest
    ports:
      - &quot;3000:3000&quot;
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true
</code></pre>
<p><strong>tempo.yaml:</strong></p>
<pre><code class="language-yaml">server:
  http_listen_port: 3200

distributor:
  receivers:
    otlp:
      protocols:
        http:
          endpoint: 0.0.0.0:4318

storage:
  trace:
    backend: local
    local:
      path: /tmp/tempo/traces
</code></pre>
<h3 id="tracing-grafana-datasource">Grafana Datasource<a class="headerlink" href="#tracing-grafana-datasource" title="Permanent link">&para;</a></h3>
<ol>
<li>Öffne http://localhost:3000</li>
<li>Configuration → Data Sources → Add data source</li>
<li>Wähle "Tempo"</li>
<li>URL: <code>http://tempo:3200</code></li>
<li>Save &amp; Test</li>
</ol>
<h2 id="tracing-performance-hinweise">Performance-Hinweise<a class="headerlink" href="#tracing-performance-hinweise" title="Permanent link">&para;</a></h2>
<h3 id="tracing-span-overhead">Span-Overhead<a class="headerlink" href="#tracing-span-overhead" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Mit Tracing aktiviert</strong>: ~5-10 µs pro Span (inkl. Attribut-Serialisierung)</li>
<li><strong>Ohne Tracing (THEMIS_ENABLE_TRACING=OFF)</strong>: 0 µs (inline no-ops)</li>
</ul>
<h3 id="tracing-best-practices">Best Practices<a class="headerlink" href="#tracing-best-practices" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Granularität</strong>: Erstelle Spans für HTTP-Requests, Query-Execution, Index-Scans</li>
<li><strong>Attribute</strong>: Füge relevante Metadaten hinzu (table, index_type, row_count)</li>
<li><strong>Sampling</strong> (zukünftig): Für High-Throughput-Szenarien Sampling verwenden</li>
<li><strong>Batch Processor</strong> (zukünftig): SimpleSpanProcessor → BatchSpanProcessor für bessere Performance</li>
</ol>
<h2 id="tracing-api-referenz">API-Referenz<a class="headerlink" href="#tracing-api-referenz" title="Permanent link">&para;</a></h2>
<h3 id="tracing-tracerinitialize">Tracer::initialize()<a class="headerlink" href="#tracing-tracerinitialize" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">bool Tracer::initialize(const std::string&amp; serviceName, 
                       const std::string&amp; endpoint);
</code></pre>
<p>Initialisiert den OpenTelemetry Tracer mit OTLP HTTP Exporter.</p>
<p><strong>Parameter:</strong>
- <code>serviceName</code>: Name des Services (erscheint in Jaeger/Tempo)
- <code>endpoint</code>: OTLP HTTP Receiver URL (z.B. <code>http://localhost:4318</code>)</p>
<p><strong>Returns:</strong> <code>true</code> bei Erfolg, <code>false</code> bei Fehler</p>
<h3 id="tracing-tracerstartspan">Tracer::startSpan()<a class="headerlink" href="#tracing-tracerstartspan" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">Tracer::Span Tracer::startSpan(const std::string&amp; name);
</code></pre>
<p>Erstellt einen neuen Span mit dem gegebenen Namen.</p>
<p><strong>Returns:</strong> Move-only <code>Span</code> Objekt</p>
<h3 id="tracing-scopedspan">ScopedSpan<a class="headerlink" href="#tracing-scopedspan" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">Tracer::ScopedSpan span(&quot;operationName&quot;);
span.setAttribute(&quot;key&quot;, &quot;value&quot;);
</code></pre>
<p>RAII-Wrapper für automatisches Span-Lifetime-Management.</p>
<h3 id="tracing-spansetattribute">Span::setAttribute()<a class="headerlink" href="#tracing-spansetattribute" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">void setAttribute(const std::string&amp; key, const std::string&amp; value);
void setAttribute(const std::string&amp; key, int64_t value);
void setAttribute(const std::string&amp; key, double value);
void setAttribute(const std::string&amp; key, bool value);
</code></pre>
<p>Fügt Attribute zum Span hinzu.</p>
<h3 id="tracing-spanrecorderror">Span::recordError()<a class="headerlink" href="#tracing-spanrecorderror" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">void recordError(const std::string&amp; errorMessage);
</code></pre>
<p>Zeichnet einen Fehler auf und setzt den Span-Status auf <code>kError</code>.</p>
<h3 id="tracing-spansetstatus">Span::setStatus()<a class="headerlink" href="#tracing-spansetstatus" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">void setStatus(StatusCode code);
</code></pre>
<p>Setzt den Span-Status (<code>kOk</code>, <code>kError</code>, <code>kUnset</code>).</p>
<h2 id="tracing-troubleshooting">Troubleshooting<a class="headerlink" href="#tracing-troubleshooting" title="Permanent link">&para;</a></h2>
<h3 id="tracing-tracer-not-initialized-warning">"Tracer not initialized" Warning<a class="headerlink" href="#tracing-tracer-not-initialized-warning" title="Permanent link">&para;</a></h3>
<p><strong>Symptom:</strong> Log-Meldung "Tracer not initialized, call Tracer::initialize() first"</p>
<p><strong>Lösung:</strong> Stelle sicher, dass <code>Tracer::initialize()</code> vor dem ersten <code>startSpan()</code> aufgerufen wird.</p>
<h3 id="tracing-keine-traces-in-jaeger-sichtbar">Keine Traces in Jaeger sichtbar<a class="headerlink" href="#tracing-keine-traces-in-jaeger-sichtbar" title="Permanent link">&para;</a></h3>
<p><strong>Prüfe:</strong>
1. Läuft Jaeger? <code>docker ps | grep jaeger</code>
2. Ist Tracing aktiviert? <code>"tracing.enabled": true</code> in config.json
3. Richtiger Endpoint? <code>http://localhost:4318</code> (nicht 4317 für gRPC!)
4. Firewall/Network-Einstellungen</p>
<p><strong>Debug:</strong></p>
<pre><code class="language-bash"># Log-Level auf DEBUG setzen in config.json
&quot;log_level&quot;: &quot;debug&quot;

# Themis-Logs prüfen
grep -i &quot;telemetry\|tracer\|span&quot; themis.log
</code></pre>
<h3 id="tracing-build-fehler-mit-opentelemetry">Build-Fehler mit OpenTelemetry<a class="headerlink" href="#tracing-build-fehler-mit-opentelemetry" title="Permanent link">&para;</a></h3>
<p><strong>Symptom:</strong> <code>error: opentelemetry/... not found</code></p>
<p><strong>Lösung:</strong></p>
<pre><code class="language-bash"># vcpkg-Cache löschen und neu installieren
rm -rf build/vcpkg_installed
.\build.ps1
</code></pre>
<h2 id="tracing-implementierungsstatus">Implementierungsstatus<a class="headerlink" href="#tracing-implementierungsstatus" title="Permanent link">&para;</a></h2>
<ul>
<li>✅ <strong>Infrastruktur</strong>: Tracer-Wrapper, OTLP HTTP Exporter</li>
<li>✅ <strong>Configuration</strong>: config.json + CMake-Option</li>
<li>✅ <strong>Build</strong>: Kompiliert mit opentelemetry-cpp v1.23.0</li>
<li>✅ <strong>Tests</strong>: 303/303 Tests bestanden</li>
<li>⚠️ <strong>Instrumentierung</strong>: HTTP-Handler noch nicht instrumentiert</li>
<li>⚠️ <strong>Dokumentation</strong>: Deployment-Guide für Production</li>
</ul>
<h2 id="tracing-nachste-schritte">Nächste Schritte<a class="headerlink" href="#tracing-nachste-schritte" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>HTTP-Handler instrumentieren</strong>: Spans für alle <code>/aql</code>, <code>/vector</code>, <code>/graph</code> Endpoints</li>
<li><strong>Query-Engine instrumentieren</strong>: Child Spans für Index-Scans, Filter-Operationen</li>
<li><strong>Sampling implementieren</strong>: Probabilistic Sampling für High-Throughput</li>
<li><strong>BatchSpanProcessor</strong>: Performance-Optimierung für Production</li>
<li><strong>Context Propagation</strong>: W3C Trace Context für verteilte Systeme</li>
</ol>
<h2 id="tracing-siehe-auch">Siehe auch<a class="headerlink" href="#tracing-siehe-auch" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://opentelemetry.io/docs/languages/cpp/">OpenTelemetry C++ SDK Documentation</a></li>
<li><a href="https://www.jaegertracing.io/docs/">Jaeger Documentation</a></li>
<li><a href="https://grafana.com/docs/tempo/latest/">Grafana Tempo Documentation</a></li>
<li><a href="https://opentelemetry.io/docs/specs/otlp/">OTLP Specification</a></li>
</ul></section><section class="print-page" id="change_data_capture" heading-number="13.3"><h1 id="change_data_capture-change-data-capture-cdc-themis">Change Data Capture (CDC) - Themis<a class="headerlink" href="#change_data_capture-change-data-capture-cdc-themis" title="Permanent link">&para;</a></h1>
<h2 id="change_data_capture-overview">Overview<a class="headerlink" href="#change_data_capture-overview" title="Permanent link">&para;</a></h2>
<p>Themis' Change Data Capture (CDC) implementation provides a minimal, append-only event log that tracks all data mutations (PUT/DELETE) in the database. This enables real-time data synchronization, audit trails, and stream processing use cases.</p>
<p><strong>Key Features (MVP, Stand jetzt):</strong>
- Sequence-basiertes Ordering (monoton steigende <code>sequence</code>)
- Automatische Erfassung für Entity-Operationen PUT/DELETE
- Inkrementeller Abruf mit Checkpointing (<code>from_seq</code>)
- Filterung per <code>key_prefix</code>; optionaler Event-Typ-Filter auf API-Ebene
- Ereignisse mit Timestamp und frei erweiterbarem <code>metadata</code>
- Long-Polling zur Latenzreduktion; experimentelles SSE-Streaming</p>
<hr />
<h2 id="change_data_capture-architecture">Architecture<a class="headerlink" href="#change_data_capture-architecture" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-data-model">Data Model<a class="headerlink" href="#change_data_capture-data-model" title="Permanent link">&para;</a></h3>
<p><strong>ChangeEvent Structure:</strong></p>
<pre><code class="language-json">{
  &quot;sequence&quot;: 42,
  &quot;type&quot;: &quot;PUT&quot;,
  &quot;key&quot;: &quot;user:alice&quot;,
  &quot;value&quot;: &quot;{\&quot;name\&quot;:\&quot;Alice\&quot;,\&quot;email\&quot;:\&quot;alice@example.com\&quot;}&quot;,
  &quot;timestamp_ms&quot;: 1730294567123,
  &quot;metadata&quot;: {
    &quot;table&quot;: &quot;user&quot;,
    &quot;pk&quot;: &quot;alice&quot;
  }
}
</code></pre>
<p>Hinweise zu Feldern:
- <code>sequence</code>: Monoton steigende ID (uint64)
- <code>type</code>: <code>PUT</code> oder <code>DELETE</code> (Typen <code>TRANSACTION_COMMIT</code>/<code>TRANSACTION_ROLLBACK</code> sind definiert, werden aktuell aber nicht emittiert)
- <code>key</code>: Vollständiger Schlüssel, z. B. <code>table:pk</code>
- <code>value</code>: JSON-String bei PUT, <code>null</code> bei DELETE
- <code>timestamp_ms</code>: Millisekunden seit Epoch
- <code>metadata</code>: Freies JSON (z. B. <code>table</code>, <code>pk</code>)</p>
<h3 id="change_data_capture-storage">Storage<a class="headerlink" href="#change_data_capture-storage" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Column Family</strong>: Default CF (or dedicated CF if configured)</li>
<li><strong>Key Format</strong>: <code>changefeed:{sequence_number}</code> (zero-padded for lexicographic ordering)</li>
<li><strong>Sequence Tracking</strong>: Atomic counter stored at key <code>changefeed_sequence</code></li>
</ul>
<hr />
<h2 id="change_data_capture-http-api">HTTP API<a class="headerlink" href="#change_data_capture-http-api" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-1-query-changefeed-events">1. Query Changefeed Events<a class="headerlink" href="#change_data_capture-1-query-changefeed-events" title="Permanent link">&para;</a></h3>
<p>Retrieve change events with optional filtering and pagination.</p>
<p><strong>Endpoint:</strong> <code>GET /changefeed</code></p>
<p><strong>Query Parameters:</strong>
- <code>from_seq</code> (optional): Start after this sequence number (default: 0)
- <code>limit</code> (optional): Maximum events to return (default: 100)
- <code>long_poll_ms</code> (optional): Long-poll timeout in milliseconds (default: 0 = immediate)
- <code>key_prefix</code> (optional): Filter events by key prefix (e.g., <code>user:</code>)</p>
<p><strong>Request Example:</strong></p>
<pre><code class="language-bash"># Get all events
curl &quot;http://localhost:8765/changefeed?from_seq=0&amp;limit=20&quot;

# Incremental query from checkpoint
curl &quot;http://localhost:8765/changefeed?from_seq=42&amp;limit=10&quot;

# Filter by key prefix
curl &quot;http://localhost:8765/changefeed?from_seq=0&amp;limit=50&amp;key_prefix=user:&quot;

# Long-poll for new events
curl &quot;http://localhost:8765/changefeed?from_seq=100&amp;limit=10&amp;long_poll_ms=5000&quot;
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;events&quot;: [
    {
      &quot;sequence&quot;: 1,
      &quot;type&quot;: &quot;PUT&quot;,
      &quot;key&quot;: &quot;user:alice&quot;,
      &quot;value&quot;: &quot;{\&quot;name\&quot;:\&quot;Alice\&quot;,\&quot;email\&quot;:\&quot;alice@example.com\&quot;}&quot;,
      &quot;timestamp_ms&quot;: 1730294567123,
      &quot;metadata&quot;: {&quot;table&quot;: &quot;user&quot;, &quot;pk&quot;: &quot;alice&quot;}
    },
    {
      &quot;sequence&quot;: 2,
      &quot;type&quot;: &quot;DELETE&quot;,
      &quot;key&quot;: &quot;user:bob&quot;,
      &quot;value&quot;: null,
      &quot;timestamp_ms&quot;: 1730294568456,
      &quot;metadata&quot;: {&quot;table&quot;: &quot;user&quot;, &quot;pk&quot;: &quot;bob&quot;}
    }
  ],
  &quot;count&quot;: 2,
  &quot;latest_sequence&quot;: 42
}
</code></pre>
<p>Antwortfelder:
- <code>events</code>: Liste von ChangeEvent-Objekten
- <code>count</code>: Anzahl der zurückgegebenen Events
- <code>latest_sequence</code>: Aktuell letzter Sequence-Wert in der DB (für Checkpointing hilfreich)</p>
<hr />
<h2 id="change_data_capture-validation-tests-30102025">Validation Tests (30.10.2025)<a class="headerlink" href="#change_data_capture-validation-tests-30102025" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-test-1-automatic-cdc-recording">Test 1: Automatic CDC Recording<a class="headerlink" href="#change_data_capture-test-1-automatic-cdc-recording" title="Permanent link">&para;</a></h3>
<p><strong>Status:</strong> ✅ PASSED</p>
<ul>
<li>Created 4 entities via PUT → 4 CDC PUT events recorded</li>
<li>Deleted 1 entity → 1 CDC DELETE event recorded</li>
<li><strong>Result:</strong> All mutations automatically tracked without manual intervention</li>
</ul>
<h3 id="change_data_capture-test-2-query-api">Test 2: Query API<a class="headerlink" href="#change_data_capture-test-2-query-api" title="Permanent link">&para;</a></h3>
<p><strong>Status:</strong> ✅ PASSED</p>
<ul>
<li><strong>Full Query:</strong> Retrieved all events with <code>from_seq=0&amp;limit=20</code></li>
<li><strong>Incremental Query:</strong> Retrieved only new events after checkpoint</li>
<li><strong>Key Prefix Filter:</strong> Successfully filtered events by <code>user:</code> prefix</li>
<li><strong>Pagination:</strong> Limit parameter correctly restricts result size</li>
<li><strong>Result:</strong> Query API fully functional with all parameters</li>
</ul>
<h3 id="change_data_capture-test-3-event-structure">Test 3: Event Structure<a class="headerlink" href="#change_data_capture-test-3-event-structure" title="Permanent link">&para;</a></h3>
<p><strong>Status:</strong> ✅ PASSED</p>
<ul>
<li><strong>Event Types:</strong> PUT and DELETE events correctly distinguished</li>
<li><strong>Metadata:</strong> Table and PK correctly embedded in each event</li>
<li><strong>Timestamps:</strong> Millisecond precision timestamps present</li>
<li><strong>Value Handling:</strong> PUT events include value, DELETE events have <code>value: null</code></li>
<li><strong>Result:</strong> Event structure matches specification</li>
</ul>
<h3 id="change_data_capture-test-4-checkpointing-pattern">Test 4: Checkpointing Pattern<a class="headerlink" href="#change_data_capture-test-4-checkpointing-pattern" title="Permanent link">&para;</a></h3>
<p><strong>Status:</strong> ✅ PASSED</p>
<p><strong>Scenario:</strong> Consumer reads batch → updates checkpoint → resumes from checkpoint</p>
<pre><code>1. Consume events 1-5, checkpoint = 5
2. New events 6-7 arrive
3. Resume from checkpoint 5, receive events 6-7
</code></pre>
<p><strong>Result:</strong> Sequential consumption with checkpointing works correctly</p>
<hr />
<h2 id="change_data_capture-use-cases">Use Cases<a class="headerlink" href="#change_data_capture-use-cases" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-1-real-time-data-synchronization">1. Real-Time Data Synchronization<a class="headerlink" href="#change_data_capture-1-real-time-data-synchronization" title="Permanent link">&para;</a></h3>
<p>Stream database changes to external systems (analytics, search, caching):</p>
<pre><code class="language-javascript">let checkpoint = 0;
setInterval(async () =&gt; {
  const res = await fetch(`/changefeed?from_seq=${checkpoint}&amp;limit=100`);
  const data = await res.json();

  for (const event of data.events) {
    await externalSystem.sync(event);
    checkpoint = event.sequence;
  }
}, 1000);
</code></pre>
<h3 id="change_data_capture-2-audit-trail-compliance">2. Audit Trail &amp; Compliance<a class="headerlink" href="#change_data_capture-2-audit-trail-compliance" title="Permanent link">&para;</a></h3>
<p>Track all data mutations for compliance (GDPR, HIPAA):</p>
<pre><code class="language-sql">-- Query all user data modifications
SELECT * FROM changefeed 
WHERE key LIKE 'user:%' AND timestamp_ms &gt; '2025-01-01';
</code></pre>
<h3 id="change_data_capture-3-materialized-views">3. Materialized Views<a class="headerlink" href="#change_data_capture-3-materialized-views" title="Permanent link">&para;</a></h3>
<p>Maintain denormalized views automatically:</p>
<pre><code class="language-javascript">// Maintain user count by role
for (const event of events) {
  if (event.key.startsWith('user:')) {
    if (event.type === 'PUT') {
      const user = JSON.parse(event.value);
      roleCountMap[user.role] = (roleCountMap[user.role] || 0) + 1;
    } else if (event.type === 'DELETE') {
      // Decrement count
    }
  }
}
</code></pre>
<h3 id="change_data_capture-4-event-sourcing">4. Event Sourcing<a class="headerlink" href="#change_data_capture-4-event-sourcing" title="Permanent link">&para;</a></h3>
<p>Rebuild application state from event log:</p>
<pre><code class="language-javascript">// Rebuild state from beginning
const events = await fetch('/changefeed?from_seq=0&amp;limit=1000');
const state = {};
for (const event of events.events) {
  applyEvent(state, event);
}
</code></pre>
<hr />
<h2 id="change_data_capture-performance-skalierung">Performance &amp; Skalierung<a class="headerlink" href="#change_data_capture-performance-skalierung" title="Permanent link">&para;</a></h2>
<p>Aktueller Stand (MVP):
- Einfache, direkte Speicherung in RocksDB (append-only)
- Sequenzvergabe zentral; ausreichend für moderate Schreibraten
- Long-Poll als einfaches Warten mit kurzer Sleep-Periode (~50ms)</p>
<p>Mögliche Erweiterungen (zukünftig):
1. RocksDB WAL Tailing für geringere Latenz
2. Batch-Sequenzvergabe (z. B. Blöcke reservieren)
3. Dedizierte Column Family für CDC
4. Automatische Retention/TTL
5. Push-basierte Benachrichtigungen (WebSocket)
6. Integration in Kafka</p>
<hr />
<h2 id="change_data_capture-retention-cleanup">Retention &amp; Cleanup<a class="headerlink" href="#change_data_capture-retention-cleanup" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-retention-cleanup_1">Retention &amp; Cleanup<a class="headerlink" href="#change_data_capture-retention-cleanup_1" title="Permanent link">&para;</a></h3>
<p>Aktuell: Admin-Endpoint <code>POST /changefeed/retention</code> mit Body <code>{ "before_sequence": &lt;uint64&gt; }</code> löscht Events mit kleinerer Sequence. Statistiken über <code>GET /changefeed/stats</code>.</p>
<p>Zukünftig möglich: TTL-/Zeit-basierte Retention und automatische Bereinigung.</p>
<hr />
<h2 id="change_data_capture-limitations-trade-offs">Limitations &amp; Trade-offs<a class="headerlink" href="#change_data_capture-limitations-trade-offs" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-current-limitations">Current Limitations<a class="headerlink" href="#change_data_capture-current-limitations" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>No Transaction Isolation:</strong> Events are recorded per-mutation, not per-transaction</li>
<li><strong>No Backpressure:</strong> Unlimited event accumulation (manual cleanup required)</li>
<li><strong>Sequential Sequence Generation:</strong> Single point of contention at high write rates</li>
<li><strong>Polling-based Long-poll:</strong> 50ms granularity, not instant</li>
</ol>
<h3 id="change_data_capture-trade-offs">Trade-offs<a class="headerlink" href="#change_data_capture-trade-offs" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Benefit</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>Append-only log</td>
<td>Simple, reliable, never loses events</td>
<td>Linear storage growth</td>
</tr>
<tr>
<td>Automatic tracking</td>
<td>Zero code changes, transparent</td>
<td>Cannot disable for specific entities</td>
</tr>
<tr>
<td>Sequence-based</td>
<td>Guaranteed order, easy checkpointing</td>
<td>Sequential bottleneck</td>
</tr>
<tr>
<td>Default CF storage</td>
<td>Simple deployment</td>
<td>No isolation from application data</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="change_data_capture-integration-examples">Integration Examples<a class="headerlink" href="#change_data_capture-integration-examples" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-powershell-consumer">PowerShell Consumer<a class="headerlink" href="#change_data_capture-powershell-consumer" title="Permanent link">&para;</a></h3>
<pre><code class="language-powershell">$checkpoint = 0
while ($true) {
    $r = Invoke-RestMethod -Uri &quot;http://localhost:8765/changefeed?from_seq=$checkpoint&amp;limit=100&quot;

    foreach ($event in $r.events) {
        Write-Host &quot;[$($event.sequence)] $($event.type) $($event.key)&quot;

        # Process event
        if ($event.type -eq &quot;PUT&quot;) {
            $data = $event.value | ConvertFrom-Json
            # Sync to external system
        }

        $checkpoint = $event.sequence
    }

    Start-Sleep -Seconds 1
}
</code></pre>
<h3 id="change_data_capture-python-consumer">Python Consumer<a class="headerlink" href="#change_data_capture-python-consumer" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">import requests
import time

checkpoint = 0
while True:
    r = requests.get(f'http://localhost:8765/changefeed?from_seq={checkpoint}&amp;limit=100')
    data = r.json()

    for event in data['events']:
        print(f&quot;[{event['sequence']}] {event['type']} {event['key']}&quot;)

        # Process event
        if event['type'] == 'PUT':
            value = json.loads(event['value'])
            # Sync to external system

        checkpoint = event['sequence']

    time.sleep(1)
</code></pre>
<h3 id="change_data_capture-nodejs-consumer-with-long-poll">Node.js Consumer with Long-Poll<a class="headerlink" href="#change_data_capture-nodejs-consumer-with-long-poll" title="Permanent link">&para;</a></h3>
<pre><code class="language-javascript">let checkpoint = 0;

async function consumeChangefeed() {
  while (true) {
    const res = await fetch(
      `http://localhost:8765/changefeed?from_seq=${checkpoint}&amp;limit=100&amp;long_poll_ms=5000`
    );
    const data = await res.json();

    for (const event of data.events) {
      console.log(`[${event.sequence}] ${event.type} ${event.key}`);

      // Process event
      if (event.type === 'PUT') {
        const value = JSON.parse(event.value);
        await processEvent(value);
      }

      checkpoint = event.sequence;
    }

    // Long-poll handles waiting, no need to sleep
  }
}

consumeChangefeed();
</code></pre>
<hr />
<h2 id="change_data_capture-configuration">Configuration<a class="headerlink" href="#change_data_capture-configuration" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-enable-cdc-feature">Enable CDC Feature<a class="headerlink" href="#change_data_capture-enable-cdc-feature" title="Permanent link">&para;</a></h3>
<p><strong>config/config.json:</strong></p>
<pre><code class="language-json">{
  &quot;features&quot;: {
    &quot;cdc&quot;: true
  }
}
</code></pre>
<h3 id="change_data_capture-verify-cdc-status">Verify CDC Status<a class="headerlink" href="#change_data_capture-verify-cdc-status" title="Permanent link">&para;</a></h3>
<p>Check logs on server startup:</p>
<pre><code>[INFO] Changefeed initialized using default CF
</code></pre>
<p>Query an endpoint to verify feature is enabled:</p>
<pre><code class="language-bash">curl http://localhost:8765/changefeed?from_seq=0&amp;limit=1
# Should return events, not 404
</code></pre>
<hr />
<h2 id="change_data_capture-next-steps">Next Steps<a class="headerlink" href="#change_data_capture-next-steps" title="Permanent link">&para;</a></h2>
<h3 id="change_data_capture-geplante-erweiterungen">Geplante Erweiterungen<a class="headerlink" href="#change_data_capture-geplante-erweiterungen" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>RocksDB WAL Tailing:</strong> Real-time event streaming</li>
<li><strong>Transaction-level Events:</strong> Group mutations by transaction</li>
<li><strong>Event Notifications:</strong> WebSocket/SSE for push-based updates</li>
<li><strong>Kafka Integration:</strong> Stream to Kafka topics</li>
<li><strong>Schema Evolution:</strong> Track schema changes in metadata</li>
</ol>
<hr />
<h2 id="change_data_capture-summary">Summary<a class="headerlink" href="#change_data_capture-summary" title="Permanent link">&para;</a></h2>
<p>Zusammenfassung:</p>
<ul>
<li>Sequence-basiertes append-only Log</li>
<li>Automatisches Tracking für PUT/DELETE</li>
<li>GET /changefeed mit Filter/Pagination + Long-Poll</li>
<li>Experimentelles SSE-Streaming (<code>/changefeed/stream</code>) mit Keep-Alive/Heartbeats</li>
</ul>
<p>Einsatz: Echtzeit-Sync, Audit-Trails, Event Sourcing – produktionsnah nutzbar; für sehr hohe Last ggf. Erweiterungen einplanen.</p></section><section class="print-page" id="operations_runbook" heading-number="13.4"><h1 id="operations_runbook-operations-runbook">Operations Runbook<a class="headerlink" href="#operations_runbook-operations-runbook" title="Permanent link">&para;</a></h1>
<p>Dieses Runbook fasst die wichtigsten Betriebsaufgaben und Notfallmaßnahmen für THEMIS zusammen. Es richtet sich an On-Call/Operations und beschreibt Checks, Standardprozeduren und Playbooks.</p>
<h2 id="operations_runbook-1-quick-checks-60-sekunden">1) Quick Checks (60 Sekunden)<a class="headerlink" href="#operations_runbook-1-quick-checks-60-sekunden" title="Permanent link">&para;</a></h2>
<ul>
<li>Health: GET /health</li>
<li>Version: GET /version (falls aktiviert) oder Server-Logs</li>
<li>Metrics: GET /metrics (Prometheus Textformat)</li>
<li>Stats: GET /stats (System-/Storage-Kurzüberblick, falls aktiviert)</li>
<li>Config (laufend): GET /config</li>
</ul>
<p>Beispiele (Windows PowerShell):</p>
<pre><code class="language-powershell">Invoke-RestMethod http://localhost:8765/health
Invoke-RestMethod http://localhost:8765/metrics | Out-String | Select-Object -First 50
Invoke-RestMethod http://localhost:8765/config | ConvertTo-Json -Depth 5
</code></pre>
<p>Linux/macOS:</p>
<pre><code class="language-bash">curl -fsS http://localhost:8765/health
curl -fsS http://localhost:8765/metrics | head -50
curl -fsS http://localhost:8765/config | jq .
</code></pre>
<h2 id="operations_runbook-2-startstoprestart">2) Start/Stop/Restart<a class="headerlink" href="#operations_runbook-2-startstoprestart" title="Permanent link">&para;</a></h2>
<h3 id="operations_runbook-systemd-linux">Systemd (Linux)<a class="headerlink" href="#operations_runbook-systemd-linux" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">sudo systemctl status vccdb
sudo systemctl restart vccdb
sudo journalctl -u vccdb -f
</code></pre>
<h3 id="operations_runbook-docker-docker-compose">Docker / Docker Compose<a class="headerlink" href="#operations_runbook-docker-docker-compose" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash">docker ps | grep vccdb
docker logs -f vccdb
# Restart
docker restart vccdb

# Compose Stack
docker-compose ps
docker-compose logs -f vccdb
docker-compose restart vccdb
</code></pre>
<h3 id="operations_runbook-windows-powershell-standalone-binary">Windows (PowerShell, Standalone Binary)<a class="headerlink" href="#operations_runbook-windows-powershell-standalone-binary" title="Permanent link">&para;</a></h3>
<pre><code class="language-powershell"># Prozess prüfen
Get-Process themis_server -ErrorAction SilentlyContinue
# Starten (aus Build/Release-Verzeichnis)
Start-Process -FilePath &quot;.\build\Release\themis_server.exe&quot; -NoNewWindow
# Stoppen
Get-Process themis_server -ErrorAction SilentlyContinue | Stop-Process -Force
</code></pre>
<h2 id="operations_runbook-3-monitoring-alert-response">3) Monitoring &amp; Alert Response<a class="headerlink" href="#operations_runbook-3-monitoring-alert-response" title="Permanent link">&para;</a></h2>
<p>Wichtige Metriken (siehe auch docs/deployment.md):</p>
<ul>
<li>Server: vccdb_requests_total, vccdb_errors_total, vccdb_qps, process_uptime_seconds</li>
<li>Latenz: vccdb_latency_bucket_microseconds{le="..."}, vccdb_latency_sum_microseconds, vccdb_latency_count</li>
<li>RocksDB: rocksdb_block_cache_usage_bytes, rocksdb_block_cache_capacity_bytes, rocksdb_pending_compaction_bytes, rocksdb_estimate_num_keys</li>
<li>Index: themis_index_rebuild_count, themis_index_rebuild_duration_ms_total, themis_index_rebuild_entities_processed_total, themis_index_cursor_anchor_hits_total, themis_index_range_scan_steps_total</li>
</ul>
<p>Typische Alarme und Sofortmaßnahmen:</p>
<ul>
<li>Hohe Fehlerquote (errors_total):</li>
<li>Logs auf Exceptions prüfen (Server-Logs, /metrics für spikes)</li>
<li>Falls Konfig-Änderung ursächlich: /config zurückdrehen oder Neustart mit bekannter funktionierender config.json</li>
<li>Hohe p95/p99 Latenz:</li>
<li>Compaction-Backlog prüfen (rocksdb_pending_compaction_bytes)</li>
<li>Block Cache Nutzung vs. Kapazität prüfen; ggf. Cache vergrößern (Neustart erforderlich)</li>
<li>Index-Hitrate/Range-Schritte prüfen (range_scan_steps_total); Query-Filter/Indexierung optimieren</li>
<li>Compaction-Backlog hoch:</li>
<li>Wartungsfenster: <code>flush</code>/<code>compactRange</code> per Admin-Tool, IO-Budget freihalten, kurzzeitig Ingestion drosseln</li>
<li>/metrics nicht erreichbar:</li>
<li>Health prüfen; Reverse Proxy/Firewall prüfen; ggf. direkt auf die Instanz zugreifen</li>
</ul>
<h2 id="operations_runbook-4-konfiguration-im-betrieb-hot-reload">4) Konfiguration im Betrieb (Hot-Reload)<a class="headerlink" href="#operations_runbook-4-konfiguration-im-betrieb-hot-reload" title="Permanent link">&para;</a></h2>
<p>Folgende Werte sind zur Laufzeit änderbar (siehe docs/deployment.md → Runtime Configuration):</p>
<ul>
<li>logging.level (trace/debug/info/warn/error)</li>
<li>logging.format (text/json)</li>
<li>request_timeout_ms (1000–300000)</li>
<li>features (z. B. cdc, semantic_cache)</li>
</ul>
<p>Beispiel (Timeout auf 60s):</p>
<pre><code class="language-bash">curl -X POST http://localhost:8765/config \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;request_timeout_ms&quot;: 60000}'
</code></pre>
<p>Tracing an/aus (siehe docs/tracing.md):</p>
<pre><code class="language-json">{
  &quot;tracing&quot;: { &quot;enabled&quot;: true, &quot;service_name&quot;: &quot;themis&quot;, &quot;otlp_endpoint&quot;: &quot;http://localhost:4318&quot; }
}
</code></pre>
<h2 id="operations_runbook-5-backup-restore">5) Backup &amp; Restore<a class="headerlink" href="#operations_runbook-5-backup-restore" title="Permanent link">&para;</a></h2>
<p>Siehe Details in docs/deployment.md → Backup &amp; Recovery.</p>
<h3 id="operations_runbook-snapshot-checkpoint">Snapshot (Checkpoint)<a class="headerlink" href="#operations_runbook-snapshot-checkpoint" title="Permanent link">&para;</a></h3>
<pre><code class="language-bash"># Snapshot erstellen
curl -X POST http://localhost:8765/admin/snapshot \
  -H &quot;Content-Type: application/json&quot; \
  -d '{&quot;path&quot;:&quot;/backups/themis-snap-$(date +%Y%m%d-%H%M%S)&quot;}'

# Restore (Server stoppen, Daten zurückspielen, verifizieren)
./themis_server --restore /backups/themis-snap-YYYYMMDD-HHMMSS --target /var/lib/vccdb/data
</code></pre>
<h3 id="operations_runbook-wal-archivierung">WAL-Archivierung<a class="headerlink" href="#operations_runbook-wal-archivierung" title="Permanent link">&para;</a></h3>
<ul>
<li>WAL-Archiv aktivieren (config.json), regelmäßige Rotation/Retention einplanen</li>
</ul>
<h2 id="operations_runbook-6-index-und-datenpflege-wartung">6) Index- und Datenpflege (Wartung)<a class="headerlink" href="#operations_runbook-6-index-und-datenpflege-wartung" title="Permanent link">&para;</a></h2>
<p>Dokumentation und API-Beispiele: <code>docs/indexes.md</code>, <code>docs/index_stats_maintenance.md</code>.</p>
<ul>
<li>Rebuild einzelner Indizes (bei Inkonsistenzen, Schema-Änderungen)</li>
<li>Reindex ganzer Tabellen (geplant für Wartungsfenster)</li>
<li>TTL-Cleanup regelmäßig ausführen (Cron/Timer in Admin-Service)</li>
</ul>
<p>Hinweis: Die Rebuild-/Reindex-APIs existieren in der Serverbibliothek (C++). In Produktion idealerweise über ein Admin-Tool oder Maintenance-Job nutzen. Beachte die Metriken <code>themis_index_rebuild_*</code> für Dauer/Progress.</p>
<h2 id="operations_runbook-7-cdc-betrieb-change-data-capture">7) CDC Betrieb (Change Data Capture)<a class="headerlink" href="#operations_runbook-7-cdc-betrieb-change-data-capture" title="Permanent link">&para;</a></h2>
<p>Siehe <code>docs/change_data_capture.md</code>.</p>
<ul>
<li>Aktivieren über Feature Flag in config.json</li>
<li>Pull-Pattern: <code>GET /changefeed?from_seq=&lt;checkpoint&gt;&amp;limit=&lt;N&gt;</code></li>
<li>Long-Poll: <code>long_poll_ms</code> zur Latenzreduktion</li>
<li>Retention/Cleanup: Admin-Endpunkt (vorherige Sequenzen entfernen) gemäß Doku</li>
<li>Reverse Proxy für SSE-Stream <code>/changefeed/stream</code> korrekt konfigurieren (Keep-Alive, keine Pufferung)</li>
</ul>
<h2 id="operations_runbook-8-skalierung-performance">8) Skalierung &amp; Performance<a class="headerlink" href="#operations_runbook-8-skalierung-performance" title="Permanent link">&para;</a></h2>
<ul>
<li>Threads: <code>server.worker_threads</code> (Neustart erforderlich)</li>
<li>VectorIndex (ANN): <code>efSearch</code> zur Laufzeit erhöhen für Genauigkeit, trade-off Latenz</li>
<li>RocksDB:</li>
<li><code>block_cache_size_mb</code>, <code>memtable_size_mb</code> (Neustart erforderlich)</li>
<li>Direct IO/Compaction-Optionen nur nach Tests ändern</li>
<li>Compose/K8s: Ressourcenlimits und Replikate anpassen; Load Balancer/Sticky Sessions bei SSE beachten</li>
</ul>
<h2 id="operations_runbook-9-troubleshooting-playbooks-kurzfassung">9) Troubleshooting Playbooks (Kurzfassung)<a class="headerlink" href="#operations_runbook-9-troubleshooting-playbooks-kurzfassung" title="Permanent link">&para;</a></h2>
<ul>
<li>API 5xx Spike</li>
<li>Health OK? /health</li>
<li>Logs auf Exceptions prüfen</li>
<li>Letzte Config-Änderungen rückgängig machen (POST /config) oder Neustart</li>
<li>
<p>Bei Indexfehlern: betroffenen Index im Wartungsfenster rebuilden</p>
</li>
<li>
<p>Abfragen sehr langsam</p>
</li>
<li>p95/p99 prüfen, Range-Schritte hoch? → Index-Selektion/Prädikate prüfen</li>
<li>Compaction-Backlog hoch? → IO-Feuerwehr (Flush/Compaction), Ingestion drosseln</li>
<li>
<p>Vector-Suche: <code>efSearch</code> erhöhen, ggf. ANN-Persistenz laden (<code>saveIndex</code>/<code>loadIndex</code>)</p>
</li>
<li>
<p>CDC Events fehlen</p>
</li>
<li>Feature aktiviert? Config prüfen</li>
<li>/changefeed liefert latest_sequence, checkpoint-Logik auf Consumer-Seite prüfen</li>
<li>
<p>Reverse Proxy-Einstellungen für SSE prüfen</p>
</li>
<li>
<p>Graph-Anomalien (Kanten fehlen)</p>
</li>
<li>Topologie neu aufbauen (<code>GraphIndexManager::rebuildTopology()</code> im Maintenance-Tool)</li>
</ul>
<h2 id="operations_runbook-10-slosli-empfehlung">10) SLO/SLI (Empfehlung)<a class="headerlink" href="#operations_runbook-10-slosli-empfehlung" title="Permanent link">&para;</a></h2>
<ul>
<li>Verfügbarkeit (monthly): ≥ 99.9%</li>
<li>p95 Latenz (Query): ≤ 200 ms (je Index/Workload variabel)</li>
<li>Fehlerquote: &lt; 0.1% Requests</li>
<li>Compaction Backlog: &lt; 5 GB über 15 Minuten</li>
</ul>
<h2 id="operations_runbook-11-checklisten">11) Checklisten<a class="headerlink" href="#operations_runbook-11-checklisten" title="Permanent link">&para;</a></h2>
<h3 id="operations_runbook-releasedeployment-checklist">Release/Deployment Checklist<a class="headerlink" href="#operations_runbook-releasedeployment-checklist" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] Config validiert (<code>--validate</code>)</li>
<li>[ ] Health/Metrics erreichbar</li>
<li>[ ] Prometheus/Grafana up-to-date</li>
<li>[ ] CDC Feature-Flags korrekt</li>
<li>[ ] Backup-Policy aktiv</li>
</ul>
<h3 id="operations_runbook-incident-checklist">Incident Checklist<a class="headerlink" href="#operations_runbook-incident-checklist" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] Health/Errors/Latenz geprüft</li>
<li>[ ] Logs nach top Errors gefiltert</li>
<li>[ ] Konfig-Drift ausgeschlossen (/config)</li>
<li>[ ] Compaction/Storage-Lage geprüft</li>
<li>[ ] Eskalation/Kommunikation dokumentiert</li>
</ul>
<hr />
<p>Weitere Details: 
- Deployment &amp; Betrieb: <code>docs/deployment.md</code>
- Tracing: <code>docs/tracing.md</code>
- CDC: <code>docs/change_data_capture.md</code>
- Indexe &amp; Wartung: <code>docs/indexes.md</code>, <code>docs/index_stats_maintenance.md</code></p></section></section><section class="print-page" id="publishing" heading-number="14"><h1 id="publishing-publikation-ablage">Publikation &amp; Ablage<a class="headerlink" href="#publishing-publikation-ablage" title="Permanent link">&para;</a></h1>
<p>Diese Seite beschreibt den Build der Dokumentation, die Veröffentlichung auf GitHub Pages und einen optionalen PDF-Export für Offline-Nutzung.</p>
<h2 id="publishing-1-lokaler-docs-build">1) Lokaler Docs-Build<a class="headerlink" href="#publishing-1-lokaler-docs-build" title="Permanent link">&para;</a></h2>
<p>Voraussetzungen: Python 3.x, <code>pip</code>, <code>mkdocs</code>, <code>mkdocs-material</code>.</p>
<pre><code class="language-powershell"># Optional: Virtuelle Umgebung (empfohlen)
# py -3 -m venv .venv ; .\.venv\Scripts\Activate.ps1

pip install --upgrade pip
pip install mkdocs mkdocs-material

# Aus dem Repo-Root
mkdocs serve
# Browser: http://127.0.0.1:8000

# Produktion (statisches Site-Verzeichnis &quot;site/&quot;)
mkdocs build
</code></pre>
<h2 id="publishing-2-github-pages-deployment-ci">2) GitHub Pages Deployment (CI)<a class="headerlink" href="#publishing-2-github-pages-deployment-ci" title="Permanent link">&para;</a></h2>
<p>Das Repo enthält einen Workflow unter <code>.github/workflows/docs.yml</code>, der bei Push auf <code>main</code> die Seite baut und per GitHub Pages veröffentlicht.</p>
<ul>
<li>Artefakt: <code>site/</code></li>
<li>Veröffentlichung: <code>https://&lt;owner&gt;.github.io/&lt;repo&gt;/</code> (Repository Settings → Pages → Build &amp; Deployment: GitHub Actions)</li>
</ul>
<p>Falls dein Projektname/Org abweicht, passe optional <code>site_url</code> in <code>mkdocs.yml</code>.</p>
<h2 id="publishing-3-pdf-export-optional">3) PDF-Export (optional)<a class="headerlink" href="#publishing-3-pdf-export-optional" title="Permanent link">&para;</a></h2>
<p>Für einen einfachen PDF-Export gibt es mehrere Wege; zwei pragmatische Varianten:</p>
<ul>
<li>Browser-basiert: <code>mkdocs build</code> ausführen und die Startseite <code>site/index.html</code> im Browser als PDF drucken (Hintergrundgrafiken aktivieren).</li>
<li>Plugin-basiert: <code>mkdocs-with-pdf</code> oder <code>mkdocs-pdf-export-plugin</code> nutzen.</li>
</ul>
<p>Beispiel (lokal, ohne CI-Verpflichtung):</p>
<pre><code class="language-powershell">pip install mkdocs-with-pdf
# Temporär im Build aufrufen
mkdocs build --use-directory-urls
# Danach PDF-Generierung (abhängig vom Plugin, siehe Plugin-Doku)
</code></pre>
<p>Hinweis: PDF-Plugins benötigen oft zusätzliche Systembibliotheken (WeasyPrint/wkhtmltopdf). Für Repro in CI lieber separat halten.</p>
<h2 id="publishing-4-artefakt-ablage">4) Artefakt-Ablage<a class="headerlink" href="#publishing-4-artefakt-ablage" title="Permanent link">&para;</a></h2>
<ul>
<li>Site-Build: <code>site/</code>-Ordner (statisch, kann als Release-Asset oder Pages-Artefakt genutzt werden)</li>
<li>Optional: ZIP der Doku für Offline-Verteilung</li>
</ul>
<pre><code class="language-powershell">Compress-Archive -Path .\site\* -DestinationPath .\site.zip -Force
</code></pre>
<h2 id="publishing-5-troubleshooting">5) Troubleshooting<a class="headerlink" href="#publishing-5-troubleshooting" title="Permanent link">&para;</a></h2>
<ul>
<li>404 in Navigation: Prüfe <code>mkdocs.yml</code>-Pfade und ob Dateien existieren</li>
<li>Lokaler Build schlägt fehl: <code>mkdocs build --verbose</code> und auf fehlende Plugins achten</li>
<li>Pages zeigt alte Version: Warte auf Actions-Finish, ggf. Browser-Cache leeren</li>
</ul></section>
                    <section class='print-page md-section' id='section-15' heading-number='15'>
                        <h1>Admin-Tools<a class='headerlink' href='#section-15' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="admin_tools_admin_guide" heading-number="15.1"><h1 id="admin_tools_admin_guide-themis-admin-tools-admin-guide">Themis Admin Tools – Admin-Guide<a class="headerlink" href="#admin_tools_admin_guide-themis-admin-tools-admin-guide" title="Permanent link">&para;</a></h1>
<p>Dieser Guide richtet sich an Administratoren und beschreibt Bereitstellung, Konfiguration, Betrieb und Troubleshooting der Themis Admin-Tools (Audit, SAGA, Keys, Classification, Reports, Retention, PII).</p>
<h2 id="admin_tools_admin_guide-architektur-uberblick">Architektur-Überblick<a class="headerlink" href="#admin_tools_admin_guide-architektur-uberblick" title="Permanent link">&para;</a></h2>
<ul>
<li>Frontend: WPF-Tools mit einheitlichem Themis-Layout</li>
<li>Backend: Themis-Server (Boost.Beast HTTP), Standard-Port: 8765</li>
<li>Kommunikation: REST-APIs gemäß <code>docs/openapi.yaml</code> und ergänzende SSE-Streams</li>
</ul>
<h2 id="admin_tools_admin_guide-build-deployment">Build &amp; Deployment<a class="headerlink" href="#admin_tools_admin_guide-build-deployment" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_admin_guide-self-contained-publish-win-x64">Self-contained Publish (Win-x64)<a class="headerlink" href="#admin_tools_admin_guide-self-contained-publish-win-x64" title="Permanent link">&para;</a></h3>
<ul>
<li>Skript: <code>publish-all.ps1</code></li>
<li>Ausgabe: <code>dist/&lt;ProjektName&gt;/</code></li>
<li>Beispiel:</li>
<li>Release-Build aller Tools veröffentlichen</li>
<li>Artefakte in gemeinsamen <code>dist</code>-Ordner ablegen</li>
</ul>
<h3 id="admin_tools_admin_guide-verteilung">Verteilung<a class="headerlink" href="#admin_tools_admin_guide-verteilung" title="Permanent link">&para;</a></h3>
<ul>
<li>Kopieren Sie die jeweiligen Tool-Ordner aus <code>dist/&lt;ProjektName&gt;/</code> auf Zielsysteme</li>
<li>Optional: Code Signing der EXEs (Empfehlung für produktive Nutzung)</li>
</ul>
<h3 id="admin_tools_admin_guide-update-prozess">Update-Prozess<a class="headerlink" href="#admin_tools_admin_guide-update-prozess" title="Permanent link">&para;</a></h3>
<ul>
<li>Erneut <code>publish-all.ps1</code> ausführen (Release)</li>
<li>Verteilte Ordner ersetzen (Downtime beachten, wenn Tools geöffnet sind)</li>
</ul>
<h2 id="admin_tools_admin_guide-konfiguration">Konfiguration<a class="headerlink" href="#admin_tools_admin_guide-konfiguration" title="Permanent link">&para;</a></h2>
<ul>
<li>Standard-Server-URL: <code>http://localhost:8765</code></li>
<li>WICHTIG: Aktuell erwarten die Admin-Tools-HTTP-Clients teils einen <code>/api</code>-Prefix (z. B. <code>/api/keys</code>). Der Themis-Server stellt die Endpunkte ohne Prefix bereit (z. B. <code>/keys</code>). Empfohlene Optionen:</li>
<li>Reverse-Proxy (empfohlen): Leiten Sie <code>/api/*</code> auf den Server-Root <code>/</code> um (Rewrite). Beispiel: Nginx <code>location /api/ { proxy_pass http://localhost:8765/; rewrite ^/api/(.*)$ /$1 break; }</code></li>
<li>Alternativ (Folgearbeit): Die Tools auf prefix-freie Routen umstellen.</li>
<li>Netzwerk: Firewalls/Proxies so konfigurieren, dass der Server erreichbar ist</li>
<li>Konfigurationsdatei: Basis-URL der Tools zentral konfigurierbar halten (BaseUrl, Timeout)</li>
</ul>
<h2 id="admin_tools_admin_guide-relevante-admin-apis-fur-keysclassificationreports">Relevante Admin-APIs (für Keys/Classification/Reports)<a class="headerlink" href="#admin_tools_admin_guide-relevante-admin-apis-fur-keysclassificationreports" title="Permanent link">&para;</a></h2>
<ul>
<li>Keys Management</li>
<li>GET <code>/keys</code> → Liste gemanagter Schlüssel</li>
<li>POST <code>/keys/rotate</code> → Rotation eines Schlüssels; Parameter <code>key_id</code> im Body (JSON) oder als Query (<code>?key_id=...</code>)</li>
<li>Classification</li>
<li>GET <code>/classification/rules</code> → Liste aktiver Klassifizierungsregeln</li>
<li>POST <code>/classification/test</code> → Testen mit Body <code>{ "text": "...", "metadata": { ... } }</code></li>
<li>Compliance Reports</li>
<li>GET <code>/reports/compliance?type=overview|dsgvo|sox|hipaa|iso27001|pci</code></li>
</ul>
<p>Hinweis: Die genauen Schemas und Fehlercodes sind in <code>docs/openapi.yaml</code> beschrieben. Der SSE-Changefeed ist separat dokumentiert (<code>docs/apis/openapi.md#sse-streaming-changefeed</code>).</p>
<h2 id="admin_tools_admin_guide-betrieb-monitoring">Betrieb &amp; Monitoring<a class="headerlink" href="#admin_tools_admin_guide-betrieb-monitoring" title="Permanent link">&para;</a></h2>
<ul>
<li>Server-Logs prüfen (<code>server.err</code>)</li>
<li>Health-Check: <code>GET /health</code> → 200 OK bei funktionsfähigem Server</li>
<li>Metriken: <code>GET /metrics</code> (Prometheus-Format)</li>
<li>Tool-Start per Doppelklick aus <code>dist/...</code></li>
<li>Performance: Self-contained reduziert Abhängigkeiten; ggf. R2R/Trim anpassen</li>
</ul>
<h2 id="admin_tools_admin_guide-sicherheit-kurzuberblick">Sicherheit (Kurzüberblick)<a class="headerlink" href="#admin_tools_admin_guide-sicherheit-kurzuberblick" title="Permanent link">&para;</a></h2>
<ul>
<li>Code-Signierung der Binaries</li>
<li>Least-Privilege für Service-Accounts</li>
<li>TLS-Termination/Reverse-Proxy vor Themis-Server</li>
<li>Regelmäßige Dependency-Scans (Server/Clients)</li>
<li>Schlüsselverwaltung: Nur autorisierte Nutzer dürfen <code>/keys/rotate</code> verwenden (Absicherung via Reverse-Proxy/Firewall/RBAC)</li>
</ul>
<h2 id="admin_tools_admin_guide-troubleshooting">Troubleshooting<a class="headerlink" href="#admin_tools_admin_guide-troubleshooting" title="Permanent link">&para;</a></h2>
<ul>
<li>Tools zeigen keine Daten</li>
<li>Läuft der Server? Hört er auf Port 8765?</li>
<li>API-Routen mit Browser/HTTP-Client testen</li>
<li>Stimmt das Routing <code>/api/*</code> → <code>/</code> (Reverse-Proxy)?</li>
<li>Filter zurücksetzen, Logs prüfen</li>
<li>Export schlägt fehl</li>
<li>Schreibrechte im Zielverzeichnis</li>
<li>Ggf. Admin-Konsole verwenden</li>
<li>UI wirkt „leer“</li>
<li>Server offline / Endpoints liefern 204/404</li>
<li>Prüfen, ob Demo-Daten-Backend aktiv ist</li>
</ul>
<h2 id="admin_tools_admin_guide-anhang">Anhang<a class="headerlink" href="#admin_tools_admin_guide-anhang" title="Permanent link">&para;</a></h2>
<ul>
<li>OpenAPI: <code>docs/openapi.yaml</code></li>
<li>Architekturdokumentation: <code>docs/architecture.md</code>, <code>docs/content_architecture.md</code></li>
<li>Admin-Tools Benutzerhandbuch: <code>docs/admin_tools_user_guide.md</code></li>
</ul></section><section class="print-page" id="admin_tools_user_guide" heading-number="15.2"><h1 id="admin_tools_user_guide-themis-admin-tools-benutzerhandbuch">Themis Admin Tools – Benutzerhandbuch<a class="headerlink" href="#admin_tools_user_guide-themis-admin-tools-benutzerhandbuch" title="Permanent link">&para;</a></h1>
<p>Dieses Handbuch beschreibt die sieben Themis Admin-Tools mit einheitlichem Layout (Toolbar | Sidebar | Content | StatusBar) und erklärt die wichtigsten Funktionen und Workflows.</p>
<ul>
<li>Einheitliches Branding: Rechts oben „Themis“ (hellblau) öffnet den About-Dialog</li>
<li>Hamburger-Menü: Links oben einklappbare Sidebar</li>
<li>StatusBar: Live-Status, Zähler und Ladeindikator</li>
</ul>
<h2 id="admin_tools_user_guide-gemeinsame-bedienkonzepte">Gemeinsame Bedienkonzepte<a class="headerlink" href="#admin_tools_user_guide-gemeinsame-bedienkonzepte" title="Permanent link">&para;</a></h2>
<ul>
<li>Themis-Brand-Button: Klick öffnet „Über …“-Dialog mit Version/Build-Hinweisen</li>
<li>Hamburger-Button: Sidebar ein-/ausblenden</li>
<li>Suche: Textfeld über dem Grid filtert die angezeigten Einträge</li>
<li>Export: CSV/PDF/Excel je nach Tool verfügbar</li>
</ul>
<h2 id="admin_tools_user_guide-1-audit-log-viewer">1) Audit Log Viewer<a class="headerlink" href="#admin_tools_user_guide-1-audit-log-viewer" title="Permanent link">&para;</a></h2>
<ul>
<li>Zweck: Audit-Events sichten, filtern, exportieren</li>
<li>Wichtige Aktionen: Aktualisieren, CSV-Export</li>
<li>Filter: Datum, Benutzer, Action, Entity</li>
<li>Tipps: Multi-Column-Sortierung über Spaltenköpfe nutzen</li>
</ul>
<h2 id="admin_tools_user_guide-2-saga-verifier">2) SAGA Verifier<a class="headerlink" href="#admin_tools_user_guide-2-saga-verifier" title="Permanent link">&para;</a></h2>
<ul>
<li>Zweck: SAGA-Batch-Signaturen verifizieren</li>
<li>Aktionen: Batches laden, Details ansehen, Signatur prüfen, Batch flushen</li>
<li>Hinweise: Detail-View zeigt Steps/Ergebnisse; Export-Funktion verfügbar</li>
</ul>
<h2 id="admin_tools_user_guide-3-pii-manager">3) PII Manager<a class="headerlink" href="#admin_tools_user_guide-3-pii-manager" title="Permanent link">&para;</a></h2>
<ul>
<li>Zweck: Verwaltung von UUID↔Pseudonym-Mappings, Art. 17 Löschung, Export</li>
<li>Aktionen: Laden, Export CSV, Filter zurücksetzen, DSGVO-Löschung per UUID</li>
<li>Grid-Spalten: OriginalUuid, Pseudonym, CreatedAt, UpdatedAt, Active</li>
</ul>
<h2 id="admin_tools_user_guide-4-key-rotation-dashboard">4) Key Rotation Dashboard<a class="headerlink" href="#admin_tools_user_guide-4-key-rotation-dashboard" title="Permanent link">&para;</a></h2>
<ul>
<li>Zweck: Überblick über LEK/KEK/DEK-Keys, Rotations-Status und manuelle Rotation</li>
<li>Aktionen: Aktualisieren, Rotieren (gesamt oder je Typ LEK/KEK/DEK)</li>
<li>Filter: Schlüsseltyp, nur abgelaufene Keys</li>
<li>StatusBar: Anzahl Schlüssel und abgelaufene in Rot</li>
</ul>
<p>Backend-Calls:
- Liste laden: GET <code>/keys</code>
- Rotation auslösen: POST <code>/keys/rotate</code>
    - Parameter: <code>key_id</code> im JSON-Body <code>{ "key_id": "DEK" }</code> oder als Query <code>?key_id=DEK</code></p>
<p>Fehlerfälle und Hinweise:
- 400 Missing key_id → Bitte Schlüssel auswählen
- 503 Keys API not available → Server-Konfiguration prüfen (KeyProvider)</p>
<h2 id="admin_tools_user_guide-5-retention-manager">5) Retention Manager<a class="headerlink" href="#admin_tools_user_guide-5-retention-manager" title="Permanent link">&para;</a></h2>
<ul>
<li>Zweck: Aufbewahrungs-Policies verwalten und Bereinigung auslösen</li>
<li>Aktionen: Policies laden, neue Policy erstellen, Bereinigung starten</li>
<li>Filter: Status (Aktiv/Inaktiv/Abgelaufen), Entitätstyp (AuditLog/Document/…)</li>
</ul>
<h2 id="admin_tools_user_guide-6-classification-dashboard">6) Classification Dashboard<a class="headerlink" href="#admin_tools_user_guide-6-classification-dashboard" title="Permanent link">&para;</a></h2>
<ul>
<li>Zweck: Datenklassifizierung (PUBLIC/INTERNAL/CONFIDENTIAL/RESTRICTED) überwachen und testen</li>
<li>Aktionen: Aktualisieren, CSV-Export, Compliance-Check, Test-Classification</li>
<li>Filter: Klassifizierung, Verschlüsselung, Compliance-Status, Gaps-only</li>
<li>Statistik: Live-Counts in der Sidebar</li>
</ul>
<p>Backend-Calls:
- Regeln laden: GET <code>/classification/rules</code>
- Klassifikation testen: POST <code>/classification/test</code>
    - Body: <code>{ "text": "&lt;Probeinhalt&gt;", "metadata": { "source": "sample" } }</code>
    - Response: <code>{ "classification": "CONFIDENTIAL", "confidence": 0.92, "detected_entities": [ { "type": "EMAIL", "value": "a@b.c" } ] }</code></p>
<p>Fehlerfälle und Hinweise:
- 400 Missing JSON body → Eingabefeld ausfüllen
- 503 Classification API not available → Server-Konfiguration (PIIDetector) prüfen</p>
<h2 id="admin_tools_user_guide-7-compliance-reports">7) Compliance Reports<a class="headerlink" href="#admin_tools_user_guide-7-compliance-reports" title="Permanent link">&para;</a></h2>
<ul>
<li>Zweck: Reports (DSGVO, SOX, HIPAA, ISO 27001, PCI-DSS) generieren und exportieren</li>
<li>Aktionen: Report generieren, Export (PDF/Excel/CSV)</li>
<li>Einstellungen: Zeitraum, Template (Standard/Detailliert/…); Diagramme/Technikdetails</li>
</ul>
<p>Backend-Calls:
- Compliance-Übersicht laden: GET <code>/reports/compliance?type=overview|dsgvo|sox|hipaa|iso27001|pci</code>
    - Response-Beispiel (gekürzt): <code>{ "report_type": "overview", "generated_at": "2025-11-02T14:55:00Z", "metrics": { "encrypted_entities": 1234, "pii_findings": 42 } }</code></p>
<p>Fehlerfälle und Hinweise:
- 503 Reports API not available → Server-Berechtigungen/Config prüfen</p>
<h2 id="admin_tools_user_guide-starten-der-tools">Starten der Tools<a class="headerlink" href="#admin_tools_user_guide-starten-der-tools" title="Permanent link">&para;</a></h2>
<ul>
<li>Bereitstellung: Veröffentlichte EXEs liegen unter <code>dist/&lt;ToolName&gt;/</code></li>
<li>Start: Doppelklick auf die jeweilige EXE</li>
<li>Voraussetzung: Themis-Server sollte laufen (Standard: http://localhost:8765)</li>
</ul>
<p>Routing-Hinweis:
- Falls die Tools <code>/api/*</code>-Routen verwenden, richten Sie einen Reverse-Proxy ein, der <code>/api/</code> auf den Server-Root <code>/</code> rewritet (siehe Admin-Guide). Alternativ die Tool-Konfiguration auf prefix-freie Endpunkte anpassen.</p>
<h2 id="admin_tools_user_guide-haufige-fragen-faq">Häufige Fragen (FAQ)<a class="headerlink" href="#admin_tools_user_guide-haufige-fragen-faq" title="Permanent link">&para;</a></h2>
<ul>
<li>Die Sidebar ist weg? → Mit dem ☰-Button oben links wieder einblenden</li>
<li>Export-Datei nicht sichtbar? → In den Standard-Download-Ordner oder Tool-Verzeichnis schauen; ggf. mit Admin-Rechten starten</li>
<li>Keine Daten? → Server/Endpoint prüfen, Logs ansehen, Filter zurücksetzen</li>
</ul></section><section class="print-page" id="admin_tools_feature_matrix" heading-number="15.3"><h1 id="admin_tools_feature_matrix-themisdb-admin-tools-feature-matrix">ThemisDB Admin Tools - Feature Matrix<a class="headerlink" href="#admin_tools_feature_matrix-themisdb-admin-tools-feature-matrix" title="Permanent link">&para;</a></h1>
<h2 id="admin_tools_feature_matrix-ubersicht-der-implementierten-features">Übersicht der implementierten Features<a class="headerlink" href="#admin_tools_feature_matrix-ubersicht-der-implementierten-features" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_feature_matrix-key-rotation-dashboard">✅ Key Rotation Dashboard<a class="headerlink" href="#admin_tools_feature_matrix-key-rotation-dashboard" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schlüssel-Übersicht</td>
<td>✅</td>
<td>Anzeige LEK/KEK/DEK inkl. Version/Status</td>
</tr>
<tr>
<td>Manuelle Rotation</td>
<td>✅</td>
<td>POST <code>/keys/rotate</code> mit <code>key_id</code> (Body/Query)</td>
</tr>
<tr>
<td>Filter</td>
<td>✅</td>
<td>Nach Typ (LEK/KEK/DEK), „nur abgelaufene“</td>
</tr>
<tr>
<td>Status-Updates</td>
<td>✅</td>
<td>Zähler gesamt/abgelaufen</td>
</tr>
<tr>
<td>Fehlerbehandlung</td>
<td>✅</td>
<td>400/503 verständlich anzeigen</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="admin_tools_feature_matrix-classification-dashboard">✅ Classification Dashboard<a class="headerlink" href="#admin_tools_feature_matrix-classification-dashboard" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Regeln laden</td>
<td>✅</td>
<td>GET <code>/classification/rules</code></td>
</tr>
<tr>
<td>Test-Classification</td>
<td>✅</td>
<td>POST <code>/classification/test</code> mit <code>{ text, metadata }</code></td>
</tr>
<tr>
<td>Export</td>
<td>✅</td>
<td>CSV-Export der Ergebnisse</td>
</tr>
<tr>
<td>Filter</td>
<td>✅</td>
<td>Level, Verschlüsselung, Compliance-Status</td>
</tr>
<tr>
<td>Live-Statistik</td>
<td>✅</td>
<td>Counts in Sidebar</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="admin_tools_feature_matrix-compliance-reports">✅ Compliance Reports<a class="headerlink" href="#admin_tools_feature_matrix-compliance-reports" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Report-Generierung</td>
<td>✅</td>
<td>GET <code>/reports/compliance?type=...</code></td>
</tr>
<tr>
<td>Formate</td>
<td>✅</td>
<td>JSON (Server), Export in den Tools (CSV/PDF/Excel)</td>
</tr>
<tr>
<td>Vorlagen</td>
<td>✅</td>
<td>Standard/Detailliert (Tool-seitig)</td>
</tr>
<tr>
<td>Zeitraum</td>
<td>✅</td>
<td>Parametrierbar (Tool-seitig)</td>
</tr>
<tr>
<td>Fehlerbehandlung</td>
<td>✅</td>
<td>503 „Reports API not available“ verständlich</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="admin_tools_feature_matrix-audit-log-viewer">✅ Audit Log Viewer<a class="headerlink" href="#admin_tools_feature_matrix-audit-log-viewer" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Datumsfilter</strong></td>
<td>✅</td>
<td>Von/Bis-Datum mit DatePicker</td>
</tr>
<tr>
<td><strong>Benutzerfilter</strong></td>
<td>✅</td>
<td>Filter nach Username</td>
</tr>
<tr>
<td><strong>Aktionsfilter</strong></td>
<td>✅</td>
<td>Filter nach Action-Typ</td>
</tr>
<tr>
<td><strong>Entitätsfilter</strong></td>
<td>✅</td>
<td>Filter nach EntityType</td>
</tr>
<tr>
<td><strong>Erfolgsfilter</strong></td>
<td>✅</td>
<td>"Nur erfolgreiche Aktionen" Checkbox</td>
</tr>
<tr>
<td><strong>Globale Suche</strong></td>
<td>✅</td>
<td>Durchsucht alle 9 Spalten gleichzeitig</td>
</tr>
<tr>
<td><strong>Multi-Column Sort</strong></td>
<td>✅</td>
<td>Sortierung nach ID, Timestamp, User, Action, etc.</td>
</tr>
<tr>
<td><strong>Toggle Sort</strong></td>
<td>✅</td>
<td>Klick wechselt aufsteigend/absteigend</td>
</tr>
<tr>
<td><strong>Paginierung</strong></td>
<td>✅</td>
<td>Vor/Zurück Buttons, 100 Einträge/Seite</td>
</tr>
<tr>
<td><strong>CSV Export</strong></td>
<td>✅</td>
<td>Export gefilterte Daten</td>
</tr>
<tr>
<td><strong>Status-Updates</strong></td>
<td>✅</td>
<td>Zeigt gefilterte/gesamt Anzahl</td>
</tr>
<tr>
<td><strong>Filter löschen</strong></td>
<td>✅</td>
<td>Reset aller Filter auf Default</td>
</tr>
<tr>
<td><strong>ICollectionView</strong></td>
<td>✅</td>
<td>Performante Client-Filter</td>
</tr>
<tr>
<td><strong>MVVM Pattern</strong></td>
<td>✅</td>
<td>Clean Architecture</td>
</tr>
<tr>
<td><strong>Dependency Injection</strong></td>
<td>✅</td>
<td>Microsoft.Extensions.DI</td>
</tr>
</tbody>
</table>
<p><strong>Durchsuchbare Felder:</strong>
- User (Benutzername)
- Action (Aktion)
- EntityType (Entitätstyp)
- EntityId (Entitäts-ID)
- OldValue (Alter Wert)
- NewValue (Neuer Wert)
- IpAddress (IP-Adresse)
- SessionId (Sitzungs-ID)
- ErrorMessage (Fehlermeldung)</p>
<hr />
<h3 id="admin_tools_feature_matrix-saga-verifier">✅ SAGA Verifier<a class="headerlink" href="#admin_tools_feature_matrix-saga-verifier" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Batch-Liste</strong></td>
<td>✅</td>
<td>Übersicht aller SAGA-Batches</td>
</tr>
<tr>
<td><strong>Batch-Suche</strong></td>
<td>✅</td>
<td>Suche nach ID, Hash, Signatur, Timestamp</td>
</tr>
<tr>
<td><strong>Batch-Detail</strong></td>
<td>✅</td>
<td>Vollständige Batch-Informationen</td>
</tr>
<tr>
<td><strong>SAGA-Steps</strong></td>
<td>✅</td>
<td>Liste aller Schritte im Batch</td>
</tr>
<tr>
<td><strong>Step-Suche</strong></td>
<td>✅</td>
<td>Suche nach SAGA ID, Step Name, Status, etc.</td>
</tr>
<tr>
<td><strong>Multi-Column Sort</strong></td>
<td>✅</td>
<td>Sortierung für Batches &amp; Steps</td>
</tr>
<tr>
<td><strong>Signatur-Verifizierung</strong></td>
<td>✅</td>
<td>Kryptographische Prüfung</td>
</tr>
<tr>
<td><strong>Batch Flush</strong></td>
<td>✅</td>
<td>Manuelles Flushen des aktuellen Batches</td>
</tr>
<tr>
<td><strong>CSV Export</strong></td>
<td>✅</td>
<td>Export SAGA-Steps</td>
</tr>
<tr>
<td><strong>Auto-Load Detail</strong></td>
<td>✅</td>
<td>Automatisches Laden bei Batch-Auswahl</td>
</tr>
<tr>
<td><strong>Status-Updates</strong></td>
<td>✅</td>
<td>Zeigt gefilterte/gesamt Anzahl</td>
</tr>
<tr>
<td><strong>Split-View</strong></td>
<td>✅</td>
<td>Batch-Liste</td>
</tr>
<tr>
<td><strong>Visual Feedback</strong></td>
<td>✅</td>
<td>✓/✗ für Verifikations-Status</td>
</tr>
<tr>
<td><strong>ICollectionView</strong></td>
<td>✅</td>
<td>Separate Filter für Batches &amp; Steps</td>
</tr>
<tr>
<td><strong>MVVM Pattern</strong></td>
<td>✅</td>
<td>CommunityToolkit.Mvvm</td>
</tr>
</tbody>
</table>
<p><strong>Batch-Suchfelder:</strong>
- BatchId (Batch-ID)
- Hash (SHA-256 Hash)
- Signature (Kryptographische Signatur)
- Timestamp (Zeitstempel)</p>
<p><strong>Step-Suchfelder:</strong>
- SagaId (SAGA-ID)
- StepName (Schrittname)
- Status (Status)
- CorrelationId (Korrelations-ID)
- Metadata (Metadaten JSON)</p>
<hr />
<h2 id="admin_tools_feature_matrix-gemeinsame-features">Gemeinsame Features<a class="headerlink" href="#admin_tools_feature_matrix-gemeinsame-features" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_feature_matrix-technologie-stack">Technologie-Stack<a class="headerlink" href="#admin_tools_feature_matrix-technologie-stack" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Komponente</th>
<th>Technologie</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Framework</strong></td>
<td>.NET</td>
<td>8.0</td>
</tr>
<tr>
<td><strong>UI</strong></td>
<td>WPF</td>
<td>Windows Presentation Foundation</td>
</tr>
<tr>
<td><strong>MVVM</strong></td>
<td>CommunityToolkit.Mvvm</td>
<td>8.x</td>
</tr>
<tr>
<td><strong>DI</strong></td>
<td>Microsoft.Extensions.DI</td>
<td>8.x</td>
</tr>
<tr>
<td><strong>HTTP</strong></td>
<td>HttpClient</td>
<td>.NET 8</td>
</tr>
<tr>
<td><strong>Config</strong></td>
<td>Microsoft.Extensions.Configuration.Json</td>
<td>8.x</td>
</tr>
<tr>
<td><strong>Backend</strong></td>
<td>C++ themis_server</td>
<td>REST API</td>
</tr>
</tbody>
</table>
<h3 id="admin_tools_feature_matrix-architektur-pattern">Architektur-Pattern<a class="headerlink" href="#admin_tools_feature_matrix-architektur-pattern" title="Permanent link">&para;</a></h3>
<p>✅ <strong>MVVM (Model-View-ViewModel)</strong>
- Klare Trennung UI ↔ Logik
- Data Binding
- Command Pattern
- ObservableObject/ObservableProperty</p>
<p>✅ <strong>Dependency Injection</strong>
- Service Container (App.xaml.cs)
- Singleton ThemisServerConfig
- Transient ViewModels &amp; Windows
- Factory Pattern für HttpClient</p>
<p>✅ <strong>ICollectionView Pattern</strong>
- Client-seitige Filterung
- Keine Änderung der Source-Collection
- Performance-Optimierung
- Kombinierbar mit Sorting</p>
<p>✅ <strong>Repository Pattern</strong>
- ThemisApiClient als Repository
- ApiResponse<T> Wrapper
- Error Handling
- Asynchrone Operationen</p>
<h3 id="admin_tools_feature_matrix-benutzerfreundlichkeit">Benutzerfreundlichkeit<a class="headerlink" href="#admin_tools_feature_matrix-benutzerfreundlichkeit" title="Permanent link">&para;</a></h3>
<p>✅ <strong>Echtzeit-Suche</strong>
- UpdateSourceTrigger=PropertyChanged
- Instant Feedback
- Keine Server-Anfragen bei Texteingabe</p>
<p>✅ <strong>Visuelle Indikatoren</strong>
- Loading Spinner/Progress Bar
- Status-Leiste mit Meldungen
- Sortier-Pfeile in Spaltenüberschriften
- Platzhalter-Text in Suchfeldern ("🔍 Search...")</p>
<p>✅ <strong>Tastatur-Support</strong>
- Tab-Navigation
- Enter in Suchfeldern
- ESC für Abbrechen</p>
<p>✅ <strong>Responsive Design</strong>
- GridSplitter für variable Layouts
- Auto-Sizing Columns
- ScrollViewer für große Daten
- AlternatingRowBackground für Lesbarkeit</p>
<h3 id="admin_tools_feature_matrix-performance">Performance<a class="headerlink" href="#admin_tools_feature_matrix-performance" title="Permanent link">&para;</a></h3>
<p>✅ <strong>Optimierungen</strong>
- Server-seitige Paginierung (100/Seite)
- Client-seitige Filterung nur auf geladene Daten
- ICollectionView statt Collection-Manipulation
- Async/Await für non-blocking UI
- Background-Threads für I/O</p>
<p>✅ <strong>Memory Management</strong>
- ObservableCollection statt List (für Binding)
- Dispose Pattern in App.OnExit
- ServiceProvider Lifecycle Management</p>
<h3 id="admin_tools_feature_matrix-fehlerbehandlung">Fehlerbehandlung<a class="headerlink" href="#admin_tools_feature_matrix-fehlerbehandlung" title="Permanent link">&para;</a></h3>
<p>✅ <strong>Exception Handling</strong>
- Try-Catch in allen Commands
- MessageBox für Benutzer-Feedback
- ErrorMessage Property für UI
- StatusMessage für Kontext</p>
<p>✅ <strong>Validation</strong>
- Null-Checks vor API-Calls
- Config-Validation beim Startup
- Filter-Validation (optional vs. required)</p>
<hr />
<h2 id="admin_tools_feature_matrix-rest-api-endpoints">REST API Endpoints<a class="headerlink" href="#admin_tools_feature_matrix-rest-api-endpoints" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_feature_matrix-admin-apis-keys-classification-reports">Admin APIs (Keys | Classification | Reports)<a class="headerlink" href="#admin_tools_feature_matrix-admin-apis-keys-classification-reports" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Endpoint</th>
<th>Method</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/keys</code></td>
<td>GET</td>
<td>Liste aller gemanagten Schlüssel</td>
</tr>
<tr>
<td><code>/keys/rotate</code></td>
<td>POST</td>
<td>Rotation; <code>key_id</code> im Body <code>{ key_id: "DEK" }</code> oder Query <code>?key_id=DEK</code></td>
</tr>
<tr>
<td><code>/classification/rules</code></td>
<td>GET</td>
<td>Liste der Klassifizierungsregeln</td>
</tr>
<tr>
<td><code>/classification/test</code></td>
<td>POST</td>
<td>Test-Classification <code>{ text, metadata }</code></td>
</tr>
<tr>
<td><code>/reports/compliance</code></td>
<td>GET</td>
<td>Compliance-Report <code>?type=overview|dsgvo|sox|hipaa|iso27001|pci</code></td>
</tr>
</tbody>
</table>
<p>Hinweis: Einige Tool-Clients verwenden einen <code>/api</code>-Prefix (z. B. <code>/api/keys</code>). Siehe Admin-Guide für Reverse-Proxy-Rewrite auf prefix-freie Server-Endpunkte.</p>
<h3 id="admin_tools_feature_matrix-audit-api">Audit API<a class="headerlink" href="#admin_tools_feature_matrix-audit-api" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Endpoint</th>
<th>Method</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/api/audit</code></td>
<td>GET</td>
<td>Liste Audit-Logs mit Filtern</td>
</tr>
<tr>
<td><code>/api/audit/export/csv</code></td>
<td>GET</td>
<td>Export als CSV</td>
</tr>
</tbody>
</table>
<p><strong>Query-Parameter:</strong>
- <code>start_date</code> (DateTime)
- <code>end_date</code> (DateTime)
- <code>user</code> (string)
- <code>action</code> (string)
- <code>entity_type</code> (string)
- <code>success_only</code> (bool)
- <code>page</code> (int)
- <code>page_size</code> (int)</p>
<h3 id="admin_tools_feature_matrix-saga-api">SAGA API<a class="headerlink" href="#admin_tools_feature_matrix-saga-api" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Endpoint</th>
<th>Method</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/api/saga/batches</code></td>
<td>GET</td>
<td>Liste aller SAGA-Batches</td>
</tr>
<tr>
<td><code>/api/saga/batch/{id}</code></td>
<td>GET</td>
<td>Batch-Detail mit Steps</td>
</tr>
<tr>
<td><code>/api/saga/batch/{id}/verify</code></td>
<td>POST</td>
<td>Verifiziere Signatur</td>
</tr>
<tr>
<td><code>/api/saga/flush</code></td>
<td>POST</td>
<td>Flush aktuellen Batch</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="admin_tools_feature_matrix-geplante-features-roadmap">Geplante Features (Roadmap)<a class="headerlink" href="#admin_tools_feature_matrix-geplante-features-roadmap" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_feature_matrix-kurzfristig-nachste-2-wochen">Kurzfristig (nächste 2 Wochen)<a class="headerlink" href="#admin_tools_feature_matrix-kurzfristig-nachste-2-wochen" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] <strong>PII-Manager Tool</strong></li>
<li>UUID ↔ Pseudonym Mapping</li>
<li>DSGVO Art. 17 Löschung</li>
<li>Export-Funktionen</li>
</ul>
<h3 id="admin_tools_feature_matrix-mittelfristig-nachste-4-wochen">Mittelfristig (nächste 4 Wochen)<a class="headerlink" href="#admin_tools_feature_matrix-mittelfristig-nachste-4-wochen" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] <strong>Retention-Manager</strong></li>
<li>Policy-Konfiguration</li>
<li>Überwachung</li>
<li>Manuelle Bereinigung</li>
</ul>
<h3 id="admin_tools_feature_matrix-langfristig-2-3-monate">Langfristig (2-3 Monate)<a class="headerlink" href="#admin_tools_feature_matrix-langfristig-2-3-monate" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] <strong>Erweiterte Admin-Features</strong></li>
<li>Saved Filter Profiles</li>
<li>Team-Filter Templates</li>
<li>Regex-Support in Suche</li>
<li>Advanced Filter Builder (AND/OR)</li>
<li>Visualisierung (Charts)</li>
</ul>
<hr />
<h2 id="admin_tools_feature_matrix-deployment">Deployment<a class="headerlink" href="#admin_tools_feature_matrix-deployment" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_feature_matrix-aktueller-status">Aktueller Status<a class="headerlink" href="#admin_tools_feature_matrix-aktueller-status" title="Permanent link">&para;</a></h3>
<p>✅ <strong>Development Build</strong>
- Debug-Build funktionsfähig
- Local Testing erfolgreich
- themis_server Integration getestet</p>
<h3 id="admin_tools_feature_matrix-geplant">Geplant<a class="headerlink" href="#admin_tools_feature_matrix-geplant" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] <strong>Release Build</strong></li>
<li>Optimierte Binaries</li>
<li>Code-Signierung</li>
<li>
<p>Installer (MSI/ClickOnce)</p>
</li>
<li>
<p>[ ] <strong>Auto-Update</strong></p>
</li>
<li>ClickOnce Deployment</li>
<li>Version-Check</li>
<li>
<p>Automatische Updates</p>
</li>
<li>
<p>[ ] <strong>Documentation</strong></p>
</li>
<li>Benutzerhandbücher</li>
<li>Admin-Guide</li>
<li>API-Dokumentation</li>
<li>Video-Tutorials</li>
</ul>
<hr />
<h2 id="admin_tools_feature_matrix-zusammenfassung">Zusammenfassung<a class="headerlink" href="#admin_tools_feature_matrix-zusammenfassung" title="Permanent link">&para;</a></h2>
<p><strong>Aktuelle Features:</strong>
- ✅ Admin-Tools: AuditLogViewer, SAGAVerifier, KeyRotation, Classification, Compliance Reports
- ✅ Vollständige Such-, Sortier- und Filterlogik
- ✅ REST API Integration (inkl. Keys, Classification, Reports)
- ✅ MVVM + DI Architecture
- ✅ ICollectionView Performance-Optimierung
- ✅ CSV Export
- ✅ Echtzeit-Suche
- ✅ Multi-Column Sorting
- ✅ Responsive UI</p>
<p><strong>Nächste Schritte:</strong>
1. PII-Manager Tool entwickeln
2. Retention-Manager erstellen
3. Deployment vorbereiten
4. Dokumentation vervollständigen</p>
<p><strong>Code-Qualität:</strong>
- ✅ MVVM Pattern konsequent
- ✅ Dependency Injection
- ✅ Error Handling
- ✅ Performance-optimiert
- ✅ Wartbar &amp; erweiterbar</p></section><section class="print-page" id="admin_tools_search_sort_filter" heading-number="15.4"><h1 id="admin_tools_search_sort_filter-admin-tools-such-sortier-und-filterlogik">Admin Tools - Such-, Sortier- und Filterlogik<a class="headerlink" href="#admin_tools_search_sort_filter-admin-tools-such-sortier-und-filterlogik" title="Permanent link">&para;</a></h1>
<h2 id="admin_tools_search_sort_filter-ubersicht">Übersicht<a class="headerlink" href="#admin_tools_search_sort_filter-ubersicht" title="Permanent link">&para;</a></h2>
<p>Alle ThemisDB Admin Tools verfügen über eine vollständige Such-, Sortier- und Filterlogik, um große Datenmengen effizient zu durchsuchen und zu analysieren.</p>
<h2 id="admin_tools_search_sort_filter-implementierte-features">Implementierte Features<a class="headerlink" href="#admin_tools_search_sort_filter-implementierte-features" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_search_sort_filter-1-echtzeit-suche-real-time-search">1. Echtzeit-Suche (Real-time Search)<a class="headerlink" href="#admin_tools_search_sort_filter-1-echtzeit-suche-real-time-search" title="Permanent link">&para;</a></h3>
<p><strong>AuditLogViewer:</strong>
- Suchfeld: Durchsucht alle Spalten gleichzeitig
- Durchsuchte Felder:
  - User (Benutzername)
  - Action (Aktion)
  - EntityType (Entitätstyp)
  - EntityId (Entitäts-ID)
  - OldValue (Alter Wert)
  - NewValue (Neuer Wert)
  - IpAddress (IP-Adresse)
  - SessionId (Sitzungs-ID)
  - ErrorMessage (Fehlermeldung)
- <strong>UpdateSourceTrigger=PropertyChanged</strong>: Suche erfolgt automatisch bei jeder Texteingabe
- Case-insensitive: Groß-/Kleinschreibung wird ignoriert</p>
<p><strong>SAGAVerifier:</strong>
- <strong>Batch-Suche</strong>: Durchsucht Batch-Liste
  - BatchId (Batch-ID)
  - Hash (SHA-256 Hash)
  - Signature (Kryptographische Signatur)
  - Timestamp (Zeitstempel formatiert)
- <strong>Step-Suche</strong>: Durchsucht SAGA-Schritte
  - SagaId (SAGA-ID)
  - StepName (Schrittname)
  - Status (Status)
  - CorrelationId (Korrelations-ID)
  - Metadata (Metadaten)
- Separate Suchfelder für Batches und Steps
- Platzhalter-Text mit 🔍 Icon</p>
<h3 id="admin_tools_search_sort_filter-2-multi-column-sorting">2. Multi-Column Sorting<a class="headerlink" href="#admin_tools_search_sort_filter-2-multi-column-sorting" title="Permanent link">&para;</a></h3>
<p><strong>Implementierung:</strong>
- Click-to-Sort: Klick auf Spaltenüberschrift sortiert
- Toggle Sort Direction: Erneuter Klick kehrt Sortierung um
- Visual Feedback: WPF DataGrid zeigt Sortier-Pfeile
- SortMemberPath: Definiert Sortier-Eigenschaft pro Spalte</p>
<p><strong>AuditLogViewer Sortierbare Spalten:</strong>
- Id (Audit-Log ID)
- Timestamp (Zeitstempel)
- User (Benutzer)
- Action (Aktion)
- EntityType (Entitätstyp)
- EntityId (Entitäts-ID)
- OldValue (Alter Wert)
- NewValue (Neuer Wert)
- Success (Erfolgsstatus)</p>
<p><strong>SAGAVerifier Sortierbare Spalten:</strong></p>
<p><em>Batches:</em>
- BatchId (Batch-ID)
- Timestamp (Zeitstempel)
- EntryCount (Anzahl Einträge)</p>
<p><em>Steps:</em>
- Timestamp (Zeitstempel)
- SagaId (SAGA-ID)
- StepName (Schrittname)
- Status (Status)
- CorrelationId (Korrelations-ID)</p>
<h3 id="admin_tools_search_sort_filter-3-erweiterte-filter">3. Erweiterte Filter<a class="headerlink" href="#admin_tools_search_sort_filter-3-erweiterte-filter" title="Permanent link">&para;</a></h3>
<p><strong>AuditLogViewer:</strong>
- <strong>Datum-Filter:</strong>
  - Von-Datum (StartDate)
  - Bis-Datum (EndDate)
  - Default: Letzte 7 Tage
- <strong>Text-Filter:</strong>
  - Benutzer (UserFilter)
  - Aktion (ActionFilter)
  - Entitätstyp (EntityTypeFilter)
- <strong>Boolean-Filter:</strong>
  - "Nur erfolgreiche Aktionen" (SuccessOnly)
- <strong>Globale Suche:</strong>
  - Durchsucht alle Spalten gleichzeitig
  - Kombinierbar mit anderen Filtern</p>
<p><strong>Filter werden kombiniert:</strong>
- Server-seitige Filter: Datum, User, Action, EntityType, SuccessOnly
- Client-seitige Suche: SearchText (nach Laden der Daten)</p>
<h3 id="admin_tools_search_sort_filter-4-icollectionview-integration">4. ICollectionView Integration<a class="headerlink" href="#admin_tools_search_sort_filter-4-icollectionview-integration" title="Permanent link">&para;</a></h3>
<p><strong>Technische Implementierung:</strong></p>
<pre><code class="language-csharp">// ViewModel Setup
_logsView = CollectionViewSource.GetDefaultView(AuditLogs);
_logsView.Filter = FilterLogs;

// Filter-Methode
private bool FilterLogs(object obj)
{
    if (obj is not AuditLogEntry log)
        return false;

    if (!string.IsNullOrWhiteSpace(SearchText))
    {
        var search = SearchText.ToLowerInvariant();
        var matches = log.User?.ToLowerInvariant().Contains(search) == true ||
                     log.Action?.ToLowerInvariant().Contains(search) == true ||
                     // ... weitere Felder

        if (!matches)
            return false;
    }

    return true;
}

// Refresh bei Änderung
partial void OnSearchTextChanged(string value)
{
    _logsView?.Refresh();
    UpdateStatusMessage();
}
</code></pre>
<p><strong>Vorteile:</strong>
- ✅ Keine Änderung der Quell-Collection nötig
- ✅ Performance: Nur Ansicht wird aktualisiert
- ✅ Observable Pattern: Automatische UI-Updates
- ✅ Kombinierbar mit Sorting</p>
<h3 id="admin_tools_search_sort_filter-5-status-updates">5. Status-Updates<a class="headerlink" href="#admin_tools_search_sort_filter-5-status-updates" title="Permanent link">&para;</a></h3>
<p><strong>Intelligente Statusmeldungen:</strong></p>
<pre><code class="language-csharp">private void UpdateStatusMessage()
{
    var filtered = AuditLogs.Count(log =&gt; _logsView?.Filter == null || _logsView.Filter(log));
    var total = AuditLogs.Count;

    if (filtered != total)
    {
        StatusMessage = $&quot;{filtered} von {total} Einträgen angezeigt (Gesamt im System: {TotalCount})&quot;;
    }
    else
    {
        StatusMessage = $&quot;{total} Einträge geladen (Gesamt: {TotalCount})&quot;;
    }
}
</code></pre>
<p><strong>Angezeigte Informationen:</strong>
- Gefilterte Anzahl (wenn Filter aktiv)
- Geladene Anzahl (aktuelle Seite)
- Gesamt-Anzahl im System (alle Seiten)</p>
<h3 id="admin_tools_search_sort_filter-6-performance-optimierungen">6. Performance-Optimierungen<a class="headerlink" href="#admin_tools_search_sort_filter-6-performance-optimierungen" title="Permanent link">&para;</a></h3>
<p><strong>Client-seitige Filterung:</strong>
- Filter wird nur auf geladene Daten angewendet (max. 100 Einträge pro Seite)
- Keine Server-Anfrage bei jeder Texteingabe
- Instant Feedback für Benutzer</p>
<p><strong>Paginierung:</strong>
- Server-seitige Paginierung (100 Einträge pro Seite)
- Reduziert Netzwerk-Traffic
- Schnelle Ladezeiten</p>
<p><strong>UpdateSourceTrigger:</strong>
- PropertyChanged: Sofortige Suche bei Texteingabe
- Balance zwischen Responsiveness und Performance</p>
<h2 id="admin_tools_search_sort_filter-benutzer-workflows">Benutzer-Workflows<a class="headerlink" href="#admin_tools_search_sort_filter-benutzer-workflows" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_search_sort_filter-workflow-1-schnellsuche-nach-benutzeraktionen">Workflow 1: Schnellsuche nach Benutzeraktionen<a class="headerlink" href="#admin_tools_search_sort_filter-workflow-1-schnellsuche-nach-benutzeraktionen" title="Permanent link">&para;</a></h3>
<pre><code>1. Tool öffnen → AuditLogViewer
2. Standard-Filter → Letzte 7 Tage
3. &quot;Laden&quot; klicken → Daten werden geladen
4. Suchfeld eingeben → &quot;admin&quot; (durchsucht alle Spalten)
5. Ergebnis → Nur Einträge mit &quot;admin&quot; in irgendeinem Feld
6. Spalte klicken → Nach Zeitstempel sortieren
7. Export → Gefilterte Daten als CSV exportieren
</code></pre>
<h3 id="admin_tools_search_sort_filter-workflow-2-saga-batch-verifizierung-finden">Workflow 2: SAGA-Batch Verifizierung finden<a class="headerlink" href="#admin_tools_search_sort_filter-workflow-2-saga-batch-verifizierung-finden" title="Permanent link">&para;</a></h3>
<pre><code>1. Tool öffnen → SAGAVerifier
2. Auto-Load → Batches werden geladen
3. Batch-Suche → &quot;abc123&quot; (Batch-ID Teilstring)
4. Batch auswählen → Details werden geladen
5. Step-Suche → &quot;compensation&quot; (findet Kompensationsschritte)
6. Step-Spalte sortieren → Nach Status sortieren
7. Verify → Signatur prüfen
8. Export → Schritte als CSV exportieren
</code></pre>
<h3 id="admin_tools_search_sort_filter-workflow-3-fehleranalyse">Workflow 3: Fehleranalyse<a class="headerlink" href="#admin_tools_search_sort_filter-workflow-3-fehleranalyse" title="Permanent link">&para;</a></h3>
<pre><code>1. AuditLogViewer öffnen
2. Datum setzen → Gestern bis Heute
3. Filter: SuccessOnly → DEAKTIVIEREN
4. Laden → Alle Einträge (inkl. Fehler)
5. Suche → &quot;error&quot; oder &quot;exception&quot;
6. Spalte &quot;Success&quot; → Sortieren (Fehler zuerst)
7. Spalte &quot;Timestamp&quot; → Sekundäre Sortierung
8. Analyse → Fehler-Pattern erkennen
</code></pre>
<h2 id="admin_tools_search_sort_filter-code-beispiele">Code-Beispiele<a class="headerlink" href="#admin_tools_search_sort_filter-code-beispiele" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_search_sort_filter-beispiel-1-filter-logik-erweitern">Beispiel 1: Filter-Logik erweitern<a class="headerlink" href="#admin_tools_search_sort_filter-beispiel-1-filter-logik-erweitern" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">// Neue Filter-Eigenschaft hinzufügen
[ObservableProperty]
private string _customFilter = string.Empty;

// In FilterLogs-Methode erweitern
private bool FilterLogs(object obj)
{
    if (obj is not AuditLogEntry log)
        return false;

    // Bestehende Suche...
    if (!string.IsNullOrWhiteSpace(SearchText))
    {
        // ...
    }

    // NEUE Filter-Logik
    if (!string.IsNullOrWhiteSpace(CustomFilter))
    {
        if (!log.SomeField?.Contains(CustomFilter) == true)
            return false;
    }

    return true;
}
</code></pre>
<h3 id="admin_tools_search_sort_filter-beispiel-2-benutzerdefinierte-sortierung">Beispiel 2: Benutzerdefinierte Sortierung<a class="headerlink" href="#admin_tools_search_sort_filter-beispiel-2-benutzerdefinierte-sortierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">[RelayCommand]
private void CustomSort()
{
    _logsView?.SortDescriptions.Clear();

    // Multi-Level Sorting
    _logsView?.SortDescriptions.Add(
        new SortDescription(&quot;Success&quot;, ListSortDirection.Ascending));
    _logsView?.SortDescriptions.Add(
        new SortDescription(&quot;Timestamp&quot;, ListSortDirection.Descending));

    UpdateStatusMessage();
}
</code></pre>
<h3 id="admin_tools_search_sort_filter-beispiel-3-filter-kombinieren">Beispiel 3: Filter kombinieren<a class="headerlink" href="#admin_tools_search_sort_filter-beispiel-3-filter-kombinieren" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">private bool FilterLogs(object obj)
{
    if (obj is not AuditLogEntry log)
        return false;

    // AND-Verknüpfung: Alle Bedingungen müssen erfüllt sein

    // 1. Suchtext-Filter
    if (!string.IsNullOrWhiteSpace(SearchText))
    {
        var search = SearchText.ToLowerInvariant();
        var matches = log.User?.ToLowerInvariant().Contains(search) == true ||
                     log.Action?.ToLowerInvariant().Contains(search) == true;

        if (!matches)
            return false; // Nicht gefunden → raus
    }

    // 2. Erfolgs-Filter
    if (SuccessOnlyFilter &amp;&amp; !log.Success)
        return false; // Fehler, aber nur Erfolge gewünscht → raus

    // 3. Benutzer-Filter
    if (!string.IsNullOrWhiteSpace(UserFilter))
    {
        if (!log.User?.Contains(UserFilter, StringComparison.OrdinalIgnoreCase) == true)
            return false; // Benutzer passt nicht → raus
    }

    return true; // Alle Filter bestanden → anzeigen
}
</code></pre>
<h2 id="admin_tools_search_sort_filter-best-practices">Best Practices<a class="headerlink" href="#admin_tools_search_sort_filter-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_search_sort_filter-1-performance">1. Performance<a class="headerlink" href="#admin_tools_search_sort_filter-1-performance" title="Permanent link">&para;</a></h3>
<p>✅ <strong>DO:</strong>
- Client-seitige Filterung für geladene Daten verwenden
- UpdateSourceTrigger=PropertyChanged für Echtzeit-Suche
- ICollectionView für effiziente Filterung
- Paginierung für große Datenmengen</p>
<p>❌ <strong>DON'T:</strong>
- Nicht bei jeder Texteingabe Server-Request
- Nicht gesamte Datenbank in Memory laden
- Nicht ohne Paginierung arbeiten bei &gt;1000 Einträgen</p>
<h3 id="admin_tools_search_sort_filter-2-benutzerfreundlichkeit">2. Benutzerfreundlichkeit<a class="headerlink" href="#admin_tools_search_sort_filter-2-benutzerfreundlichkeit" title="Permanent link">&para;</a></h3>
<p>✅ <strong>DO:</strong>
- Platzhalter-Text in Suchfeldern ("🔍 Search...")
- Tooltips für Suchfunktion
- Status-Updates (gefilterte/gesamte Anzahl)
- Klare visuelle Trennung von Filtern</p>
<p>❌ <strong>DON'T:</strong>
- Nicht ohne Feedback filtern
- Nicht Filter ohne "Löschen"-Button
- Nicht ohne Sortier-Indikatoren</p>
<h3 id="admin_tools_search_sort_filter-3-code-qualitat">3. Code-Qualität<a class="headerlink" href="#admin_tools_search_sort_filter-3-code-qualitat" title="Permanent link">&para;</a></h3>
<p>✅ <strong>DO:</strong>
- MVVM Pattern verwenden
- ICollectionView für Filterung
- ObservableCollection für Data Binding
- Partial Methods für Property-Change-Events</p>
<p>❌ <strong>DON'T:</strong>
- Nicht Code-Behind für Filter-Logik
- Nicht direkt Collection manipulieren
- Nicht ohne Property Change Notifications</p>
<h2 id="admin_tools_search_sort_filter-testing">Testing<a class="headerlink" href="#admin_tools_search_sort_filter-testing" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_search_sort_filter-unit-tests-fur-filter-logik">Unit Tests für Filter-Logik<a class="headerlink" href="#admin_tools_search_sort_filter-unit-tests-fur-filter-logik" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">[Fact]
public void FilterLogs_WithSearchText_FiltersCorrectly()
{
    // Arrange
    var viewModel = new MainWindowViewModel(_mockApiClient.Object);
    viewModel.SearchText = &quot;admin&quot;;

    var log1 = new AuditLogEntry { User = &quot;admin_user&quot; };
    var log2 = new AuditLogEntry { User = &quot;normal_user&quot; };

    // Act
    var result1 = viewModel.FilterLogs(log1);
    var result2 = viewModel.FilterLogs(log2);

    // Assert
    Assert.True(result1); // admin_user enthält &quot;admin&quot;
    Assert.False(result2); // normal_user enthält nicht &quot;admin&quot;
}
</code></pre>
<h3 id="admin_tools_search_sort_filter-integration-tests">Integration Tests<a class="headerlink" href="#admin_tools_search_sort_filter-integration-tests" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">[Fact]
public async Task Search_And_Sort_Integration()
{
    // Arrange
    var viewModel = new MainWindowViewModel(_apiClient);
    await viewModel.LoadBatchesAsync();

    // Act - Suche
    viewModel.BatchSearchText = &quot;batch_123&quot;;

    // Act - Sortierung
    viewModel.SortBatchesCommand.Execute(&quot;Timestamp&quot;);

    // Assert
    var view = CollectionViewSource.GetDefaultView(viewModel.Batches);
    Assert.True(view.SortDescriptions.Count &gt; 0);
    Assert.All(viewModel.Batches, b =&gt; 
        Assert.Contains(&quot;batch_123&quot;, b.BatchId));
}
</code></pre>
<h2 id="admin_tools_search_sort_filter-zukunftige-erweiterungen">Zukünftige Erweiterungen<a class="headerlink" href="#admin_tools_search_sort_filter-zukunftige-erweiterungen" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_search_sort_filter-geplante-features">Geplante Features<a class="headerlink" href="#admin_tools_search_sort_filter-geplante-features" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Erweiterte Filter-Builder:</strong></li>
<li>UND/ODER-Verknüpfungen</li>
<li>Reguläre Ausdrücke</li>
<li>
<p>Datumsbereich-Presets ("Letzte Woche", "Letzter Monat")</p>
</li>
<li>
<p><strong>Gespeicherte Filter:</strong></p>
</li>
<li>Filter-Profile speichern</li>
<li>Favoriten-Filter</li>
<li>
<p>Team-weite Filter-Templates</p>
</li>
<li>
<p><strong>Export-Optionen:</strong></p>
</li>
<li>Excel-Export mit Formatierung</li>
<li>PDF-Reports mit Charts</li>
<li>
<p>JSON/XML Export</p>
</li>
<li>
<p><strong>Visualisierung:</strong></p>
</li>
<li>Histogram für Zeitstempel-Verteilung</li>
<li>Pie-Chart für Action-Verteilung</li>
<li>Heatmap für Benutzer-Aktivität</li>
</ol>
<h2 id="admin_tools_search_sort_filter-zusammenfassung">Zusammenfassung<a class="headerlink" href="#admin_tools_search_sort_filter-zusammenfassung" title="Permanent link">&para;</a></h2>
<p>Die Such-, Sortier- und Filterlogik in den ThemisDB Admin Tools bietet:</p>
<p>✅ Echtzeit-Suche über alle Spalten
✅ Multi-Column Sorting mit Toggle
✅ Kombinierbare Filter (AND-Logik)
✅ ICollectionView für Performance
✅ Intelligente Status-Updates
✅ MVVM-Pattern für Wartbarkeit
✅ Responsive UI (UpdateSourceTrigger)
✅ Export gefilterte Daten</p>
<p>Diese Implementierung ermöglicht es Administratoren, große Datenmengen effizient zu durchsuchen, zu analysieren und zu exportieren.</p></section><section class="print-page" id="admin_tools_demo_script" heading-number="15.5"><h1 id="admin_tools_demo_script-themisdb-admin-tools-demo-script">ThemisDB Admin Tools - Demo Script<a class="headerlink" href="#admin_tools_demo_script-themisdb-admin-tools-demo-script" title="Permanent link">&para;</a></h1>
<h2 id="admin_tools_demo_script-demo-1-audit-log-viewer-such-und-filterfunktionen-5-minuten">Demo 1: Audit Log Viewer - Such- und Filterfunktionen (5 Minuten)<a class="headerlink" href="#admin_tools_demo_script-demo-1-audit-log-viewer-such-und-filterfunktionen-5-minuten" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-setup-30-sekunden">Setup (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-setup-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>1. themis_server starten (Port 8765)
2. AuditLogViewer.exe öffnen
3. Zeige UI-Overview:
   - Header &quot;ThemisDB Audit Log Viewer&quot;
   - Filter-Bereich (Datum, User, Action, Entity)
   - DataGrid (leer)
   - Status-Leiste &quot;Bereit&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-1-basis-filter-1-minute">Szenario 1: Basis-Filter (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-1-basis-filter-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Datum-Filter setzen
- Von: Letzte 7 Tage (bereits gesetzt)
- Bis: Heute
- Klick &quot;Laden&quot;

ERWARTUNG:
✓ Loading-Indicator erscheint
✓ DataGrid füllt sich mit Audit-Logs
✓ Status: &quot;X Einträge geladen (Gesamt: Y)&quot;

DEMO-PUNKT:
→ &quot;Standard-Filter lädt Audit-Logs der letzten Woche&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-2-echtzeit-suche-1-minute">Szenario 2: Echtzeit-Suche (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-2-echtzeit-suche-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Globale Suche verwenden
- Suchfeld: &quot;admin&quot;
- KEINE Taste drücken (auto-update)

ERWARTUNG:
✓ DataGrid filtert sofort
✓ Nur Zeilen mit &quot;admin&quot; (in User, Action, etc.)
✓ Status: &quot;5 von 100 Einträgen angezeigt&quot;

DEMO-PUNKT:
→ &quot;Echtzeit-Suche durchsucht alle Spalten gleichzeitig&quot;
→ &quot;UpdateSourceTrigger=PropertyChanged = Instant Feedback&quot;

AKTION: Suche ändern
- Suchfeld: &quot;create&quot; (überschreibe &quot;admin&quot;)

ERWARTUNG:
✓ DataGrid aktualisiert sofort
✓ Nur Zeilen mit &quot;create&quot;
✓ Status: &quot;12 von 100 Einträgen angezeigt&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-3-multi-column-sorting-1-minute">Szenario 3: Multi-Column Sorting (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-3-multi-column-sorting-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Nach Zeitstempel sortieren
- Klick auf &quot;Zeitstempel&quot; Spaltenüberschrift

ERWARTUNG:
✓ Sortier-Pfeil erscheint (↑ aufsteigend)
✓ Einträge chronologisch sortiert

AKTION: Sortierung umkehren
- Nochmal Klick auf &quot;Zeitstempel&quot;

ERWARTUNG:
✓ Sortier-Pfeil dreht (↓ absteigend)
✓ Neueste Einträge zuerst

DEMO-PUNKT:
→ &quot;Toggle Sort Direction mit einem Klick&quot;

AKTION: Nach anderem Feld sortieren
- Klick auf &quot;Benutzer&quot; Spalte

ERWARTUNG:
✓ Sortierung wechselt zu &quot;Benutzer&quot; (alphabetisch)
✓ Alter Sortier-Pfeil verschwindet
✓ Neuer Sortier-Pfeil bei &quot;Benutzer&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-4-kombinierte-filter-1-minute">Szenario 4: Kombinierte Filter (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-4-kombinierte-filter-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Filter kombinieren
- Suchfeld: &quot;error&quot;
- Checkbox: &quot;Nur erfolgreiche Aktionen&quot; DEAKTIVIEREN
- Benutzer-Filter: &quot;system&quot;
- Klick &quot;Laden&quot;

ERWARTUNG:
✓ Server-Request mit Filtern
✓ DataGrid zeigt nur:
  - Einträge mit &quot;error&quot; im Text
  - Von Benutzer &quot;system&quot;
  - Inkl. Fehler (Success=false)
✓ Status: &quot;3 von 8 Einträgen angezeigt (Gesamt im System: 1234)&quot;

DEMO-PUNKT:
→ &quot;Server-Filter (User, Datum) + Client-Suche (Suchfeld)&quot;
→ &quot;AND-Verknüpfung aller Filter&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-5-export-30-sekunden">Szenario 5: Export (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-5-export-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: CSV Export
- Klick &quot;CSV Export&quot;
- Save-Dialog: &quot;audit_log_20251101_143022.csv&quot;
- Klick &quot;Speichern&quot;

ERWARTUNG:
✓ Loading-Indicator
✓ Success-Dialog: &quot;Daten erfolgreich exportiert&quot;
✓ CSV-Datei mit gefilterten Daten

DEMO-PUNKT:
→ &quot;Export berücksichtigt aktuelle Filter&quot;
→ &quot;Automatischer Dateiname mit Timestamp&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-6-filter-zurucksetzen-30-sekunden">Szenario 6: Filter zurücksetzen (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-6-filter-zurucksetzen-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Filter löschen
- Klick &quot;Filter löschen&quot;

ERWARTUNG:
✓ Datum: Zurück zu &quot;Letzte 7 Tage&quot;
✓ Suchfeld: Leer
✓ Benutzer/Action/Entity: Leer
✓ SuccessOnly: Deaktiviert
✓ DataGrid: Zeigt wieder alle Einträge

DEMO-PUNKT:
→ &quot;Ein Klick zurück zu Standard-Filtern&quot;
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-demo-2-saga-verifier-batch-suche-und-verifizierung-5-minuten">Demo 2: SAGA Verifier - Batch-Suche und Verifizierung (5 Minuten)<a class="headerlink" href="#admin_tools_demo_script-demo-2-saga-verifier-batch-suche-und-verifizierung-5-minuten" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-setup-30-sekunden_1">Setup (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-setup-30-sekunden_1" title="Permanent link">&para;</a></h3>
<pre><code>1. themis_server läuft (Port 8765)
2. SAGAVerifier.exe öffnen
3. Zeige UI-Overview:
   - Header &quot;SAGA Batch Verifier&quot;
   - Toolbar (Refresh, Verify, Flush, Export)
   - Split-View: Batch-Liste | Detail-Ansicht
   - Status-Leiste
</code></pre>
<h3 id="admin_tools_demo_script-szenario-1-auto-load-batch-liste-1-minute">Szenario 1: Auto-Load &amp; Batch-Liste (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-1-auto-load-batch-liste-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>BEIM START:
✓ Auto-Load lädt Batches
✓ Batch-Liste zeigt:
  - Batch ID (kurz)
  - Timestamp (formatiert)
  - Entries (Anzahl)
✓ Status: &quot;Loaded 5 batch(es)&quot;

DEMO-PUNKT:
→ &quot;Automatisches Laden beim Start&quot;
→ &quot;Window.Loaded Event → LoadBatchesCommand&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-2-batch-suche-1-minute">Szenario 2: Batch-Suche (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-2-batch-suche-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Batch suchen
- Batch-Suchfeld: &quot;abc&quot; (Teil der Batch-ID)

ERWARTUNG:
✓ Batch-Liste filtert sofort
✓ Nur Batches mit &quot;abc&quot; in ID, Hash, Signatur, Timestamp
✓ Status: &quot;2 of 5 batches shown&quot;

DEMO-PUNKT:
→ &quot;Echtzeit-Suche in Batch-Liste&quot;
→ &quot;Durchsucht BatchId, Hash, Signature, Timestamp&quot;

AKTION: Batch-ID sortieren
- Klick auf &quot;Batch ID&quot; Spalte

ERWARTUNG:
✓ Batches alphabetisch sortiert
✓ Sortier-Pfeil erscheint
</code></pre>
<h3 id="admin_tools_demo_script-szenario-3-batch-detail-auto-load-1-minute">Szenario 3: Batch-Detail Auto-Load (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-3-batch-detail-auto-load-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Batch auswählen
- Klick auf ersten Batch in Liste

ERWARTUNG:
✓ Loading-Indicator
✓ Detail-Bereich füllt sich:
  - Batch ID (vollständig)
  - Hash (SHA-256, Monospace-Font)
  - Signature (Kryptographisch, Monospace-Font)
  - Verification: (leer, noch nicht verifiziert)
✓ SAGA-Steps DataGrid:
  - Time, SAGA ID, Step, Status, Correlation ID
  - X Schritte geladen
✓ Status: &quot;Loaded 15 SAGA step(s)&quot;

DEMO-PUNKT:
→ &quot;Auto-Load Detail bei Batch-Auswahl&quot;
→ &quot;OnSelectedBatchChanged → LoadBatchDetailAsync&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-4-saga-steps-suche-1-minute">Szenario 4: SAGA-Steps Suche (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-4-saga-steps-suche-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Steps durchsuchen
- Step-Suchfeld: &quot;compensation&quot;

ERWARTUNG:
✓ Steps-DataGrid filtert
✓ Nur Steps mit &quot;compensation&quot; in:
  - SagaId, StepName, Status, CorrelationId, Metadata
✓ Status: &quot;3 of 15 steps shown&quot;

DEMO-PUNKT:
→ &quot;Separate Suche für Batches und Steps&quot;
→ &quot;ICollectionView für beide unabhängig&quot;

AKTION: Nach Status sortieren
- Klick auf &quot;Status&quot; Spalte

ERWARTUNG:
✓ Steps nach Status sortiert
✓ z.B. &quot;completed&quot; → &quot;pending&quot; → &quot;failed&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-5-signatur-verifizierung-1-minute">Szenario 5: Signatur-Verifizierung (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-5-signatur-verifizierung-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Batch verifizieren
- Button &quot;Verify Selected&quot; klicken

ERWARTUNG:
✓ Loading-Indicator
✓ REST API Call: POST /api/saga/batch/{id}/verify
✓ MessageBox erscheint:
  - Bei Erfolg: &quot;✓ Batch verified successfully&quot;
  - Bei Fehler: &quot;✗ Verification failed: ...&quot;
✓ Detail-Bereich aktualisiert:
  - Verification: &quot;✓ Verified&quot; (grün) / &quot;✗ Failed&quot; (rot)
✓ Status: &quot;✓ Batch verified successfully&quot;

DEMO-PUNKT:
→ &quot;Kryptographische Signatur-Prüfung&quot;
→ &quot;SHA-256 Hash + HMAC-Verification&quot;
→ &quot;Visual Feedback (✓/✗, Farben)&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-6-export-saga-steps-30-sekunden">Szenario 6: Export SAGA-Steps (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-6-export-saga-steps-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Steps exportieren
- Button &quot;Export Steps&quot; klicken
- Save-Dialog: &quot;saga_steps_abc123_20251101_143530.csv&quot;
- Klick &quot;Speichern&quot;

ERWARTUNG:
✓ CSV-Datei mit allen (gefilterten) Steps
✓ Success-Dialog
✓ Status: &quot;Exported 15 steps&quot;

DEMO-PUNKT:
→ &quot;Export berücksichtigt aktuelle Step-Suche&quot;
→ &quot;Batch-ID im Dateinamen&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-7-batch-flush-30-sekunden">Szenario 7: Batch Flush (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-7-batch-flush-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Aktuellen Batch flushen
- Button &quot;Flush Current&quot; klicken

ERWARTUNG:
✓ Confirmation-Dialog (optional)
✓ REST API Call: POST /api/saga/flush
✓ MessageBox: &quot;Current SAGA batch flushed successfully&quot;
✓ Batch-Liste aktualisiert (neuer Batch erscheint)
✓ Status: &quot;Batch flushed successfully&quot;

DEMO-PUNKT:
→ &quot;Manuelles Flushen erzwingt Batch-Abschluss&quot;
→ &quot;Nützlich für Testing oder Notfall-Situationen&quot;
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-demo-3-key-rotation-schlussel-anzeigen-und-rotieren-3-minuten">Demo 3: Key Rotation – Schlüssel anzeigen und rotieren (3 Minuten)<a class="headerlink" href="#admin_tools_demo_script-demo-3-key-rotation-schlussel-anzeigen-und-rotieren-3-minuten" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-setup-30-sekunden_2">Setup (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-setup-30-sekunden_2" title="Permanent link">&para;</a></h3>
<pre><code>1. themis_server läuft (Port 8765)
2. KeyRotation.exe öffnen
3. UI-Überblick: Schlüssel-Liste, Filter (Typ/abgelaufen), Buttons (Aktualisieren, Rotieren)
</code></pre>
<h3 id="admin_tools_demo_script-szenario-1-schlussel-laden-1-minute">Szenario 1: Schlüssel laden (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-szenario-1-schlussel-laden-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Klick „Aktualisieren“

ERWARTUNG:
✓ GET /keys → Liste mit LEK/KEK/DEK
✓ Spalten: KeyId, Version, Status, ExpiresAt
✓ Status: &quot;3 Schlüssel geladen&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-2-rotation-auslosen-15-minuten">Szenario 2: Rotation auslösen (1,5 Minuten)<a class="headerlink" href="#admin_tools_demo_script-szenario-2-rotation-auslosen-15-minuten" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Schlüssel „DEK“ auswählen → „Rotieren“ klicken

ERWARTUNG:
✓ POST /keys/rotate mit Body { key_id: &quot;DEK&quot; }
✓ Success-Dialog: &quot;DEK erfolgreich rotiert (neue Version: X)&quot;
✓ Liste aktualisiert → neue Version sichtbar

EDGE CASES:
• 400 Missing key_id → Hinweis im UI
• 503 Keys API not available → Admin-Guide verlinken
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-demo-4-classification-regeln-laden-und-test-classification-3-minuten">Demo 4: Classification – Regeln laden und Test-Classification (3 Minuten)<a class="headerlink" href="#admin_tools_demo_script-demo-4-classification-regeln-laden-und-test-classification-3-minuten" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-setup-30-sekunden_3">Setup (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-setup-30-sekunden_3" title="Permanent link">&para;</a></h3>
<pre><code>1. themis_server läuft (Port 8765)
2. ClassificationDashboard.exe öffnen
3. UI-Überblick: Regeln-Panel, Testeingabe, Ergebnisse/Export
</code></pre>
<h3 id="admin_tools_demo_script-szenario-1-regeln-laden-45-sekunden">Szenario 1: Regeln laden (45 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-1-regeln-laden-45-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Klick „Aktualisieren“

ERWARTUNG:
✓ GET /classification/rules
✓ Anzeige: Name, Muster, Gewichtung
</code></pre>
<h3 id="admin_tools_demo_script-szenario-2-klassifikation-testen-15-minuten">Szenario 2: Klassifikation testen (1,5 Minuten)<a class="headerlink" href="#admin_tools_demo_script-szenario-2-klassifikation-testen-15-minuten" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Beispieltext eingeben → „Testen“

ERWARTUNG:
✓ POST /classification/test mit { text, metadata }
✓ Ergebnis: classification=CONFIDENTIAL, confidence ~0.9, detected_entities
✓ Export-Button aktiv

EDGE CASES:
• 400 Missing JSON body → Validierungs-Hinweis
• 503 Classification API not available → Admin-Guide verlinken
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-demo-5-compliance-reports-ubersicht-abrufen-2-minuten">Demo 5: Compliance Reports – Übersicht abrufen (2 Minuten)<a class="headerlink" href="#admin_tools_demo_script-demo-5-compliance-reports-ubersicht-abrufen-2-minuten" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-setup-15-sekunden">Setup (15 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-setup-15-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>Tool &quot;ComplianceReports.exe&quot; öffnen
</code></pre>
<h3 id="admin_tools_demo_script-szenario-overview-report-15-minuten">Szenario: Overview-Report (1,5 Minuten)<a class="headerlink" href="#admin_tools_demo_script-szenario-overview-report-15-minuten" title="Permanent link">&para;</a></h3>
<pre><code>AKTION: Typ „overview“ auswählen → „Generieren“

ERWARTUNG:
✓ GET /reports/compliance?type=overview
✓ Anzeige zentraler Metriken (verschlüsselte Entitäten, PII-Funde, etc.)
✓ Export als CSV/PDF/Excel

EDGE CASES:
• 503 Reports API not available → Hinweis/Retry Option
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-demo-6-performance-benutzerfreundlichkeit-3-minuten">Demo 6: Performance &amp; Benutzerfreundlichkeit (3 Minuten)<a class="headerlink" href="#admin_tools_demo_script-demo-6-performance-benutzerfreundlichkeit-3-minuten" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-feature-1-echtzeit-feedback-30-sekunden">Feature 1: Echtzeit-Feedback (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-feature-1-echtzeit-feedback-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>DEMO:
1. Suchfeld langsam tippen: &quot;a&quot; → &quot;ad&quot; → &quot;adm&quot; → &quot;admin&quot;
2. Zeige: Filter aktualisiert bei JEDEM Buchstaben
3. Status-Leiste zeigt sofort gefilterte Anzahl

ERKLÄRUNG:
→ &quot;UpdateSourceTrigger=PropertyChanged&quot;
→ &quot;Kein Button-Klick nötig&quot;
→ &quot;Instant Visual Feedback&quot;
</code></pre>
<h3 id="admin_tools_demo_script-feature-2-icollectionview-performance-1-minute">Feature 2: ICollectionView Performance (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-feature-2-icollectionview-performance-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>DEMO:
1. Lade 100 Audit-Logs
2. Suche &quot;test&quot; → Filter in &lt;50ms
3. Wechsle zu &quot;admin&quot; → Filter in &lt;50ms
4. Sortiere nach Zeitstempel → Instant

ERKLÄRUNG:
→ &quot;ICollectionView ändert nur Ansicht&quot;
→ &quot;Quell-Collection bleibt unverändert&quot;
→ &quot;Keine Netzwerk-Requests&quot;
→ &quot;Nur bereits geladene Daten betroffen&quot;
</code></pre>
<h3 id="admin_tools_demo_script-feature-3-kombinierte-filter-1-minute">Feature 3: Kombinierte Filter (1 Minute)<a class="headerlink" href="#admin_tools_demo_script-feature-3-kombinierte-filter-1-minute" title="Permanent link">&para;</a></h3>
<pre><code>DEMO:
1. Server-Filter: User=&quot;admin&quot;, Datum=Letzte Woche
2. Klick &quot;Laden&quot; → 50 Einträge vom Server
3. Client-Suche: &quot;create&quot; → 12 von 50 angezeigt
4. Status: &quot;12 von 50 Einträgen angezeigt (Gesamt im System: 1234)&quot;

ERKLÄRUNG:
→ &quot;Server-Filter reduzieren Netzwerk-Traffic&quot;
→ &quot;Client-Suche für Feinabstimmung&quot;
→ &quot;AND-Verknüpfung aller Filter&quot;
→ &quot;Status zeigt 3 Ebenen: Gefiltert / Geladen / Gesamt&quot;
</code></pre>
<h3 id="admin_tools_demo_script-feature-4-platzhalter-tooltips-30-sekunden">Feature 4: Platzhalter &amp; Tooltips (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-feature-4-platzhalter-tooltips-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>DEMO:
1. Zeige leeres Suchfeld: &quot;🔍 Search...&quot;
2. Hover über Suchfeld: Tooltip &quot;Durchsucht alle Spalten...&quot;
3. Hover über Buttons: Tooltips erklären Funktion

ERKLÄRUNG:
→ &quot;VisualBrush für Platzhalter-Text&quot;
→ &quot;Tooltips für Benutzerfreundlichkeit&quot;
→ &quot;Keine zusätzlichen Labels nötig&quot;
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-demo-7-error-handling-edge-cases-2-minuten">Demo 7: Error Handling &amp; Edge Cases (2 Minuten)<a class="headerlink" href="#admin_tools_demo_script-demo-7-error-handling-edge-cases-2-minuten" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-szenario-1-server-nicht-erreichbar-30-sekunden">Szenario 1: Server nicht erreichbar (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-1-server-nicht-erreichbar-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>SETUP: themis_server beenden

AKTION:
- AuditLogViewer öffnen
- Klick &quot;Laden&quot;

ERWARTUNG:
✓ Loading-Indicator erscheint
✓ Nach Timeout: MessageBox &quot;Fehler beim Laden der Audit-Logs: ...&quot;
✓ Status: &quot;Fehler: Connection refused&quot;
✓ DataGrid bleibt leer

DEMO-PUNKT:
→ &quot;Graceful Error Handling&quot;
→ &quot;Benutzer-freundliche Fehlermeldungen&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-2-keine-ergebnisse-30-sekunden">Szenario 2: Keine Ergebnisse (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-2-keine-ergebnisse-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION:
- Suchfeld: &quot;XYZABCNOTFOUND&quot;

ERWARTUNG:
✓ DataGrid leer
✓ Status: &quot;0 von 100 Einträgen angezeigt (Gesamt: 100)&quot;
✓ KEINE Fehlermeldung (= valider Zustand)

DEMO-PUNKT:
→ &quot;Leere Ergebnisse ≠ Fehler&quot;
→ &quot;Status zeigt deutlich: 0 Treffer&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-3-verify-ohne-auswahl-30-sekunden">Szenario 3: Verify ohne Auswahl (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-3-verify-ohne-auswahl-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION:
- SAGAVerifier öffnen
- Klick &quot;Verify Selected&quot; (ohne Batch-Auswahl)

ERWARTUNG:
✓ Button ist DISABLED
✓ Grau ausgegraut
✓ Kein API-Call möglich

DEMO-PUNKT:
→ &quot;IsEnabled Binding verhindert ungültige Aktionen&quot;
→ &quot;Converter: NullToBoolConverter&quot;
</code></pre>
<h3 id="admin_tools_demo_script-szenario-4-export-ohne-daten-30-sekunden">Szenario 4: Export ohne Daten (30 Sekunden)<a class="headerlink" href="#admin_tools_demo_script-szenario-4-export-ohne-daten-30-sekunden" title="Permanent link">&para;</a></h3>
<pre><code>AKTION:
- SAGAVerifier öffnen (keine Steps geladen)
- Klick &quot;Export Steps&quot;

ERWARTUNG:
✓ Button ist DISABLED (wegen CountToBoolConverter)
✓ Oder: MessageBox &quot;No SAGA steps to export&quot;

DEMO-PUNKT:
→ &quot;Validation vor Export&quot;
→ &quot;Verhindert leere Dateien&quot;
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-technische-highlights-fur-entwickler-prasentation">Technische Highlights (für Entwickler-Präsentation)<a class="headerlink" href="#admin_tools_demo_script-technische-highlights-fur-entwickler-prasentation" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-highlight-1-mvvm-pattern">Highlight 1: MVVM Pattern<a class="headerlink" href="#admin_tools_demo_script-highlight-1-mvvm-pattern" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">// ViewModel (MainViewModel.cs)
[ObservableProperty]
private string _searchText = string.Empty;

partial void OnSearchTextChanged(string value)
{
    _logsView?.Refresh();  // Aktualisiert UI automatisch
    UpdateStatusMessage();
}

// View (MainWindow.xaml)
&lt;TextBox Text=&quot;{Binding SearchText, UpdateSourceTrigger=PropertyChanged}&quot;/&gt;
</code></pre>
<h3 id="admin_tools_demo_script-highlight-2-icollectionview-filter">Highlight 2: ICollectionView Filter<a class="headerlink" href="#admin_tools_demo_script-highlight-2-icollectionview-filter" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">// Setup
_logsView = CollectionViewSource.GetDefaultView(AuditLogs);
_logsView.Filter = FilterLogs;

// Filter-Logik
private bool FilterLogs(object obj)
{
    if (obj is not AuditLogEntry log)
        return false;

    if (!string.IsNullOrWhiteSpace(SearchText))
    {
        var search = SearchText.ToLowerInvariant();
        return log.User?.ToLowerInvariant().Contains(search) == true ||
               log.Action?.ToLowerInvariant().Contains(search) == true;
    }

    return true;
}
</code></pre>
<h3 id="admin_tools_demo_script-highlight-3-dependency-injection">Highlight 3: Dependency Injection<a class="headerlink" href="#admin_tools_demo_script-highlight-3-dependency-injection" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">// App.xaml.cs
protected override void OnStartup(StartupEventArgs e)
{
    var services = new ServiceCollection();

    services.AddSingleton(serverConfig);
    services.AddTransient&lt;ThemisApiClient&gt;(sp =&gt; {
        var config = sp.GetRequiredService&lt;ThemisServerConfig&gt;();
        var httpClient = new HttpClient {
            BaseAddress = new Uri(config.BaseUrl),
            Timeout = TimeSpan.FromSeconds(config.Timeout)
        };
        return new ThemisApiClient(httpClient, config);
    });
    services.AddTransient&lt;MainViewModel&gt;();
    services.AddTransient&lt;MainWindow&gt;();

    _serviceProvider = services.BuildServiceProvider();
    _serviceProvider.GetRequiredService&lt;MainWindow&gt;().Show();
}
</code></pre>
<h3 id="admin_tools_demo_script-highlight-4-async-commands">Highlight 4: Async Commands<a class="headerlink" href="#admin_tools_demo_script-highlight-4-async-commands" title="Permanent link">&para;</a></h3>
<pre><code class="language-csharp">// CommunityToolkit.Mvvm
[RelayCommand]
private async Task LoadBatchesAsync()
{
    IsLoading = true;
    StatusMessage = &quot;Loading SAGA batches...&quot;;

    var response = await _apiClient.GetSAGABatchesAsync();

    if (response.Success &amp;&amp; response.Data != null)
    {
        Batches = new ObservableCollection&lt;SAGABatchInfo&gt;(response.Data.Batches);
        StatusMessage = $&quot;Loaded {Batches.Count} batch(es)&quot;;
    }

    IsLoading = false;
}
</code></pre>
<hr />
<h2 id="admin_tools_demo_script-zusammenfassung-fur-prasentation">Zusammenfassung für Präsentation<a class="headerlink" href="#admin_tools_demo_script-zusammenfassung-fur-prasentation" title="Permanent link">&para;</a></h2>
<h3 id="admin_tools_demo_script-key-messages">Key Messages:<a class="headerlink" href="#admin_tools_demo_script-key-messages" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Echtzeit-Suche</strong>: Sofortiges Feedback, keine Button-Klicks</li>
<li><strong>Multi-Column Sort</strong>: Toggle Direction, visueller Feedback</li>
<li><strong>Kombinierte Filter</strong>: Server + Client, AND-Logik</li>
<li><strong>Performance</strong>: ICollectionView, keine Collection-Manipulation</li>
<li><strong>Benutzerfreundlichkeit</strong>: Tooltips, Platzhalter, Status-Updates</li>
<li><strong>Fehlerbehandlung</strong>: Graceful Degradation, klare Meldungen</li>
<li><strong>MVVM</strong>: Clean Architecture, Testbar, Wartbar</li>
<li><strong>DI</strong>: Loose Coupling, konfigurierbar</li>
</ol>
<h3 id="admin_tools_demo_script-demo-reihenfolge-10-minuten">Demo-Reihenfolge (10 Minuten):<a class="headerlink" href="#admin_tools_demo_script-demo-reihenfolge-10-minuten" title="Permanent link">&para;</a></h3>
<ol>
<li>AuditLogViewer - Basis-Funktionen (2 Min)</li>
<li>AuditLogViewer - Such &amp; Filter (2 Min)</li>
<li>SAGAVerifier - Batch-Suche (2 Min)</li>
<li>SAGAVerifier - Verifizierung (2 Min)</li>
<li>Performance &amp; UX Highlights (1 Min)</li>
<li>Error Handling (1 Min)</li>
</ol></section></section>
                    <section class='print-page md-section' id='section-16' heading-number='16'>
                        <h1>APIs<a class='headerlink' href='#section-16' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="apis-openapi" heading-number="16.1"><h1 id="apis-openapi-openapi-endpunkte">OpenAPI &amp; Endpunkte<a class="headerlink" href="#apis-openapi-openapi-endpunkte" title="Permanent link">&para;</a></h1>
<p>Die vollständige API-Spezifikation liegt als YAML vor:</p>
<ul>
<li><code>docs/openapi.yaml</code> (aktuell)</li>
<li>optional: <code>openapi/openapi.yaml</code> (alternativ, ggf. konsolidieren)</li>
</ul>
<p>Aktualisierungen anstehend:
- Aufnahme der neuen Endpunkte für Keys, Classification, Reports (bereits in <code>docs/openapi.yaml</code> ergänzt)
- Beispiele mit Request/Response und Fehlercodes
- Hinweis: Das SSE-Streaming <code>GET /changefeed/stream</code> ist nicht Teil der OpenAPI (Content-Type <code>text/event-stream</code>). Details siehe „Change Data Capture (CDC)“.</p>
<p>Hinweis: Für eine gerenderte Ansicht (Swagger/Redoc) kann später ein MkDocs-Plugin ergänzt werden. Bis dahin bitte die YAML-Datei direkt öffnen oder mit einem lokalen Viewer betrachten.</p>
<h2 id="apis-openapi-sse-streaming-changefeed">SSE-Streaming (Changefeed)<a class="headerlink" href="#apis-openapi-sse-streaming-changefeed" title="Permanent link">&para;</a></h2>
<p>Dieser Endpoint ist nicht Teil der OpenAPI-Spezifikation, da er <code>text/event-stream</code> zurückliefert.</p>
<ul>
<li>Endpoint: <code>GET /changefeed/stream</code></li>
<li>Query-Parameter:<ul>
<li><code>from_seq</code> (optional, uint64): Start-Sequenz (exklusiv); Standard 0</li>
<li><code>key_prefix</code> (optional, string): Filtert Events nach Schlüsselpräfix</li>
<li><code>keep_alive</code> (optional, bool): Hält die Verbindung offen und streamt fortlaufend; Standard <code>true</code></li>
<li><code>max_seconds</code> (optional, int): Maximale Streamdauer, 1..60 Sekunden (Standard 30) – für Rotation/Tests</li>
<li><code>heartbeat_ms</code> (optional, int): Test-Override für Heartbeat-Intervall (min. 100ms); in Produktion nicht nötig</li>
</ul>
</li>
</ul>
<p>Antwort:
- Content-Type: <code>text/event-stream</code>
- Format: jeweils eine Zeile pro Event <code>data: {JSON}\n\n</code>; bei Leerlauf Heartbeats <code>: heartbeat\n\n</code></p>
<p>Beispiel (curl, Einmal-Stream für 10s):</p>
<pre><code class="language-bash">curl -N &quot;http://localhost:8765/changefeed/stream?from_seq=0&amp;keep_alive=true&amp;max_seconds=10&quot;
</code></pre>
<p>Weitere Details und Best Practices (Checkpointing, Heartbeats, Reverse Proxy) siehe „Change Data Capture (CDC)“ unter Deployment &amp; Betrieb.</p></section></section>
                    <section class='print-page md-section' id='section-17' heading-number='17'>
                        <h1>Styleguide & Glossar<a class='headerlink' href='#section-17' title='Permanent link'></a>
                        </h1>
                    <section class="print-page" id="styleguide" heading-number="17.1"><h1 id="styleguide-styleguide-konventionen-themis">Styleguide &amp; Konventionen – THEMIS<a class="headerlink" href="#styleguide-styleguide-konventionen-themis" title="Permanent link">&para;</a></h1>
<p><strong>Version:</strong> 2.0<br />
<strong>Status:</strong> Implementiert<br />
<strong>Letzte Aktualisierung:</strong> 2. November 2025</p>
<hr />
<h2 id="styleguide-ubersicht">Übersicht<a class="headerlink" href="#styleguide-ubersicht" title="Permanent link">&para;</a></h2>
<p>Dieser Styleguide definiert Coding-Standards, Namenskonventionen, Error Handling und Logging-Richtlinien für das THEMIS-Projekt. Ziel ist Konsistenz, Wartbarkeit und Qualität über alle C++-Module hinweg.</p>
<hr />
<h2 id="styleguide-1-c-coding-standards">1. C++ Coding Standards<a class="headerlink" href="#styleguide-1-c-coding-standards" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-11-c-version-compiler">1.1 C++ Version &amp; Compiler<a class="headerlink" href="#styleguide-11-c-version-compiler" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Standard:</strong> C++17 (minimum)</li>
<li><strong>Compiler:</strong> MSVC (Windows), GCC/Clang (Linux)</li>
<li><strong>Features:</strong> STL, <code>std::optional</code>, <code>std::variant</code>, <code>std::string_view</code>, structured bindings</li>
</ul>
<h3 id="styleguide-12-header-guards">1.2 Header Guards<a class="headerlink" href="#styleguide-12-header-guards" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#pragma once  // Bevorzugt (MSVC/GCC/Clang)
</code></pre>
<p><strong>Alternativ (klassisch):</strong></p>
<pre><code class="language-cpp">#ifndef THEMIS_MODULE_HEADER_H
#define THEMIS_MODULE_HEADER_H
// ...
#endif // THEMIS_MODULE_HEADER_H
</code></pre>
<h3 id="styleguide-13-includes">1.3 Includes<a class="headerlink" href="#styleguide-13-includes" title="Permanent link">&para;</a></h3>
<p><strong>Reihenfolge:</strong>
1. Eigener Header (<code>.cpp</code> → <code>.h</code>)
2. Themis-Headers (<code>include/...</code>)
3. Externe Libraries (RocksDB, Boost, spdlog)
4. STL-Headers (<code>&lt;memory&gt;</code>, <code>&lt;string&gt;</code>, etc.)</p>
<pre><code class="language-cpp">#include &quot;storage/base_entity.h&quot;        // 1. Eigener Header

#include &quot;index/secondary_index.h&quot;      // 2. Themis-Headers
#include &quot;utils/logger.h&quot;

#include &lt;rocksdb/db.h&gt;                 // 3. Externe Libraries
#include &lt;boost/beast/http.hpp&gt;

#include &lt;memory&gt;                       // 4. STL
#include &lt;string&gt;
#include &lt;vector&gt;
</code></pre>
<hr />
<h2 id="styleguide-2-naming-conventions">2. Naming Conventions<a class="headerlink" href="#styleguide-2-naming-conventions" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-21-klassen-structs">2.1 Klassen &amp; Structs<a class="headerlink" href="#styleguide-21-klassen-structs" title="Permanent link">&para;</a></h3>
<p><strong>PascalCase</strong> mit sprechenden Namen:</p>
<pre><code class="language-cpp">class BaseEntity { };
class SecondaryIndexManager { };
class TransactionManager { };
struct Status { };
struct DataPoint { };
</code></pre>
<h3 id="styleguide-22-funktionen-methoden">2.2 Funktionen &amp; Methoden<a class="headerlink" href="#styleguide-22-funktionen-methoden" title="Permanent link">&para;</a></h3>
<p><strong>camelCase</strong> mit Verben (get/set/create/delete/has/is):</p>
<pre><code class="language-cpp">class BaseEntity {
public:
    const std::string&amp; getPrimaryKey() const;
    void setPrimaryKey(std::string_view pk);
    bool hasField(std::string_view field_name) const;

    static BaseEntity fromJson(std::string_view pk, std::string_view json);
    static BaseEntity deserialize(std::string_view pk, const Blob&amp; blob);
};
</code></pre>
<h3 id="styleguide-23-variablen">2.3 Variablen<a class="headerlink" href="#styleguide-23-variablen" title="Permanent link">&para;</a></h3>
<p><strong>snake_case</strong> für Member-Variablen (mit Unterstrich-Suffix):</p>
<pre><code class="language-cpp">class BaseEntity {
private:
    std::string primary_key_;
    Blob blob_;
    Format format_;
    mutable std::shared_ptr&lt;FieldMap&gt; field_cache_;
};
</code></pre>
<p><strong>camelCase</strong> für lokale Variablen:</p>
<pre><code class="language-cpp">void processEntity() {
    std::string entityKey = makeKey(&quot;users&quot;, &quot;alice&quot;);
    auto blob = db.get(entityKey);
    BaseEntity entity = BaseEntity::deserialize(&quot;alice&quot;, *blob);
}
</code></pre>
<h3 id="styleguide-24-konstanten-enums">2.4 Konstanten &amp; Enums<a class="headerlink" href="#styleguide-24-konstanten-enums" title="Permanent link">&para;</a></h3>
<p><strong>UPPER_CASE</strong> für Makros/Konstanten:</p>
<pre><code class="language-cpp">#define THEMIS_INFO(...) ::themis::utils::Logger::info(__VA_ARGS__)

static constexpr const char* KEY_PREFIX = &quot;ts:&quot;;
static constexpr size_t MAX_BATCH_SIZE = 1000;
</code></pre>
<p><strong>PascalCase</strong> für Enums:</p>
<pre><code class="language-cpp">enum class Format {
    BINARY,
    JSON
};

enum class Level {
    TRACE, DEBUG, INFO, WARN, ERROR, CRITICAL
};
</code></pre>
<h3 id="styleguide-25-namespaces">2.5 Namespaces<a class="headerlink" href="#styleguide-25-namespaces" title="Permanent link">&para;</a></h3>
<p><strong>lowercase</strong> mit Sub-Namespaces:</p>
<pre><code class="language-cpp">namespace themis {
namespace utils {

class Logger { };

} // namespace utils
} // namespace themis
</code></pre>
<p><strong>Verwendung:</strong></p>
<pre><code class="language-cpp">using themis::BaseEntity;
using themis::utils::Logger;
</code></pre>
<hr />
<h2 id="styleguide-3-error-handling">3. Error Handling<a class="headerlink" href="#styleguide-3-error-handling" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-31-status-objekt-kein-exceptions">3.1 Status-Objekt (kein Exceptions)<a class="headerlink" href="#styleguide-31-status-objekt-kein-exceptions" title="Permanent link">&para;</a></h3>
<p>Alle öffentlichen APIs verwenden <code>Status</code>-Objekte statt Exceptions:</p>
<pre><code class="language-cpp">struct Status {
    bool ok = true;
    std::string message;

    static Status OK() { return {}; }
    static Status Error(std::string msg) { return Status{false, std::move(msg)}; }
};
</code></pre>
<p><strong>Verwendung:</strong></p>
<pre><code class="language-cpp">// ✅ RICHTIG: Status zurückgeben
Status createIndex(std::string_view table, std::string_view column) {
    if (table.empty()) {
        return Status::Error(&quot;createIndex: table darf nicht leer sein&quot;);
    }
    // ...
    return Status::OK();
}

// Aufrufer prüft Status
auto status = idx.createIndex(&quot;users&quot;, &quot;age&quot;);
if (!status.ok) {
    THEMIS_ERROR(&quot;Index creation failed: {}&quot;, status.message);
    return;
}
</code></pre>
<h3 id="styleguide-32-stdoptional-fur-optionale-werte">3.2 std::optional für optionale Werte<a class="headerlink" href="#styleguide-32-stdoptional-fur-optionale-werte" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: optional für fehlende Werte
std::optional&lt;std::string&gt; getFieldAsString(std::string_view field_name) const;

auto name = entity.getFieldAsString(&quot;name&quot;);
if (name) {
    std::cout &lt;&lt; *name &lt;&lt; &quot;\n&quot;;
}

// ❌ FALSCH: nullptr zurückgeben (unsicher)
std::string* getFieldAsString(std::string_view field_name) const;  // NEIN!
</code></pre>
<h3 id="styleguide-33-stdpair-fur-status-wert">3.3 std::pair für Status + Wert<a class="headerlink" href="#styleguide-33-stdpair-fur-status-wert" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// Query mit Result
std::pair&lt;Status, std::vector&lt;std::string&gt;&gt; scanKeysEqual(
    std::string_view table,
    std::string_view column,
    std::string_view value
) const;

// Aufrufer
auto [status, keys] = idx.scanKeysEqual(&quot;users&quot;, &quot;age&quot;, &quot;30&quot;);
if (!status.ok) {
    THEMIS_ERROR(&quot;Scan failed: {}&quot;, status.message);
    return;
}
for (const auto&amp; key : keys) {
    // Process keys
}
</code></pre>
<hr />
<h2 id="styleguide-4-logging">4. Logging<a class="headerlink" href="#styleguide-4-logging" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-41-logger-makros">4.1 Logger-Makros<a class="headerlink" href="#styleguide-41-logger-makros" title="Permanent link">&para;</a></h3>
<p><strong>Verfügbare Level:</strong></p>
<pre><code class="language-cpp">THEMIS_TRACE(...)     // Detaillierte Debug-Info (selten verwendet)
THEMIS_DEBUG(...)     // Debug-Informationen (Development)
THEMIS_INFO(...)      // Allgemeine Informationen
THEMIS_WARN(...)      // Warnungen (nicht kritisch)
THEMIS_ERROR(...)     // Fehler (kritisch, aber nicht fatal)
THEMIS_CRITICAL(...)  // Fatale Fehler (Server-Absturz)
</code></pre>
<h3 id="styleguide-42-logging-best-practices">4.2 Logging-Best Practices<a class="headerlink" href="#styleguide-42-logging-best-practices" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: Strukturiertes Logging mit fmt-Syntax
THEMIS_INFO(&quot;Index erstellt: {}.{}&quot;, table, column);
THEMIS_ERROR(&quot;Put fehlgeschlagen: {}, Key: {}&quot;, status.message, key);
THEMIS_DEBUG(&quot;Cache hit: {}, Size: {} bytes&quot;, pk, blob.size());

// ✅ RICHTIG: Sensible Daten vermeiden
THEMIS_INFO(&quot;User authenticated: id={}&quot;, userId);  // OK
THEMIS_ERROR(&quot;Auth failed for user: {}&quot;, username);  // ❌ PII!

// ✅ RICHTIG: Error-Kontext
if (!db.put(key, value)) {
    THEMIS_ERROR(&quot;RocksDB put failed: key={}, table={}&quot;, key, table);
}

// ❌ FALSCH: std::cout/printf verwenden
std::cout &lt;&lt; &quot;Index created\n&quot;;  // NEIN! Nutze Logger
</code></pre>
<h3 id="styleguide-43-log-initialisierung">4.3 Log-Initialisierung<a class="headerlink" href="#styleguide-43-log-initialisierung" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// main_server.cpp
Logger::init(&quot;themis_server.log&quot;, Logger::Level::INFO);

// Runtime-Änderung
Logger::setLevel(Logger::Level::DEBUG);
Logger::setPattern(&quot;[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [thread %t] %v&quot;);
</code></pre>
<hr />
<h2 id="styleguide-5-code-struktur">5. Code-Struktur<a class="headerlink" href="#styleguide-5-code-struktur" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-51-klassen-layout">5.1 Klassen-Layout<a class="headerlink" href="#styleguide-51-klassen-layout" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">class SecondaryIndexManager {
public:
    // 1. Nested Types
    struct Status { };
    enum class IndexType { };

    // 2. Konstruktoren
    explicit SecondaryIndexManager(RocksDBWrapper&amp; db);

    // 3. Öffentliche API (alphabetisch oder logisch gruppiert)
    Status createIndex(std::string_view table, std::string_view column);
    Status dropIndex(std::string_view table, std::string_view column);
    bool hasIndex(std::string_view table, std::string_view column) const;

private:
    // 4. Private Helper-Methoden
    std::string makeIndexKey_(std::string_view table, std::string_view column);

    // 5. Member-Variablen (mit Unterstrich-Suffix)
    RocksDBWrapper&amp; db_;
    std::unordered_set&lt;std::string&gt; indexed_columns_;
};
</code></pre>
<h3 id="styleguide-52-funktions-reihenfolge">5.2 Funktions-Reihenfolge<a class="headerlink" href="#styleguide-52-funktions-reihenfolge" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Öffentliche API</strong> (Header + Implementierung)</li>
<li><strong>Private Helper</strong> (nur Implementierung)</li>
<li><strong>Static Utilities</strong> (am Ende)</li>
</ol>
<h3 id="styleguide-53-kommentare">5.3 Kommentare<a class="headerlink" href="#styleguide-53-kommentare" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: Doxygen-Style für öffentliche APIs
/**
 * @brief Create secondary index on table column
 * @param table Table name
 * @param column Column name
 * @param unique If true, enforce unique values
 * @return Status OK or Error with message
 */
Status createIndex(std::string_view table, std::string_view column, bool unique = false);

// ✅ RICHTIG: Inline-Kommentare für komplexe Logik
// Calculate expire timestamp: now + TTL seconds
auto now = std::chrono::system_clock::now();
int64_t expireTimestamp = currentTimestamp + ttlSeconds;

// ❌ FALSCH: Offensichtliches kommentieren
i++;  // increment i
</code></pre>
<hr />
<h2 id="styleguide-6-speicher-management">6. Speicher-Management<a class="headerlink" href="#styleguide-6-speicher-management" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-61-smart-pointers">6.1 Smart Pointers<a class="headerlink" href="#styleguide-61-smart-pointers" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: std::unique_ptr für Ownership
std::unique_ptr&lt;BaseEntity&gt; entity = std::make_unique&lt;BaseEntity&gt;(&quot;alice&quot;);

// ✅ RICHTIG: std::shared_ptr für Shared Ownership
mutable std::shared_ptr&lt;FieldMap&gt; field_cache_;

// ❌ FALSCH: Raw Pointers (außer für Nicht-Owning-References)
BaseEntity* entity = new BaseEntity(&quot;alice&quot;);  // NEIN!
</code></pre>
<h3 id="styleguide-62-string-handling">6.2 String-Handling<a class="headerlink" href="#styleguide-62-string-handling" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: std::string_view für Read-Only-Parameter
void processKey(std::string_view key);

// ✅ RICHTIG: std::string für Ownership
std::string makeKey(std::string_view table, std::string_view pk) {
    return std::string(table) + &quot;:&quot; + std::string(pk);
}

// ❌ FALSCH: const char* (unsicher bei temporären Strings)
void processKey(const char* key);  // Verwende string_view!
</code></pre>
<hr />
<h2 id="styleguide-7-testing-assertions">7. Testing &amp; Assertions<a class="headerlink" href="#styleguide-7-testing-assertions" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-71-unit-tests-google-test">7.1 Unit Tests (Google Test)<a class="headerlink" href="#styleguide-71-unit-tests-google-test" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">TEST_F(SecondaryIndexTest, CreateIndex) {
    auto status = idx_-&gt;createIndex(&quot;users&quot;, &quot;age&quot;);
    ASSERT_TRUE(status.ok);

    EXPECT_TRUE(idx_-&gt;hasIndex(&quot;users&quot;, &quot;age&quot;));
}

TEST_F(SecondaryIndexTest, CreateIndex_EmptyTable) {
    auto status = idx_-&gt;createIndex(&quot;&quot;, &quot;age&quot;);
    EXPECT_FALSE(status.ok);
    EXPECT_NE(status.message.find(&quot;table&quot;), std::string::npos);
}
</code></pre>
<h3 id="styleguide-72-runtime-assertions-development">7.2 Runtime-Assertions (Development)<a class="headerlink" href="#styleguide-72-runtime-assertions-development" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">#include &lt;cassert&gt;

// Nur in Debug-Builds
assert(pk.size() &gt; 0 &amp;&amp; &quot;Primary key must not be empty&quot;);
assert(dim &gt; 0 &amp;&amp; &quot;Vector dimension must be positive&quot;);
</code></pre>
<hr />
<h2 id="styleguide-8-dokumentations-standards">8. Dokumentations-Standards<a class="headerlink" href="#styleguide-8-dokumentations-standards" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-81-sprache">8.1 Sprache<a class="headerlink" href="#styleguide-81-sprache" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Code-Kommentare:</strong> Deutsch (Doku-Konsistenz)</li>
<li><strong>API-Doku (Doxygen):</strong> Deutsch</li>
<li><strong>Logs:</strong> Deutsch (Fehlermeldungen)</li>
<li><strong>Variablen/Funktionen:</strong> Englisch (etablierte Begriffe wie <code>getPrimaryKey</code>, <code>serialize</code>)</li>
</ul>
<h3 id="styleguide-82-markdown-dokumentation">8.2 Markdown-Dokumentation<a class="headerlink" href="#styleguide-82-markdown-dokumentation" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Dateinamen:</strong> <code>kebab-case.md</code> oder <code>snake_case.md</code> (z. B. <code>base_entity.md</code>)</li>
<li><strong>Überschriften:</strong> Eine <code>#</code> pro Datei, dann <code>##</code>-Abschnitte</li>
<li><strong>Code-Blöcke:</strong> Sprache angeben (<code>cpp,</code>json, ```http)</li>
<li><strong>Verweise:</strong> Backticks für Code/Dateien (<code>src/server/http_server.cpp</code>)</li>
</ul>
<h3 id="styleguide-83-beispiel">8.3 Beispiel<a class="headerlink" href="#styleguide-83-beispiel" title="Permanent link">&para;</a></h3>
<pre><code class="language-markdown">## BaseEntity – Verwendung

```cpp
// Entity erstellen
BaseEntity user = BaseEntity::fromJson(&quot;alice&quot;, json_string);

// Feld lesen
auto name = user.getFieldAsString(&quot;name&quot;);
if (name) {
    THEMIS_INFO(&quot;User: {}&quot;, *name);
}
```

**Siehe auch:** [RocksDB Storage](storage/rocksdb_layout.md)
</code></pre>
<hr />
<h2 id="styleguide-9-performance-best-practices">9. Performance-Best Practices<a class="headerlink" href="#styleguide-9-performance-best-practices" title="Permanent link">&para;</a></h2>
<h3 id="styleguide-91-vermeidung-von-kopien">9.1 Vermeidung von Kopien<a class="headerlink" href="#styleguide-91-vermeidung-von-kopien" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: string_view für Parameter (keine Kopie)
void processKey(std::string_view key);

// ✅ RICHTIG: const&amp; für große Objekte
void processEntity(const BaseEntity&amp; entity);

// ❌ FALSCH: Pass-by-Value für große Objekte
void processEntity(BaseEntity entity);  // Kopiert Blob!
</code></pre>
<h3 id="styleguide-92-reserve-fur-vektoren">9.2 Reserve für Vektoren<a class="headerlink" href="#styleguide-92-reserve-fur-vektoren" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: reserve() vor Push-Schleife
std::vector&lt;std::string&gt; keys;
keys.reserve(expectedSize);
for (...) {
    keys.push_back(key);
}
</code></pre>
<h3 id="styleguide-93-move-semantik">9.3 Move-Semantik<a class="headerlink" href="#styleguide-93-move-semantik" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">// ✅ RICHTIG: std::move für Ownership-Transfer
std::string value = std::move(tempValue);
batch-&gt;put(key, std::move(blob));

// ✅ RICHTIG: Return-Value-Optimization (RVO)
BaseEntity createEntity() {
    BaseEntity entity(&quot;alice&quot;);
    // ... fill fields
    return entity;  // RVO, keine Kopie
}
</code></pre>
<hr />
<h2 id="styleguide-10-definition-of-done-code">10. Definition of Done (Code)<a class="headerlink" href="#styleguide-10-definition-of-done-code" title="Permanent link">&para;</a></h2>
<p>Bevor Code committed wird:</p>
<ul>
<li>[ ] <strong>Kompiliert</strong> ohne Warnings (MSVC <code>/W4</code>, GCC <code>-Wall -Wextra</code>)</li>
<li>[ ] <strong>Unit Tests</strong> vorhanden und grün</li>
<li>[ ] <strong>Logging</strong> an kritischen Stellen (Error Paths)</li>
<li>[ ] <strong>Status-Objekt</strong> für Fehlerbehandlung (keine Exceptions in öffentlichen APIs)</li>
<li>[ ] <strong>Doxygen-Kommentare</strong> für öffentliche APIs</li>
<li>[ ] <strong>Code-Review</strong> abgeschlossen</li>
<li>[ ] <strong>Dokumentation</strong> aktualisiert (wenn nötig)</li>
</ul>
<hr />
<h2 id="styleguide-11-definition-of-done-dokumentation">11. Definition of Done (Dokumentation)<a class="headerlink" href="#styleguide-11-definition-of-done-dokumentation" title="Permanent link">&para;</a></h2>
<p>Bevor Doku als "fertig" gilt:</p>
<ul>
<li>[ ] <strong>Inhalt korrekt</strong> (mit Source-Code abgeglichen)</li>
<li>[ ] <strong>Beispiele valide</strong> (kompilierbar/ausführbar)</li>
<li>[ ] <strong>Interne Verweise</strong> funktionieren</li>
<li>[ ] <strong>Navigation</strong> in <code>mkdocs.yml</code> verlinkt</li>
<li>[ ] <strong>Rechtschreibung</strong> geprüft (DE)</li>
</ul>
<hr />
<h2 id="styleguide-referenzen">Referenzen<a class="headerlink" href="#styleguide-referenzen" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Logger:</strong> <code>include/utils/logger.h</code></li>
<li><strong>Status Pattern:</strong> <code>include/index/secondary_index.h</code> (Status struct)</li>
<li><strong>BaseEntity:</strong> <code>include/storage/base_entity.h</code></li>
<li><strong>Google Test:</strong> https://github.com/google/googletest</li>
<li><strong>spdlog:</strong> https://github.com/gabime/spdlog</li>
</ul></section><section class="print-page" id="glossary" heading-number="17.2"><h1 id="glossary-glossar">Glossar<a class="headerlink" href="#glossary-glossar" title="Permanent link">&para;</a></h1>
<ul>
<li>AQL: Abfragesprache von ThemisDB (ähnlich JSON-basiert)</li>
<li>Entity: Knoten-Element (Dokument) im Graph-/Dokumentenmodell</li>
<li>Edge: Beziehung zwischen Entities</li>
<li>MVCC: Multi-Version Concurrency Control (Nebenläufigkeitskontrolle)</li>
<li>WAL: Write-Ahead Log von RocksDB</li>
<li>TSStore: Zeitreihen-Speicherkomponente von ThemisDB</li>
<li>HNSW: Graph-basierter Algorithmus für Vektor-NN-Suche</li>
<li>PII: Personally Identifiable Information (personenbeziehbare Daten)</li>
<li>OpenAPI: Spezifikation der HTTP-REST-APIs</li>
</ul></section></section><section class="print-page" id="roadmap" heading-number="18"><h1 id="roadmap-roadmap">Roadmap<a class="headerlink" href="#roadmap-roadmap" title="Permanent link">&para;</a></h1>
<p>Diese Roadmap skizziert priorisierte Vorhaben für ThemisDB. Zeitpläne sind indikativ; Änderungen ergeben sich aus Feedback und Prioritäten.</p>
<h2 id="roadmap-kurzfristig-01-quartal">Kurzfristig (0–1 Quartal)<a class="headerlink" href="#roadmap-kurzfristig-01-quartal" title="Permanent link">&para;</a></h2>
<ul>
<li>RBAC/Policies für Admin- und Datenendpunkte (Scopes, API-Keys)</li>
<li>VectorIndex: HNSW Persistenz/Recovery-Härtung, Warmstart-Optimierungen</li>
<li>CDC/SSE: Skalierung und Backpressure (Proxy/Ingress-Guidelines), Reconnect-Strategien</li>
<li>Backup/Restore: Inkrementelle Backups und Automatisierung (systemd/K8s CronJobs)</li>
<li>CI: clang-tidy/cppcheck Gates, Coverage-Reporting, Secrets-Scanning (gitleaks)</li>
</ul>
<h2 id="roadmap-mittelfristig-13-quartale">Mittelfristig (1–3 Quartale)<a class="headerlink" href="#roadmap-mittelfristig-13-quartale" title="Permanent link">&para;</a></h2>
<ul>
<li>Query Engine: Join-Optimierungen, Kostenmodell verfeinern, Statistiken/Histograms</li>
<li>Indexe: Kompakte Fulltext-Indexierung, Geo-Verbesserungen, progressives Reindexing</li>
<li>Sicherheit: Externe KMS-Integration (Vault/AWS KMS), Key-Rotation APIs</li>
<li>Speicherformate: Binary-Format Spezifikation stabilisieren, Zero-Copy-Reads ausbauen</li>
<li>Observability: Mehr Metriken (Abfrage-Latenzen pro Typ), Trace-Sampling Regeln</li>
</ul>
<h2 id="roadmap-langfristig-3-quartale">Langfristig (3+ Quartale)<a class="headerlink" href="#roadmap-langfristig-3-quartale" title="Permanent link">&para;</a></h2>
<ul>
<li>Verteilte Replikation (Leader/Follower), Konsistenzmodi, Leseskalierung</li>
<li>Multi-Tenancy mit Quotas/Isolation</li>
<li>GNN/Hybrid-Search Pipelines (Online/Offline) inkl. Feature Store Hooks</li>
<li>Policy-Engine (ABAC) und Compliance-Vorlagen (GDPR/ISO)</li>
</ul>
<h2 id="roadmap-angenommene-risiken-und-gegenmanahmen">Angenommene Risiken und Gegenmaßnahmen<a class="headerlink" href="#roadmap-angenommene-risiken-und-gegenmanahmen" title="Permanent link">&para;</a></h2>
<ul>
<li>Performance-Regressionen: Regelmäßige Benchmarks, Budget für Optimierungssprints</li>
<li>Sicherheit: Security Reviews pro Release, Pen-Tests bei größeren Änderungen</li>
<li>Komplexität: Modulare Architektur, klare Verantwortlichkeiten, Dokumentation aktuell halten</li>
</ul></section><section class="print-page" id="changelog" heading-number="19"><h1 id="changelog-changelog">Changelog<a class="headerlink" href="#changelog-changelog" title="Permanent link">&para;</a></h1>
<p>Alle nennenswerten Änderungen dieses Projekts werden in diesem Dokument festgehalten. Das Format orientiert sich lose an Keep a Changelog.</p>
<h2 id="changelog-unreleased">[Unreleased]<a class="headerlink" href="#changelog-unreleased" title="Permanent link">&para;</a></h2>
<h3 id="changelog-added">Added<a class="headerlink" href="#changelog-added" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>RBAC/Authorization (MVP):</strong> Token-basierte Zugriffskontrolle mit Scopes (admin, config:write, cdc:read, metrics:read)</li>
<li>AuthMiddleware Klasse mit Scope-Prüfung und Metriken</li>
<li>Dokumentation: <code>docs/rbac_authorization.md</code></li>
<li>Tests: <code>tests/test_auth_middleware.cpp</code></li>
<li><strong>HNSW Persistenz &amp; Warmstart:</strong> Vektorindex-Persistierung für schnellere Startzeiten</li>
<li><code>saveIndex()</code>, <code>loadIndex()</code>, <code>setAutoSavePath()</code>, <code>shutdown()</code> APIs</li>
<li>Automatisches Laden beim Init, Auto-Save bei Shutdown</li>
<li>Dokumentation: <code>docs/hnsw_persistence.md</code></li>
<li>Konsolidierte Seite „Performance &amp; Benchmarks" mit Kompression, Pagination, MVCC/WriteBatch, Index-Rebuilds, Vector-Tuning</li>
<li>Vector-Benchmarks: <code>BM_VectorSearch_efSearch</code>, <code>BM_VectorInsert_Batch100</code></li>
<li>Qualitätssicherung (QA) Dokument mit Teststrategie, CI/CD, Coverage, Static Analysis</li>
<li>Security/Compliance Review Seite mit Checkliste und Verlinkungen</li>
</ul>
<h3 id="changelog-changed">Changed<a class="headerlink" href="#changelog-changed" title="Permanent link">&para;</a></h3>
<ul>
<li>Navigation (mkdocs.yml) um RBAC, HNSW Persistenz, Performance, QA, Security Review, Roadmap &amp; Changelog erweitert</li>
<li>Pagination/Kompressionsdokus ergänzt und verlinkt</li>
</ul>
<h3 id="changelog-fixed">Fixed<a class="headerlink" href="#changelog-fixed" title="Permanent link">&para;</a></h3>
<ul>
<li>Diverse Dokumentverlinkungen (Deployment, CDC, Index-Metriken) bereinigt</li>
<li>MkDocs-Build-Fehler behoben (YAML-Indentation, docs_dir entfernt)</li>
</ul>
<h2 id="changelog-010-2025-10-20">[0.1.0] - 2025-10-20<a class="headerlink" href="#changelog-010-2025-10-20" title="Permanent link">&para;</a></h2>
<p>Erste konsolidierte Doku-Fassung (Architektur, Storage &amp; MVCC, Query Engine &amp; AQL, Indexe, Content Pipeline, Deployment &amp; Betrieb).</p>
<h3 id="changelog-added_1">Added<a class="headerlink" href="#changelog-added_1" title="Permanent link">&para;</a></h3>
<ul>
<li>Grundlegende Seitenstruktur und Navigation</li>
<li>OpenAPI und Admin-Tools Dokus</li>
</ul></section></div><style>.print-site-enumerate-headings #index > h1:before { content: '1 ' }

                .print-site-enumerate-headings #index h2:before { content: '1.' counter(counter-index-2) ' ' }
                .print-site-enumerate-headings #index h2 {  counter-reset: counter-index-3 ;  counter-increment: counter-index-2 }
            
                .print-site-enumerate-headings #index h3:before { content: '1.' counter(counter-index-2) '.' counter(counter-index-3) ' ' }
                .print-site-enumerate-headings #index h3 {  counter-increment: counter-index-3 }
            
.print-site-enumerate-headings #architecture > h1:before { content: '2 ' }

                .print-site-enumerate-headings #architecture h2:before { content: '2.' counter(counter-architecture-2) ' ' }
                .print-site-enumerate-headings #architecture h2 {  counter-reset: counter-architecture-3 ;  counter-increment: counter-architecture-2 }
            
                .print-site-enumerate-headings #architecture h3:before { content: '2.' counter(counter-architecture-2) '.' counter(counter-architecture-3) ' ' }
                .print-site-enumerate-headings #architecture h3 {  counter-increment: counter-architecture-3 }
            
.print-site-enumerate-headings #section-3 > h1:before { content: '3 ' }
.print-site-enumerate-headings #base_entity > h1:before { content: '3.1 ' }

                .print-site-enumerate-headings #base_entity h2:before { content: '3.1.' counter(counter-base_entity-2) ' ' }
                .print-site-enumerate-headings #base_entity h2 {  counter-increment: counter-base_entity-2 }
            
.print-site-enumerate-headings #path_constraints > h1:before { content: '3.2 ' }

                .print-site-enumerate-headings #path_constraints h2:before { content: '3.2.' counter(counter-path_constraints-2) ' ' }
                .print-site-enumerate-headings #path_constraints h2 {  counter-increment: counter-path_constraints-2 }
            
.print-site-enumerate-headings #property_graph_model > h1:before { content: '3.3 ' }

                .print-site-enumerate-headings #property_graph_model h2:before { content: '3.3.' counter(counter-property_graph_model-2) ' ' }
                .print-site-enumerate-headings #property_graph_model h2 {  counter-increment: counter-property_graph_model-2 }
            
.print-site-enumerate-headings #section-4 > h1:before { content: '4 ' }
.print-site-enumerate-headings #storage-geo_relational_schema > h1:before { content: '4.1 ' }

                .print-site-enumerate-headings #storage-geo_relational_schema h2:before { content: '4.1.' counter(counter-storage-geo_relational_schema-2) ' ' }
                .print-site-enumerate-headings #storage-geo_relational_schema h2 {  counter-increment: counter-storage-geo_relational_schema-2 }
            
.print-site-enumerate-headings #storage-rocksdb_layout > h1:before { content: '4.2 ' }

                .print-site-enumerate-headings #storage-rocksdb_layout h2:before { content: '4.2.' counter(counter-storage-rocksdb_layout-2) ' ' }
                .print-site-enumerate-headings #storage-rocksdb_layout h2 {  counter-increment: counter-storage-rocksdb_layout-2 }
            
.print-site-enumerate-headings #mvcc_design > h1:before { content: '4.3 ' }

                .print-site-enumerate-headings #mvcc_design h2:before { content: '4.3.' counter(counter-mvcc_design-2) ' ' }
                .print-site-enumerate-headings #mvcc_design h2 {  counter-increment: counter-mvcc_design-2 }
            
.print-site-enumerate-headings #transactions > h1:before { content: '4.4 ' }

                .print-site-enumerate-headings #transactions h2:before { content: '4.4.' counter(counter-transactions-2) ' ' }
                .print-site-enumerate-headings #transactions h2 {  counter-increment: counter-transactions-2 }
            
.print-site-enumerate-headings #time_series > h1:before { content: '4.5 ' }

                .print-site-enumerate-headings #time_series h2:before { content: '4.5.' counter(counter-time_series-2) ' ' }
                .print-site-enumerate-headings #time_series h2 {  counter-increment: counter-time_series-2 }
            
.print-site-enumerate-headings #memory_tuning > h1:before { content: '4.6 ' }

                .print-site-enumerate-headings #memory_tuning h2:before { content: '4.6.' counter(counter-memory_tuning-2) ' ' }
                .print-site-enumerate-headings #memory_tuning h2 {  counter-increment: counter-memory_tuning-2 }
            
.print-site-enumerate-headings #section-5 > h1:before { content: '5 ' }
.print-site-enumerate-headings #indexes > h1:before { content: '5.1 ' }

                .print-site-enumerate-headings #indexes h2:before { content: '5.1.' counter(counter-indexes-2) ' ' }
                .print-site-enumerate-headings #indexes h2 {  counter-increment: counter-indexes-2 }
            
.print-site-enumerate-headings #index_stats_maintenance > h1:before { content: '5.2 ' }

                .print-site-enumerate-headings #index_stats_maintenance h2:before { content: '5.2.' counter(counter-index_stats_maintenance-2) ' ' }
                .print-site-enumerate-headings #index_stats_maintenance h2 {  counter-increment: counter-index_stats_maintenance-2 }
            
.print-site-enumerate-headings #cursor_pagination > h1:before { content: '5.3 ' }

                .print-site-enumerate-headings #cursor_pagination h2:before { content: '5.3.' counter(counter-cursor_pagination-2) ' ' }
                .print-site-enumerate-headings #cursor_pagination h2 {  counter-increment: counter-cursor_pagination-2 }
            
.print-site-enumerate-headings #section-6 > h1:before { content: '6 ' }
.print-site-enumerate-headings #query_engine_aql > h1:before { content: '6.1 ' }

                .print-site-enumerate-headings #query_engine_aql h2:before { content: '6.1.' counter(counter-query_engine_aql-2) ' ' }
                .print-site-enumerate-headings #query_engine_aql h2 {  counter-increment: counter-query_engine_aql-2 }
            
.print-site-enumerate-headings #aql_syntax > h1:before { content: '6.2 ' }

                .print-site-enumerate-headings #aql_syntax h2:before { content: '6.2.' counter(counter-aql_syntax-2) ' ' }
                .print-site-enumerate-headings #aql_syntax h2 {  counter-increment: counter-aql_syntax-2 }
            
.print-site-enumerate-headings #aql_explain_profile > h1:before { content: '6.3 ' }

                .print-site-enumerate-headings #aql_explain_profile h2:before { content: '6.3.' counter(counter-aql_explain_profile-2) ' ' }
                .print-site-enumerate-headings #aql_explain_profile h2 {  counter-increment: counter-aql_explain_profile-2 }
            
.print-site-enumerate-headings #recursive_path_queries > h1:before { content: '6.4 ' }

                .print-site-enumerate-headings #recursive_path_queries h2:before { content: '6.4.' counter(counter-recursive_path_queries-2) ' ' }
                .print-site-enumerate-headings #recursive_path_queries h2 {  counter-increment: counter-recursive_path_queries-2 }
            
.print-site-enumerate-headings #temporal_graphs > h1:before { content: '6.5 ' }

                .print-site-enumerate-headings #temporal_graphs h2:before { content: '6.5.' counter(counter-temporal_graphs-2) ' ' }
                .print-site-enumerate-headings #temporal_graphs h2 {  counter-increment: counter-temporal_graphs-2 }
            
.print-site-enumerate-headings #temporal_time_range_queries > h1:before { content: '6.6 ' }

                .print-site-enumerate-headings #temporal_time_range_queries h2:before { content: '6.6.' counter(counter-temporal_time_range_queries-2) ' ' }
                .print-site-enumerate-headings #temporal_time_range_queries h2 {  counter-increment: counter-temporal_time_range_queries-2 }
            
.print-site-enumerate-headings #semantic_cache > h1:before { content: '6.7 ' }

                .print-site-enumerate-headings #semantic_cache h2:before { content: '6.7.' counter(counter-semantic_cache-2) ' ' }
                .print-site-enumerate-headings #semantic_cache h2 {  counter-increment: counter-semantic_cache-2 }
            
.print-site-enumerate-headings #section-7 > h1:before { content: '7 ' }
.print-site-enumerate-headings #content_pipeline > h1:before { content: '7.1 ' }

                .print-site-enumerate-headings #content_pipeline h2:before { content: '7.1.' counter(counter-content_pipeline-2) ' ' }
                .print-site-enumerate-headings #content_pipeline h2 {  counter-increment: counter-content_pipeline-2 }
            
.print-site-enumerate-headings #content_architecture > h1:before { content: '7.2 ' }

                .print-site-enumerate-headings #content_architecture h2:before { content: '7.2.' counter(counter-content_architecture-2) ' ' }
                .print-site-enumerate-headings #content_architecture h2 {  counter-increment: counter-content_architecture-2 }
            
.print-site-enumerate-headings #content-ingestion > h1:before { content: '7.3 ' }

                .print-site-enumerate-headings #content-ingestion h2:before { content: '7.3.' counter(counter-content-ingestion-2) ' ' }
                .print-site-enumerate-headings #content-ingestion h2 {  counter-increment: counter-content-ingestion-2 }
            
.print-site-enumerate-headings #ingestion-json_ingestion_spec > h1:before { content: '7.4 ' }

                .print-site-enumerate-headings #ingestion-json_ingestion_spec h2:before { content: '7.4.' counter(counter-ingestion-json_ingestion_spec-2) ' ' }
                .print-site-enumerate-headings #ingestion-json_ingestion_spec h2 {  counter-increment: counter-ingestion-json_ingestion_spec-2 }
            
.print-site-enumerate-headings #content-geo_processor_design > h1:before { content: '7.5 ' }

                .print-site-enumerate-headings #content-geo_processor_design h2:before { content: '7.5.' counter(counter-content-geo_processor_design-2) ' ' }
                .print-site-enumerate-headings #content-geo_processor_design h2 {  counter-increment: counter-content-geo_processor_design-2 }
            
.print-site-enumerate-headings #content-image_processor_design > h1:before { content: '7.6 ' }

                .print-site-enumerate-headings #content-image_processor_design h2:before { content: '7.6.' counter(counter-content-image_processor_design-2) ' ' }
                .print-site-enumerate-headings #content-image_processor_design h2 {  counter-increment: counter-content-image_processor_design-2 }
            
.print-site-enumerate-headings #section-8 > h1:before { content: '8 ' }
.print-site-enumerate-headings #search-hybrid_search_design > h1:before { content: '8.1 ' }

                .print-site-enumerate-headings #search-hybrid_search_design h2:before { content: '8.1.' counter(counter-search-hybrid_search_design-2) ' ' }
                .print-site-enumerate-headings #search-hybrid_search_design h2 {  counter-increment: counter-search-hybrid_search_design-2 }
            
.print-site-enumerate-headings #search-pagination_benchmarks > h1:before { content: '8.2 ' }

                .print-site-enumerate-headings #search-pagination_benchmarks h2:before { content: '8.2.' counter(counter-search-pagination_benchmarks-2) ' ' }
                .print-site-enumerate-headings #search-pagination_benchmarks h2 {  counter-increment: counter-search-pagination_benchmarks-2 }
            
.print-site-enumerate-headings #section-9 > h1:before { content: '9 ' }
.print-site-enumerate-headings #performance_benchmarks > h1:before { content: '9.1 ' }

                .print-site-enumerate-headings #performance_benchmarks h2:before { content: '9.1.' counter(counter-performance_benchmarks-2) ' ' }
                .print-site-enumerate-headings #performance_benchmarks h2 {  counter-increment: counter-performance_benchmarks-2 }
            
.print-site-enumerate-headings #compression_benchmarks > h1:before { content: '9.2 ' }

                .print-site-enumerate-headings #compression_benchmarks h2:before { content: '9.2.' counter(counter-compression_benchmarks-2) ' ' }
                .print-site-enumerate-headings #compression_benchmarks h2 {  counter-increment: counter-compression_benchmarks-2 }
            
.print-site-enumerate-headings #search-pagination_benchmarks > h1:before { content: '9.3 ' }

                .print-site-enumerate-headings #search-pagination_benchmarks h2:before { content: '9.3.' counter(counter-search-pagination_benchmarks-2) ' ' }
                .print-site-enumerate-headings #search-pagination_benchmarks h2 {  counter-increment: counter-search-pagination_benchmarks-2 }
            
.print-site-enumerate-headings #quality_assurance > h1:before { content: '10 ' }

                .print-site-enumerate-headings #quality_assurance h2:before { content: '10.' counter(counter-quality_assurance-2) ' ' }
                .print-site-enumerate-headings #quality_assurance h2 {  counter-reset: counter-quality_assurance-3 ;  counter-increment: counter-quality_assurance-2 }
            
                .print-site-enumerate-headings #quality_assurance h3:before { content: '10.' counter(counter-quality_assurance-2) '.' counter(counter-quality_assurance-3) ' ' }
                .print-site-enumerate-headings #quality_assurance h3 {  counter-increment: counter-quality_assurance-3 }
            
.print-site-enumerate-headings #section-11 > h1:before { content: '11 ' }
.print-site-enumerate-headings #vector_ops > h1:before { content: '11.1 ' }

                .print-site-enumerate-headings #vector_ops h2:before { content: '11.1.' counter(counter-vector_ops-2) ' ' }
                .print-site-enumerate-headings #vector_ops h2 {  counter-increment: counter-vector_ops-2 }
            
.print-site-enumerate-headings #gnn_embeddings > h1:before { content: '11.2 ' }

                .print-site-enumerate-headings #gnn_embeddings h2:before { content: '11.2.' counter(counter-gnn_embeddings-2) ' ' }
                .print-site-enumerate-headings #gnn_embeddings h2 {  counter-increment: counter-gnn_embeddings-2 }
            
.print-site-enumerate-headings #hnsw_persistence > h1:before { content: '11.3 ' }

                .print-site-enumerate-headings #hnsw_persistence h2:before { content: '11.3.' counter(counter-hnsw_persistence-2) ' ' }
                .print-site-enumerate-headings #hnsw_persistence h2 {  counter-increment: counter-hnsw_persistence-2 }
            
.print-site-enumerate-headings #section-12 > h1:before { content: '12 ' }
.print-site-enumerate-headings #security-overview > h1:before { content: '12.1 ' }

                .print-site-enumerate-headings #security-overview h2:before { content: '12.1.' counter(counter-security-overview-2) ' ' }
                .print-site-enumerate-headings #security-overview h2 {  counter-increment: counter-security-overview-2 }
            
.print-site-enumerate-headings #rbac_authorization > h1:before { content: '12.2 ' }

                .print-site-enumerate-headings #rbac_authorization h2:before { content: '12.2.' counter(counter-rbac_authorization-2) ' ' }
                .print-site-enumerate-headings #rbac_authorization h2 {  counter-increment: counter-rbac_authorization-2 }
            
.print-site-enumerate-headings #security-key_management > h1:before { content: '12.3 ' }

                .print-site-enumerate-headings #security-key_management h2:before { content: '12.3.' counter(counter-security-key_management-2) ' ' }
                .print-site-enumerate-headings #security-key_management h2 {  counter-increment: counter-security-key_management-2 }
            
.print-site-enumerate-headings #encryption_strategy > h1:before { content: '12.4 ' }

                .print-site-enumerate-headings #encryption_strategy h2:before { content: '12.4.' counter(counter-encryption_strategy-2) ' ' }
                .print-site-enumerate-headings #encryption_strategy h2 {  counter-increment: counter-encryption_strategy-2 }
            
.print-site-enumerate-headings #encryption_deployment > h1:before { content: '12.5 ' }

                .print-site-enumerate-headings #encryption_deployment h2:before { content: '12.5.' counter(counter-encryption_deployment-2) ' ' }
                .print-site-enumerate-headings #encryption_deployment h2 {  counter-increment: counter-encryption_deployment-2 }
            
.print-site-enumerate-headings #column_encryption > h1:before { content: '12.6 ' }

                .print-site-enumerate-headings #column_encryption h2:before { content: '12.6.' counter(counter-column_encryption-2) ' ' }
                .print-site-enumerate-headings #column_encryption h2 {  counter-increment: counter-column_encryption-2 }
            
.print-site-enumerate-headings #security-pii_detection > h1:before { content: '12.7 ' }

                .print-site-enumerate-headings #security-pii_detection h2:before { content: '12.7.' counter(counter-security-pii_detection-2) ' ' }
                .print-site-enumerate-headings #security-pii_detection h2 {  counter-increment: counter-security-pii_detection-2 }
            
.print-site-enumerate-headings #pii_detection_engines > h1:before { content: '12.8 ' }

                .print-site-enumerate-headings #pii_detection_engines h2:before { content: '12.8.' counter(counter-pii_detection_engines-2) ' ' }
                .print-site-enumerate-headings #pii_detection_engines h2 {  counter-increment: counter-pii_detection_engines-2 }
            
.print-site-enumerate-headings #pii_engine_signing > h1:before { content: '12.9 ' }

                .print-site-enumerate-headings #pii_engine_signing h2:before { content: '12.9.' counter(counter-pii_engine_signing-2) ' ' }
                .print-site-enumerate-headings #pii_engine_signing h2 {  counter-increment: counter-pii_engine_signing-2 }
            
.print-site-enumerate-headings #security-audit_and_retention > h1:before { content: '12.10 ' }

                .print-site-enumerate-headings #security-audit_and_retention h2:before { content: '12.10.' counter(counter-security-audit_and_retention-2) ' ' }
                .print-site-enumerate-headings #security-audit_and_retention h2 {  counter-increment: counter-security-audit_and_retention-2 }
            
.print-site-enumerate-headings #security-threat_model > h1:before { content: '12.11 ' }

                .print-site-enumerate-headings #security-threat_model h2:before { content: '12.11.' counter(counter-security-threat_model-2) ' ' }
                .print-site-enumerate-headings #security-threat_model h2 {  counter-increment: counter-security-threat_model-2 }
            
.print-site-enumerate-headings #security_hardening_guide > h1:before { content: '12.12 ' }

                .print-site-enumerate-headings #security_hardening_guide h2:before { content: '12.12.' counter(counter-security_hardening_guide-2) ' ' }
                .print-site-enumerate-headings #security_hardening_guide h2 {  counter-increment: counter-security_hardening_guide-2 }
            
.print-site-enumerate-headings #security_audit_checklist > h1:before { content: '12.13 ' }

                .print-site-enumerate-headings #security_audit_checklist h2:before { content: '12.13.' counter(counter-security_audit_checklist-2) ' ' }
                .print-site-enumerate-headings #security_audit_checklist h2 {  counter-increment: counter-security_audit_checklist-2 }
            
.print-site-enumerate-headings #compliance_audit > h1:before { content: '12.14 ' }

                .print-site-enumerate-headings #compliance_audit h2:before { content: '12.14.' counter(counter-compliance_audit-2) ' ' }
                .print-site-enumerate-headings #compliance_audit h2 {  counter-increment: counter-compliance_audit-2 }
            
.print-site-enumerate-headings #compliance_governance_strategy > h1:before { content: '12.15 ' }

                .print-site-enumerate-headings #compliance_governance_strategy h2:before { content: '12.15.' counter(counter-compliance_governance_strategy-2) ' ' }
                .print-site-enumerate-headings #compliance_governance_strategy h2 {  counter-increment: counter-compliance_governance_strategy-2 }
            
.print-site-enumerate-headings #compliance_integration > h1:before { content: '12.16 ' }

                .print-site-enumerate-headings #compliance_integration h2:before { content: '12.16.' counter(counter-compliance_integration-2) ' ' }
                .print-site-enumerate-headings #compliance_integration h2 {  counter-increment: counter-compliance_integration-2 }
            
.print-site-enumerate-headings #governance_usage > h1:before { content: '12.17 ' }

                .print-site-enumerate-headings #governance_usage h2:before { content: '12.17.' counter(counter-governance_usage-2) ' ' }
                .print-site-enumerate-headings #governance_usage h2 {  counter-increment: counter-governance_usage-2 }
            
.print-site-enumerate-headings #security-security_compliance_review > h1:before { content: '12.18 ' }

                .print-site-enumerate-headings #security-security_compliance_review h2:before { content: '12.18.' counter(counter-security-security_compliance_review-2) ' ' }
                .print-site-enumerate-headings #security-security_compliance_review h2 {  counter-increment: counter-security-security_compliance_review-2 }
            
.print-site-enumerate-headings #section-13 > h1:before { content: '13 ' }
.print-site-enumerate-headings #deployment > h1:before { content: '13.1 ' }

                .print-site-enumerate-headings #deployment h2:before { content: '13.1.' counter(counter-deployment-2) ' ' }
                .print-site-enumerate-headings #deployment h2 {  counter-increment: counter-deployment-2 }
            
.print-site-enumerate-headings #tracing > h1:before { content: '13.2 ' }

                .print-site-enumerate-headings #tracing h2:before { content: '13.2.' counter(counter-tracing-2) ' ' }
                .print-site-enumerate-headings #tracing h2 {  counter-increment: counter-tracing-2 }
            
.print-site-enumerate-headings #change_data_capture > h1:before { content: '13.3 ' }

                .print-site-enumerate-headings #change_data_capture h2:before { content: '13.3.' counter(counter-change_data_capture-2) ' ' }
                .print-site-enumerate-headings #change_data_capture h2 {  counter-increment: counter-change_data_capture-2 }
            
.print-site-enumerate-headings #operations_runbook > h1:before { content: '13.4 ' }

                .print-site-enumerate-headings #operations_runbook h2:before { content: '13.4.' counter(counter-operations_runbook-2) ' ' }
                .print-site-enumerate-headings #operations_runbook h2 {  counter-increment: counter-operations_runbook-2 }
            
.print-site-enumerate-headings #publishing > h1:before { content: '14 ' }

                .print-site-enumerate-headings #publishing h2:before { content: '14.' counter(counter-publishing-2) ' ' }
                .print-site-enumerate-headings #publishing h2 {  counter-reset: counter-publishing-3 ;  counter-increment: counter-publishing-2 }
            
                .print-site-enumerate-headings #publishing h3:before { content: '14.' counter(counter-publishing-2) '.' counter(counter-publishing-3) ' ' }
                .print-site-enumerate-headings #publishing h3 {  counter-increment: counter-publishing-3 }
            
.print-site-enumerate-headings #section-15 > h1:before { content: '15 ' }
.print-site-enumerate-headings #admin_tools_admin_guide > h1:before { content: '15.1 ' }

                .print-site-enumerate-headings #admin_tools_admin_guide h2:before { content: '15.1.' counter(counter-admin_tools_admin_guide-2) ' ' }
                .print-site-enumerate-headings #admin_tools_admin_guide h2 {  counter-increment: counter-admin_tools_admin_guide-2 }
            
.print-site-enumerate-headings #admin_tools_user_guide > h1:before { content: '15.2 ' }

                .print-site-enumerate-headings #admin_tools_user_guide h2:before { content: '15.2.' counter(counter-admin_tools_user_guide-2) ' ' }
                .print-site-enumerate-headings #admin_tools_user_guide h2 {  counter-increment: counter-admin_tools_user_guide-2 }
            
.print-site-enumerate-headings #admin_tools_feature_matrix > h1:before { content: '15.3 ' }

                .print-site-enumerate-headings #admin_tools_feature_matrix h2:before { content: '15.3.' counter(counter-admin_tools_feature_matrix-2) ' ' }
                .print-site-enumerate-headings #admin_tools_feature_matrix h2 {  counter-increment: counter-admin_tools_feature_matrix-2 }
            
.print-site-enumerate-headings #admin_tools_search_sort_filter > h1:before { content: '15.4 ' }

                .print-site-enumerate-headings #admin_tools_search_sort_filter h2:before { content: '15.4.' counter(counter-admin_tools_search_sort_filter-2) ' ' }
                .print-site-enumerate-headings #admin_tools_search_sort_filter h2 {  counter-increment: counter-admin_tools_search_sort_filter-2 }
            
.print-site-enumerate-headings #admin_tools_demo_script > h1:before { content: '15.5 ' }

                .print-site-enumerate-headings #admin_tools_demo_script h2:before { content: '15.5.' counter(counter-admin_tools_demo_script-2) ' ' }
                .print-site-enumerate-headings #admin_tools_demo_script h2 {  counter-increment: counter-admin_tools_demo_script-2 }
            
.print-site-enumerate-headings #section-16 > h1:before { content: '16 ' }
.print-site-enumerate-headings #apis-openapi > h1:before { content: '16.1 ' }

                .print-site-enumerate-headings #apis-openapi h2:before { content: '16.1.' counter(counter-apis-openapi-2) ' ' }
                .print-site-enumerate-headings #apis-openapi h2 {  counter-increment: counter-apis-openapi-2 }
            
.print-site-enumerate-headings #section-17 > h1:before { content: '17 ' }
.print-site-enumerate-headings #styleguide > h1:before { content: '17.1 ' }

                .print-site-enumerate-headings #styleguide h2:before { content: '17.1.' counter(counter-styleguide-2) ' ' }
                .print-site-enumerate-headings #styleguide h2 {  counter-increment: counter-styleguide-2 }
            
.print-site-enumerate-headings #glossary > h1:before { content: '17.2 ' }

                .print-site-enumerate-headings #glossary h2:before { content: '17.2.' counter(counter-glossary-2) ' ' }
                .print-site-enumerate-headings #glossary h2 {  counter-increment: counter-glossary-2 }
            
.print-site-enumerate-headings #roadmap > h1:before { content: '18 ' }

                .print-site-enumerate-headings #roadmap h2:before { content: '18.' counter(counter-roadmap-2) ' ' }
                .print-site-enumerate-headings #roadmap h2 {  counter-reset: counter-roadmap-3 ;  counter-increment: counter-roadmap-2 }
            
                .print-site-enumerate-headings #roadmap h3:before { content: '18.' counter(counter-roadmap-2) '.' counter(counter-roadmap-3) ' ' }
                .print-site-enumerate-headings #roadmap h3 {  counter-increment: counter-roadmap-3 }
            
.print-site-enumerate-headings #changelog > h1:before { content: '19 ' }

                .print-site-enumerate-headings #changelog h2:before { content: '19.' counter(counter-changelog-2) ' ' }
                .print-site-enumerate-headings #changelog h2 {  counter-reset: counter-changelog-3 ;  counter-increment: counter-changelog-2 }
            
                .print-site-enumerate-headings #changelog h3:before { content: '19.' counter(counter-changelog-2) '.' counter(counter-changelog-3) ' ' }
                .print-site-enumerate-headings #changelog h3 {  counter-increment: counter-changelog-3 }
            </style>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "/themisdb/docs/", "features": ["navigation.tabs", "navigation.instant", "content.code.copy"], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "In Zwischenablage kopiert", "clipboard.copy": "In Zwischenablage kopieren", "search.result.more.one": "1 weiteres Suchergebnis auf dieser Seite", "search.result.more.other": "# weitere Suchergebnisse auf dieser Seite", "search.result.none": "Keine Suchergebnisse", "search.result.one": "1 Suchergebnis", "search.result.other": "# Suchergebnisse", "search.result.placeholder": "Suchbegriff eingeben", "search.result.term.missing": "Es fehlt", "select.version": "Version ausw\u00e4hlen"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../js/print-site.js"></script>
      
    
  </body>
</html>