#include "query/aql_translator.h"
#include "query/subquery_optimizer.h"
#include <sstream>
#include <variant>

// Import query types - must be outside namespace themis
using themis::query::BinaryOpExpr;
using themis::query::FieldAccessExpr;
using themis::query::LiteralExpr;
using themis::query::ASTNodeType;
using themis::query::FunctionCallExpr;
using themis::query::BinaryOperator;
using themis::query::UnaryOperator;
using themis::query::UnaryOpExpr;
using themis::query::VariableExpr;
using themis::query::SimilarityCallExpr;
using themis::query::ProximityCallExpr;
using themis::query::ArrayLiteralExpr;
using themis::query::Expression;
using themis::query::LiteralValue;
using themis::query::Query;

namespace themis {

AQLTranslator::TranslationResult AQLTranslator::translate(const std::shared_ptr<Query>& ast) {
    if (!ast) {
        return TranslationResult::Error("Null AST provided");
    }
    
    // Phase 4.1: WITH clause processing
    // Analyze CTEs and prepare execution metadata before translating main query
    std::vector<TranslationResult::CTEExecution> cte_executions;
    if (ast->with_clause) {
        query::SubqueryOptimizer optimizer;
        
        for (const auto& cte_def : ast->with_clause->ctes) {
            if (!cte_def.subquery) {
                return TranslationResult::Error("CTE '" + cte_def.name + "' has null query");
            }
            
            // Determine materialization strategy using optimizer heuristics
            // Count references in main query to decide if materialization is beneficial
            size_t ref_count = countCTEReferences(ast, cte_def.name);
            bool should_materialize = optimizer.shouldMaterializeCTE(cte_def, ref_count);
            
            TranslationResult::CTEExecution cte_exec;
            cte_exec.name = cte_def.name;
            cte_exec.subquery = cte_def.subquery;
            cte_exec.should_materialize = should_materialize;
            
            cte_executions.push_back(std::move(cte_exec));
        }
    }
    
    // Graph-Traversal Unterstützung: Wenn Traversal-Klausel vorhanden ist,
    // übersetzen wir in eine TraversalQuery und umgehen die relationale Pfadlogik.
    if (ast->traversal) {
        TranslationResult::TraversalQuery tq;
        tq.variable = ast->traversal->varVertex;
        tq.minDepth = ast->traversal->minDepth;
        tq.maxDepth = ast->traversal->maxDepth;
        // Mappe Richtung
        switch (ast->traversal->direction) {
            case Query::TraversalNode::Direction::Outbound: tq.direction = TranslationResult::TraversalQuery::Direction::Outbound; break;
            case Query::TraversalNode::Direction::Inbound:  tq.direction = TranslationResult::TraversalQuery::Direction::Inbound;  break;
            case Query::TraversalNode::Direction::Any:      tq.direction = TranslationResult::TraversalQuery::Direction::Any;      break;
        }
        tq.startVertex = ast->traversal->startVertex;
        tq.graphName = ast->traversal->graphName;
        if (ast->traversal->shortestPath) {
            tq.shortestPath = true;
            tq.endVertex = ast->traversal->shortestPathTarget;
        }
        auto tr_result = TranslationResult::SuccessTraversal(std::move(tq));
        attachCTEs(tr_result, std::move(cte_executions));
        return tr_result;
    }
    
    // Multi-FOR Join: Wenn mehr als eine FOR-Klausel vorhanden ist, als Join behandeln
    if (ast->for_nodes.size() > 1 || !ast->let_nodes.empty() || ast->collect) {
        // Sonderfall: Single LET mit Similarity/Proximity für Hybrid-Erkennung
        if (ast->for_nodes.size()==1 && ast->let_nodes.size()==1 && !ast->collect && ast->sort && ast->sort->specifications.size()==1) {
            auto letNode = ast->let_nodes[0];
            auto sortExpr = ast->sort->specifications[0].expression;
            // Variable in SORT?
            if (sortExpr->getType()==ASTNodeType::Variable) {
                auto varName = std::static_pointer_cast<VariableExpr>(sortExpr)->name;
                if (varName == letNode.variable) {
                    // Prüfe ob LET Ausdruck SimilarityCall/ProximityCall ist
                    if (letNode.expression->getType()==ASTNodeType::SimilarityCall) {
                        auto sim = std::static_pointer_cast<SimilarityCallExpr>(letNode.expression);
                        if (sim->arguments.size()>=2) {
                            // Reuse existing Similarity translation path
                            std::vector<std::shared_ptr<Expression>> fakeArgs = sim->arguments; // [field, vector, optional k]
                            // Erzeuge temporäre SortNode ohne LET für reguläre Pfadlogik -> dupliziere Code minimal
                            // Direkt übersetzen ähnlich wie oben (Refactoring vermeiden hier)
                            if (sim->arguments[0]->getType()!=ASTNodeType::FieldAccess) return TranslationResult::Error("SIMILARITY() LET first arg must be field access");
                            std::string vectorField = extractColumnName(sim->arguments[0]);
                            if (sim->arguments[1]->getType()!=ASTNodeType::ArrayLiteral) return TranslationResult::Error("SIMILARITY() LET second arg must be array literal");
                            auto arr = std::static_pointer_cast<ArrayLiteralExpr>(sim->arguments[1]);
                            std::vector<float> queryVec; queryVec.reserve(arr->elements.size());
                            for (auto &el : arr->elements) { if (el->getType()!=ASTNodeType::Literal) return TranslationResult::Error("SIMILARITY() vector elements must be literals"); auto lit=std::static_pointer_cast<LiteralExpr>(el); if (std::holds_alternative<int64_t>(lit->value)) queryVec.push_back((float)std::get<int64_t>(lit->value)); else if (std::holds_alternative<double>(lit->value)) queryVec.push_back((float)std::get<double>(lit->value)); else return TranslationResult::Error("SIMILARITY() vector must be numeric"); }
                            size_t k = 10; if (sim->arguments.size()==3) { auto kLit=std::static_pointer_cast<LiteralExpr>(sim->arguments[2]); if (!std::holds_alternative<int64_t>(kLit->value)) return TranslationResult::Error("SIMILARITY() k must be int"); k=(size_t)std::get<int64_t>(kLit->value); } else if (ast->limit) { k=(size_t)std::max<int64_t>(0, ast->limit->count); }
                            std::shared_ptr<Expression> spatialExpr; std::vector<std::shared_ptr<Expression>> extraPreds; for (auto &f: ast->filters){ if (!f||!f->condition) continue; auto cond=f->condition; if(!spatialExpr && cond->getType()==ASTNodeType::FunctionCall){ auto fc=std::static_pointer_cast<FunctionCallExpr>(cond); std::string nm=fc->name; std::transform(nm.begin(),nm.end(),nm.begin(),::tolower); if(nm.rfind("st_",0)==0){ spatialExpr=cond; continue; } } extraPreds.push_back(cond);} VectorGeoQuery vq; vq.table=ast->for_node.collection; vq.vector_field=vectorField; vq.query_vector=std::move(queryVec); vq.k=k; vq.spatial_filter=spatialExpr; vq.extra_filters=std::move(extraPreds); auto vg_result = TranslationResult::SuccessVectorGeo(std::move(vq)); attachCTEs(vg_result, std::move(cte_executions)); return vg_result;
                        }
                    }
                    if (letNode.expression->getType()==ASTNodeType::ProximityCall) {
                        auto prox = std::static_pointer_cast<ProximityCallExpr>(letNode.expression);
                        if (prox->arguments.size()==2) {
                            if (prox->arguments[0]->getType()!=ASTNodeType::FieldAccess) return TranslationResult::Error("PROXIMITY() LET first arg must be field access");
                            std::string geomField = extractColumnName(prox->arguments[0]);
                            if (prox->arguments[1]->getType()!=ASTNodeType::ArrayLiteral) return TranslationResult::Error("PROXIMITY() LET second arg must array literal");
                            auto arr=std::static_pointer_cast<ArrayLiteralExpr>(prox->arguments[1]); if (arr->elements.size()<2) return TranslationResult::Error("PROXIMITY() point needs 2 elements");
                            std::vector<float> point; for(size_t i=0;i<2;i++){ auto el=arr->elements[i]; if(el->getType()!=ASTNodeType::Literal) return TranslationResult::Error("PROXIMITY() point elements must literal"); auto lit=std::static_pointer_cast<LiteralExpr>(el); if(std::holds_alternative<int64_t>(lit->value)) point.push_back((float)std::get<int64_t>(lit->value)); else if(std::holds_alternative<double>(lit->value)) point.push_back((float)std::get<double>(lit->value)); else return TranslationResult::Error("PROXIMITY() numeric only"); }
                            std::shared_ptr<Expression> spatialExpr; std::string fulltextQuery; std::string fulltextField; size_t fulltextLimit=1000; for (auto &f: ast->filters){ if(!f||!f->condition) continue; auto cond=f->condition; if(cond->getType()==ASTNodeType::FunctionCall){ auto fc=std::static_pointer_cast<FunctionCallExpr>(cond); std::string nm=fc->name; std::transform(nm.begin(),nm.end(),nm.begin(),::tolower); if(nm.rfind("st_",0)==0 && !spatialExpr){ spatialExpr=cond; continue;} if(nm=="fulltext" && fulltextQuery.empty()){ if(fc->arguments.size()<2||fc->arguments.size()>3) return TranslationResult::Error("FULLTEXT() requires 2-3 args"); if(fc->arguments[0]->getType()!=ASTNodeType::FieldAccess) return TranslationResult::Error("FULLTEXT() first arg field access"); fulltextField=extractColumnName(fc->arguments[0]); if(fc->arguments[1]->getType()!=ASTNodeType::Literal) return TranslationResult::Error("FULLTEXT() second arg string literal"); auto litq=std::static_pointer_cast<LiteralExpr>(fc->arguments[1]); if(!std::holds_alternative<std::string>(litq->value)) return TranslationResult::Error("FULLTEXT() query must string"); fulltextQuery=std::get<std::string>(litq->value); if(fc->arguments.size()==3){ auto limLit=std::static_pointer_cast<LiteralExpr>(fc->arguments[2]); if(std::holds_alternative<int64_t>(limLit->value)) fulltextLimit=(size_t)std::get<int64_t>(limLit->value); } continue; } } }
                            if (fulltextQuery.empty()) return TranslationResult::Error("PROXIMITY LET requires FULLTEXT filter");
                            ContentGeoQuery cq; cq.table=ast->for_node.collection; cq.geom_field=geomField; cq.spatial_filter=spatialExpr; cq.boost_by_distance=true; cq.center_point=std::vector<float>{point[0], point[1]}; cq.limit=ast->limit? (size_t)std::max<int64_t>(0, ast->limit->count) : 100; cq.text_field=fulltextField; cq.fulltext_query=fulltextQuery; cq.limit=std::min(cq.limit, fulltextLimit); auto cg_result1 = TranslationResult::SuccessContentGeo(std::move(cq)); attachCTEs(cg_result1, std::move(cte_executions)); return cg_result1;
                        }
                    }
                }
            }
        }
        TranslationResult::JoinQuery jq;
        jq.for_nodes = ast->for_nodes;
        jq.filters = ast->filters;
        jq.let_nodes = ast->let_nodes;
        jq.return_node = ast->return_node;
        jq.sort = ast->sort;
        jq.limit = ast->limit;
        jq.collect = ast->collect;
        auto result = TranslationResult::SuccessJoin(std::move(jq));
        attachCTEs(result, std::move(cte_executions));
        return result;
    }

    // ---------------------------------------------------------------------
    // Hybrid Vector+Geo Query Erkennung (Phase 2 Syntax Sugar)
    // Muster: SORT SIMILARITY(doc.embedding, [..vector..] [, k]) DESC/ASC
    // Optional: FILTER mit ST_* Funktion (z.B. ST_WITHIN(doc.location, ...))
    // LIMIT kann k überschreiben, falls drittes Argument nicht gesetzt ist.
    // Aktuell: Zusätzliche Nicht-Spatial FILTER werden noch nicht unterstützt.
    // ---------------------------------------------------------------------
    if (ast->sort && ast->sort->specifications.size() == 1 && ast->for_nodes.empty()) {
        const auto& spec = ast->sort->specifications[0];
        if (spec.expression) {
            // Prefer specialized node types first
            if (spec.expression->getType() == ASTNodeType::SimilarityCall) {
                auto sim = std::static_pointer_cast<SimilarityCallExpr>(spec.expression);
                auto &args = sim->arguments;
                if (args.size() < 2 || args.size() > 3) {
                    return TranslationResult::Error("SIMILARITY() requires 2-3 arguments: SIMILARITY(doc.embedding, [vector] [, k])");
                }
                if (args[0]->getType() != ASTNodeType::FieldAccess) {
                    return TranslationResult::Error("SIMILARITY() first argument must be field access (e.g. doc.embedding)");
                }
                std::string vectorField = extractColumnName(args[0]);
                if (args[1]->getType() != ASTNodeType::ArrayLiteral) {
                    return TranslationResult::Error("SIMILARITY() second argument must be an array literal of numbers");
                }
                auto arr = std::static_pointer_cast<ArrayLiteralExpr>(args[1]);
                std::vector<float> queryVec; queryVec.reserve(arr->elements.size());
                for (const auto &el : arr->elements) {
                    if (el->getType() != ASTNodeType::Literal) return TranslationResult::Error("SIMILARITY() vector elements must be numeric literals");
                    auto lit = std::static_pointer_cast<LiteralExpr>(el);
                    if (std::holds_alternative<int64_t>(lit->value)) queryVec.push_back(static_cast<float>(std::get<int64_t>(lit->value)));
                    else if (std::holds_alternative<double>(lit->value)) queryVec.push_back(static_cast<float>(std::get<double>(lit->value)));
                    else return TranslationResult::Error("SIMILARITY() vector elements must be numeric (int or double)");
                }
                size_t k = 10;
                if (args.size() == 3) {
                    if (args[2]->getType() != ASTNodeType::Literal) return TranslationResult::Error("SIMILARITY() third argument k must be integer literal");
                    auto kLit = std::static_pointer_cast<LiteralExpr>(args[2]);
                    if (std::holds_alternative<int64_t>(kLit->value)) k = static_cast<size_t>(std::get<int64_t>(kLit->value)); else return TranslationResult::Error("SIMILARITY() k must be integer literal");
                } else if (ast->limit) {
                    k = static_cast<size_t>(std::max<int64_t>(0, ast->limit->count));
                }
                std::shared_ptr<Expression> spatialExpr; std::vector<std::shared_ptr<Expression>> extraPreds;
                for (const auto &f : ast->filters) {
                    if (!f || !f->condition) continue; auto cond = f->condition;
                    if (!spatialExpr && cond->getType()==ASTNodeType::FunctionCall) {
                        auto fc = std::static_pointer_cast<FunctionCallExpr>(cond); std::string nm = fc->name; std::transform(nm.begin(), nm.end(), nm.begin(), ::tolower); if (nm.rfind("st_",0)==0) { spatialExpr = cond; continue; }
                    }
                    extraPreds.push_back(cond);
                }
                VectorGeoQuery vq; vq.table = ast->for_node.collection; vq.vector_field = vectorField; vq.query_vector = std::move(queryVec); vq.k = k; vq.spatial_filter = spatialExpr; vq.extra_filters = std::move(extraPreds); auto vg_result2 = TranslationResult::SuccessVectorGeo(std::move(vq)); attachCTEs(vg_result2, std::move(cte_executions)); return vg_result2;
            }
            if (spec.expression->getType() == ASTNodeType::ProximityCall) {
                auto prox = std::static_pointer_cast<ProximityCallExpr>(spec.expression);
                auto &args = prox->arguments;
                if (args.size() != 2) return TranslationResult::Error("PROXIMITY() requires exactly 2 arguments: PROXIMITY(doc.location, [lon,lat])");
                if (args[0]->getType()!=ASTNodeType::FieldAccess) return TranslationResult::Error("PROXIMITY() first argument must be field access (e.g. doc.location)");
                std::string geomField = extractColumnName(args[0]);
                if (args[1]->getType()!=ASTNodeType::ArrayLiteral) return TranslationResult::Error("PROXIMITY() second argument must be array literal [lon, lat]");
                auto arr = std::static_pointer_cast<ArrayLiteralExpr>(args[1]); if (arr->elements.size()<2) return TranslationResult::Error("PROXIMITY() point array must have at least 2 numeric elements [lon, lat]");
                std::vector<float> point; for (size_t i=0;i<2;i++){ auto el=arr->elements[i]; if (el->getType()!=ASTNodeType::Literal) return TranslationResult::Error("PROXIMITY() point elements must be numeric literals"); auto lit=std::static_pointer_cast<LiteralExpr>(el); if (std::holds_alternative<int64_t>(lit->value)) point.push_back(static_cast<float>(std::get<int64_t>(lit->value))); else if (std::holds_alternative<double>(lit->value)) point.push_back(static_cast<float>(std::get<double>(lit->value))); else return TranslationResult::Error("PROXIMITY() point elements must be numeric"); }
                std::shared_ptr<Expression> spatialExpr; std::string fulltextQuery; std::string fulltextField; size_t fulltextLimit=1000;
                for (const auto &f : ast->filters) { if (!f || !f->condition) continue; auto cond=f->condition; if (cond->getType()==ASTNodeType::FunctionCall) { auto fc=std::static_pointer_cast<FunctionCallExpr>(cond); std::string nm=fc->name; std::transform(nm.begin(), nm.end(), nm.begin(), ::tolower); if (nm.rfind("st_",0)==0 && !spatialExpr){ spatialExpr=cond; continue;} if (nm=="fulltext" && fulltextQuery.empty()) { if (fc->arguments.size()<2 || fc->arguments.size()>3) return TranslationResult::Error("FULLTEXT() requires 2-3 arguments inside PROXIMITY hybrid"); if (fc->arguments[0]->getType()!=ASTNodeType::FieldAccess) return TranslationResult::Error("FULLTEXT() first argument must be field access"); fulltextField=extractColumnName(fc->arguments[0]); if (fc->arguments[1]->getType()!=ASTNodeType::Literal) return TranslationResult::Error("FULLTEXT() second argument must be literal string"); auto litq=std::static_pointer_cast<LiteralExpr>(fc->arguments[1]); if (!std::holds_alternative<std::string>(litq->value)) return TranslationResult::Error("FULLTEXT() query must be string"); fulltextQuery=std::get<std::string>(litq->value); if (fc->arguments.size()==3){ if (fc->arguments[2]->getType()!=ASTNodeType::Literal) return TranslationResult::Error("FULLTEXT() limit must be integer"); auto lim=std::static_pointer_cast<LiteralExpr>(fc->arguments[2]); if (std::holds_alternative<int64_t>(lim->value)) fulltextLimit=static_cast<size_t>(std::get<int64_t>(lim->value)); } continue; } } }
                ContentGeoQuery cq; cq.table=ast->for_node.collection; cq.geom_field=geomField; cq.spatial_filter=spatialExpr; cq.boost_by_distance=true; cq.center_point=std::vector<float>{point[0], point[1]}; cq.limit=ast->limit? static_cast<size_t>(std::max<int64_t>(0, ast->limit->count)) : 100; if (!fulltextQuery.empty()) { cq.text_field=fulltextField; cq.fulltext_query=fulltextQuery; cq.limit=std::min(cq.limit, fulltextLimit); } else { return TranslationResult::Error("PROXIMITY() requires a FULLTEXT() filter for Content+Geo hybrid"); } auto cg_result2 = TranslationResult::SuccessContentGeo(std::move(cq)); attachCTEs(cg_result2, std::move(cte_executions)); return cg_result2;
            }
            // Backward compatibility: function call sugar
            if (spec.expression->getType() == ASTNodeType::FunctionCall) {
                auto func = std::static_pointer_cast<FunctionCallExpr>(spec.expression);
                std::string nameLower = func->name; std::transform(nameLower.begin(), nameLower.end(), nameLower.begin(), ::tolower);
                if (nameLower == "similarity") {
                // Erwartet mind. 2 Argumente: Feld, Vektor; optional k
                if (func->arguments.size() < 2 || func->arguments.size() > 3) {
                    return TranslationResult::Error("SIMILARITY() requires 2-3 arguments: SIMILARITY(doc.embedding, [vector] [, k])");
                }
                // Erstes Argument: FieldAccess (Vektorspaltenname)
                if (func->arguments[0]->getType() != ASTNodeType::FieldAccess) {
                    return TranslationResult::Error("SIMILARITY() first argument must be field access (e.g. doc.embedding)");
                }
                std::string vectorField = extractColumnName(func->arguments[0]);
                // Zweites Argument: ArrayLiteral mit numerischen Werten
                if (func->arguments[1]->getType() != ASTNodeType::ArrayLiteral) {
                    return TranslationResult::Error("SIMILARITY() second argument must be an array literal of numbers");
                }
                auto arr = std::static_pointer_cast<ArrayLiteralExpr>(func->arguments[1]);
                std::vector<float> queryVec;
                queryVec.reserve(arr->elements.size());
                for (const auto& el : arr->elements) {
                    if (el->getType() != ASTNodeType::Literal) {
                        return TranslationResult::Error("SIMILARITY() vector elements must be numeric literals");
                    }
                    auto lit = std::static_pointer_cast<LiteralExpr>(el);
                    if (std::holds_alternative<int64_t>(lit->value)) {
                        queryVec.push_back(static_cast<float>(std::get<int64_t>(lit->value)));
                    } else if (std::holds_alternative<double>(lit->value)) {
                        queryVec.push_back(static_cast<float>(std::get<double>(lit->value)));
                    } else {
                        return TranslationResult::Error("SIMILARITY() vector elements must be numeric (int or double)");
                    }
                }
                size_t k = 10; // default
                if (func->arguments.size() == 3) {
                    if (func->arguments[2]->getType() != ASTNodeType::Literal) {
                        return TranslationResult::Error("SIMILARITY() third argument k must be integer literal");
                    }
                    auto kLit = std::static_pointer_cast<LiteralExpr>(func->arguments[2]);
                    if (std::holds_alternative<int64_t>(kLit->value)) {
                        k = static_cast<size_t>(std::get<int64_t>(kLit->value));
                    } else {
                        return TranslationResult::Error("SIMILARITY() k must be integer literal");
                    }
                } else if (ast->limit) {
                    // LIMIT count als top-k wenn nicht explizit angegeben
                    k = static_cast<size_t>(std::max<int64_t>(0, ast->limit->count));
                }
                // Spatial Filter suchen + zusätzliche Prädikate sammeln (nur einfache Vergleiche zunächst)
                std::shared_ptr<Expression> spatialExpr;
                std::vector<std::shared_ptr<Expression>> extraPreds;
                for (const auto& f : ast->filters) {
                    if (!f || !f->condition) continue;
                    auto cond = f->condition;
                    if (cond->getType() == ASTNodeType::FunctionCall) {
                        auto fc = std::static_pointer_cast<FunctionCallExpr>(cond);
                        std::string fcNameLower = fc->name;
                        std::transform(fcNameLower.begin(), fcNameLower.end(), fcNameLower.begin(), ::tolower);
                        if (!spatialExpr && fcNameLower.rfind("st_", 0) == 0) {
                            spatialExpr = cond;
                            continue;
                        }
                    }
                    // Nur einfache BinaryOp Vergleiche (==,<,>,<=,>=) und AND-Ketten akzeptieren
                    // Vereinfachung: wir akzeptieren Ausdruck direkt; spätere Optimierung extrahiert Prädikate.
                    extraPreds.push_back(cond);
                }
                VectorGeoQuery vq;
                vq.table = ast->for_node.collection;
                vq.vector_field = vectorField; // nur Feldname (embedding oder nested)
                vq.query_vector = std::move(queryVec);
                vq.k = k;
                vq.spatial_filter = spatialExpr; // kann null sein -> reine Vektorabfrage über Syntax-Sugar
                vq.extra_filters = std::move(extraPreds);
                auto vg_result3 = TranslationResult::SuccessVectorGeo(std::move(vq));
                attachCTEs(vg_result3, std::move(cte_executions));
                return vg_result3;
            }
                }
                if (nameLower == "proximity") {
                if (func->arguments.size() != 2) {
                    return TranslationResult::Error("PROXIMITY() requires exactly 2 arguments: PROXIMITY(doc.location, [lon,lat])");
                }
                // geo field access
                if (func->arguments[0]->getType() != ASTNodeType::FieldAccess) {
                    return TranslationResult::Error("PROXIMITY() first argument must be field access (e.g. doc.location)");
                }
                std::string geomField = extractColumnName(func->arguments[0]);
                // point array literal [lon, lat]
                if (func->arguments[1]->getType() != ASTNodeType::ArrayLiteral) {
                    return TranslationResult::Error("PROXIMITY() second argument must be array literal [lon, lat]");
                }
                auto arr = std::static_pointer_cast<ArrayLiteralExpr>(func->arguments[1]);
                if (arr->elements.size() < 2) {
                    return TranslationResult::Error("PROXIMITY() point array must have at least 2 numeric elements [lon, lat]");
                }
                std::vector<float> point;
                for (size_t i=0;i<2;i++) {
                    auto el = arr->elements[i];
                    if (el->getType() != ASTNodeType::Literal) return TranslationResult::Error("PROXIMITY() point elements must be numeric literals");
                    auto lit = std::static_pointer_cast<LiteralExpr>(el);
                    if (std::holds_alternative<int64_t>(lit->value)) point.push_back(static_cast<float>(std::get<int64_t>(lit->value)));
                    else if (std::holds_alternative<double>(lit->value)) point.push_back(static_cast<float>(std::get<double>(lit->value)));
                    else return TranslationResult::Error("PROXIMITY() point elements must be numeric");
                }
                // Extract FULLTEXT filter (if present) & spatial ST_* filter & other predicates (extra for future)
                std::shared_ptr<Expression> spatialExpr;
                std::string fulltextQuery;
                std::string fulltextField;
                size_t fulltextLimit = 1000;
                for (const auto& f : ast->filters) {
                    if (!f || !f->condition) continue;
                    if (f->condition->getType() == ASTNodeType::FunctionCall) {
                        auto fc = std::static_pointer_cast<FunctionCallExpr>(f->condition);
                        std::string fcNameLower = fc->name; std::transform(fcNameLower.begin(), fcNameLower.end(), fcNameLower.begin(), ::tolower);
                        if (fcNameLower.rfind("st_",0)==0 && !spatialExpr) { spatialExpr = f->condition; continue; }
                        if (fcNameLower == "fulltext" && fulltextQuery.empty()) {
                            if (fc->arguments.size() < 2 || fc->arguments.size() > 3) return TranslationResult::Error("FULLTEXT() requires 2-3 arguments inside PROXIMITY hybrid");
                            if (fc->arguments[0]->getType() != ASTNodeType::FieldAccess) return TranslationResult::Error("FULLTEXT() first argument must be field access");
                            fulltextField = extractColumnName(fc->arguments[0]);
                            if (fc->arguments[1]->getType() != ASTNodeType::Literal) return TranslationResult::Error("FULLTEXT() second argument must be literal string");
                            auto litq = std::static_pointer_cast<LiteralExpr>(fc->arguments[1]);
                            if (!std::holds_alternative<std::string>(litq->value)) return TranslationResult::Error("FULLTEXT() query must be string");
                            fulltextQuery = std::get<std::string>(litq->value);
                            if (fc->arguments.size()==3) {
                                if (fc->arguments[2]->getType()!=ASTNodeType::Literal) return TranslationResult::Error("FULLTEXT() limit must be integer");
                                auto lim = std::static_pointer_cast<LiteralExpr>(fc->arguments[2]);
                                if (std::holds_alternative<int64_t>(lim->value)) fulltextLimit = static_cast<size_t>(std::get<int64_t>(lim->value));
                            }
                            continue;
                        }
                    }
                }
                // Build ContentGeoQuery
                ContentGeoQuery cq;
                cq.table = ast->for_node.collection;
                cq.geom_field = geomField;
                cq.spatial_filter = spatialExpr; // optional
                cq.boost_by_distance = true; // PROXIMITY implies ranking by distance
                cq.center_point = std::vector<float>{point[0], point[1]};
                cq.limit = ast->limit ? static_cast<size_t>(std::max<int64_t>(0, ast->limit->count)) : 100;
                if (!fulltextQuery.empty()) {
                    cq.text_field = fulltextField;
                    cq.fulltext_query = fulltextQuery;
                    // Use explicit fulltext limit if smaller than overall cq.limit
                    cq.limit = std::min(cq.limit, fulltextLimit);
                } else {
                    // Without FULLTEXT we must specify a default text_field; treat as error for now
                    return TranslationResult::Error("PROXIMITY() requires a FULLTEXT() filter for Content+Geo hybrid");
                }
                    auto cg_result3 = TranslationResult::SuccessContentGeo(std::move(cq));
                    attachCTEs(cg_result3, std::move(cte_executions));
                    return cg_result3;
                }
            }
        }
    }

    // Single-FOR Query: Standard ConjunctiveQuery für einfache Queries
    ConjunctiveQuery conjQuery;
    conjQuery.table = ast->for_node.collection;
    
    // Process FILTER clauses
    std::string error;
    
    // Check if any filter contains OR - if so, use DisjunctiveQuery
    bool hasOr = false;
    for (const auto& filter : ast->filters) {
        if (filter && filter->condition && containsOr(filter->condition)) {
            hasOr = true;
            break;
        }
    }
    
    if (hasOr) {
        // Build DisjunctiveQuery using DNF conversion
        DisjunctiveQuery disjQuery;
        disjQuery.table = ast->for_node.collection;
        
        // Convert all filters to DNF and merge
        for (const auto& filter : ast->filters) {
            if (!filter || !filter->condition) {
                return TranslationResult::Error("Invalid filter node");
            }
            
            auto disjuncts = convertToDNF(filter->condition, disjQuery.table, error);
            if (!error.empty()) {
                return TranslationResult::Error("OR filter translation failed: " + error);
            }
            
            // Merge disjuncts (for now, just append - proper DNF merge would distribute)
            if (disjQuery.disjuncts.empty()) {
                disjQuery.disjuncts = std::move(disjuncts);
            } else {
                // Multiple filters with OR: combine via cartesian product (DNF expansion)
                // For simplicity in v1, require single FILTER with OR
                if (ast->filters.size() > 1) {
                    return TranslationResult::Error("Multiple FILTER clauses with OR not yet supported - combine into single FILTER");
                }
            }
        }
        
        // Process SORT + LIMIT
        if (ast->sort) {
            disjQuery.orderBy = extractOrderBy(ast->sort, ast->limit);
        }
        
        auto result = TranslationResult::SuccessDisjunctive(std::move(disjQuery));
        attachCTEs(result, std::move(cte_executions));
        return result;
    }
    
    // No OR: Standard conjunctive query
    for (const auto& filter : ast->filters) {
        if (!filter || !filter->condition) {
            return TranslationResult::Error("Invalid filter node");
        }
        
        // Check if filter is a FULLTEXT function call
        if (filter->condition->getType() == ASTNodeType::FunctionCall) {
            auto funcCall = std::static_pointer_cast<FunctionCallExpr>(filter->condition);
            std::string funcName = funcCall->name;
            std::transform(funcName.begin(), funcName.end(), funcName.begin(), ::tolower);
            
            if (funcName == "fulltext") {
                // Parse FULLTEXT(column, query [, limit])
                if (funcCall->arguments.size() < 2 || funcCall->arguments.size() > 3) {
                    return TranslationResult::Error("FULLTEXT() requires 2-3 arguments: FULLTEXT(column, query [, limit])");
                }
                
                // Extract column (must be field access: doc.column)
                if (funcCall->arguments[0]->getType() != ASTNodeType::FieldAccess) {
                    return TranslationResult::Error("FULLTEXT() first argument must be field access (e.g., doc.content)");
                }
                std::string column = extractColumnName(funcCall->arguments[0]);
                
                // Extract query string (must be literal)
                if (funcCall->arguments[1]->getType() != ASTNodeType::Literal) {
                    return TranslationResult::Error("FULLTEXT() second argument must be string literal");
                }
                auto queryLiteral = std::static_pointer_cast<LiteralExpr>(funcCall->arguments[1]);
                if (!std::holds_alternative<std::string>(queryLiteral->value)) {
                    return TranslationResult::Error("FULLTEXT() query must be a string");
                }
                std::string queryStr = std::get<std::string>(queryLiteral->value);
                
                // Extract optional limit
                size_t limit = 1000; // default
                if (funcCall->arguments.size() == 3) {
                    if (funcCall->arguments[2]->getType() != ASTNodeType::Literal) {
                        return TranslationResult::Error("FULLTEXT() third argument (limit) must be integer literal");
                    }
                    auto limitLiteral = std::static_pointer_cast<LiteralExpr>(funcCall->arguments[2]);
                    if (std::holds_alternative<int64_t>(limitLiteral->value)) {
                        limit = static_cast<size_t>(std::get<int64_t>(limitLiteral->value));
                    } else {
                        return TranslationResult::Error("FULLTEXT() limit must be an integer");
                    }
                }
                
                // Set fulltext predicate
                conjQuery.fulltextPredicate = PredicateFulltext{column, queryStr, limit};
                continue; // Skip normal predicate extraction for this filter
            }
        }
        
        // Check if filter contains FULLTEXT combined with AND
        // Helper to recursively find FULLTEXT in AND tree
        std::function<std::shared_ptr<FunctionCallExpr>(const std::shared_ptr<Expression>&)> findFulltext;
        findFulltext = [&](const std::shared_ptr<Expression>& e) -> std::shared_ptr<FunctionCallExpr> {
            if (!e) return nullptr;
            
            if (e->getType() == ASTNodeType::FunctionCall) {
                auto fc = std::static_pointer_cast<FunctionCallExpr>(e);
                std::string name = fc->name;
                std::transform(name.begin(), name.end(), name.begin(), ::tolower);
                if (name == "fulltext") return fc;
            }
            
            if (e->getType() == ASTNodeType::BinaryOp) {
                auto bo = std::static_pointer_cast<BinaryOpExpr>(e);
                if (bo->op == BinaryOperator::And) {
                    auto left = findFulltext(bo->left);
                    if (left) return left;
                    return findFulltext(bo->right);
                }
            }
            
            return nullptr;
        };
        
        // Helper to collect all non-FULLTEXT predicates from AND tree
        std::function<void(const std::shared_ptr<Expression>&, std::vector<std::shared_ptr<Expression>>&)> collectNonFulltext;
        collectNonFulltext = [&](const std::shared_ptr<Expression>& e, std::vector<std::shared_ptr<Expression>>& preds) {
            if (!e) return;
            
            if (e->getType() == ASTNodeType::FunctionCall) {
                auto fc = std::static_pointer_cast<FunctionCallExpr>(e);
                std::string name = fc->name;
                std::transform(name.begin(), name.end(), name.begin(), ::tolower);
                if (name != "fulltext") {
                    preds.push_back(e); // Non-FULLTEXT function
                }
                // Skip FULLTEXT itself
                return;
            }
            
            if (e->getType() == ASTNodeType::BinaryOp) {
                auto bo = std::static_pointer_cast<BinaryOpExpr>(e);
                if (bo->op == BinaryOperator::And) {
                    collectNonFulltext(bo->left, preds);
                    collectNonFulltext(bo->right, preds);
                    return;
                }
            }
            
            // Leaf predicate (equality, range, etc.)
            preds.push_back(e);
        };
        
        if (filter->condition->getType() == ASTNodeType::BinaryOp) {
            auto binOp = std::static_pointer_cast<BinaryOpExpr>(filter->condition);
            
            if (binOp->op == BinaryOperator::And) {
                auto fulltextFunc = findFulltext(filter->condition);
                
                if (fulltextFunc) {
                    // Parse FULLTEXT part
                    if (fulltextFunc->arguments.size() < 2 || fulltextFunc->arguments.size() > 3) {
                        return TranslationResult::Error("FULLTEXT() requires 2-3 arguments");
                    }
                    
                    if (fulltextFunc->arguments[0]->getType() != ASTNodeType::FieldAccess) {
                        return TranslationResult::Error("FULLTEXT() first argument must be field access");
                    }
                    std::string column = extractColumnName(fulltextFunc->arguments[0]);
                    
                    if (fulltextFunc->arguments[1]->getType() != ASTNodeType::Literal) {
                        return TranslationResult::Error("FULLTEXT() second argument must be string literal");
                    }
                    auto queryLiteral = std::static_pointer_cast<LiteralExpr>(fulltextFunc->arguments[1]);
                    if (!std::holds_alternative<std::string>(queryLiteral->value)) {
                        return TranslationResult::Error("FULLTEXT() query must be a string");
                    }
                    std::string queryStr = std::get<std::string>(queryLiteral->value);
                    
                    size_t limit = 1000;
                    if (fulltextFunc->arguments.size() == 3) {
                        if (fulltextFunc->arguments[2]->getType() != ASTNodeType::Literal) {
                            return TranslationResult::Error("FULLTEXT() limit must be integer literal");
                        }
                        auto limitLiteral = std::static_pointer_cast<LiteralExpr>(fulltextFunc->arguments[2]);
                        if (std::holds_alternative<int64_t>(limitLiteral->value)) {
                            limit = static_cast<size_t>(std::get<int64_t>(limitLiteral->value));
                        } else {
                            return TranslationResult::Error("FULLTEXT() limit must be an integer");
                        }
                    }
                    
                    conjQuery.fulltextPredicate = PredicateFulltext{column, queryStr, limit};
                    
                    // Collect all non-FULLTEXT predicates
                    std::vector<std::shared_ptr<Expression>> predicateExprs;
                    collectNonFulltext(filter->condition, predicateExprs);
                    
                    // Extract each predicate
                    for (const auto& predExpr : predicateExprs) {
                        if (!extractPredicates(predExpr, conjQuery.predicates, conjQuery.rangePredicates, error)) {
                            return TranslationResult::Error("Filter translation failed: " + error);
                        }
                    }
                    
                    continue; // Successfully handled FULLTEXT AND <predicates>
                }
            }
        }
        
        if (!extractPredicates(filter->condition, conjQuery.predicates, conjQuery.rangePredicates, error)) {
            return TranslationResult::Error("Filter translation failed: " + error);
        }
    }
    
    // Process SORT + LIMIT
    if (ast->sort) {
        conjQuery.orderBy = extractOrderBy(ast->sort, ast->limit);
    }
    auto result = TranslationResult::Success(std::move(conjQuery));
    auto result = TranslationResult::Success(std::move(query));
    attachCTEs(result, std::move(cte_executions));
    return result;
}

bool AQLTranslator::extractPredicates(
    const std::shared_ptr<Expression>& expr,
    std::vector<PredicateEq>& eqPredicates,
    std::vector<PredicateRange>& rangePredicates,
    std::string& error
) {
    if (!expr) {
        error = "Null expression";
        return false;
    }
    
    // Check for FULLTEXT function call in FILTER
    if (expr->getType() == ASTNodeType::FunctionCall) {
        auto funcCall = std::static_pointer_cast<FunctionCallExpr>(expr);
        
        // Check if it's FULLTEXT(...) - case insensitive
        std::string funcName = funcCall->name;
        std::transform(funcName.begin(), funcName.end(), funcName.begin(), ::tolower);
        
        if (funcName == "fulltext") {
            // FULLTEXT is now allowed in both AND and OR combinations
            // In OR: each disjunct can have its own FULLTEXT
            // In AND: handled at translate level
            // When called from extractPredicates in OR context, we shouldn't reach here
            // (DNF conversion handles FULLTEXT directly)
            error = "FULLTEXT() should be handled by DNF converter in OR context";
            return false;
        }
    }
    
    // Check expression type
    if (expr->getType() == ASTNodeType::BinaryOp) {
        auto binOp = std::static_pointer_cast<BinaryOpExpr>(expr);
        
        // Handle AND: Recursively extract from both sides
        if (binOp->op == BinaryOperator::And) {
            return extractPredicates(binOp->left, eqPredicates, rangePredicates, error) &&
                   extractPredicates(binOp->right, eqPredicates, rangePredicates, error);
        }
        
        // Handle OR: Should be handled at higher level via convertToDNF
        // If we reach here, it means OR is nested in a way that requires DNF conversion
        if (binOp->op == BinaryOperator::Or) {
            error = "OR operator detected - should be handled via DisjunctiveQuery (internal error)";
            return false;
        }
        
        if (binOp->op == BinaryOperator::Xor) {
            error = "XOR operator not supported";
            return false;
        }
        
        // Extract column name from left side (must be field access)
        if (binOp->left->getType() != ASTNodeType::FieldAccess) {
            error = "Left side of comparison must be field access (e.g., doc.age)";
            return false;
        }
        
        std::string column = extractColumnName(binOp->left);
        
        // Extract value from right side (must be literal)
        if (binOp->right->getType() != ASTNodeType::Literal) {
            error = "Right side of comparison must be literal value";
            return false;
        }
        
        auto literal = std::static_pointer_cast<LiteralExpr>(binOp->right);
        std::string value = literalToString(literal->value);
        
        // Map operator to predicate type
        switch (binOp->op) {
            case BinaryOperator::Eq:
                eqPredicates.push_back(PredicateEq{column, value});
                break;
                
            case BinaryOperator::Neq:
                // NEQ should be handled in convertToDNF, not here
                // If we reach here, it's a programming error
                error = "Internal error: NEQ should be converted to (< OR >) in convertToDNF";
                return false;
                
            case BinaryOperator::Lt:
                rangePredicates.push_back(PredicateRange{
                    column,
                    std::nullopt,   // no lower bound
                    value,          // upper bound
                    true,           // include lower (doesn't matter)
                    false           // exclude upper (< not <=)
                });
                break;
                
            case BinaryOperator::Lte:
                rangePredicates.push_back(PredicateRange{
                    column,
                    std::nullopt,   // no lower bound
                    value,          // upper bound
                    true,           // include lower (doesn't matter)
                    true            // include upper (<=)
                });
                break;
                
            case BinaryOperator::Gt:
                rangePredicates.push_back(PredicateRange{
                    column,
                    value,          // lower bound
                    std::nullopt,   // no upper bound
                    false,          // exclude lower (> not >=)
                    true            // include upper (doesn't matter)
                });
                break;
                
            case BinaryOperator::Gte:
                rangePredicates.push_back(PredicateRange{
                    column,
                    value,          // lower bound
                    std::nullopt,   // no upper bound
                    true,           // include lower (>=)
                    true            // include upper (doesn't matter)
                });
                break;
                
            default:
                error = "Unsupported operator in filter";
                return false;
        }
        
        return true;
    }
    
    error = "Unsupported expression type in filter (only binary operators supported)";
    return false;
}

std::string AQLTranslator::extractColumnName(const std::shared_ptr<Expression>& expr) {
    if (expr->getType() == ASTNodeType::FieldAccess) {
        auto fieldAccess = std::static_pointer_cast<FieldAccessExpr>(expr);
        
        // Handle nested field access: doc.address.city -> "address.city"
        std::string result;
        
        // Recursively extract parent field names
        if (fieldAccess->object->getType() == ASTNodeType::FieldAccess) {
            result = extractColumnName(fieldAccess->object) + ".";
        }
        // Skip the variable name (e.g., "doc") at the root
        
        result += fieldAccess->field;
        return result;
    }
    
    return "";
}

std::string AQLTranslator::literalToString(const LiteralValue& value) {
    return std::visit([](auto&& arg) -> std::string {
        using T = std::decay_t<decltype(arg)>;
        
        if constexpr (std::is_same_v<T, std::nullptr_t>) {
            return "null";
        } else if constexpr (std::is_same_v<T, bool>) {
            return arg ? "true" : "false";
        } else if constexpr (std::is_same_v<T, int64_t>) {
            return std::to_string(arg);
        } else if constexpr (std::is_same_v<T, double>) {
            return std::to_string(arg);
        } else if constexpr (std::is_same_v<T, std::string>) {
            return arg;
        }
        
        return "";
    }, value);
}

std::optional<OrderBy> AQLTranslator::extractOrderBy(
    const std::shared_ptr<SortNode>& sort,
    const std::shared_ptr<LimitNode>& limit
) {
    if (!sort || sort->specifications.empty()) {
        return std::nullopt;
    }
    
    // Only support single-column sorting for now
    const auto& spec = sort->specifications[0];
    
    OrderBy orderBy;
    orderBy.column = extractColumnName(spec.expression);
    orderBy.desc = !spec.ascending;
    
    // Apply limit if present
    if (limit) {
        // For offset support, request offset+count from index scan and slice later in handler
        auto off = static_cast<size_t>(std::max<int64_t>(0, limit->offset));
        auto cnt = static_cast<size_t>(std::max<int64_t>(0, limit->count));
        orderBy.limit = off + cnt;
    } else {
        orderBy.limit = 1000; // default limit
    }
    
    return orderBy;
}

bool AQLTranslator::containsOr(const std::shared_ptr<Expression>& expr) {
    if (!expr) return false;
    
    if (expr->getType() == ASTNodeType::BinaryOp) {
        auto binOp = std::static_pointer_cast<BinaryOpExpr>(expr);
        if (binOp->op == BinaryOperator::Or) {
            return true;
        }
        // Recursively check both sides
        return containsOr(binOp->left) || containsOr(binOp->right);
    }
    
    return false;
}

std::vector<ConjunctiveQuery> AQLTranslator::convertToDNF(
    const std::shared_ptr<Expression>& expr,
    const std::string& table,
    std::string& error
) {
    if (!expr) {
        error = "Null expression in DNF conversion";
        return {};
    }
    
    // Handle NOT operator using De Morgan's Laws
    // NOT (A AND B) = (NOT A) OR (NOT B)
    // NOT (A OR B) = (NOT A) AND (NOT B)
    if (expr->getType() == ASTNodeType::UnaryOp) {
        auto unaryOp = std::static_pointer_cast<UnaryOpExpr>(expr);
        
        if (unaryOp->op == UnaryOperator::Not) {
            auto operand = unaryOp->operand;
            
            // NOT of binary operator - apply De Morgan's Laws
            if (operand->getType() == ASTNodeType::BinaryOp) {
                auto binOp = std::static_pointer_cast<BinaryOpExpr>(operand);
                
                // NOT (A OR B) = (NOT A) AND (NOT B)
                if (binOp->op == BinaryOperator::Or) {
                    auto notLeft = std::make_shared<UnaryOpExpr>();
                    notLeft->op = UnaryOperator::Not;
                    notLeft->operand = binOp->left;
                    
                    auto notRight = std::make_shared<UnaryOpExpr>();
                    notRight->op = UnaryOperator::Not;
                    notRight->operand = binOp->right;
                    
                    auto andExpr = std::make_shared<BinaryOpExpr>();
                    andExpr->op = BinaryOperator::And;
                    andExpr->left = notLeft;
                    andExpr->right = notRight;
                    
                    return convertToDNF(andExpr, table, error);
                }
                
                // NOT (A AND B) = (NOT A) OR (NOT B)
                if (binOp->op == BinaryOperator::And) {
                    auto notLeft = std::make_shared<UnaryOpExpr>();
                    notLeft->op = UnaryOperator::Not;
                    notLeft->operand = binOp->left;
                    
                    auto notRight = std::make_shared<UnaryOpExpr>();
                    notRight->op = UnaryOperator::Not;
                    notRight->operand = binOp->right;
                    
                    auto orExpr = std::make_shared<BinaryOpExpr>();
                    orExpr->op = BinaryOperator::Or;
                    orExpr->left = notLeft;
                    orExpr->right = notRight;
                    
                    return convertToDNF(orExpr, table, error);
                }
                
                // NOT (A == B) becomes (A != B)
                if (binOp->op == BinaryOperator::Eq) {
                    // NEQ is converted to: (A < B) OR (A > B)
                    // This allows index usage via DisjunctiveQuery
                    auto ltExpr = std::make_shared<BinaryOpExpr>();
                    ltExpr->op = BinaryOperator::Lt;
                    ltExpr->left = binOp->left;
                    ltExpr->right = binOp->right;
                    
                    auto gtExpr = std::make_shared<BinaryOpExpr>();
                    gtExpr->op = BinaryOperator::Gt;
                    gtExpr->left = binOp->left;
                    gtExpr->right = binOp->right;
                    
                    auto orExpr = std::make_shared<BinaryOpExpr>();
                    orExpr->op = BinaryOperator::Or;
                    orExpr->left = ltExpr;
                    orExpr->right = gtExpr;
                    
                    return convertToDNF(orExpr, table, error);
                }
                
                // NOT (A != B) becomes (A == B)
                if (binOp->op == BinaryOperator::Neq) {
                    auto eqExpr = std::make_shared<BinaryOpExpr>();
                    eqExpr->op = BinaryOperator::Eq;
                    eqExpr->left = binOp->left;
                    eqExpr->right = binOp->right;
                    return convertToDNF(eqExpr, table, error);
                }
                
                // NOT (A < B) becomes (A >= B)
                if (binOp->op == BinaryOperator::Lt) {
                    auto gteExpr = std::make_shared<BinaryOpExpr>();
                    gteExpr->op = BinaryOperator::Gte;
                    gteExpr->left = binOp->left;
                    gteExpr->right = binOp->right;
                    return convertToDNF(gteExpr, table, error);
                }
                
                // NOT (A > B) becomes (A <= B)
                if (binOp->op == BinaryOperator::Gt) {
                    auto lteExpr = std::make_shared<BinaryOpExpr>();
                    lteExpr->op = BinaryOperator::Lte;
                    lteExpr->left = binOp->left;
                    lteExpr->right = binOp->right;
                    return convertToDNF(lteExpr, table, error);
                }
                
                // NOT (A <= B) becomes (A > B)
                if (binOp->op == BinaryOperator::Lte) {
                    auto gtExpr = std::make_shared<BinaryOpExpr>();
                    gtExpr->op = BinaryOperator::Gt;
                    gtExpr->left = binOp->left;
                    gtExpr->right = binOp->right;
                    return convertToDNF(gtExpr, table, error);
                }
                
                // NOT (A >= B) becomes (A < B)
                if (binOp->op == BinaryOperator::Gte) {
                    auto ltExpr = std::make_shared<BinaryOpExpr>();
                    ltExpr->op = BinaryOperator::Lt;
                    ltExpr->left = binOp->left;
                    ltExpr->right = binOp->right;
                    return convertToDNF(ltExpr, table, error);
                }
            }
            
            // NOT of NOT - double negation elimination
            if (operand->getType() == ASTNodeType::UnaryOp) {
                auto innerUnary = std::static_pointer_cast<UnaryOpExpr>(operand);
                if (innerUnary->op == UnaryOperator::Not) {
                    return convertToDNF(innerUnary->operand, table, error);
                }
            }
            
            // NOT of literal/variable - can't convert to index predicate
            // This would require full scan with negation filter
            error = "NOT of non-comparison expression not yet supported for index queries";
            return {};
        }
    }
    
    // Base case: Single predicate (leaf node)
    if (expr->getType() == ASTNodeType::BinaryOp) {
        auto binOp = std::static_pointer_cast<BinaryOpExpr>(expr);
        
        // OR: Split into multiple disjuncts
        if (binOp->op == BinaryOperator::Or) {
            auto leftDNF = convertToDNF(binOp->left, table, error);
            if (!error.empty()) return {};
            
            auto rightDNF = convertToDNF(binOp->right, table, error);
            if (!error.empty()) return {};
            
            // Merge disjuncts (union)
            leftDNF.insert(leftDNF.end(), rightDNF.begin(), rightDNF.end());
            return leftDNF;
        }
        
        // AND: Distribute over existing disjuncts
        if (binOp->op == BinaryOperator::And) {
            auto leftDNF = convertToDNF(binOp->left, table, error);
            if (!error.empty()) return {};
            
            auto rightDNF = convertToDNF(binOp->right, table, error);
            if (!error.empty()) return {};
            
            // Cartesian product: (A OR B) AND (C OR D) = (A AND C) OR (A AND D) OR (B AND C) OR (B AND D)
            std::vector<ConjunctiveQuery> result;
            for (const auto& leftConj : leftDNF) {
                for (const auto& rightConj : rightDNF) {
                    ConjunctiveQuery merged;
                    merged.table = table;
                    
                    // Merge predicates
                    merged.predicates = leftConj.predicates;
                    merged.predicates.insert(merged.predicates.end(), 
                                            rightConj.predicates.begin(), 
                                            rightConj.predicates.end());
                    
                    // Merge range predicates
                    merged.rangePredicates = leftConj.rangePredicates;
                    merged.rangePredicates.insert(merged.rangePredicates.end(),
                                                 rightConj.rangePredicates.begin(),
                                                 rightConj.rangePredicates.end());
                    
                    // Merge fulltext predicates
                    // Only one FULLTEXT per disjunct allowed (can't merge multiple FULLTEXT into single AND clause)
                    if (leftConj.fulltextPredicate.has_value() && rightConj.fulltextPredicate.has_value()) {
                        error = "Cannot combine multiple FULLTEXT() predicates in AND - only one FULLTEXT per clause allowed";
                        return {};
                    }
                    if (leftConj.fulltextPredicate.has_value()) {
                        merged.fulltextPredicate = leftConj.fulltextPredicate;
                    } else if (rightConj.fulltextPredicate.has_value()) {
                        merged.fulltextPredicate = rightConj.fulltextPredicate;
                    }
                    
                    result.push_back(std::move(merged));
                }
            }
            return result;
        }
        
        // Leaf comparison (==, <, >, !=, etc.)
        // Special handling for NEQ: convert to (< value) OR (> value)
        if (binOp->op == BinaryOperator::Neq) {
            // A != B is converted to: (A < B) OR (A > B)
            auto ltExpr = std::make_shared<BinaryOpExpr>();
            ltExpr->op = BinaryOperator::Lt;
            ltExpr->left = binOp->left;
            ltExpr->right = binOp->right;
            
            auto gtExpr = std::make_shared<BinaryOpExpr>();
            gtExpr->op = BinaryOperator::Gt;
            gtExpr->left = binOp->left;
            gtExpr->right = binOp->right;
            
            auto orExpr = std::make_shared<BinaryOpExpr>();
            orExpr->op = BinaryOperator::Or;
            orExpr->left = ltExpr;
            orExpr->right = gtExpr;
            
            return convertToDNF(orExpr, table, error);
        }
        
        // Create single-predicate conjunctive query
        ConjunctiveQuery conj;
        conj.table = table;
        
        std::vector<PredicateEq> eqPreds;
        std::vector<PredicateRange> rangePreds;
        
        if (!extractPredicates(expr, eqPreds, rangePreds, error)) {
            return {};
        }
        
        conj.predicates = std::move(eqPreds);
        conj.rangePredicates = std::move(rangePreds);
        
        return {conj};
    }
    
    // FULLTEXT function call - create single-predicate query with FULLTEXT
    if (expr->getType() == ASTNodeType::FunctionCall) {
        auto funcCall = std::static_pointer_cast<FunctionCallExpr>(expr);
        std::string funcName = funcCall->name;
        std::transform(funcName.begin(), funcName.end(), funcName.begin(), ::tolower);
        
        if (funcName == "fulltext") {
            // Parse FULLTEXT(column, query [, limit])
            if (funcCall->arguments.size() < 2 || funcCall->arguments.size() > 3) {
                error = "FULLTEXT() requires 2-3 arguments: FULLTEXT(column, query [, limit])";
                return {};
            }
            
            if (funcCall->arguments[0]->getType() != ASTNodeType::FieldAccess) {
                error = "FULLTEXT() first argument must be field access (e.g., doc.content)";
                return {};
            }
            std::string column = extractColumnName(funcCall->arguments[0]);
            
            if (funcCall->arguments[1]->getType() != ASTNodeType::Literal) {
                error = "FULLTEXT() second argument must be string literal";
                return {};
            }
            auto queryLiteral = std::static_pointer_cast<LiteralExpr>(funcCall->arguments[1]);
            if (!std::holds_alternative<std::string>(queryLiteral->value)) {
                error = "FULLTEXT() query must be a string";
                return {};
            }
            std::string queryStr = std::get<std::string>(queryLiteral->value);
            
            size_t limit = 1000; // default
            if (funcCall->arguments.size() == 3) {
                if (funcCall->arguments[2]->getType() != ASTNodeType::Literal) {
                    error = "FULLTEXT() third argument (limit) must be integer literal";
                    return {};
                }
                auto limitLiteral = std::static_pointer_cast<LiteralExpr>(funcCall->arguments[2]);
                if (std::holds_alternative<int64_t>(limitLiteral->value)) {
                    limit = static_cast<size_t>(std::get<int64_t>(limitLiteral->value));
                } else {
                    error = "FULLTEXT() limit must be an integer";
                    return {};
                }
            }
            
            // Create a ConjunctiveQuery with only the fulltext predicate
            ConjunctiveQuery conj;
            conj.table = table;
            conj.fulltextPredicate = PredicateFulltext{column, queryStr, limit};
            return {conj};
        }
    }
    
    error = "Unsupported expression type in DNF conversion";
    return {};
}

// Phase 4.1: Count CTE references in query AST
size_t AQLTranslator::countCTEReferences(
    const std::shared_ptr<Query>& ast,
    const std::string& cte_name
) {
    if (!ast) return 0;
    
    size_t count = 0;
    
    // Count references in FOR nodes
    for (const auto& for_node : ast->for_nodes) {
        if (for_node.collection == cte_name) {
            count++;
        }
    }
    
    // Single FOR node (legacy compatibility)
    if (ast->for_node.collection == cte_name) {
        count++;
    }
    
    // Recursively check nested queries in LET expressions
    // (e.g., LET x = (FOR ... FROM cte ...))
    for (const auto& let_node : ast->let_nodes) {
        if (let_node.expression && let_node.expression->getType() == ASTNodeType::SubqueryExpr) {
            auto subq = std::static_pointer_cast<query::SubqueryExpr>(let_node.expression);
            count += countCTEReferences(subq->query, cte_name);
        }
    }
    
    // Check subqueries in FILTER conditions (ANY/ALL)
    for (const auto& filter : ast->filters) {
        if (!filter || !filter->condition) continue;
        count += countCTEReferencesInExpr(filter->condition, cte_name);
    }
    
    return count;
}

// Helper: recursively count CTE references in expressions
size_t AQLTranslator::countCTEReferencesInExpr(
    const std::shared_ptr<Expression>& expr,
    const std::string& cte_name
) {
    if (!expr) return 0;
    
    size_t count = 0;
    
    switch (expr->getType()) {
        case ASTNodeType::SubqueryExpr: {
            auto subq = std::static_pointer_cast<query::SubqueryExpr>(expr);
            count += countCTEReferences(subq->query, cte_name);
            break;
        }
        case ASTNodeType::AnyExpr: {
            auto any = std::static_pointer_cast<query::AnyExpr>(expr);
            count += countCTEReferences(any->query, cte_name);
            count += countCTEReferencesInExpr(any->condition, cte_name);
            break;
        }
        case ASTNodeType::AllExpr: {
            auto all = std::static_pointer_cast<query::AllExpr>(expr);
            count += countCTEReferences(all->query, cte_name);
            count += countCTEReferencesInExpr(all->condition, cte_name);
            break;
        }
        case ASTNodeType::BinaryOp: {
            auto binop = std::static_pointer_cast<query::BinaryOpExpr>(expr);
            count += countCTEReferencesInExpr(binop->left, cte_name);
            count += countCTEReferencesInExpr(binop->right, cte_name);
            break;
        }
        case ASTNodeType::FunctionCall: {
            auto func = std::static_pointer_cast<query::FunctionCallExpr>(expr);
            for (const auto& arg : func->arguments) {
                count += countCTEReferencesInExpr(arg, cte_name);
            }
            break;
        }
        default:
            // Other expression types don't contain subqueries
            break;
    }
    
    return count;
}

// Phase 4.1: Attach CTEs to translation result
void AQLTranslator::attachCTEs(
    TranslationResult& result,
    std::vector<TranslationResult::CTEExecution> ctes
) {
    if (!ctes.empty() && result.success) {
        result.ctes = std::move(ctes);
    }
}

} // namespace themis

